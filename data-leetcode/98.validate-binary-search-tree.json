[
    {
        "title": "Validate Binary Search Tree",
        "question_content": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\n\n\tThe left subtree of a node contains only nodes with keys less than the node's key.\n\tThe right subtree of a node contains only nodes with keys greater than the node's key.\n\tBoth the left and right subtrees must also be binary search trees.\n\n&nbsp;\nExample 1:\n\nInput: root = [2,1,3]\nOutput: true\n\nExample 2:\n\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 104].\n\t-231 <= Node.val <= 231 - 1",
        "solutions": [
            {
                "id": 32112,
                "title": "learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution",
                "content": "I will show you all how to tackle various tree questions using iterative inorder traversal. First one is the standard iterative inorder traversal using stack. Hope everyone agrees with this solution. \\n\\nQuestion : [Binary Tree Inorder Traversal][1]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n            \\n        }\\n        return list;\\n    }\\n\\nNow, we can use this structure to find the Kth smallest element in BST.\\n\\nQuestion : [Kth Smallest Element in a BST][2]\\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<>();\\n         while(root != null || !stack.isEmpty()) {\\n             while(root != null) {\\n                 stack.push(root);    \\n                 root = root.left;   \\n             } \\n             root = stack.pop();\\n             if(--k == 0) break;\\n             root = root.right;\\n         }\\n         return root.val;\\n     }\\n\\nWe can also use this structure to solve BST validation question. \\n\\nQuestion : [Validate Binary Search Tree][3]\\n\\n    public boolean isValidBST(TreeNode root) {\\n       if (root == null) return true;\\n       Stack<TreeNode> stack = new Stack<>();\\n       TreeNode pre = null;\\n       while (root != null || !stack.isEmpty()) {\\n          while (root != null) {\\n             stack.push(root);\\n             root = root.left;\\n          }\\n          root = stack.pop();\\n          if(pre != null && root.val <= pre.val) return false;\\n          pre = root;\\n          root = root.right;\\n       }\\n       return true;\\n    }\\n\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n  [2]: https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\n  [3]: https://leetcode.com/problems/validate-binary-search-tree/",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "I will show you all how to tackle various tree questions using iterative inorder traversal. First one is the standard iterative inorder traversal using stack. Hope everyone agrees with this solution. \\n\\nQuestion : [Binary Tree Inorder Traversal][1]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n            \\n        }\\n        return list;\\n    }\\n\\nNow, we can use this structure to find the Kth smallest element in BST.\\n\\nQuestion : [Kth Smallest Element in a BST][2]\\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<>();\\n         while(root != null || !stack.isEmpty()) {\\n             while(root != null) {\\n                 stack.push(root);    \\n                 root = root.left;   \\n             } \\n             root = stack.pop();\\n             if(--k == 0) break;\\n             root = root.right;\\n         }\\n         return root.val;\\n     }\\n\\nWe can also use this structure to solve BST validation question. \\n\\nQuestion : [Validate Binary Search Tree][3]\\n\\n    public boolean isValidBST(TreeNode root) {\\n       if (root == null) return true;\\n       Stack<TreeNode> stack = new Stack<>();\\n       TreeNode pre = null;\\n       while (root != null || !stack.isEmpty()) {\\n          while (root != null) {\\n             stack.push(root);\\n             root = root.left;\\n          }\\n          root = stack.pop();\\n          if(pre != null && root.val <= pre.val) return false;\\n          pre = root;\\n          root = root.right;\\n       }\\n       return true;\\n    }\\n\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n  [2]: https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\n  [3]: https://leetcode.com/problems/validate-binary-search-tree/",
                "codeTag": "Unknown"
            },
            {
                "id": 32109,
                "title": "my-simple-java-solution-in-3-lines",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }\\n        \\n        public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\\n            if (root == null) return true;\\n            if (root.val >= maxVal || root.val <= minVal) return false;\\n            return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\\n        }\\n    }\\n\\nBasically what I am doing is recursively iterating over the tree while defining interval `<minVal, maxVal>` for each node which value must fit in.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32104,
                "title": "c-in-order-traversal-and-please-do-not-rely-on-buggy-int-max-int-min-solutions-any-more",
                "content": "    class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            TreeNode* prev = NULL;\\n            return validate(root, prev);\\n        }\\n        bool validate(TreeNode* node, TreeNode* &prev) {\\n            if (node == NULL) return true;\\n            if (!validate(node->left, prev)) return false;\\n            if (prev != NULL && prev->val >= node->val) return false;\\n            prev = node;\\n            return validate(node->right, prev);\\n        }\\n    };\\n\\n> Update:\\n> \\n> If we use in-order traversal to serialize a binary search tree, we can\\n> get a list of values in ascending order. It can be proved with the\\n> definition of BST. And here I use the reference of TreeNode\\n> pointer `prev` as a global variable to mark the address of previous node in the\\n> list.\\n> \\n> \\u201cIn-order Traversal\\u201d:\\n> [https://en.wikipedia.org/wiki/Tree_traversal#In-order]()\\n\\nIf you know what `INT_MAX` or `INT_MIN` is, then it is no excuse for your carelessness.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            TreeNode* prev = NULL;\\n            return validate(root, prev);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32141,
                "title": "c-simple-recursive-solution",
                "content": "    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, NULL, NULL);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n        if(!root) return true;\\n        if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n            return false;\\n        return isValidBST(root->left, minNode, root) && isValidBST(root->right, root, maxNode);\\n    }",
                "solutionTags": [],
                "code": "    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, NULL, NULL);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n        if(!root) return true;\\n        if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n            return false;\\n        return isValidBST(root->left, minNode, root) && isValidBST(root->right, root, maxNode);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3169560,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n\\nbool isPossible(TreeNode* root, long long l, long long r){\\n    if(root == nullptr)  return true;\\n    if(root->val < r and root->val > l)\\n        return isPossible(root->left, l, root->val) and \\n                                isPossible(root->right, root->val, r);\\n    else return false;\\n}\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long long int min = -1000000000000, max = 1000000000000;\\n        return isPossible(root, min, max);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        prev = float(\\'-inf\\')\\n        def inorder(node):\\n            nonlocal prev\\n            if not node:\\n                return True\\n            if not (inorder(node.left) and prev < node.val):\\n                return False\\n            prev = node.val\\n            return inorder(node.right)\\n        return inorder(root)\\n```\\n\\n```Java []\\nclass Solution {\\n    private long minVal = Long.MIN_VALUE;\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true; \\n        if (!isValidBST(root.left)) return false;\\n        \\n        if (minVal >= root.val) return false; \\n\\n        minVal = root.val;\\n\\n        if (!isValidBST(root.right)) return false;\\n\\n        return true;\\n    } \\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n\\nbool isPossible(TreeNode* root, long long l, long long r){\\n    if(root == nullptr)  return true;\\n    if(root->val < r and root->val > l)\\n        return isPossible(root->left, l, root->val) and \\n                                isPossible(root->right, root->val, r);\\n    else return false;\\n}\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long long int min = -1000000000000, max = 1000000000000;\\n        return isPossible(root, min, max);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        prev = float(\\'-inf\\')\\n        def inorder(node):\\n            nonlocal prev\\n            if not node:\\n                return True\\n            if not (inorder(node.left) and prev < node.val):\\n                return False\\n            prev = node.val\\n            return inorder(node.right)\\n        return inorder(root)\\n```\n```Java []\\nclass Solution {\\n    private long minVal = Long.MIN_VALUE;\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true; \\n        if (!isValidBST(root.left)) return false;\\n        \\n        if (minVal >= root.val) return false; \\n\\n        minVal = root.val;\\n\\n        if (!isValidBST(root.right)) return false;\\n\\n        return true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786520,
                "title": "general-tree-traversal-problems-interview-prep",
                "content": "Please feel free to suggest similar problems in the comment section.\\n\\nThere are three types of Tree traversal: Inorder, Preorder and Postorder\\n\\n* **Inorder:** left, root, right\\n* **Preorder:** root, left child, right child **OR**  root, right child, left child\\t\\t\\t\\n* **Postorder:** left child, right child, root **OR** right child, left child, root\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\n**INORDER TRAVERSAL**\\n\\n**98. Validate Binary Search Tree**\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        output =[]\\n        self.inorder(root, output)\\n        \\n        for i in range(1, len(output)):\\n\\t\\t\\tif output[i-1]>= output[i]:\\n\\t\\t\\t\\treturn False\\n        \\n        return True\\n    \\n    # Time complexity of inorder traversal is O(n)\\n    # Fun fact: Inorder traversal leads to a sorted array if it is \\n    # a Valid Binary Search. Tree.\\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n        \\n```\\n**94. Binary Tree Inorder Traversal**\\n\\n\\n```\\n# Recursive: runtime-16ms\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.inorder(root, output)\\n        return output\\n        \\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n\\n\\n# Iterative Runtime: 20 ms, faster than 70.13%\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack=[]\\n        \\n        while stack or root:\\n            \\n            if root:\\n                stack.append(root)\\n                root =root.left\\n                \\n            else:\\n                temp =stack.pop()\\n                output.append(temp.val)\\n                root= temp.right\\n           \\n        return output\\n```\\n\\n**PREORDER TRAVERSAL**\\n\\n**589. N-ary Tree Preorder Traversal**\\n\\n\\n```\\n## Recursive Solution: Runtime: 36 ms, faster than 97.16%\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output =[]\\n        \\n        # perform dfs on the root and get the output stack\\n        self.dfs(root, output)\\n        \\n        # return the output of all the nodes.\\n        return output\\n    \\n    def dfs(self, root, output):\\n        \\n        # If root is none return \\n        if root is None:\\n            return\\n        \\n        # for preorder we first add the root val\\n        output.append(root.val)\\n        \\n        # Then add all the children to the output\\n        for child in root.children:\\n            self.dfs(child, output)\\n       \\n\\t   \\n\\t   \\n# Iterative Solution- Runtime: 40 ms, faster than 91.86% \\n\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n        \\n        # Till there is element in stack the loop runs.\\n        while stack:\\n            \\n            #pop the last element from the stack and store it into temp.\\n            temp = stack.pop()\\n            \\n            # append. the value of temp to output\\n            output.append(temp.val)\\n            \\n            #add the children of the temp into the stack in reverse order.\\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\\n            # This continues till the stack is empty.\\n            stack.extend(temp.children[::-1])\\n        \\n        #return the output\\n        return output\\n        \\n```\\n\\n\\n\\n**144. Binary Tree Preorder Traversal**\\n\\n\\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        \\n        output.append(root.val)\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output)\\n       \\n\\t   \\n# Iterative Solution- Runtime: 12 ms, faster than 97.82%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            temp=stack.pop()\\n            if temp:\\n                output.append(temp.val)\\n                stack.append(temp.right)\\n                stack.append(temp.left)\\n        \\n        return output\\n```\\n**257. Binary Tree Paths** : Runtime: 16 ms, faster than 93.92% of Python \\nhttps://leetcode.com/problems/binary-tree-paths/\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[str]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        result = []\\n        self.dfs(root, \"\", result)\\n        return result\\n\\n    def dfs(self, root, path, result):\\n        if not root.left and not root.right:\\n            result.append(path + str(root.val))\\n        \\n        if root.left:\\n            self.dfs(root.left, path + str(root.val) + \"->\" , result)\\n        if root.right:\\n            self.dfs(root.right, path + str(root.val) + \"->\", result)\\n        \\n```\\n\\n\\n**POSTORDER TRAVERSAL**\\n\\n**590. N-ary Tree Postorder Traversal**\\n```\\n# Recursive : Runtime: 40 ms, faster than 89.79% \\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        for child in root.children:\\n            self.dfs(child, output)\\n        \\n        output.append(root.val)\\n \\n \\n # Iterative Solution: Runtime: 48 ms, faster than 62.81%\\n \\n `\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                output.append(root.val)\\n                stack += root.children\\n                \\n        return output[::-1]`\\n        \\n```\\n\\n**145. Binary Tree Postorder Traversal**\\n\\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output) \\n        output.append(root.val)\\n\\t\\t\\n\\t\\t\\n# Iterative solution: Runtime: 12 ms, faster than 98.10%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack =[root]\\n        \\n        if not root:\\n            return None\\n        \\n        # iterate only when there is elements inside the stack.\\n        while stack:\\n            \\n            # pop the element from stack and stored it into temp\\n            temp=stack.pop()\\n            \\n            #append the value of temp to output\\n            output.append(temp.val)\\n            \\n            #Now traverse through left node and add the node to stack\\n            if temp.left:\\n                stack.append(temp.left)\\n                \\n            #else traverse through right node and add to stack\\n            if temp.right:\\n                stack.append(temp.right)\\n         \\n        # After iterating through the stack,  print the result in reverse order.  \\n        return output[::-1]\\n    \\n    \\n# Example: Iteration 1 : #stack=[1] - first iteration, temp =1, \\n                #output[1]\\n                #temp.left is Null\\n                #temp.right is [2]\\n                # stack =[2]\\n\\n```\\n\\n**LEVEL ORDER TRAVERSAL**\\n\\n**102. Binary Tree Level Order Traversal**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        \\n        if not root:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)    \\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\\n\\n**107. Binary Tree Level Order Traversal II**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrderBottom(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, 0, output)\\n        return output[::-1]\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n             return\\n            \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n```\\n\\n**429. N-ary Tree Level Order Traversal**\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level ,output):\\n        if root is None:\\n            return\\n        if len(output)< level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        for child in root.children:\\n            self.dfs(child, level+1, output)\\n      \\n```\\n\\n**103. Binary Tree Zigzag Level Order Traversal**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        \\n        for i in range(len(output)):\\n            if i % 2 !=0:\\n                output[i].reverse()\\n            else:\\n                continue\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\\n\\n\\n**BINARY TREE CONSTRUCTION**\\n\\n\\n**105. Construct Binary Tree from Preorder and Inorder Traversal**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not inorder or not preorder:\\n            return None\\n        \\n        #pattern is preorder=[root, left, right]\\n        #inorder = [left, root, right],  so find index and value using root.\\n        \\n        root = TreeNode(preorder[0])\\n        \\n        root_index= 0\\n        \\n        #iterate through inorder list and find the list index of the root.\\n        for i in range(len(inorder)):\\n            if inorder[i]== root.val:\\n                root_index = i\\n            else:\\n                continue\\n                \\n        #slice the inorder list into left and right.     \\n        left_inorder = inorder[:root_index]\\n        right_inorder = inorder[root_index+1:]\\n        \\n        #slice the preorder list into left and right.\\n        left_preorder = preorder[1:len(left_inorder)+1]\\n        right_preorder = preorder[len(left_preorder)+1:]\\n        \\n        #append by updating preorder and inorder lists\\n        root.left = self.buildTree(left_preorder, left_inorder)\\n        root.right = self.buildTree(right_preorder, right_inorder)\\n        \\n        return root\\n```\\n\\n**106. Construct Binary Tree from Inorder and Postorder Traversal**\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        # PATTERN\\n        # inorder: l, root, right\\n        # postorder: l,r,root\\n        # the last element of postorder is root\\n        \\n        if not inorder or not postorder:\\n            return None\\n        \\n        root_index=0\\n        \\n        # Build the data structure based on root value\\n        root = TreeNode(postorder.pop())\\n        \\n        for i in range(len(inorder)):\\n            if inorder[i]==root.val:\\n                root_index=i\\n            else:\\n                continue\\n        \\n        left_in=inorder[:root_index]\\n        right_in = inorder[root_index+1:]\\n        \\n        root.right = self.buildTree(right_in, postorder)\\n        root.left = self.buildTree(left_in,  postorder)\\n\\n        return root\\n   \\n```\\n\\n**889. Construct Binary Tree from Preorder and Postorder Traversal:** \\nRuntime: 40 ms, faster than 80.14%\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre:\\n            return None\\n        \\n        root = TreeNode(post.pop())\\n        \\n        if len(pre) == 1:\\n            return root\\n        \\n        # Find the index of the root value from pre\\n        for i in range(len(pre)):\\n            if pre[i]==post[-1]:\\n                root_index= i\\n            else:\\n                continue\\n        \\n        root.right = self.constructFromPrePost(pre[root_index:], post) \\n        root.left = self.constructFromPrePost(pre[1:root_index],post) \\n        \\n        return root \\n   \\n# Explanation:   root=1, root_index = 0, root.right=(pre(1,2,3,4,5,6,7))  [1, 2,3,4,5,6,7]                           vii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 3, root_index= 4, root.right=(pre(3,6,7))  [3,4,5,6,7]                               v\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root=7, root_index=2, root.right= pre(7), now len(pre) == 1, return 7 ---[7]        i\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =6, root_index=1, root.left= pre(6), now len(pre)==1, return 6 -----[6,7]      ii \\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =2, root_index= 1, root.right= pre(2,4,5)   [2,3,4,5,6,7]                               vi \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 5, root_index=2, root.right= pre(5)  now len(pre)==1, return 5 ----[5,6,7]   iii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 4, root_index=1, root.right= pre(4)  now len(pre)==1, return 4-----[4,5,6,7]  iv\\n\\n```\\n=========================================================\\nHope you\\'ve found the solutions useful. Please do UPVOTE, it only motivates me to write more such posts. Thanks!",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        output =[]\\n        self.inorder(root, output)\\n        \\n        for i in range(1, len(output)):\\n\\t\\t\\tif output[i-1]>= output[i]:\\n\\t\\t\\t\\treturn False\\n        \\n        return True\\n    \\n    # Time complexity of inorder traversal is O(n)\\n    # Fun fact: Inorder traversal leads to a sorted array if it is \\n    # a Valid Binary Search. Tree.\\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n        \\n```\n```\\n# Recursive: runtime-16ms\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.inorder(root, output)\\n        return output\\n        \\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n\\n\\n# Iterative Runtime: 20 ms, faster than 70.13%\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack=[]\\n        \\n        while stack or root:\\n            \\n            if root:\\n                stack.append(root)\\n                root =root.left\\n                \\n            else:\\n                temp =stack.pop()\\n                output.append(temp.val)\\n                root= temp.right\\n           \\n        return output\\n```\n```\\n## Recursive Solution: Runtime: 36 ms, faster than 97.16%\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output =[]\\n        \\n        # perform dfs on the root and get the output stack\\n        self.dfs(root, output)\\n        \\n        # return the output of all the nodes.\\n        return output\\n    \\n    def dfs(self, root, output):\\n        \\n        # If root is none return \\n        if root is None:\\n            return\\n        \\n        # for preorder we first add the root val\\n        output.append(root.val)\\n        \\n        # Then add all the children to the output\\n        for child in root.children:\\n            self.dfs(child, output)\\n       \\n\\t   \\n\\t   \\n# Iterative Solution- Runtime: 40 ms, faster than 91.86% \\n\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n        \\n        # Till there is element in stack the loop runs.\\n        while stack:\\n            \\n            #pop the last element from the stack and store it into temp.\\n            temp = stack.pop()\\n            \\n            # append. the value of temp to output\\n            output.append(temp.val)\\n            \\n            #add the children of the temp into the stack in reverse order.\\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\\n            # This continues till the stack is empty.\\n            stack.extend(temp.children[::-1])\\n        \\n        #return the output\\n        return output\\n        \\n```\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        \\n        output.append(root.val)\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output)\\n       \\n\\t   \\n# Iterative Solution- Runtime: 12 ms, faster than 97.82%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            temp=stack.pop()\\n            if temp:\\n                output.append(temp.val)\\n                stack.append(temp.right)\\n                stack.append(temp.left)\\n        \\n        return output\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[str]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        result = []\\n        self.dfs(root, \"\", result)\\n        return result\\n\\n    def dfs(self, root, path, result):\\n        if not root.left and not root.right:\\n            result.append(path + str(root.val))\\n        \\n        if root.left:\\n            self.dfs(root.left, path + str(root.val) + \"->\" , result)\\n        if root.right:\\n            self.dfs(root.right, path + str(root.val) + \"->\", result)\\n        \\n```\n```\\n# Recursive : Runtime: 40 ms, faster than 89.79% \\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        for child in root.children:\\n            self.dfs(child, output)\\n        \\n        output.append(root.val)\\n \\n \\n # Iterative Solution: Runtime: 48 ms, faster than 62.81%\\n \\n `\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                output.append(root.val)\\n                stack += root.children\\n                \\n        return output[::-1]`\\n        \\n```\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output) \\n        output.append(root.val)\\n\\t\\t\\n\\t\\t\\n# Iterative solution: Runtime: 12 ms, faster than 98.10%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack =[root]\\n        \\n        if not root:\\n            return None\\n        \\n        # iterate only when there is elements inside the stack.\\n        while stack:\\n            \\n            # pop the element from stack and stored it into temp\\n            temp=stack.pop()\\n            \\n            #append the value of temp to output\\n            output.append(temp.val)\\n            \\n            #Now traverse through left node and add the node to stack\\n            if temp.left:\\n                stack.append(temp.left)\\n                \\n            #else traverse through right node and add to stack\\n            if temp.right:\\n                stack.append(temp.right)\\n         \\n        # After iterating through the stack,  print the result in reverse order.  \\n        return output[::-1]\\n    \\n    \\n# Example: Iteration 1 : #stack=[1] - first iteration, temp =1, \\n                #output[1]\\n                #temp.left is Null\\n                #temp.right is [2]\\n                # stack =[2]\\n\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        \\n        if not root:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)    \\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrderBottom(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, 0, output)\\n        return output[::-1]\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n             return\\n            \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level ,output):\\n        if root is None:\\n            return\\n        if len(output)< level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        for child in root.children:\\n            self.dfs(child, level+1, output)\\n      \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        \\n        for i in range(len(output)):\\n            if i % 2 !=0:\\n                output[i].reverse()\\n            else:\\n                continue\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not inorder or not preorder:\\n            return None\\n        \\n        #pattern is preorder=[root, left, right]\\n        #inorder = [left, root, right],  so find index and value using root.\\n        \\n        root = TreeNode(preorder[0])\\n        \\n        root_index= 0\\n        \\n        #iterate through inorder list and find the list index of the root.\\n        for i in range(len(inorder)):\\n            if inorder[i]== root.val:\\n                root_index = i\\n            else:\\n                continue\\n                \\n        #slice the inorder list into left and right.     \\n        left_inorder = inorder[:root_index]\\n        right_inorder = inorder[root_index+1:]\\n        \\n        #slice the preorder list into left and right.\\n        left_preorder = preorder[1:len(left_inorder)+1]\\n        right_preorder = preorder[len(left_preorder)+1:]\\n        \\n        #append by updating preorder and inorder lists\\n        root.left = self.buildTree(left_preorder, left_inorder)\\n        root.right = self.buildTree(right_preorder, right_inorder)\\n        \\n        return root\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        # PATTERN\\n        # inorder: l, root, right\\n        # postorder: l,r,root\\n        # the last element of postorder is root\\n        \\n        if not inorder or not postorder:\\n            return None\\n        \\n        root_index=0\\n        \\n        # Build the data structure based on root value\\n        root = TreeNode(postorder.pop())\\n        \\n        for i in range(len(inorder)):\\n            if inorder[i]==root.val:\\n                root_index=i\\n            else:\\n                continue\\n        \\n        left_in=inorder[:root_index]\\n        right_in = inorder[root_index+1:]\\n        \\n        root.right = self.buildTree(right_in, postorder)\\n        root.left = self.buildTree(left_in,  postorder)\\n\\n        return root\\n   \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre:\\n            return None\\n        \\n        root = TreeNode(post.pop())\\n        \\n        if len(pre) == 1:\\n            return root\\n        \\n        # Find the index of the root value from pre\\n        for i in range(len(pre)):\\n            if pre[i]==post[-1]:\\n                root_index= i\\n            else:\\n                continue\\n        \\n        root.right = self.constructFromPrePost(pre[root_index:], post) \\n        root.left = self.constructFromPrePost(pre[1:root_index],post) \\n        \\n        return root \\n   \\n# Explanation:   root=1, root_index = 0, root.right=(pre(1,2,3,4,5,6,7))  [1, 2,3,4,5,6,7]                           vii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 3, root_index= 4, root.right=(pre(3,6,7))  [3,4,5,6,7]                               v\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root=7, root_index=2, root.right= pre(7), now len(pre) == 1, return 7 ---[7]        i\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =6, root_index=1, root.left= pre(6), now len(pre)==1, return 6 -----[6,7]      ii \\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =2, root_index= 1, root.right= pre(2,4,5)   [2,3,4,5,6,7]                               vi \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 5, root_index=2, root.right= pre(5)  now len(pre)==1, return 5 ----[5,6,7]   iii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 4, root_index=1, root.right= pre(4)  now len(pre)==1, return 4-----[4,5,6,7]  iv\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32178,
                "title": "clean-python-solution",
                "content": "Use recursion. Pass down two parameters: `lessThan` (which means that all nodes in the the current subtree must be smaller than this value) and `largerThan` (all must be larger than it). Compare root of the current subtree with these two values. Then, recursively check the left and right subtree of the current one. Take care of the values passed down.\\n\\n\\n    class Solution(object):\\n        def isValidBST(self, root, lessThan = float('inf'), largerThan = float('-inf')):\\n            if not root:\\n                return True\\n            if root.val <= largerThan or root.val >= lessThan:\\n                return False\\n            return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and \\\\\\n                   self.isValidBST(root.right, lessThan, max(root.val, largerThan))",
                "solutionTags": [],
                "code": "Use recursion. Pass down two parameters: `lessThan` (which means that all nodes in the the current subtree must be smaller than this value) and `largerThan` (all must be larger than it). Compare root of the current subtree with these two values. Then, recursively check the left and right subtree of the current one. Take care of the values passed down.\\n\\n\\n    class Solution(object):\\n        def isValidBST(self, root, lessThan = float('inf'), largerThan = float('-inf')):\\n            if not root:\\n                return True\\n            if root.val <= largerThan or root.val >= lessThan:\\n                return False\\n            return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and \\\\\\n                   self.isValidBST(root.right, lessThan, max(root.val, largerThan))",
                "codeTag": "Java"
            },
            {
                "id": 32138,
                "title": "another-passed-java-solution",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return helper(root, null, null);\\n        }\\n        \\n        boolean helper(TreeNode root, Integer min, Integer max) {\\n            if (root == null)\\n                return true;\\n            \\n            if ((min != null && root.val <= min) || (max != null && root.val >= max))\\n                return false;\\n            \\n            return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n        }\\n    }\\n\\nMy original solution was calling helper(root, Integer.MIN_VALUE, Integer.MAX_VALUE), but it failed when a tree node is either Integer.MIN_VALUE or Integer.MAX_VALUE. The correct solution is don't check with them.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return helper(root, null, null);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 974511,
                "title": "c-the-simplest-o-n-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\nprivate:\\n    vector<int> tree;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\nprivate:\\n    vector<int> tree;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32153,
                "title": "python-version-based-on-inorder-traversal",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @return a boolean\\n        # 7:38\\n        def isValidBST(self, root):\\n            output = []\\n            self.inOrder(root, output)\\n            \\n            for i in range(1, len(output)):\\n                if output[i-1] >= output[i]:\\n                    return False\\n    \\n            return True\\n    \\n        def inOrder(self, root, output):\\n            if root is None:\\n                return\\n            \\n            self.inOrder(root.left, output)\\n            output.append(root.val)\\n            self.inOrder(root.right, output)",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @return a boolean\\n        # 7:38\\n        def isValidBST(self, root):\\n            output = []\\n            self.inOrder(root, output)\\n            \\n            for i in range(1, len(output)):\\n                if output[i-1] >= output[i]:\\n                    return False\\n    \\n            return True\\n    \\n        def inOrder(self, root, output):\\n            if root is None:\\n                return\\n            \\n            self.inOrder(root.left, output)\\n            output.append(root.val)\\n            self.inOrder(root.right, output)",
                "codeTag": "Java"
            },
            {
                "id": 234410,
                "title": "c-recursive-and-iterative",
                "content": "For the recursive solution, we set a lower bound and a upper bound for the tree. When we recurse on the left subtree, the upper bound becomes the value of its root. When we recurse on the right subtree, the lower bound becomes the value of its root.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return valid(root, LONG_MIN, LONG_MAX);\\n    }\\nprivate:\\n    bool valid(TreeNode* root, long min, long max) {\\n        if (!root) {\\n            return true;\\n        }\\n        if (root -> val <= min || root -> val >= max) {\\n            return false;\\n        }\\n        return valid(root -> left, min, root -> val) && valid(root -> right, root -> val, max);\\n    }\\n};\\n```\\n\\nNote we use `LONG_MIN` and `LONG_MAX` to handle edge cases like `[INT_MAX]`.\\n\\nThe iterative idea is to apply iterative inorder traversal to the tree and check whether the current value is always larger than the previous one.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long pre = LONG_MIN;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            if (root -> val <= pre) {\\n                return false;\\n            }\\n            pre = root -> val;\\n            root = root -> right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return valid(root, LONG_MIN, LONG_MAX);\\n    }\\nprivate:\\n    bool valid(TreeNode* root, long min, long max) {\\n        if (!root) {\\n            return true;\\n        }\\n        if (root -> val <= min || root -> val >= max) {\\n            return false;\\n        }\\n        return valid(root -> left, min, root -> val) && valid(root -> right, root -> val, max);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long pre = LONG_MIN;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            if (root -> val <= pre) {\\n                return false;\\n            }\\n            pre = root -> val;\\n            root = root -> right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974147,
                "title": "python-js-java-go-c-o-n-by-dfs-and-rule-w-hint",
                "content": "O( n ) sol. by divide-and-conquer.\\n\\n[\\u672C\\u984C\\u5C0D\\u61C9\\u7684\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/650988e9fd897800019a383f)\\n\\n---\\n\\n**Hint**:\\n\\nThink of BST rule:\\n**Left sub-tree** nodes\\' value **< current** node value\\n**Right sub-tree** nodes\\' value **> current** node value\\n\\n---\\n\\n**Algorithm**:\\n\\nStep_#1:\\nSet upper bound as maximum integer, and lower bound as minimum integer in run-time environment.\\n\\nStep_#2:\\nStart DFS traversal from root node, and check whether each level follow BST rules or not.\\nUpdate lower bound and upper bound before going down to next level.\\n\\nStep_#3:\\nOnce we find the violation, reject and early return False.\\nOtherwise, accept and return True if all tree nodes follow BST rule.\\n\\n---\\n\\nPython\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        \\n        # Use maximal system integer to represent infinity\\n        INF = sys.maxsize\\n        \\n        def helper(node, lower, upper):\\n            \\n            if not node:\\n\\t\\t\\t\\t# empty node or empty tree\\n                return True\\n            \\n            if lower < node.val < upper:\\n\\t\\t\\t\\t# check if all tree nodes follow BST rule\\n                return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\\n            \\n            else:\\n\\t\\t\\t\\t# early reject when we find violation\\n                return False\\n            \\n        # ----------------------------------\\n        \\n        return helper( node=root, lower=-INF, upper=INF )\\n```\\n\\n---\\n\\nJava\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        \\n        return checker( -INF, INF, root);\\n    }\\n    \\n    private boolean checker( long lower, long upper, TreeNode node ){\\n        \\n        if( node == null ){\\n            return true;\\n        }\\n        \\n        if( (lower < node.val) && ( node.val < upper ) ){\\n            return checker(lower, node.val, node.left) && checker(node.val, upper, node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private long INF = Long.MAX_VALUE;\\n\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nC++\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidBST(TreeNode* root) {\\n\\n\\t\\t\\treturn validate(root, std::numeric_limits<long>::min(), std::numeric_limits<long>::max() );\\n\\t\\t}\\n\\n\\tprivate:\\n\\t\\tbool validate(TreeNode* node, long lower, long upper){\\n\\n\\t\\t\\tif( node == NULL ){\\n\\n\\t\\t\\t\\t// empty node or empty tree is valid always\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif( (lower < node->val) && (node->val < upper) ){\\n\\n\\t\\t\\t\\t// check if all tree nodes follow BST rule\\n\\t\\t\\t\\treturn validate(node->left, lower, node->val) && validate(node->right, node->val, upper);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// early reject when we find violation\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n\\t};\\n```\\n\\n</details>\\n\\n,or\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        prev = NULL;\\n        \\n        return validate(root );\\n    }\\n    \\nprivate:\\n    TreeNode *prev;\\n    bool validate(TreeNode* node){\\n        \\n        if( node == NULL ){\\n            \\n            // empty node or empty tree is valid always\\n            return true;\\n        }\\n        \\n        \\n        if( !validate(node->left ) ){\\n            return false;\\n        }\\n        \\n        if( prev != NULL && (node->val <= prev -> val) ){\\n            return false;\\n        }\\n        prev = node;\\n        \\n        return validate(node->right);\\n        \\n    }\\n};\\n```\\n\\n</details>\\n\\n\\n\\n---\\nGo\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\nfunc isValidBST(root *TreeNode) bool {\\n    \\n    return validate( root, math.MinInt, math.MaxInt)\\n}\\n\\nfunc validate(node *TreeNode, lower int, upper int)bool{\\n    \\n    if node == nil{\\n        \\n        //empty node or empty tree is always valid\\n        return true\\n    }\\n    \\n    if( (lower < node.Val) && (node.Val < upper) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.Left, lower, node.Val ) && validate( node.Right, node.Val, upper )\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false\\n    }\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\nJavascript\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\nvar isValidBST = function(root) {\\n    \\n    return validate(root, -Infinity, Infinity);\\n};\\n\\n\\nvar validate = function(node, lower,upper){\\n    \\n    if ( node == null ){\\n        \\n        // empty node or empty tree\\n        return true;\\n    }\\n    \\n    if( (lower < node.val) && ( node.val < upper ) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.left, lower, node.val) && validate( node.right, node.val, upper);\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false;\\n    }\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\nShare anotehr implementation with well-ordered property of BST\\'s inorder traversal\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def checker(node):\\n            \\n            if not node:\\n\\t\\t\\t\\t## Base case\\n                # empty node or empty tree\\n                yield True\\n                \\n            else:\\n                ## General cases:\\n\\n                yield from checker(node.left)\\n\\n                if checker.prev and (checker.prev.val >= node.val):\\n                    # previous node should be smaller then current node\\n                    # find violation\\n                    yield False\\n\\n                checker.prev = node\\n\\n                yield from checker(node.right)\\n                \\n            return\\n        # ---------------------------------------\\n        \\n        # use the property that inorder traversla of BST outputs sorted ascending sequence naturally\\n        checker.prev = None\\n        return all( checker(root) )\\n```\\n\\n---\\n\\nRelative leetcode challenge\\n\\n[Leetcode #99 Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)\\n\\n[Leetcode #700 Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        \\n        # Use maximal system integer to represent infinity\\n        INF = sys.maxsize\\n        \\n        def helper(node, lower, upper):\\n            \\n            if not node:\\n\\t\\t\\t\\t# empty node or empty tree\\n                return True\\n            \\n            if lower < node.val < upper:\\n\\t\\t\\t\\t# check if all tree nodes follow BST rule\\n                return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\\n            \\n            else:\\n\\t\\t\\t\\t# early reject when we find violation\\n                return False\\n            \\n        # ----------------------------------\\n        \\n        return helper( node=root, lower=-INF, upper=INF )\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        \\n        return checker( -INF, INF, root);\\n    }\\n    \\n    private boolean checker( long lower, long upper, TreeNode node ){\\n        \\n        if( node == null ){\\n            return true;\\n        }\\n        \\n        if( (lower < node.val) && ( node.val < upper ) ){\\n            return checker(lower, node.val, node.left) && checker(node.val, upper, node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private long INF = Long.MAX_VALUE;\\n\\n}\\n```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidBST(TreeNode* root) {\\n\\n\\t\\t\\treturn validate(root, std::numeric_limits<long>::min(), std::numeric_limits<long>::max() );\\n\\t\\t}\\n\\n\\tprivate:\\n\\t\\tbool validate(TreeNode* node, long lower, long upper){\\n\\n\\t\\t\\tif( node == NULL ){\\n\\n\\t\\t\\t\\t// empty node or empty tree is valid always\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif( (lower < node->val) && (node->val < upper) ){\\n\\n\\t\\t\\t\\t// check if all tree nodes follow BST rule\\n\\t\\t\\t\\treturn validate(node->left, lower, node->val) && validate(node->right, node->val, upper);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// early reject when we find violation\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n\\t};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        prev = NULL;\\n        \\n        return validate(root );\\n    }\\n    \\nprivate:\\n    TreeNode *prev;\\n    bool validate(TreeNode* node){\\n        \\n        if( node == NULL ){\\n            \\n            // empty node or empty tree is valid always\\n            return true;\\n        }\\n        \\n        \\n        if( !validate(node->left ) ){\\n            return false;\\n        }\\n        \\n        if( prev != NULL && (node->val <= prev -> val) ){\\n            return false;\\n        }\\n        prev = node;\\n        \\n        return validate(node->right);\\n        \\n    }\\n};\\n```\n```\\nfunc isValidBST(root *TreeNode) bool {\\n    \\n    return validate( root, math.MinInt, math.MaxInt)\\n}\\n\\nfunc validate(node *TreeNode, lower int, upper int)bool{\\n    \\n    if node == nil{\\n        \\n        //empty node or empty tree is always valid\\n        return true\\n    }\\n    \\n    if( (lower < node.Val) && (node.Val < upper) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.Left, lower, node.Val ) && validate( node.Right, node.Val, upper )\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false\\n    }\\n    \\n}\\n```\n```\\nvar isValidBST = function(root) {\\n    \\n    return validate(root, -Infinity, Infinity);\\n};\\n\\n\\nvar validate = function(node, lower,upper){\\n    \\n    if ( node == null ){\\n        \\n        // empty node or empty tree\\n        return true;\\n    }\\n    \\n    if( (lower < node.val) && ( node.val < upper ) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.left, lower, node.val) && validate( node.right, node.val, upper);\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false;\\n    }\\n    \\n}\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def checker(node):\\n            \\n            if not node:\\n\\t\\t\\t\\t## Base case\\n                # empty node or empty tree\\n                yield True\\n                \\n            else:\\n                ## General cases:\\n\\n                yield from checker(node.left)\\n\\n                if checker.prev and (checker.prev.val >= node.val):\\n                    # previous node should be smaller then current node\\n                    # find violation\\n                    yield False\\n\\n                checker.prev = node\\n\\n                yield from checker(node.right)\\n                \\n            return\\n        # ---------------------------------------\\n        \\n        # use the property that inorder traversla of BST outputs sorted ascending sequence naturally\\n        checker.prev = None\\n        return all( checker(root) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32101,
                "title": "my-java-inorder-iteration-solution",
                "content": "the idea is to do a inorder Traversal and keep the value of the\\n\\n    public boolean isValidBST (TreeNode root){\\n    \\t\\t   Stack<TreeNode> stack = new Stack<TreeNode> ();\\n    \\t\\t   TreeNode cur = root ;\\n    \\t\\t   TreeNode pre = null ;\\t\\t   \\n    \\t\\t   while (!stack.isEmpty() || cur != null) {\\t\\t\\t   \\n    \\t\\t\\t   if (cur != null) {\\n    \\t\\t\\t\\t   stack.push(cur);\\n    \\t\\t\\t\\t   cur = cur.left ;\\n    \\t\\t\\t   } else {\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   TreeNode p = stack.pop() ;\\n    \\t\\t\\t\\t   if (pre != null && p.val <= pre.val) {\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t\\t   return false ;\\n    \\t\\t\\t\\t   }\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   pre = p ;\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   cur = p.right ;\\n    \\t\\t\\t   }\\n    \\t\\t   }\\n    \\t\\t   return true ; \\n    \\t   }",
                "solutionTags": [],
                "code": "the idea is to do a inorder Traversal and keep the value of the\\n\\n    public boolean isValidBST (TreeNode root){\\n    \\t\\t   Stack<TreeNode> stack = new Stack<TreeNode> ();\\n    \\t\\t   TreeNode cur = root ;\\n    \\t\\t   TreeNode pre = null ;\\t\\t   \\n    \\t\\t   while (!stack.isEmpty() || cur != null) {\\t\\t\\t   \\n    \\t\\t\\t   if (cur != null) {\\n    \\t\\t\\t\\t   stack.push(cur);\\n    \\t\\t\\t\\t   cur = cur.left ;\\n    \\t\\t\\t   } else {\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   TreeNode p = stack.pop() ;\\n    \\t\\t\\t\\t   if (pre != null && p.val <= pre.val) {\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t\\t   return false ;\\n    \\t\\t\\t\\t   }\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   pre = p ;\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   cur = p.right ;\\n    \\t\\t\\t   }\\n    \\t\\t   }\\n    \\t\\t   return true ; \\n    \\t   }",
                "codeTag": "Unknown"
            },
            {
                "id": 146601,
                "title": "python3-100-using-easy-recursion",
                "content": "If you just want a solution scroll down, otherwise here\\'s an explanation.\\n\\nLet\\'s start with a simple definition of the nodes of a binary search tree!\\nA parent node is greater than its left child but smaller than its right.\\n```\\n    2\\n   / \\\\\\n  1   3 // valid tree!\\n```\\n\\n```\\n    5\\n   / \\\\\\n  1   4  // not valid here!\\n     / \\\\\\n    3   6\\n```\\n\\nOne solution would be to check every parent as we work down the tree but it creates a lot of complicated logic. So why don\\'t we check every child on the way up! All we have to do is keep track of the mininum and maximum valid values on the way down.\\n\\nTo prevent some extra checks let\\'s start with -infinity and infinity.\\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n```\\n\\nSo let\\'s walk it out!\\n```\\n    2 \\n   / \\\\\\n  1   3 \\n\\t\\n1 // -inf < 1 < 2, so it\\'s still valid\\n3 //  2 < 3 < inf, so it\\'s still a valid tree\\n2 // -inf < 2 < inf, so it\\'s a valid tree!\\n```\\n\\nAnd what about an invalid tree?\\n\\n```\\n    5 \\n   / \\\\\\n  1   4 \\n\\t\\n1 // -inf < 1 < 5, so it\\'s still a valid tree\\n4 // 5 > 4 < inf, this tree is not a valid binary tree!\\t\\n```\\n\\nSo here\\'s one way we could implement this logic!\\n\\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n\\t\\ndef check_bst(self, node, left, right):\\n    if not node:\\n        return True\\n\\n    if not left < node.val < right:\\n        return False\\n\\n    return (check_bst(node.left, left, node.val)\\n            and check_bst(node.right, node.val, right))\\n```",
                "solutionTags": [],
                "code": "```\\n    2\\n   / \\\\\\n  1   3 // valid tree!\\n```\n```\\n    5\\n   / \\\\\\n  1   4  // not valid here!\\n     / \\\\\\n    3   6\\n```\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n```\n```\\n    2 \\n   / \\\\\\n  1   3 \\n\\t\\n1 // -inf < 1 < 2, so it\\'s still valid\\n3 //  2 < 3 < inf, so it\\'s still a valid tree\\n2 // -inf < 2 < inf, so it\\'s a valid tree!\\n```\n```\\n    5 \\n   / \\\\\\n  1   4 \\n\\t\\n1 // -inf < 1 < 5, so it\\'s still a valid tree\\n4 // 5 > 4 < inf, this tree is not a valid binary tree!\\t\\n```\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n\\t\\ndef check_bst(self, node, left, right):\\n    if not node:\\n        return True\\n\\n    if not left < node.val < right:\\n        return False\\n\\n    return (check_bst(node.left, left, node.val)\\n            and check_bst(node.right, node.val, right))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2409071,
                "title": "python-one-liner-96-6-with-detailed-explantion-recursion-simple",
                "content": "There are two steps:\\n1. set a range (at first we set it to (-infinity, infinity)\\n2. see if every node is in their own range\\n![image](https://assets.leetcode.com/users/images/864f8660-dcc9-4ae5-82a6-4edbf8190755_1660181425.0985472.png)\\nHere\\'s the one line code:\\n```\\nclass Solution:\\n    def isValidBST(self, node: Optional[TreeNode],low=-inf, high=inf) -> bool:\\n            return (not node) or ((low < node.val < high) and self.isValidBST(node.left, low, node.val)  and self.isValidBST(node.right, node.val, high))\\n```\\n\\nHere\\'s the code for better understand:\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def helper(node, low, high):\\n            if not node:\\n                return True\\n            if not (low < node.val < high):\\n                return False\\n            return helper(node.left, low, node.val) and helper(node.right, node.val, high)\\n        \\n        return helper(root, -inf, inf)\\n```\\n**Please UPVOTE if you LIKE!!**\\n![image](https://assets.leetcode.com/users/images/6be7315b-0f00-463e-b813-977d576b9e0b_1660180800.7504048.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, node: Optional[TreeNode],low=-inf, high=inf) -> bool:\\n            return (not node) or ((low < node.val < high) and self.isValidBST(node.left, low, node.val)  and self.isValidBST(node.right, node.val, high))\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def helper(node, low, high):\\n            if not node:\\n                return True\\n            if not (low < node.val < high):\\n                return False\\n            return helper(node.left, low, node.val) and helper(node.right, node.val, high)\\n        \\n        return helper(root, -inf, inf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32193,
                "title": "1-ms-java-solution-using-recursion",
                "content": "    public class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, null, null);\\n    }\\n    \\n    public boolean isValid(TreeNode root, Integer min, Integer max) {\\n        if(root == null) return true;\\n        if(min != null && root.val <= min) return false;\\n        if(max != null && root.val >= max) return false;\\n        \\n        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, null, null);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 258511,
                "title": "easy-java-0ms-solution",
                "content": "The trick is to do an inorder traversal of the tree and check that the value of each node visited is greater than the value of the previous node.\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    TreeNode prev = null;\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        \\n        if(isValidBST(root.left) && (prev == null || root.val > prev.val)) {\\n            prev = root;\\n            return isValidBST(root.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    TreeNode prev = null;\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        \\n        if(isValidBST(root.left) && (prev == null || root.val > prev.val)) {\\n            prev = root;\\n            return isValidBST(root.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959657,
                "title": "c-recursive-solution-passing-all-test-cases",
                "content": "### Keep in Mind\\n * Passing `NULL` to `int` will cast `NULL` to `0` in integer. \\n * So, It will give wrong result for [0, null, -1].\\n * If someone will pass `INT_MIN` as default value, then It\\'ll fail for case - [-2147483648] and vice-versa.\\n *  That\\'s why pointers are used here.\\n *  One can use **TreeNode** addresses as pointers.\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValid(root, NULL, NULL);\\n    }\\n    \\n    bool isValid(TreeNode* root, int* lower, int* upper){\\n        if(!root)\\n            return true;\\n\\n        if(upper && root -> val >= *upper)\\n            return false;\\n        if(lower && root -> val <= *lower)\\n            return false;\\n        \\n        return isValid(root -> left, lower, &(root -> val)) && isValid(root -> right, &(root -> val), upper);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValid(root, NULL, NULL);\\n    }\\n    \\n    bool isValid(TreeNode* root, int* lower, int* upper){\\n        if(!root)\\n            return true;\\n\\n        if(upper && root -> val >= *upper)\\n            return false;\\n        if(lower && root -> val <= *lower)\\n            return false;\\n        \\n        return isValid(root -> left, lower, &(root -> val)) && isValid(root -> right, &(root -> val), upper);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410354,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.***\\n**Also you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\nhttps://www.youtube.com/watch?v=geBeUvcMMwo\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529937,
                "title": "javascript-97-faster-simple-recursion",
                "content": "```\\nvar isValidBST = function(root, min=null, max=null) {\\n    if (!root) return true;\\n    if (min && root.val <= min.val) return false;\\n    if (max && root.val >= max.val) return false;\\n    return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar isValidBST = function(root, min=null, max=null) {\\n    if (!root) return true;\\n    if (min && root.val <= min.val) return false;\\n    if (max && root.val >= max.val) return false;\\n    return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1282793,
                "title": "faster-than-100-cpp-solution-don-t-repeat-my-mistake-int-min-int-max",
                "content": "You might be doing the same mistake that I did, using **INT_MAX**, **INT_MIN**.\\nMy first solution : \\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, INT_MAX, INT_MIN);\\n    }\\n    \\n    bool fun(TreeNode* root, int max, int min){\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val > min && root->val < max){\\n\\t\\t\\t//checking recursively the left and right-subtree, are they BST??\\n\\t\\t\\t// if both subtree are BST, then Parent tree is also BST\\n            return fun(root->left, root->val, min) && fun(root->right, max, root->val);\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nBut I did a silly mistake here, The constraint given is from -2^31 to 2^31-1, and INT_MAX = 2^31-1 and INT_MIN = -2^31.\\nIn this case, it will fail.\\n\\nBetter approach is, that will never fail at any constartint is using the reference for minNode, and maxNode. Actually this is the basic concept here to be used, first one is dependent on the constraint.\\nFollowing this approach, we came up to this solution:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, NULL, NULL);\\n    }\\n    \\n    bool fun(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t// Using the same above logic\\n\\t\\t//Just check if max or min-node is NULL, then follow it as true\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return fun(root->left, root, min) && fun(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, INT_MAX, INT_MIN);\\n    }\\n    \\n    bool fun(TreeNode* root, int max, int min){\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val > min && root->val < max){\\n\\t\\t\\t//checking recursively the left and right-subtree, are they BST??\\n\\t\\t\\t// if both subtree are BST, then Parent tree is also BST\\n            return fun(root->left, root->val, min) && fun(root->right, max, root->val);\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, NULL, NULL);\\n    }\\n    \\n    bool fun(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t// Using the same above logic\\n\\t\\t//Just check if max or min-node is NULL, then follow it as true\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return fun(root->left, root, min) && fun(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724888,
                "title": "java-dfs-recursion-clean-0-ms",
                "content": "### **Please Upvote** :D\\n``` java []\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValid(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (root.val >= max || root.val <= min) {\\n            return false;\\n        }\\n        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValid(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (root.val >= max || root.val <= min) {\\n            return false;\\n        }\\n        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974185,
                "title": "python-simple-dfs-explained",
                "content": "We need to check that some property holds for every node of our tree, so as usual any recursion method should work here. Let us use function `dfs(node, low, high)`, where:\\n1. `node` is node we are currently in\\n2. `low` and `high` are bounds we expect to value of this node be in.\\n\\nNow, let us go to the main algorithm:\\n1. If we have `None` node, we are happy: empty tree is BST\\n2. Next we check if `low < node.val < high` and if it is not true, we can immedietly return `False`.\\n3. Finally, we check conditions for left children: its value should be in `(low, node.val)` and for right children: `(node.val, high)`. If one of this `dfs` return False, we need to return False.\\n\\n**Complexity**: time complexity is `O(n)` to traverse every node of our tree. Space complexity is `O(h)`, where `h` is height of our tree.\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root):\\n        def dfs(node, low, high):\\n            if not node: return True\\n            if not low < node.val < high: return False\\n            return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)\\n        \\n        return dfs(root, -float(\"inf\"), float(\"inf\"))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root):\\n        def dfs(node, low, high):\\n            if not node: return True\\n            if not low < node.val < high: return False\\n            return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)\\n        \\n        return dfs(root, -float(\"inf\"), float(\"inf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32117,
                "title": "my-javascript-solution",
                "content": "This is a very classic BST problem, we just need to scan every single node in the tree and see if the node's value matches the BST rules, that is all the values in node's left subtree are less than the value in node, and all the values in node's right subtree are greater than the value in node, if we found a node that doesn't satisfy the rules, simply return false from the recursion.\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isValidBST = function(root) {\\n    if (!root) {\\n        return true; // Sanity check for passing test case '[]'\\n    }\\n\\n    function helper(root, min, max) {\\n        if (!root) {\\n            return true; // We hit the end of the path\\n        }\\n        \\n        if ((min !== null && root.val <= min) || (max !== null && root.val >= max)) {\\n            return false; // current node's val doesn't satisfy the BST rules\\n        }\\n        \\n        // Continue to scan left and right\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n    \\n    return helper(root, null, null);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isValidBST = function(root) {\\n    if (!root) {\\n        return true; // Sanity check for passing test case '[]'\\n    }\\n\\n    function helper(root, min, max) {\\n        if (!root) {\\n            return true; // We hit the end of the path\\n        }\\n        \\n        if ((min !== null && root.val <= min) || (max !== null && root.val >= max)) {\\n            return false; // current node's val doesn't satisfy the BST rules\\n        }\\n        \\n        // Continue to scan left and right\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n    \\n    return helper(root, null, null);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32347,
                "title": "c-easy-to-read-in-order-traversal-solution",
                "content": "Ensure that every next node of in-order traversal is larger than previous one. Using boolean flag to start with the left most node.\\n\\n    class Solution {\\n        bool first = true;\\n        int prev = 0;\\n    public:\\n        bool isValidBST(TreeNode *root) {\\n            if(root == NULL) return true;\\n            \\n            return (\\n                isValidBST(root->left)\\n                && check(root->val)\\n                && isValidBST(root->right));\\n        }\\n        \\n        bool check(int val)\\n        {\\n            if(first)\\n            {\\n                first = false;\\n                prev = val;\\n                return true;\\n            }\\n            \\n            if(prev >= val) return false;\\n            \\n            prev = val;\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        bool first = true;\\n        int prev = 0;\\n    public:\\n        bool isValidBST(TreeNode *root) {\\n            if(root == NULL) return true;\\n            \\n            return (\\n                isValidBST(root->left)\\n                && check(root->val)\\n                && isValidBST(root->right));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3053617,
                "title": "c-inorder-ascending-order",
                "content": "# Intuition\\nThe inorder traversal of BST is in ascending order.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStore the elements of inorder traversal of BST in an array. If it doesn\\'t follow strictly increasing order, return false.\\nReturn true otherwise. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> numbers;//declare it globally, it contains the inorder traversal of BST\\n\\nvoid inorderpush(TreeNode* root){\\n    if(root==nullptr){\\n        return;\\n    }\\n    inorderpush(root->left);\\n    numbers.push_back(root->val);//inserts the element in array\\n    inorderpush(root->right);\\n}\\n\\nbool isValidBST(TreeNode* root) {\\n    inorderpush(root);\\n\\n    for(int i=0;i<numbers.size()-1;i++){\\n        if(numbers[i+1]<=numbers[i]){\\n            return false;//if array is not strictly increasing\\n        }\\n    }\\n    return true; //if array is strictly increasing   \\n    }\\n};\\n```\\n**Please upvote if it helps. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> numbers;//declare it globally, it contains the inorder traversal of BST\\n\\nvoid inorderpush(TreeNode* root){\\n    if(root==nullptr){\\n        return;\\n    }\\n    inorderpush(root->left);\\n    numbers.push_back(root->val);//inserts the element in array\\n    inorderpush(root->right);\\n}\\n\\nbool isValidBST(TreeNode* root) {\\n    inorderpush(root);\\n\\n    for(int i=0;i<numbers.size()-1;i++){\\n        if(numbers[i+1]<=numbers[i]){\\n            return false;//if array is not strictly increasing\\n        }\\n    }\\n    return true; //if array is strictly increasing   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642757,
                "title": "2-solutions-easy-to-understand-simple-recursive-iterative-python-solution",
                "content": "```\\n    def iterative(self, root):\\n        if not root: return True\\n        stack = [(root, -float(\\'inf\\'), float(\\'inf\\'))]\\n        while len(stack):\\n            node, left, right = stack.pop()\\n            if node.val <= left or node.val >= right: return False\\n            if node.left: stack.append((node.left, left, node.val))\\n            if node.right: stack.append((node.right, node.val, right))\\n        return True\\n        \\n        \\n        \\n        \\n    def recursive(self, root): \\n        def rec(node, left, right):\\n            if node:\\n                if node.val <= left or node.val >= right: return False\\n                return rec(node.left, left, node.val) and rec(node.right, node.val, right)\\n            return True\\n        return rec(root, -float(\\'inf\\'), float(\\'inf\\') )\\n        \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def iterative(self, root):\\n        if not root: return True\\n        stack = [(root, -float(\\'inf\\'), float(\\'inf\\'))]\\n        while len(stack):\\n            node, left, right = stack.pop()\\n            if node.val <= left or node.val >= right: return False\\n            if node.left: stack.append((node.left, left, node.val))\\n            if node.right: stack.append((node.right, node.val, right))\\n        return True\\n        \\n        \\n        \\n        \\n    def recursive(self, root): \\n        def rec(node, left, right):\\n            if node:\\n                if node.val <= left or node.val >= right: return False\\n                return rec(node.left, left, node.val) and rec(node.right, node.val, right)\\n            return True\\n        return rec(root, -float(\\'inf\\'), float(\\'inf\\') )\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1278481,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isBST(TreeNode root,long min,long max)\\n    {\\n        if(root == null)\\n            return true;\\n        \\n        //System.out.println(root.val + \" \"+min + \" \"+max);\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        \\n        boolean left = isBST(root.left,min,root.val);\\n        boolean right = isBST(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isBST(TreeNode root,long min,long max)\\n    {\\n        if(root == null)\\n            return true;\\n        \\n        //System.out.println(root.val + \" \"+min + \" \"+max);\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        \\n        boolean left = isBST(root.left,min,root.val);\\n        boolean right = isBST(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114459,
                "title": "3-python-solutions-clamping-window-in-order-traversal",
                "content": "*Solution 1:\\n\\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.isValidNode(root,float('-inf'), float('inf'))\\n    \\n    def isValidNode(self, root, l, r):\\n        if not root:\\n            return True\\n        return l<root.val<r and self.isValidNode(root.left, l, root.val) and self.isValidNode(root.right, root.val, r)\\n```\\n\\n\\n\\n\\n*Solution 2:\\n\\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        self.inorderT(root, order)\\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n    \\n    def inorderT(self, root, order):\\n        if root is None:\\n            return\\n        self.inorderT(root.left, order)\\n        order.append(root.val)\\n        self.inorderT(root.right, order)\\n```\\n\\n\\n\\n*Solution 3:\\n\\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        stack = []\\n        cur = root\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            cur = stack.pop()\\n            order.append(cur.val)\\n            cur = cur.right\\n        print(order)\\n        \\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.isValidNode(root,float('-inf'), float('inf'))\\n    \\n    def isValidNode(self, root, l, r):\\n        if not root:\\n            return True\\n        return l<root.val<r and self.isValidNode(root.left, l, root.val) and self.isValidNode(root.right, root.val, r)\\n```\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        self.inorderT(root, order)\\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n    \\n    def inorderT(self, root, order):\\n        if root is None:\\n            return\\n        self.inorderT(root.left, order)\\n        order.append(root.val)\\n        self.inorderT(root.right, order)\\n```\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        stack = []\\n        cur = root\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            cur = stack.pop()\\n            order.append(cur.val)\\n            cur = cur.right\\n        print(order)\\n        \\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440997,
                "title": "easy-to-understand-concise-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621513,
                "title": "javascript-intuitive-solution-using-inorder-traversal",
                "content": "```javascript\\nvar isValidBST = function(root) {\\n    \\n    function inOrder(node) {\\n        if(!node) return [];\\n        return [...inOrder(node.left), node.val, ...inOrder(node.right)]\\n    }\\n    \\n    const sortedArr = inOrder(root);\\n    \\n    for(let i = 0; i < sortedArr.length; i++) {\\n        if(sortedArr[i+1] <= sortedArr[i]) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isValidBST = function(root) {\\n    \\n    function inOrder(node) {\\n        if(!node) return [];\\n        return [...inOrder(node.left), node.val, ...inOrder(node.right)]\\n    }\\n    \\n    const sortedArr = inOrder(root);\\n    \\n    for(let i = 0; i < sortedArr.length; i++) {\\n        if(sortedArr[i+1] <= sortedArr[i]) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2409583,
                "title": "python-easily-understood-faster-than-96-recursion",
                "content": "Method: `recursion`\\n```\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(root, lower, upper):\\n\\t\\tif not root:\\n\\t\\t\\treturn True\\n\\t\\tif lower >= root.val or upper <= root.val:\\n\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\treturn check_validate(root.left, lower, root.val) and check_validate(\\n\\t\\t\\t\\troot.right, root.val, upper\\n\\t\\t\\t)\\n\\n\\treturn check_validate(root, -math.inf, math.inf)\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n<br/>\\nUsing `in-order`, much more easy-understanding\\n```\\nlast = -math.inf\\nended = False\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(cur):\\n\\t\\tif self.ended:\\n\\t\\t\\treturn \\n\\t\\tif cur.left:\\n\\t\\t\\tcheck_validate(cur.left)\\n\\n\\t\\tif not(cur.val > self.last):\\n\\t\\t\\tself.ended = True\\n\\t\\t\\treturn\\n\\n\\t\\tself.last = cur.val\\n\\t\\tif cur.right:\\n\\t\\t\\tcheck_validate(cur.right)\\n\\tcheck_validate(root)\\n\\treturn not self.ended\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n<br/>\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(root, lower, upper):\\n\\t\\tif not root:\\n\\t\\t\\treturn True\\n\\t\\tif lower >= root.val or upper <= root.val:\\n\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\treturn check_validate(root.left, lower, root.val) and check_validate(\\n\\t\\t\\t\\troot.right, root.val, upper\\n\\t\\t\\t)\\n\\n\\treturn check_validate(root, -math.inf, math.inf)\\n```\n```\\nlast = -math.inf\\nended = False\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(cur):\\n\\t\\tif self.ended:\\n\\t\\t\\treturn \\n\\t\\tif cur.left:\\n\\t\\t\\tcheck_validate(cur.left)\\n\\n\\t\\tif not(cur.val > self.last):\\n\\t\\t\\tself.ended = True\\n\\t\\t\\treturn\\n\\n\\t\\tself.last = cur.val\\n\\t\\tif cur.right:\\n\\t\\t\\tcheck_validate(cur.right)\\n\\tcheck_validate(root)\\n\\treturn not self.ended\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1047111,
                "title": "simple-js-dfs",
                "content": "```\\nvar isValidBST = function(root, min = -Infinity, max = Infinity) {\\n    if(root === null)\\n        return true;\\n    if(root.val <= min || root.val >= max)\\n        return false;\\n    return isValidBST(root.right, root.val, max) && isValidBST(root.left, min, root.val)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidBST = function(root, min = -Infinity, max = Infinity) {\\n    if(root === null)\\n        return true;\\n    if(root.val <= min || root.val >= max)\\n        return false;\\n    return isValidBST(root.right, root.val, max) && isValidBST(root.left, min, root.val)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970452,
                "title": "c-dfs-recursion-time-o-n-space-o-n",
                "content": "**DFS Recusive Approach**\\nThe reason why we update min and max at every step is because:\\n1. For every left node, the max value it can have it less than its parent\\'s and the min value it can have is the left most node for that particular subtree.\\n2. For every right node, the max value it can have it less than the right most node of that particular subtree  and the min value it can have is the root value.\\n\\nTime Complexity: O (n)\\nSpace Complexity: O (n) (For the recursion Stack)\\n```\\nclass Solution {\\npublic:\\n    bool isValidBSTHelper (TreeNode* currentNode, TreeNode* min, TreeNode* max) {\\n        if (currentNode==NULL) return true;               \\n        if (min && currentNode->val <= min->val) return false;\\n        if (max && currentNode->val >= max->val) return false;\\n\\n        return isValidBSTHelper (currentNode->left, min, currentNode) && isValidBSTHelper (currentNode->right, currentNode, max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTHelper (root, NULL, NULL);\\n    }\\n};\\n```\\nThis is a [nice intuitive solution](https://leetcode.com/problems/validate-binary-search-tree/discuss/990894/C%2B%2B-faster-than-90.55-of-C%2B%2B-and-less-than-87.48-of-C%2B%2B)\\n\\n**Iterative Inorder Stack Solution**\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack <TreeNode*> s;        \\n        TreeNode* pre=NULL;\\n        \\n        while (root || !s.empty()) {\\n            while (root) {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(), s.pop();\\n            \\n            if (pre!=NULL && root->val<=pre->val) return false;\\n            pre=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\\nVery nice article https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBSTHelper (TreeNode* currentNode, TreeNode* min, TreeNode* max) {\\n        if (currentNode==NULL) return true;               \\n        if (min && currentNode->val <= min->val) return false;\\n        if (max && currentNode->val >= max->val) return false;\\n\\n        return isValidBSTHelper (currentNode->left, min, currentNode) && isValidBSTHelper (currentNode->right, currentNode, max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTHelper (root, NULL, NULL);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack <TreeNode*> s;        \\n        TreeNode* pre=NULL;\\n        \\n        while (root || !s.empty()) {\\n            while (root) {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(), s.pop();\\n            \\n            if (pre!=NULL && root->val<=pre->val) return false;\\n            pre=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574931,
                "title": "beats-100-only-3-lines-code-diagram-image-best-explaination-c-python-java",
                "content": "# Diagram Data Flow\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![code2flow_4fd67K (1).png](https://assets.leetcode.com/users/images/c309b924-df01-4309-a316-8c0e521925f5_1685354802.071912.png)\\n\\n# Approach\\n**Before we start properties to verify BST are:**\\n- Top root node should have range -infinity to +infinity\\n- When we move to left of BST its value must be in -infinity and\\nthe value of its parent root !\\n- When move to right its value lies in more the parent root value and + infinity .\\n- We just checked this condition recursively and DONE ! \\n- Let -infinity and + infinity to given constaints in questions.\\n- Done\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode*root,long long int lb,long long int ub)\\n    {\\n        if(root==nullptr)return true;\\n        if((root->val<ub&&root->val>lb)&&(solve(root->left,lb,root->val))&&(solve(root->right,root->val,ub))) return true;\\n        else return false;\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        long long int lb=-2147483649;\\n        long long int ub=2147483648;\\n        bool ans =solve(root,lb,ub);\\n        return ans;\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/3c08567f-214c-420d-9996-ba6ba915f4cf_1685355329.144175.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode*root,long long int lb,long long int ub)\\n    {\\n        if(root==nullptr)return true;\\n        if((root->val<ub&&root->val>lb)&&(solve(root->left,lb,root->val))&&(solve(root->right,root->val,ub))) return true;\\n        else return false;\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        long long int lb=-2147483649;\\n        long long int ub=2147483648;\\n        bool ans =solve(root,lb,ub);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206020,
                "title": "c-solution-using-long-max-and-long-min",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidBSTHelper(TreeNode* root, long min, long max) {\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}   \\n\\t\\t\\tif(root->val > min && root->val < max) {\\n\\t\\t\\t\\treturn isValidBSTHelper(root->left, min, root->val) && isValidBSTHelper(root->right, root->val, max);\\n\\t\\t\\t}    \\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tbool isValidBST(TreeNode* root) {\\n\\t\\t\\treturn isValidBSTHelper(root, LONG_MIN, LONG_MAX);\\n\\t\\t} \\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isValidBSTHelper(TreeNode* root, long min, long max) {\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 32382,
                "title": "accepted-java-solution",
                "content": "import java.util.Stack;\\n\\npublic class Solution {\\n\\nStack<Integer> stack = new Stack<Integer>();\\n\\npublic void inOrder(TreeNode root){\\n\\n    if(root != null){\\n        inOrder(root.left);\\n        stack.push(root.val);\\n        inOrder(root.right);\\n    }\\n}\\npublic boolean isValidBST(TreeNode root){\\n\\n    if(root == null){\\n        return true;\\n    }\\n\\n    inOrder(root);\\n    int i = stack.pop();\\n\\n    while(!stack.isEmpty()){\\n        int j = stack.pop();\\n        if(i <= j){\\n            return false;\\n        }\\n        i = j;\\n    }\\n\\n    return true;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\nStack<Integer> stack = new Stack<Integer>();\\n\\npublic void inOrder(TreeNode root){\\n\\n    if(root != null){\\n        inOrder(root.left);\\n        stack.push(root.val);\\n        inOrder(root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32196,
                "title": "1ms-java-solution-o-n-time-and-o-1-space-using-integer-object-and-null-pointer",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBSTHelper(root, null, null);\\n        }\\n    \\n        private boolean isValidBSTHelper(TreeNode root, Integer leftBound, Integer rightBound) {\\n            // recursively pass left and right bounds from higher level to lower level\\n            if (root == null) {\\n                return true;\\n            }\\n            if (leftBound != null && root.val <= leftBound || rightBound != null && root.val >= rightBound) {\\n                return false;\\n            }\\n            return isValidBSTHelper(root.left, leftBound, root.val) && isValidBSTHelper(root.right, root.val, rightBound);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBSTHelper(root, null, null);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32378,
                "title": "python-easy-to-understand-iterative-and-recursive-solutions",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        return self.valid(root, -sys.maxsize, sys.maxsize)\\n    \\n    def valid(self, root, l, r):\\n        if not root:\\n            return True\\n        if not (l < root.val < r):\\n            return False\\n        return self.valid(root.left, l, root.val) and self.valid(root.right, root.val, r)\\n        \\n    def isValidBST3(self, root):\\n        pre, stack = None, []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return True\\n            node = stack.pop()\\n            if pre and pre.val >= node.val:\\n                return False\\n            pre = node\\n            root = node.right\\n        \\n    def isValidBST2(self, root):\\n        ret, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            ret.append(node.val)\\n            root = node.right\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n                \\n    def isValidBST1(self, root):\\n        ret = []\\n        self.dfs(root, ret)\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n             \\n    def dfs(self, root, ret):\\n        if root:\\n            self.dfs(root.left, ret)\\n            ret.append(root.val)\\n            self.dfs(root.right, ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        return self.valid(root, -sys.maxsize, sys.maxsize)\\n    \\n    def valid(self, root, l, r):\\n        if not root:\\n            return True\\n        if not (l < root.val < r):\\n            return False\\n        return self.valid(root.left, l, root.val) and self.valid(root.right, root.val, r)\\n        \\n    def isValidBST3(self, root):\\n        pre, stack = None, []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return True\\n            node = stack.pop()\\n            if pre and pre.val >= node.val:\\n                return False\\n            pre = node\\n            root = node.right\\n        \\n    def isValidBST2(self, root):\\n        ret, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            ret.append(node.val)\\n            root = node.right\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n                \\n    def isValidBST1(self, root):\\n        ret = []\\n        self.dfs(root, ret)\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n             \\n    def dfs(self, root, ret):\\n        if root:\\n            self.dfs(root.left, ret)\\n            ret.append(root.val)\\n            self.dfs(root.right, ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704624,
                "title": "simple-python-solution-to-validate-binary-search-tree-using-recursion",
                "content": "**IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def valid(node, left, right):\\n            if not node:\\n                return True\\n            if not (node.val<right and node.val>left):\\n                return False\\n            \\n            return (valid(node.left, left, node.val) and \\n                    valid(node.right, node.val, right))\\n        \\n        return valid(root, float(-inf), float(inf))\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def valid(node, left, right):\\n            if not node:\\n                return True\\n            if not (node.val<right and node.val>left):\\n                return False\\n            \\n            return (valid(node.left, left, node.val) and \\n                    valid(node.right, node.val, right))\\n        \\n        return valid(root, float(-inf), float(inf))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409238,
                "title": "java-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    private boolean flag=true;\\n    TreeNode prev=null;\\n    public boolean isValidBST(TreeNode root) {\\n        inorder(root);\\n        return flag;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(prev!=null && root.val<=prev.val){\\n            flag=false;\\n            return;\\n        }\\n        prev=root;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean flag=true;\\n    TreeNode prev=null;\\n    public boolean isValidBST(TreeNode root) {\\n        inorder(root);\\n        return flag;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(prev!=null && root.val<=prev.val){\\n            flag=false;\\n            return;\\n        }\\n        prev=root;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504455,
                "title": "easy-0-ms-100-fully-explained-java-c-python-js-c-python3-dfs",
                "content": "# **Java Solution:**\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree.\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);   \\n    } \\n    public boolean isValidBST(TreeNode root, double minimum, double maximum){\\n        // Base case: root is null...\\n        if(root == null) return true;\\n        // If the value of root is less or equal to minimum...\\n        // Or If the value of root is greater or equal to maximum...\\n        if(root.val <= minimum || root.val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // Base case...\\n        if(root == NULL) return true;\\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool check(TreeNode* root, long minimum, long maximum){\\n        // If root is NULl...\\n        if(root == NULL) return true;\\n        // If the value of root is less or equal to minimum \\n        // Or If the value of root is greater or equal to maximum\\n        if(root->val <= minimum || root->val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def isValidBST(self, root, maximum = float(\\'-inf\\'), minimum = float(\\'inf\\')):\\n        # Base case: root is null...\\n        if not root: return True\\n        # If the value of root is less thsn minimum Or greater than maximum...\\n        if not maximum < root.val < minimum: return False\\n        # Recursively call the function for the left and right subtree...\\n        return self.isValidBST(root.left, maximum, root.val) and self.isValidBST(root.right, root.val, minimum)\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar isValidBST = function(root, minimum, maximum) {\\n    // Base case: root is null...\\n    if(root == null) return true;\\n    // If the value of root is less or equal to minimum...\\n    // Or If the value of root is greater or equal to maximum...\\n    if(root.val <= minimum || root.val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool check(struct TreeNode* root, long minimum, long maximum){\\n    // If root is NULl...\\n    if(root == NULL) return true;\\n    // If the value of root is less or equal to minimum \\n    // Or If the value of root is greater or equal to maximum\\n    if(root->val <= minimum || root->val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n}\\nbool isValidBST(struct TreeNode* root){\\n    // Base case...\\n    if(root == NULL) return true;\\n    return check(root, LONG_MIN, LONG_MAX);\\n}\\n```\\n\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree.\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);   \\n    } \\n    public boolean isValidBST(TreeNode root, double minimum, double maximum){\\n        // Base case: root is null...\\n        if(root == null) return true;\\n        // If the value of root is less or equal to minimum...\\n        // Or If the value of root is greater or equal to maximum...\\n        if(root.val <= minimum || root.val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // Base case...\\n        if(root == NULL) return true;\\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool check(TreeNode* root, long minimum, long maximum){\\n        // If root is NULl...\\n        if(root == NULL) return true;\\n        // If the value of root is less or equal to minimum \\n        // Or If the value of root is greater or equal to maximum\\n        if(root->val <= minimum || root->val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isValidBST(self, root, maximum = float(\\'-inf\\'), minimum = float(\\'inf\\')):\\n        # Base case: root is null...\\n        if not root: return True\\n        # If the value of root is less thsn minimum Or greater than maximum...\\n        if not maximum < root.val < minimum: return False\\n        # Recursively call the function for the left and right subtree...\\n        return self.isValidBST(root.left, maximum, root.val) and self.isValidBST(root.right, root.val, minimum)\\n```\n```\\nvar isValidBST = function(root, minimum, maximum) {\\n    // Base case: root is null...\\n    if(root == null) return true;\\n    // If the value of root is less or equal to minimum...\\n    // Or If the value of root is greater or equal to maximum...\\n    if(root.val <= minimum || root.val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n};\\n```\n```\\nbool check(struct TreeNode* root, long minimum, long maximum){\\n    // If root is NULl...\\n    if(root == NULL) return true;\\n    // If the value of root is less or equal to minimum \\n    // Or If the value of root is greater or equal to maximum\\n    if(root->val <= minimum || root->val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n}\\nbool isValidBST(struct TreeNode* root){\\n    // Base case...\\n    if(root == NULL) return true;\\n    return check(root, LONG_MIN, LONG_MAX);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409094,
                "title": "java-0ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\n```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValid(TreeNode node, long l, long h) {\\n        if (node == null) { // Base Case\\n            return true;\\n        }\\n\\t\\t// intially head can be anything between -inf to +inf\\n\\t\\t//after head left node should be l to previous head node value and right node should be head node value to h\\n        return node.val > l && node.val < h && isValid(node.left, l, node.val) && isValid(node.right, node.val, h);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValid(TreeNode node, long l, long h) {\\n        if (node == null) { // Base Case\\n            return true;\\n        }\\n\\t\\t// intially head can be anything between -inf to +inf\\n\\t\\t//after head left node should be l to previous head node value and right node should be head node value to h\\n        return node.val > l && node.val < h && isValid(node.left, l, node.val) && isValid(node.right, node.val, h);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783930,
                "title": "easy-to-understand-2-lines-solution-o-n-with-examples-and-explanation-javascript",
                "content": "Short and sweet:\\n\\n```ts\\nfunction isValidBST(root: TreeNode|null, min = -Infinity, max = Infinity): boolean {\\n  if(!root) return true;\\n  return !(root.val <= min || root.val >= max) && isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n};\\n```\\n\\nHow it works?\\n- If the root is `null`, then is a valid BST.\\n- If the root is NOT null, then we check for the following:\\n  - check if the current node\\'s value is within boundaries (min/max). The intial boundaries are -/+ Infinity so any value would be valid.\\n  - However, for the children we start restricting the boundaries. If we go to the left subtree, then we set the current node as the `max` boundary. Similarly, if we go the right subtree, then we set the current node\\'s value as the `min`.\\n\\nLet\\'s do some examples:\\n\\n**Example 1**:\\n\\n`[20,10,30,null,18,null,null,9,19]`\\n\\n![image](https://assets.leetcode.com/users/images/c25f0c88-4a57-40ba-8bea-06f02a0cf64c_1597065536.6765602.png)\\n\\nThe recursion call will be the following:\\n\\n- isValidBST(root: 20, min = -Infinity, max = Infinity)\\n\\t- isValidBST(root: 10, min = -Infinity, max = 20)\\n\\t\\t- isValidBST(root: 18, min = 10, max = 20)\\n\\t\\t\\t- isValidBST(root: 9, min = 10, max = 18): `false`, though `9 < 18 < 19`, 9 is lower than the `min=10`, so it will return false.\\n\\n\\n**Example 2**:\\n\\n`[20,10,30,null,18,null,null,17,19]`\\n\\n![image](https://assets.leetcode.com/users/images/6d31c54b-a7c0-4269-a727-b211fccc14bc_1597065014.7532413.png)\\n\\nThe recursion call will be the following:\\n- isValidBST(root: 20, min: -Infinity, max: Infinity): `true`\\n\\t- isValidBST(root: 10, min = -Infinity, max = 20): `true`\\n\\t\\t- isValidBST(root: 18, min = 10, max = 20): `true`\\n\\t\\t\\t- isValidBST(root: 17, min = 10, max = 18): `true`\\n\\t\\t\\t- isValidBST(root: 19, min = 18, max = 20): `true`\\n\\t- isValidBST(root: 30, min = 20, max = Infinity): `true`\\n\\nEach one returns true so it\\'s a valid BST.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction isValidBST(root: TreeNode|null, min = -Infinity, max = Infinity): boolean {\\n  if(!root) return true;\\n  return !(root.val <= min || root.val >= max) && isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 509816,
                "title": "go-4ms",
                "content": "```\\nfunc isValidBST(root *TreeNode) bool {\\n    return RecValidate(root, nil, nil)\\n}\\n\\nfunc RecValidate(n, min, max *TreeNode) bool {\\n    if n == nil {\\n        return true\\n    }\\n    if min != nil && n.Val <= min.Val {\\n        return false\\n    }\\n    if max != nil && n.Val >= max.Val {\\n        return false\\n    }\\n    return RecValidate(n.Left, min, n) && RecValidate(n.Right, n, max)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidBST(root *TreeNode) bool {\\n    return RecValidate(root, nil, nil)\\n}\\n\\nfunc RecValidate(n, min, max *TreeNode) bool {\\n    if n == nil {\\n        return true\\n    }\\n    if min != nil && n.Val <= min.Val {\\n        return false\\n    }\\n    if max != nil && n.Val >= max.Val {\\n        return false\\n    }\\n    return RecValidate(n.Left, min, n) && RecValidate(n.Right, n, max)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32356,
                "title": "4-line-c-simple-solution-easy-understanding",
                "content": "     bool isValidBST(TreeNode* root) {\\n        return dfs_valid(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool dfs_valid(TreeNode *root, long low, long high) {\\n        if (!root) return true;\\n        return low < root->val && root->val < high && dfs_valid(root->left, low, root->val)\\n                && dfs_valid(root->right, root->val, high);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     bool isValidBST(TreeNode* root) {\\n        return dfs_valid(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool dfs_valid(TreeNode *root, long low, long high) {\\n        if (!root) return true;\\n        return low < root->val && root->val < high && dfs_valid(root->left, low, root->val)\\n                && dfs_valid(root->right, root->val, high);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3213726,
                "title": "python-inorder-traversal-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        arr = []\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        inorder(root)\\n        return True if arr == list(sorted(set(arr))) else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        arr = []\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        inorder(root)\\n        return True if arr == list(sorted(set(arr))) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508434,
                "title": "c-python-simple-o-n-solution",
                "content": "**C++ :**\\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root -> left);\\n        bTree.push_back(root -> val);\\n        inorder(root -> right);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        // An empty tree\\n        if(!root)\\n            return true;\\n        \\n        // A leaf\\n        if(!root -> right && !root -> left)\\n            return true;\\n        \\n        // Inorder traversal to get the tree\\'s values sorted\\n        inorder(root);\\n        \\n        for(int i = 0; i < bTree.size() - 1; ++i)\\n            if(bTree[i] >= bTree[i + 1])\\n                return false;\\n        return true;\\n        \\n    }\\n    \\n    private:\\n        vector<int> bTree;\\n};\\n```\\n\\n**Python :**\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.tree = []\\n     \\n    def inorder(self, root: Optional[TreeNode]) -> None:\\n        if not root:\\n            return\\n        \\n        self.inorder(root.left);\\n        self.tree.append(root.val);\\n        self.inorder(root.right);\\n        \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        if not root.right and not root.left:\\n            return True\\n        \\n        self.inorder(root)\\n        \\n        for i in range(len(self.tree) - 1):\\n            if self.tree[i] >= self.tree[i + 1]:\\n                return False\\n        return True;\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root -> left);\\n        bTree.push_back(root -> val);\\n        inorder(root -> right);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        // An empty tree\\n        if(!root)\\n            return true;\\n        \\n        // A leaf\\n        if(!root -> right && !root -> left)\\n            return true;\\n        \\n        // Inorder traversal to get the tree\\'s values sorted\\n        inorder(root);\\n        \\n        for(int i = 0; i < bTree.size() - 1; ++i)\\n            if(bTree[i] >= bTree[i + 1])\\n                return false;\\n        return true;\\n        \\n    }\\n    \\n    private:\\n        vector<int> bTree;\\n};\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.tree = []\\n     \\n    def inorder(self, root: Optional[TreeNode]) -> None:\\n        if not root:\\n            return\\n        \\n        self.inorder(root.left);\\n        self.tree.append(root.val);\\n        self.inorder(root.right);\\n        \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        if not root.right and not root.left:\\n            return True\\n        \\n        self.inorder(root)\\n        \\n        for i in range(len(self.tree) - 1):\\n            if self.tree[i] >= self.tree[i + 1]:\\n                return False\\n        return True;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32136,
                "title": "three-solutions-in-c",
                "content": "**Solution 1.** \\n\\nBF, O(n^2).\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(!root) return true;\\n        if(!isValid(root->left, root->val, true) || !isValid(root->right, root->val, false)) return false;\\n        return isValidBST(root->left) && isValidBST(root->right);\\n    }\\n    \\n    bool isValid(TreeNode* root, int bound, bool isLeft){\\n        return !root || (isLeft ? root->val < bound : root->val > bound ) && isValid(root->left, bound, isLeft) && isValid(root->right, bound, isLeft);\\n    }\\n};\\n```\\n***\\n**Solution 2.** \\n\\nIn-order, recursive, O(n), refered from [here](https://discuss.leetcode.com/topic/4659/c-in-order-traversal-and-please-do-not-rely-on-buggy-int_max-int_min-solutions-any-more).\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* pre = NULL;\\n        return isValid(root, pre);\\n    }\\n    \\n    bool isValid(TreeNode* root, TreeNode* &pre){\\n        if(!root) return true;\\n        if(!isValid(root->left, pre)) return false;\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        return isValid(root->right, pre);\\n    }\\n};\\n```\\n***\\n**Solution 3.** \\n\\nIn-order, iterative, O(n), refered from [here](https://discuss.leetcode.com/topic/46016/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution).\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*>s;\\n        TreeNode* pre = NULL;\\n        while(root || !s.empty()){\\n            while(root){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre && root->val <= pre->val) return false;\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(!root) return true;\\n        if(!isValid(root->left, root->val, true) || !isValid(root->right, root->val, false)) return false;\\n        return isValidBST(root->left) && isValidBST(root->right);\\n    }\\n    \\n    bool isValid(TreeNode* root, int bound, bool isLeft){\\n        return !root || (isLeft ? root->val < bound : root->val > bound ) && isValid(root->left, bound, isLeft) && isValid(root->right, bound, isLeft);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* pre = NULL;\\n        return isValid(root, pre);\\n    }\\n    \\n    bool isValid(TreeNode* root, TreeNode* &pre){\\n        if(!root) return true;\\n        if(!isValid(root->left, pre)) return false;\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        return isValid(root->right, pre);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*>s;\\n        TreeNode* pre = NULL;\\n        while(root || !s.empty()){\\n            while(root){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre && root->val <= pre->val) return false;\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247077,
                "title": "java-recursive-solution-0ms-without-using-long-max-value-and-long-min-value",
                "content": "# Approach\\nFor this problem, we need to choose one biggest value > `Integer.MAX_VALUE`\\nand one smallest value < `Integer.MIN_VALUE` as the maximum and minimum, respectively. They could not be equal, otherwise cases like\\n```\\nroot = [2147483647]\\nroot = [2147483647, 2147483647]\\n```\\nwill be failed.\\n\\n`Long.MAX_VALUE` and `Long.MIN_VALUE` are luckily the two that meet our needs. However, if unluckily in the future the LeetCode admin adds them into the test cases, cases like\\n```\\nroot = [9223372036854775807]\\nroot = [9223372036854775807, 9223372036854775807]\\n```\\nwill be failed again.\\n\\nTherefore, it is better to avoid using them. We can simply replace the `int` or `long` with `TreeNode`, and set them to `null` when calling the helper function, as shown in the code below.\\n\\n# Reference\\nhttps://algs4.cs.princeton.edu/32bst/BST.java.html\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n\\n    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (min != null && root.val <= min.val) {\\n            return false;\\n        }\\n\\n        if (max != null && root.val >= max.val) {\\n            return false;\\n        }\\n        return isValidBST(root.left, min, root) \\n                && isValidBST(root.right, root, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nroot = [2147483647]\\nroot = [2147483647, 2147483647]\\n```\n```\\nroot = [9223372036854775807]\\nroot = [9223372036854775807, 9223372036854775807]\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n\\n    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (min != null && root.val <= min.val) {\\n            return false;\\n        }\\n\\n        if (max != null && root.val >= max.val) {\\n            return false;\\n        }\\n        return isValidBST(root.left, min, root) \\n                && isValidBST(root.right, root, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736338,
                "title": "easy-c-solution-dfs-recursion",
                "content": "# Solution via in-order traversal [we need to check whether that returned elements are in ascending order]\\n\\n```\\nclass Solution {\\npublic:\\n    long int num = LONG_MIN;\\n\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n        \\n        bool ans = isValidBST(root->left);\\n        \\n        if (root->val > num) {\\n            num = root->val;\\n        } else return false;\\n\\n        return ans && isValidBST(root->right);\\n    }\\n};\\n```\\n\\n# Solution via recursion\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, long int min = LONG_MIN, long int max = LONG_MAX) {\\n        if (!root) return true;\\n\\n        if (root->val > min && root->val < max) {\\n            return true && isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n\\n\\n*If the above approaches helped you, then please upvote the solution!*\\n\\n## My GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long int num = LONG_MIN;\\n\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n        \\n        bool ans = isValidBST(root->left);\\n        \\n        if (root->val > num) {\\n            num = root->val;\\n        } else return false;\\n\\n        return ans && isValidBST(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, long int min = LONG_MIN, long int max = LONG_MAX) {\\n        if (!root) return true;\\n\\n        if (root->val > min && root->val < max) {\\n            return true && isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847783,
                "title": "dfs-solution-easy-to-understand",
                "content": "```\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        self.answer = True\\n        \\n        def dfs(root, left, right):\\n            if root:\\n                if left >= root.val or root.val >= right:\\n                    self.answer = False\\n                    return\\n                dfs(root.left, left, root.val)\\n                dfs(root.right, root.val, right)\\n        dfs(root, float(\"-inf\"), float(\\'inf\\'))\\n        return self.answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        self.answer = True\\n        \\n        def dfs(root, left, right):\\n            if root:\\n                if left >= root.val or root.val >= right:\\n                    self.answer = False\\n                    return\\n                dfs(root.left, left, root.val)\\n                dfs(root.right, root.val, right)\\n        dfs(root, float(\"-inf\"), float(\\'inf\\'))\\n        return self.answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 286092,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return DFS(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool DFS(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (min < root.val && root.val < max) {\\n            var leftResult = DFS(root.left, min, root.val);\\n            var rightResult = DFS(root.right, root.val, max);\\n\\n            if (leftResult && rightResult) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return DFS(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool DFS(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (min < root.val && root.val < max) {\\n            var leftResult = DFS(root.left, min, root.val);\\n            var rightResult = DFS(root.right, root.val, max);\\n\\n            if (leftResult && rightResult) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232839,
                "title": "swift",
                "content": "```swift\\nfunc isValidBST(_ root: TreeNode?) -> Bool {\\n   return isBst(root, min: Int.min, max: Int.max)\\n}\\n    \\nprivate func isBst(_ node: TreeNode?, min: Int, max: Int) -> Bool {\\n\\tif node == nil { return true }\\n\\tif node!.val <= min || node!.val >= max { return false }\\n\\treturn isBst(node?.left, min: min, max: node!.val) &&\\n\\t\\t   isBst(node?.right, min: node!.val, max: max)\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc isValidBST(_ root: TreeNode?) -> Bool {\\n   return isBst(root, min: Int.min, max: Int.max)\\n}\\n    \\nprivate func isBst(_ node: TreeNode?, min: Int, max: Int) -> Bool {\\n\\tif node == nil { return true }\\n\\tif node!.val <= min || node!.val >= max { return false }\\n\\treturn isBst(node?.left, min: min, max: node!.val) &&\\n\\t\\t   isBst(node?.right, min: node!.val, max: max)\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207438,
                "title": "javascript",
                "content": "```\\nvar isValidBST = function(root) {\\n    if(!root) \\n        return true\\n    return dfs(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)\\n    \\n    function dfs(root, min, max){\\n        if(!root) \\n            return true\\n        if(root.val <= min || root.val >= max)\\n            return false\\n        return dfs(root.left, min, root.val) && dfs(root.right, root.val, max)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidBST = function(root) {\\n    if(!root) \\n        return true\\n    return dfs(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)\\n    \\n    function dfs(root, min, max){\\n        if(!root) \\n            return true\\n        if(root.val <= min || root.val >= max)\\n            return false\\n        return dfs(root.left, min, root.val) && dfs(root.right, root.val, max)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32306,
                "title": "1-ms-java-solution",
                "content": "    public class Solution {\\n        private TreeNode prev = null;\\n        \\n        public boolean isValidBST(TreeNode root) {\\n            if(root == null){\\n                return true;\\n            }\\n            if(!isValidBST(root.left)) return false;\\n            if(prev != null && root.val <= prev.val) return false;\\n            prev = root;\\n            return isValidBST(root.right);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        private TreeNode prev = null;\\n        \\n        public boolean isValidBST(TreeNode root) {\\n            if(root == null){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32370,
                "title": "python-inorder-non-recursive-solution-using-stack",
                "content": "    class Solution(object):\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            # using inorder - binary search tree will be ascending order\\n            stack = []\\n            cur = root\\n            pre = None\\n            while len(stack) or cur:\\n                if cur:\\n                    stack.append(cur)\\n                    cur = cur.left\\n                else:\\n                    p = stack.pop()\\n                    if pre and p.val <= pre.val:\\n                        return False\\n                    pre = p\\n                    cur = p.right\\n            return True",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    class Solution(object):\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            # using inorder - binary search tree will be ascending order\\n            stack = []\\n            cur = root\\n            pre = None\\n            while len(stack) or cur:\\n                if cur:\\n                    stack.append(cur)\\n                    cur = cur.left\\n                else:\\n                    p = stack.pop()\\n                    if pre and p.val <= pre.val:\\n                        return False\\n                    pre = p\\n                    cur = p.right\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 32502,
                "title": "test-cases-missing",
                "content": "There should be a test case where some nodes have values equal to Integer.MIN_VALUE and Integer.MAX_VALUE;\\n\\nThis solution is accepted and shouldn't be:\\n\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        return isValidBST(root.left,Integer.MIN_VALUE, root.val) \\n               && isValidBST(root.right,root.val,Integer.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, int smallest, int largest) {\\n        if (root == null) return true;\\n        if (root.val > smallest && root.val < largest)\\n            return isValidBST(root.left,smallest, root.val) \\n                   && isValidBST(root.right,root.val,largest);\\n        else\\n            return false;\\n    }",
                "solutionTags": [],
                "code": "There should be a test case where some nodes have values equal to Integer.MIN_VALUE and Integer.MAX_VALUE;\\n\\nThis solution is accepted and shouldn't be:\\n\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        return isValidBST(root.left,Integer.MIN_VALUE, root.val) \\n               && isValidBST(root.right,root.val,Integer.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, int smallest, int largest) {\\n        if (root == null) return true;\\n        if (root.val > smallest && root.val < largest)\\n            return isValidBST(root.left,smallest, root.val) \\n                   && isValidBST(root.right,root.val,largest);\\n        else\\n            return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3770870,
                "title": "superb-lgic-bst",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def BST(root,mx,mi):\\n            if not root:\\n                return True\\n            elif root.val>=mx or root.val<=mi:\\n                return False\\n            else:\\n                return BST(root.left,root.val,mi) and BST(root.right,mx,root.val)\\n        return BST(root,float(\\'inf\\'),float(\\'-inf\\'))\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def BST(root,mx,mi):\\n            if not root:\\n                return True\\n            elif root.val>=mx or root.val<=mi:\\n                return False\\n            else:\\n                return BST(root.left,root.val,mi) and BST(root.right,mx,root.val)\\n        return BST(root,float(\\'inf\\'),float(\\'-inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390380,
                "title": "intuitive-c-solution-inorder-traversal",
                "content": "##### Let\\'s connect on Linkedin https://www.linkedin.com/in/arthur-asanaliev/\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251741,
                "title": "simple-brute-force-solution-o-n-time-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you clearly understand the question, it states that you just need to check whether the BST is valid or not, and when we traverse a BST using INORDER, the output stream will be a sorted list.\\n\\n# Simple Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can traverse the BST using Inorder and store each output element in a list, and check whether the list is sorted or not.\\n\\n**FOR EXAMPLE:**\\nIf the BST looks something like this:\\n![djanj.png](https://assets.leetcode.com/users/images/4435e6a0-5248-45a0-97bf-a83d668f8569_1677843929.3729975.png)\\n\\nThe **INORDER** traversal will be - [1, 3, 4, 6, 7, 8, 10, 13, 14]\\nAnd if a tree is a BST the inorder will be sorted;\\n\\nThe above tree is a valid BST, and we can check that using the above inorder list.\\n\\n\\n# Complexity\\n- Time complexity: O(N) for traversing tree and O(N) for checking if resultant list is sorted or not,  N = Number of Nodes in a tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) in worst case if tree is skewed, and O(N) space for storing each element in a list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Travserse entire tree using inorder, and store each element inside the res.\\n    void inorder(TreeNode* root, vector<int>&res) {\\n        if(!root) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> res;\\n        inorder(root, res);\\n        for(int i=1; i<res.size(); ++i) {\\n            // Checking if res[i-1] >= res[i] then return false;\\n            // That means the input tree is not a valid BST;\\n            if(res[i-1]>=res[i]) return false;\\n        }\\n        return true;\\n        // Follow up: solve this without using any extra space.\\n        // Hint: You can use ranges, for each element.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Travserse entire tree using inorder, and store each element inside the res.\\n    void inorder(TreeNode* root, vector<int>&res) {\\n        if(!root) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> res;\\n        inorder(root, res);\\n        for(int i=1; i<res.size(); ++i) {\\n            // Checking if res[i-1] >= res[i] then return false;\\n            // That means the input tree is not a valid BST;\\n            if(res[i-1]>=res[i]) return false;\\n        }\\n        return true;\\n        // Follow up: solve this without using any extra space.\\n        // Hint: You can use ranges, for each element.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926224,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n \\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n\\n    private var prev: Int?\\n    \\n    func isValidBST(_ root: TreeNode?) -> Bool {\\n        inorder(root)\\n    }\\n    \\n    private func inorder(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return true }\\n        \\n        guard inorder(root.left) else { return false }\\n        \\n        if let prev = prev, root.val <= prev { return false }\\n        \\n        prev = root.val\\n        return inorder(root.right)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n \\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n\\n    private var prev: Int?\\n    \\n    func isValidBST(_ root: TreeNode?) -> Bool {\\n        inorder(root)\\n    }\\n    \\n    private func inorder(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return true }\\n        \\n        guard inorder(root.left) else { return false }\\n        \\n        if let prev = prev, root.val <= prev { return false }\\n        \\n        prev = root.val\\n        return inorder(root.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682393,
                "title": "easy-c-inorder-traversal-o-n",
                "content": "The inorder traversal of a BST is always sorted.\\nAlgortihm\\n1) Obtain the Inorder traversal of Binary Tree\\n2) Check if Inorder traversal is sorted\\n3) If sorted then return TRUE\\n4) If  NOT sorted then return FALSE\\n\\nInorder Traversal Explained\\n![image](https://assets.leetcode.com/users/images/6bf52f7d-5b1f-4bc1-bdab-c88511f090c6_1641889707.5851665.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void check(TreeNode* root, vector <int>& res){\\n        if(root == NULL) return;\\n        \\n        check(root->left,res);\\n        res.push_back(root->val);\\n        check(root->right,res);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector <int> res;\\n        check(root,res);\\n        for(int i = 1; i <res.size(); i++){\\n            if(res[i] <= res[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nUpvote if you understood.\\nThank you!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(TreeNode* root, vector <int>& res){\\n        if(root == NULL) return;\\n        \\n        check(root->left,res);\\n        res.push_back(root->val);\\n        check(root->right,res);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector <int> res;\\n        check(root,res);\\n        for(int i = 1; i <res.size(); i++){\\n            if(res[i] <= res[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150778,
                "title": "java-solution-both-recursive-and-non-recursive-good-way-to-build-concept-on-tree",
                "content": "I found this to be a good problem to improve concepts on tree, especially BST.\\nApproach 1: Employ BST property and iterative inorder traversal.\\nWe remember that in BST, an iterative inorder traversal is basically an ascending sorted list. Now, we also know that no two elements in the tree are equal.\\n\\nHence the simple logic that at any given point of time, the previous element should not be greater than or equal to the current element. For the first element, previous element is just \"null\".\\n\\nFor boundary conditions, we need to understand that Integer.MAX_VALUE and Integer.MIN_VALUE are all valid values, so cannot be used as sentinel markers. \\n\\nCode below:\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode prev = null;\\n        TreeNode curr = root;\\n        \\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Inorder visit of node\\n            curr = stack.pop();\\n\\t\\t\\t// Checking BST property\\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        // At this stage, all nodes have been visited, and we know the tree is BST\\n        return true;\\n        \\n    }\\n}\\n```\\n\\nNow the interviewer can ask for any alternative approach to solve this problem, like a recursive approach without any global/member variable. In this case, we need to think about invariant here are the bounds of each node.\\nIf a node is a left child in a BST, it\\'s max value is bound by its parent. Similarly, if it right child, then its min value is bound by its parent.\\n\\nOne trick here is how do we intuitively pass unbounded limits since MIN and MAX values are already taken? In Java, Integer object comes to the rescue, and the value \"null\" indicates unbounded value.\\n\\nRest of the code is pretty intuitive:\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, null, null);\\n    }\\n    \\n    private boolean helper(TreeNode node, Integer minVal, Integer maxVal) {\\n        if (node == null) {\\n            return true;\\n        }\\n        \\n        // Preorder traversal: check if the current node respects the bounds\\n        if (minVal != null && node.val <= minVal) {\\n            return false;\\n        }\\n        \\n        if (maxVal != null && node.val >= maxVal) {\\n            return false;\\n        }\\n        \\n        // Traverse left and right children, note that current node applies to min and max bounds based on which\\n        // child we select\\n        boolean left = helper(node.left, minVal, node.val);\\n        boolean right = helper(node.right, node.val, maxVal);\\n        return left == true && right == true;\\n    }\\n}\\n```\\n\\nBoth the algorithms take O(n) time complexity since they intend to visit all nodes to ensure the tree is BST, and O(h) space which signifies the stack size (explicit stack or recursion stack). Skewed tree with only left/right child will take worst case space of (n) following basic tree property.\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode prev = null;\\n        TreeNode curr = root;\\n        \\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Inorder visit of node\\n            curr = stack.pop();\\n\\t\\t\\t// Checking BST property\\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        // At this stage, all nodes have been visited, and we know the tree is BST\\n        return true;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, null, null);\\n    }\\n    \\n    private boolean helper(TreeNode node, Integer minVal, Integer maxVal) {\\n        if (node == null) {\\n            return true;\\n        }\\n        \\n        // Preorder traversal: check if the current node respects the bounds\\n        if (minVal != null && node.val <= minVal) {\\n            return false;\\n        }\\n        \\n        if (maxVal != null && node.val >= maxVal) {\\n            return false;\\n        }\\n        \\n        // Traverse left and right children, note that current node applies to min and max bounds based on which\\n        // child we select\\n        boolean left = helper(node.left, minVal, node.val);\\n        boolean right = helper(node.right, node.val, maxVal);\\n        return left == true && right == true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594360,
                "title": "simple-readable-java-recursion-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root, Integer min, Integer max) {\\n        if (root == null) \\n            return true; \\n        if ((max != null && root.val >= max) || (min != null && root.val <= min)) \\n            return false; \\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root, Integer min, Integer max) {\\n        if (root == null) \\n            return true; \\n        if ((max != null && root.val >= max) || (min != null && root.val <= min)) \\n            return false; \\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32369,
                "title": "output-in-submit-and-run-code-are-different",
                "content": "I submit my code and got return as wrong answer since it does not pass case [0,-1]. It shows my output is false but it should be true. Then I run code by check customized case [0,-1]. It shows my output is true. Is there anything wrong?\\n\\n    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        global pre\\n        pre = None\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            global pre\\n            if (root == None):\\n                return True\\n            if ((not self.isValidBST(root.left)) or (pre != None and pre.val >= root.val)):\\n                return False\\n            pre = root\\n            if (not self.isValidBST(root.right)):\\n                return False\\n            return True",
                "solutionTags": [],
                "code": "I submit my code and got return as wrong answer since it does not pass case [0,-1]. It shows my output is false but it should be true. Then I run code by check customized case [0,-1]. It shows my output is true. Is there anything wrong?\\n\\n    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        global pre\\n        pre = None\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            global pre\\n            if (root == None):\\n                return True\\n            if ((not self.isValidBST(root.left)) or (pre != None and pre.val >= root.val)):\\n                return False\\n            pre = root\\n            if (not self.isValidBST(root.right)):\\n                return False\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 32300,
                "title": "morris-traversal-o-1-space-no-recursion-o-n-time-with-explanation-java",
                "content": "    // inorder traversal to see if the value is monotonically increased\\n    // use morris traversal to gain O(1) space, No recursion and O(n) time\\n    // main idea: the key part of tree traversal is how to go back to parent,\\n    //            one way is to use recursion and store parent in function stack,\\n    //            another way is to use explicit stack to store parent,\\n    //            morris traversal modify the original tree and \\n    //            let the right child of the predecessor of the root to point back to itself\\n    //            in order to go back to the root and then restore the pointer(set it to null again)\\n    //            the overall time complexity is still O(n), since the tree is traversed\\n    //            no more than twice(there is not overlap between the path of finding predecessor).\\n    public boolean isValidBST(TreeNode root) {\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        TreeNode pred = null; // predecessor\\n        \\n        while (curr != null) {\\n            if (curr.left == null) {\\n                if (prev != null) {\\n                    if (curr.val <= prev.val) {\\n                        return false;\\n                    }\\n                }\\n                prev = curr;\\n                curr = curr.right;\\n            } else {\\n                pred = curr.left;\\n                while (pred.right != null && pred.right != curr) { // find predecessor\\n                    pred = pred.right;\\n                }\\n                if (pred.right == curr) {\\n                    pred.right = null;\\n                    if (prev != null) {\\n                        if (curr.val <= prev.val) {\\n                            return false;\\n                        }\\n                    }\\n                    prev = curr;\\n                    curr = curr.right;\\n                } else {\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    // inorder traversal to see if the value is monotonically increased\\n    // use morris traversal to gain O(1) space, No recursion and O(n) time\\n    // main idea: the key part of tree traversal is how to go back to parent,\\n    //            one way is to use recursion and store parent in function stack,\\n    //            another way is to use explicit stack to store parent,\\n    //            morris traversal modify the original tree and \\n    //            let the right child of the predecessor of the root to point back to itself\\n    //            in order to go back to the root and then restore the pointer(set it to null again)\\n    //            the overall time complexity is still O(n), since the tree is traversed\\n    //            no more than twice(there is not overlap between the path of finding predecessor).\\n    public boolean isValidBST(TreeNode root) {\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        TreeNode pred = null; // predecessor\\n        \\n        while (curr != null) {\\n            if (curr.left == null) {\\n                if (prev != null) {\\n                    if (curr.val <= prev.val) {\\n                        return false;\\n                    }\\n                }\\n                prev = curr;\\n                curr = curr.right;\\n            } else {\\n                pred = curr.left;\\n                while (pred.right != null && pred.right != curr) { // find predecessor\\n                    pred = pred.right;\\n                }\\n                if (pred.right == curr) {\\n                    pred.right = null;\\n                    if (prev != null) {\\n                        if (curr.val <= prev.val) {\\n                            return false;\\n                        }\\n                    }\\n                    prev = curr;\\n                    curr = curr.right;\\n                } else {\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3272265,
                "title": "best-o-n-solution",
                "content": "# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (root->left == NULL && root->right == NULL)\\n            return true;        \\n        return checkBST(root, NULL, NULL); \\n    }\\n\\n    bool checkBST(TreeNode* root, TreeNode* min, TreeNode* max) {\\n        if (root == NULL)\\n            return true;\\n        if ((min != NULL && root->val <= min->val) || (max != NULL && root->val >= max->val))\\n            return false;\\n        return checkBST(root->left, min, root) &&\\n               checkBST(root->right, root, max);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (root->left == NULL && root->right == NULL)\\n            return true;        \\n        return checkBST(root, NULL, NULL); \\n    }\\n\\n    bool checkBST(TreeNode* root, TreeNode* min, TreeNode* max) {\\n        if (root == NULL)\\n            return true;\\n        if ((min != NULL && root->val <= min->val) || (max != NULL && root->val >= max->val))\\n            return false;\\n        return checkBST(root->left, min, root) &&\\n               checkBST(root->right, root, max);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568142,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.***\\n**Also you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\nhttps://www.youtube.com/watch?v=geBeUvcMMwo\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350343,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        return self.helper(root, float(\\'-inf\\'), float(\\'inf\\'))\\n    \\n    def helper(self, node, minVal, maxVal):\\n        if node == None:\\n            return True\\n        \\n        if node.val <= minVal or node.val >= maxVal:\\n            return False\\n        \\n        left = self.helper(node.left, minVal, node.val)\\n        right = self.helper(node.right, node.val, maxVal)\\n        \\n        return left and right         \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        return self.helper(root, float(\\'-inf\\'), float(\\'inf\\'))\\n    \\n    def helper(self, node, minVal, maxVal):\\n        if node == None:\\n            return True\\n        \\n        if node.val <= minVal or node.val >= maxVal:\\n            return False\\n        \\n        left = self.helper(node.left, minVal, node.val)\\n        right = self.helper(node.right, node.val, maxVal)\\n        \\n        return left and right         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110589,
                "title": "python-solution-with-linear-time-complexity-100-working",
                "content": "\\n        def dfs(lower,upper,node):\\n            if not node:\\n                return True\\n            elif node.val<=lower or node.val>=upper:\\n                return False\\n            else:\\n                return dfs(lower,node.val,node.left) and dfs(node.val,upper,node.right)\\n        return dfs(float(\\'-inf\\'),float(\\'inf\\'),root) \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n        def dfs(lower,upper,node):\\n            if not node:\\n                return True\\n            elif node.val<=lower or node.val>=upper:\\n                return False\\n            else:\\n                return dfs(lower,node.val,node.left) and dfs(node.val,upper,node.right)\\n        return dfs(float(\\'-inf\\'),float(\\'inf\\'),root) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2409055,
                "title": "c-long-long-man",
                "content": "1. if you go left, set bounds to min to root->val\\n2. if you go right, set boudns to root->val to max\\n3. use long long to get away from overflow and underflows\\n**4. check out the twitch channel.  Link in profile.**\\n```\\nclass Solution {  \\n    bool dfs(TreeNode* root, long long mn, long long mx) {\\n        if(!root) return true;\\n        \\n        if(root->val <= mn || root->val >= mx) return false;\\n        \\n        bool left = dfs(root->left, mn, root->val);\\n        bool right = dfs(root->right, root->val, mx);\\n        \\n        return left && right;\\n    }\\n    \\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return dfs(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\n    bool dfs(TreeNode* root, long long mn, long long mx) {\\n        if(!root) return true;\\n        \\n        if(root->val <= mn || root->val >= mx) return false;\\n        \\n        bool left = dfs(root->left, mn, root->val);\\n        bool right = dfs(root->right, root->val, mx);\\n        \\n        return left && right;\\n    }\\n    \\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return dfs(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366749,
                "title": "python-recursion-and-recursive-stack-space-o-1-space",
                "content": "Without using a list just use prev variable to store the previous node value and check if the Tree nodes are in ascending order during the inorder traversal. You dont have to create extra space for list.\\n    \\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        self.flag = True\\n        self.prev = float(\"-inf\")\\n        self.inorder(root)\\n        return self.flag\\n\\n        \\n    def inorder(self,root):\\n        #base condition\\n        if root==None:\\n            return\\n        \\n\\n        self.inorder(root.left)\\n        \\n        if root.val<=self.prev:\\n            self.flag = False            \\n        self.prev = root.val\\n        \\n        self.inorder(root.right)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Without using a list just use prev variable to store the previous node value and check if the Tree nodes are in ascending order during the inorder traversal. You dont have to create extra space for list.\\n    \\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        self.flag = True\\n        self.prev = float(\"-inf\")\\n        self.inorder(root)\\n        return self.flag\\n\\n        \\n    def inorder(self,root):\\n        #base condition\\n        if root==None:\\n            return\\n        \\n\\n        self.inorder(root.left)\\n        \\n        if root.val<=self.prev:\\n            self.flag = False            \\n        self.prev = root.val\\n        \\n        self.inorder(root.right)",
                "codeTag": "Python3"
            },
            {
                "id": 344672,
                "title": "c-clear-recursive-solution-without-using-longlong-double",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, TreeNode* nmin = nullptr, TreeNode* nmax = nullptr) {\\n        if(!root) \\n            return true;\\n        if(nmin && root->val <= nmin->val)\\n            return false;\\n        if(nmax && root->val >= nmax->val)\\n            return false;\\n        return isValidBST(root->left, nmin, root) && isValidBST(root->right, root, nmax);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, TreeNode* nmin = nullptr, TreeNode* nmax = nullptr) {\\n        if(!root) \\n            return true;\\n        if(nmin && root->val <= nmin->val)\\n            return false;\\n        if(nmax && root->val >= nmax->val)\\n            return false;\\n        return isValidBST(root->left, nmin, root) && isValidBST(root->right, root, nmax);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229282,
                "title": "neat-java-recursive-solution",
                "content": "``` java\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode x, TreeNode min, TreeNode max) {\\n        if (x == null) return true;\\n        if (max != null && x.val >= max.val) return false;\\n        if (min != null && x.val <= min.val) return false;\\n        return isValidBST(x.left, min, x) && isValidBST(x.right, x ,max);\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/jayomg/image_1548896395.png)\\n",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode x, TreeNode min, TreeNode max) {\\n        if (x == null) return true;\\n        if (max != null && x.val >= max.val) return false;\\n        if (min != null && x.val <= min.val) return false;\\n        return isValidBST(x.left, min, x) && isValidBST(x.right, x ,max);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32371,
                "title": "java-solution-after-adding-test-cases",
                "content": "Actually, not too much needs to be changed if you got AC code when extra test cases are not added. The only difference is add if-else condition for node's value equals INT_MAX and INT_MIN. \\n\\n    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            if (root == null) {\\n                return true;\\n            }\\n            if (root.left == null && root.right == null) {\\n                return true;\\n            }\\n            return check(root, Integer.MAX_VALUE, Integer.MIN_VALUE);\\n        }\\n        \\n        public boolean check(TreeNode node, int max, int min) {\\n            if (node == null) {\\n                return true;\\n            }\\n            if (node.val > max || node.val < min) {\\n                return false;\\n            }\\n    \\n            // if node's value is INT_MIN, it should not have left child any more\\n            if (node.val == Integer.MIN_VALUE && node.left != null) {\\n                return false;\\n            }\\n            \\n            // if node's value is INT_MAX, it should not have right child any more\\n            if (node.val == Integer.MAX_VALUE && node.right != null) {\\n                return false;\\n            }\\n    \\n            return check(node.left, node.val - 1, min) && check(node.right, max, node.val + 1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            if (root == null) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3972693,
                "title": "4-best-c-solutions-recursive-iterative-and-inorder-approach-beats-100",
                "content": "# Code\\n```\\n// Recursive solution - Using LONG_MIN anmd LONG_MAX\\nclass Solution {\\npublic: \\n    bool solve(TreeNode* root, long min, long max){\\n        if(root == NULL)   \\n            return true;\\n        \\n        if(root->val <= min || root->val >= max)  \\n            return false;\\n        \\n        return solve(root->left, min, root->val) && solve(root->right, root->val, max);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n\\n// Recursion solution - Using nodes\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, NULL, NULL);\\n    }\\n    \\n    bool solve(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return solve(root->left, root, min) && solve(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(root == NULL)\\n            return true;\\n        \\n        stack<TreeNode*> s;\\n        TreeNode *pre = NULL;\\n\\n        while(root != NULL || !s.empty()){\\n            while(root != NULL){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre != NULL && root->val <= pre->val){\\n                return false;\\n            }\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n\\n// Check if inorder is sorted\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        for(int i=1; i<ans.size(); i++){\\n            if(ans[i] <= ans[i-1])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution - Using LONG_MIN anmd LONG_MAX\\nclass Solution {\\npublic: \\n    bool solve(TreeNode* root, long min, long max){\\n        if(root == NULL)   \\n            return true;\\n        \\n        if(root->val <= min || root->val >= max)  \\n            return false;\\n        \\n        return solve(root->left, min, root->val) && solve(root->right, root->val, max);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n\\n// Recursion solution - Using nodes\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, NULL, NULL);\\n    }\\n    \\n    bool solve(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return solve(root->left, root, min) && solve(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(root == NULL)\\n            return true;\\n        \\n        stack<TreeNode*> s;\\n        TreeNode *pre = NULL;\\n\\n        while(root != NULL || !s.empty()){\\n            while(root != NULL){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre != NULL && root->val <= pre->val){\\n                return false;\\n            }\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n\\n// Check if inorder is sorted\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        for(int i=1; i<ans.size(); i++){\\n            if(ans[i] <= ans[i-1])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982339,
                "title": "optimized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n\\n    bool check(TreeNode* root, long minval, long maxval ){\\n\\n        if(root==NULL) return true;\\n\\n        if(root->val >= maxval || root->val <= minval) return false;\\n\\n        return check(root->left,minval, root->val) && check(root->right, root->val, maxval);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n\\n    bool check(TreeNode* root, long minval, long maxval ){\\n\\n        if(root==NULL) return true;\\n\\n        if(root->val >= maxval || root->val <= minval) return false;\\n\\n        return check(root->left,minval, root->val) && check(root->right, root->val, maxval);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410074,
                "title": "c-6-different-solutions-recursive-iteratively-in-order-traversal-check-previous",
                "content": "I came up with a few different approaches. Please let me know if you came up with another idea.\\n\\n**Solution 1: recursive with numeric limits**\\n\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, numeric_limits<long>::min(), numeric_limits<long>::max());\\n    }\\n    \\n    bool isValidBST(TreeNode* node, long min, long max) {\\n        if (!node) return true;\\n        \\n        return\\n            (min < node->val && node->val < max) &&\\n            isValidBST(node->left, min, node->val) &&\\n            isValidBST(node->right, node->val, max);\\n    }\\n```\\n\\n**Solution 2: recursive with lower bound and upper bound node**\\n\\nIn this version we don\\'t need to make any assumptions about ```TreeNode::val```, all we care about is that they are compareable. In the following solutions we always only compare values to each other and don\\'t make any futher assumptions about there type.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, nullptr, nullptr);\\n    }\\n    \\n    bool isValidBST(TreeNode* node, TreeNode* lb, TreeNode* ub) {\\n        if (!node) return true;\\n        \\n        if (lb && !(lb->val < node->val)) return false;\\n        if (ub && !(node->val < ub->val)) return false;\\n        \\n        return\\n            isValidBST(node->left, lb, node) &&\\n            isValidBST(node->right, node, ub);\\n    }\\n```\\n\\n**Solution 3: interative with lower bound and upper bound node**\\n\\nWe might as well do this iteratively. We could also use a ```stack``` instead of a ```queue```.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n\\n        queue<array<TreeNode*, 3>> q;\\n        q.push({root, nullptr, nullptr});\\n        \\n        while (!empty(q)) {\\n            auto [node, lb, ub] = q.front(); q.pop();\\n            \\n            if (lb && lb->val >= node->val) return false;\\n            if (ub && ub->val <= node->val) return false;\\n            \\n            if (node->left) q.push({node->left, lb, node});\\n            if (node->right) q.push({node->right, node, ub});\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n**Solution 4: inorder traversal w/ previous node recursively**\\n\\nA different approach is to compare a node with a previous node in an inorder traversal. The values need to be asceding.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(root, &prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode** prev) {\\n        if (!root) return true;\\n        \\n        if (root->left && !isValidBST(root->left, prev)) return false;\\n        \\n        // visit\\n        if (*prev && root->val <= (*prev)->val) return false;\\n        *prev = root;\\n     \\n        if (root->right && !isValidBST(root->right, prev)) return false;\\n        \\n        return true;\\n    }\\n```\\n\\n**Solution 5: inorder traversal w/ previous node iteratively**\\n\\nLike solution 4, but iteratively.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        \\n        TreeNode* prev = nullptr;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n            \\n            // Visit.\\n            if (prev && prev->val >= root->val) return false;\\n            prev = root;\\n            \\n            root = root->right;\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n**Solution 6: serialise the BST and check if sequence is monotonic increasing**\\n\\nNote that ```std::is_sorted``` can\\'t be used here. This uses extra memory for the serialised sequence, which feels a bit unnecassary, but oh well, sue me. :)\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> values;\\n        stack<TreeNode*> st;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n\\n            // Visit.\\n            values.push_back(root->val);\\n            \\n            root = root->right;\\n        }\\n\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(values), end(values), greater_equal<>()) == end(values);\\n    }\\n```\\n\\n**Bonus Solution: custom STL iterator**\\n\\nWe can turn this into a one liner:\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(root), end(root), greater_equal<>()) == end(root);\\n    }\\n```\\n\\n... if we implement a custom iterator for ```TreeNode```. This avoids the extra memory for the ```vector<int>``` from solution 6, but this iterator is quite a have object and expensive to copy. It would take more work to make this effiecient, but it works. So to make the above could work we need something like this:\\n\\n```\\n// TODO(heder): Can we turn this into a \"lean\" iterator? This one is quite \"fat\", as it has\\n// a stack<> member.\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    // TODO(heder): Keep the root pointer around so we know if the iterator is\\n    // from the same tree?\\n    Iterator(TreeNode* root) : curr_(root) {\\n        gotoLeftMost(curr_);\\n    }\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        if (curr_) {\\n            gotoLeftMost(curr_->right);\\n        }\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    stack<TreeNode*> st_;\\n    TreeNode* curr_;\\n    \\n    void gotoLeftMost(TreeNode* node) {\\n        while (node) {\\n            st_.push(node);\\n            node = node->left;\\n        }\\n        \\n        if (empty(st_)) {\\n            curr_ = nullptr;\\n        } else {\\n            curr_ = st_.top();\\n            st_.pop();\\n        }\\n    }\\n};\\n\\nstruct Iterator begin(TreeNode* root) {\\n    return Iterator(root);\\n}\\n\\nstruct Iterator end(TreeNode* root) {\\n    return Iterator(nullptr);\\n}\\n```\\n\\nComments on how to improve any of the solutions are welcome.",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, numeric_limits<long>::min(), numeric_limits<long>::max());\\n    }\\n    \\n    bool isValidBST(TreeNode* node, long min, long max) {\\n        if (!node) return true;\\n        \\n        return\\n            (min < node->val && node->val < max) &&\\n            isValidBST(node->left, min, node->val) &&\\n            isValidBST(node->right, node->val, max);\\n    }\\n```\n```TreeNode::val```\n```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, nullptr, nullptr);\\n    }\\n    \\n    bool isValidBST(TreeNode* node, TreeNode* lb, TreeNode* ub) {\\n        if (!node) return true;\\n        \\n        if (lb && !(lb->val < node->val)) return false;\\n        if (ub && !(node->val < ub->val)) return false;\\n        \\n        return\\n            isValidBST(node->left, lb, node) &&\\n            isValidBST(node->right, node, ub);\\n    }\\n```\n```stack```\n```queue```\n```\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n\\n        queue<array<TreeNode*, 3>> q;\\n        q.push({root, nullptr, nullptr});\\n        \\n        while (!empty(q)) {\\n            auto [node, lb, ub] = q.front(); q.pop();\\n            \\n            if (lb && lb->val >= node->val) return false;\\n            if (ub && ub->val <= node->val) return false;\\n            \\n            if (node->left) q.push({node->left, lb, node});\\n            if (node->right) q.push({node->right, node, ub});\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(root, &prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode** prev) {\\n        if (!root) return true;\\n        \\n        if (root->left && !isValidBST(root->left, prev)) return false;\\n        \\n        // visit\\n        if (*prev && root->val <= (*prev)->val) return false;\\n        *prev = root;\\n     \\n        if (root->right && !isValidBST(root->right, prev)) return false;\\n        \\n        return true;\\n    }\\n```\n```\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        \\n        TreeNode* prev = nullptr;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n            \\n            // Visit.\\n            if (prev && prev->val >= root->val) return false;\\n            prev = root;\\n            \\n            root = root->right;\\n        }\\n        \\n        return true;\\n    }\\n```\n```std::is_sorted```\n```\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> values;\\n        stack<TreeNode*> st;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n\\n            // Visit.\\n            values.push_back(root->val);\\n            \\n            root = root->right;\\n        }\\n\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(values), end(values), greater_equal<>()) == end(values);\\n    }\\n```\n```\\n    bool isValidBST(TreeNode* root) {\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(root), end(root), greater_equal<>()) == end(root);\\n    }\\n```\n```TreeNode```\n```vector<int>```\n```\\n// TODO(heder): Can we turn this into a \"lean\" iterator? This one is quite \"fat\", as it has\\n// a stack<> member.\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    // TODO(heder): Keep the root pointer around so we know if the iterator is\\n    // from the same tree?\\n    Iterator(TreeNode* root) : curr_(root) {\\n        gotoLeftMost(curr_);\\n    }\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        if (curr_) {\\n            gotoLeftMost(curr_->right);\\n        }\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    stack<TreeNode*> st_;\\n    TreeNode* curr_;\\n    \\n    void gotoLeftMost(TreeNode* node) {\\n        while (node) {\\n            st_.push(node);\\n            node = node->left;\\n        }\\n        \\n        if (empty(st_)) {\\n            curr_ = nullptr;\\n        } else {\\n            curr_ = st_.top();\\n            st_.pop();\\n        }\\n    }\\n};\\n\\nstruct Iterator begin(TreeNode* root) {\\n    return Iterator(root);\\n}\\n\\nstruct Iterator end(TreeNode* root) {\\n    return Iterator(nullptr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408926,
                "title": "daily-leetcoding-challenge-august-day-11",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/validate-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Traversal with Valid Range\n\n  \n**Approach 2:** Iterative Traversal with Valid Range\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/validate-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1573371,
                "title": "c-easy-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(TreeNode* root, long long int min,long long int max){\\n        if(!root)return true;\\n        \\n        if(root->val>=max || root->val<=min)return false;\\n        \\n        return solve(root->left,min,root->val) and solve(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(!root)return true;\\n        \\n        return solve(root,-1e18,1e18);\\n    }\\n};\\n```\\n\\nHope you like it.\\n\\nPlease upvote it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(TreeNode* root, long long int min,long long int max){\\n        if(!root)return true;\\n        \\n        if(root->val>=max || root->val<=min)return false;\\n        \\n        return solve(root->left,min,root->val) and solve(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(!root)return true;\\n        \\n        return solve(root,-1e18,1e18);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974349,
                "title": "validate-binary-search-tree-4-line-compressed-code",
                "content": "```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root,Long.MIN_VALUE,Long.MAX_VALUE);       \\n    }\\n    public boolean isValid(TreeNode root,long least,long max){\\n        if(root==null) return true;\\n        if(root.left!=null&&(root.left.val>=root.val||root.left.val<=least)) return false;\\n        if(root.right!=null&&(root.right.val<=root.val||root.right.val>=max)) return false;\\n        return isValid(root.left,least,root.val)&&isValid(root.right,root.val,max);\\n    }\\n```\\nfor video explanation leet code soln\\nhttps://leetcode.com/problems/validate-binary-search-tree/solution/\\n\\n**If you like it please upvote ,it inspires me **",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root,Long.MIN_VALUE,Long.MAX_VALUE);       \\n    }\\n    public boolean isValid(TreeNode root,long least,long max){\\n        if(root==null) return true;\\n        if(root.left!=null&&(root.left.val>=root.val||root.left.val<=least)) return false;\\n        if(root.right!=null&&(root.right.val<=root.val||root.right.val>=max)) return false;\\n        return isValid(root.left,least,root.val)&&isValid(root.right,root.val,max);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3221320,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\\n        if (root == null) return true;\\n        if (root.val >= maxVal || root.val <= minVal) return false;\\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\\n        if (root == null) return true;\\n        if (root.val >= maxVal || root.val <= minVal) return false;\\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413874,
                "title": "easiest-3-lines-recursive-solution",
                "content": "**Easiest 3 lines recursive solution using C++.\\nSelf Explanatory**\\n```\\n    bool isBST(TreeNode* root,long min, long max){\\n        if(root==NULL) return true;\\n        if(root->val <= min || root->val >= max) return false;\\n        return isBST(root->left,min,root->val) and isBST(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isBST(root, LONG_MIN, LONG_MAX);\\n     }\\n```\\n**Please UPVOTE if you like**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n    bool isBST(TreeNode* root,long min, long max){\\n        if(root==NULL) return true;\\n        if(root->val <= min || root->val >= max) return false;\\n        return isBST(root->left,min,root->val) and isBST(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isBST(root, LONG_MIN, LONG_MAX);\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2284839,
                "title": "c-easy-solution-inorder-approach-accepted",
                "content": "```\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n//function to get inorder traversal of the tree\\nvoid inorder(TreeNode* root, vector<int> &in){\\n\\tif(root){\\n\\t\\tinorder(root->left, in);\\n\\t\\tin.push_back(root->val);\\n\\t\\tinorder(root->right, in);\\n\\t}\\n}\\n\\n//once we get the inorder traversal, we\\'ll check if it\\'s strictly increasing or not \\nbool isValidBST(TreeNode* root) {\\n\\tvector<int> in;\\n\\tinorder(root, in);\\n\\tfor(int i=1; i<in.size(); i++)\\n\\t\\tif(in[i] <= in[i-1]) return false;        \\n\\n\\treturn true;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n//function to get inorder traversal of the tree\\nvoid inorder(TreeNode* root, vector<int> &in){\\n\\tif(root){\\n\\t\\tinorder(root->left, in);\\n\\t\\tin.push_back(root->val);\\n\\t\\tinorder(root->right, in);\\n\\t}\\n}\\n\\n//once we get the inorder traversal, we\\'ll check if it\\'s strictly increasing or not \\nbool isValidBST(TreeNode* root) {\\n\\tvector<int> in;\\n\\tinorder(root, in);\\n\\tfor(int i=1; i<in.size(); i++)\\n\\t\\tif(in[i] <= in[i-1]) return false;        \\n\\n\\treturn true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185300,
                "title": "python3-pre-order-recursive-shortest-code",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root, lessThan = float(\\'inf\\'), largerThan = float(\\'-inf\\')):\\n        if not root:\\n            return True\\n        if root.val <= largerThan or root.val >= lessThan:\\n            return False\\n        return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and self.isValidBST(root.right, lessThan, max(root.val, largerThan))\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root, lessThan = float(\\'inf\\'), largerThan = float(\\'-inf\\')):\\n        if not root:\\n            return True\\n        if root.val <= largerThan or root.val >= lessThan:\\n            return False\\n        return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and self.isValidBST(root.right, lessThan, max(root.val, largerThan))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136196,
                "title": "c-using-2-approaches-inorder-vs-lower-upper-bound",
                "content": "# Approach 1: Recursive Traversal with Valid Range\\nThe idea above could be implemented as a recursion. One compares the node value with its upper and lower limits if they are available. Then one repeats the same step recursively for left and right subtrees.\\n\\n![image](https://assets.leetcode.com/users/images/a0d82e09-5323-4657-973c-6683c032a638_1654891625.0223632.png)\\n![image](https://assets.leetcode.com/users/images/8e604d74-3b9f-4b0c-9d69-6f76a9f8c450_1654891642.1756604.png)\\n![image](https://assets.leetcode.com/users/images/ce2197cb-2fdc-4780-9b43-fb9c6dbbed7e_1654891653.190994.png)\\n![image](https://assets.leetcode.com/users/images/0b868fbe-193f-431a-b1bc-b86c633e6afa_1654891663.4470136.png)\\n```\\nclass Solution {\\npublic:\\n    bool validate(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        // Empty trees are valid BSTs.\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        // The current node\\'s value must be between low and high.\\n        if ((low != nullptr and root->val <= low->val) or\\n            (high != nullptr and root->val >= high->val)) {\\n            return false;\\n        }\\n\\n        // The left and right subtree must also be valid.\\n        return validate(root->right, root, high) and\\n               validate(root->left, low, root);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return validate(root, nullptr, nullptr);\\n    }\\n};\\n```\\n\\n# Complexity Analysis:-\\nTime complexity : O(N) since we visit each node exactly once.\\nSpace complexity : O(N) since we keep up to the entire tree.\\n\\n# Approach 2: Recursive Inorder Traversal\\n**Algorithm**\\nLet\\'s use the order of nodes in the inorder traversal Left -> Node -> Right.\\n![image](https://assets.leetcode.com/users/images/3e730632-50e2-41f7-8e4a-4156e66edaa5_1654891858.3544605.png)\\nHere the nodes are enumerated in the order you visit them, and you could follow 1-2-3-4-5 to compare different strategies.\\n\\nLeft -> Node -> Right order of inorder traversal means for BST that each element should be smaller than the next one.\\nHence the algorithm with O(N) time complexity and O(N) space complexity could be simple:\\nCompute inorder traversal list inorder.\\nCheck if each element in inorder is smaller than the next one.\\n![image](https://assets.leetcode.com/users/images/ca8fe881-77ad-4de0-bb88-3f52665e6637_1654891906.4635844.png)\\n# *Do we need to keep the whole inorder traversal list?*\\n***Actually, no. The last added inorder element is enough to ensure at each step that the tree is BST (or not). Hence one could merge both steps into one and reduce the used space.***\\n\\n```\\nclass Solution {\\nprivate:\\n    TreeNode* prev = nullptr;\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return inorder(root);\\n    }\\n\\n    bool inorder(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        if (!inorder(root->left)) {\\n            return false;\\n        }\\n        if (prev != nullptr && root->val <= prev->val) {\\n            return false;\\n        }\\n        prev = root;\\n        return inorder(root->right);\\n    }\\n};\\n```\\n# Complexity Analysis:-\\nTime complexity : O(N) in the worst case when the tree is a BST or the \"bad\" element is a rightmost leaf.\\nSpace complexity : O(N) for the space on the run-time stack.\\n\\n# Guys Please Don\\'t forget to upvote me.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validate(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        // Empty trees are valid BSTs.\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        // The current node\\'s value must be between low and high.\\n        if ((low != nullptr and root->val <= low->val) or\\n            (high != nullptr and root->val >= high->val)) {\\n            return false;\\n        }\\n\\n        // The left and right subtree must also be valid.\\n        return validate(root->right, root, high) and\\n               validate(root->left, low, root);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return validate(root, nullptr, nullptr);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    TreeNode* prev = nullptr;\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return inorder(root);\\n    }\\n\\n    bool inorder(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        if (!inorder(root->left)) {\\n            return false;\\n        }\\n        if (prev != nullptr && root->val <= prev->val) {\\n            return false;\\n        }\\n        prev = root;\\n        return inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633608,
                "title": "python-solution-easy-to-understand-inorder-traverse-explanation",
                "content": "Since the inorder traversal of a binary search tree is always in ascending order, it can be used to easily validate the BST.\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def inorder(root,arr):\\n            if not root:\\n                return\\n            inorder(root.left,arr)\\n            arr.append(root.val)\\n            inorder(root.right,arr)\\n        arr=[]\\n        inorder(root,arr)\\n        #checking whether all elements in the arr are present in ascending order\\n        #if not, then its not a valid BST\\n        for i in range(1, len(arr)): \\n            if arr[i]<=arr[i-1]:\\n                return False\\n        return True\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def inorder(root,arr):\\n            if not root:\\n                return\\n            inorder(root.left,arr)\\n            arr.append(root.val)\\n            inorder(root.right,arr)\\n        arr=[]\\n        inorder(root,arr)\\n        #checking whether all elements in the arr are present in ascending order\\n        #if not, then its not a valid BST\\n        for i in range(1, len(arr)): \\n            if arr[i]<=arr[i-1]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548797,
                "title": "inorder-must-be-sorted-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129042,
                "title": "python-morris-o-1-space-approach",
                "content": "For when the Interviewer asks for a space optimal i.e. O(1) BST traversal as a follow-up question.\\nThis is standard in-order morris traversal as a generator. The values yielded by Morris generator with BST should be strictly increasing in this problem.\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def morris(root):\\n            if not root: return None\\n            curr = root\\n            while curr:\\n                if not curr.left:\\n                    yield curr.val\\n                    curr = curr.right\\n                else:\\n                    prev = curr.left\\n                    while prev.right != None and prev.right != curr:\\n                        prev = prev.right\\n                    if prev.right == None:\\n                        prev.right = curr\\n                        curr = curr.left\\n                    elif prev.right == curr:\\n                        prev.right = None\\n                        yield curr.val\\n                        curr = curr.right\\n        prev = -math.inf\\n        for val in morris(root):\\n            if val <= prev: return False\\n            prev = val\\n        return True\\n```\\nNote: Morris traversal has an O(N) time complexity, since we visit every node in the worst case. It has a O(1) space complexity, since we merely modify (change and restore) pointers during traversal and do not make use of any stack memory.\\n---\\n<img src=\"https://assets.leetcode.com/users/images/46a0cb74-af6c-48ec-8d80-6b298cbe5e4f_1616909821.403881.png\" width=700>\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def morris(root):\\n            if not root: return None\\n            curr = root\\n            while curr:\\n                if not curr.left:\\n                    yield curr.val\\n                    curr = curr.right\\n                else:\\n                    prev = curr.left\\n                    while prev.right != None and prev.right != curr:\\n                        prev = prev.right\\n                    if prev.right == None:\\n                        prev.right = curr\\n                        curr = curr.left\\n                    elif prev.right == curr:\\n                        prev.right = None\\n                        yield curr.val\\n                        curr = curr.right\\n        prev = -math.inf\\n        for val in morris(root):\\n            if val <= prev: return False\\n            prev = val\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794511,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom)\\n    {\\n        if (!root)\\n            return true;\\n        if (root->val >= top)\\n            return false; \\n        if (root->val <= bottom)\\n            return false;\\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        if ((!root->left) && (!root->right))\\n            return true;\\n        return isBST(root, 2147483648, -2147483649);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom)\\n    {\\n        if (!root)\\n            return true;\\n        if (root->val >= top)\\n            return false; \\n        if (root->val <= bottom)\\n            return false;\\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        if ((!root->left) && (!root->right))\\n            return true;\\n        return isBST(root, 2147483648, -2147483649);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634809,
                "title": "beats-100-maintain-min-max-ranges-java",
                "content": "Make sure to use LONG for min max ranges since there are inputs in test cases having long values.\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isValidBSTUtil(TreeNode root,long min,long max){\\n        if(root == null)\\n            return true;\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        return isValidBSTUtil(root.left,min,root.val) &&\\n            isValidBSTUtil(root.right,root.val,max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isValidBSTUtil(TreeNode root,long min,long max){\\n        if(root == null)\\n            return true;\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        return isValidBSTUtil(root.left,min,root.val) &&\\n            isValidBSTUtil(root.right,root.val,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581741,
                "title": "c-shortest-solution",
                "content": "This solution uses min/max borders\\n```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) {\\n\\tif (root == null) return true;\\n\\tif (root.val <= min || root.val >= max) return false;\\n\\treturn IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n}\\n```\\n\\nThe same in one line\\n```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) => root == null || !(root.val <= min) && !(root.val >= max)\\n                                                   && IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n```\\n\\nAnother solution, doesn\\'t use borders, just a value of a previous node\\n\\n```\\npublic class Solution {\\n    int? previousNode;\\n    public bool IsValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        if (!IsValidBST(root.left) || root.val <= previousNode) return false;\\n        previousNode = root.val;\\n        return IsValidBST(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) {\\n\\tif (root == null) return true;\\n\\tif (root.val <= min || root.val >= max) return false;\\n\\treturn IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n}\\n```\n```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) => root == null || !(root.val <= min) && !(root.val >= max)\\n                                                   && IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n```\n```\\npublic class Solution {\\n    int? previousNode;\\n    public bool IsValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        if (!IsValidBST(root.left) || root.val <= previousNode) return false;\\n        previousNode = root.val;\\n        return IsValidBST(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32203,
                "title": "javascript-recursive-o-n",
                "content": "At each function call, we check if the current node value is contained between an upper and lower bounds.\\n\\nThe upper bound is reduced each time we dive in the left branch, and the lower bound is increased each time we dive in the right branch.\\n\\nindeed, all the nodes of the left branch must be lower than the current node (including the ones in right branches as long as they are deeper), and vice versa.\\n\\n```js\\nvar isValidBST = function(root, upperBound=Infinity, lowerBound=-Infinity) {\\n  if (!root) { return true; }\\n  if (root.val >= upperBound || root.val <= lowerBound) return false;\\n \\n  return isValidBST(root.left, Math.min(upperBound, root.val), lowerBound) &&\\n         isValidBST(root.right, upperBound, Math.max(lowerBound, root.val));\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar isValidBST = function(root, upperBound=Infinity, lowerBound=-Infinity) {\\n  if (!root) { return true; }\\n  if (root.val >= upperBound || root.val <= lowerBound) return false;\\n \\n  return isValidBST(root.left, Math.min(upperBound, root.val), lowerBound) &&\\n         isValidBST(root.right, upperBound, Math.max(lowerBound, root.val));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32234,
                "title": "python-simple-and-clean-recursive-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def valid(node, lower, upper):\\n            if not node:\\n                return True\\n            if lower is not None and node.val <= lower:\\n                return False\\n            if upper is not None and node.val >= upper:\\n                return False\\n            return valid(node.left, lower, node.val) and valid(node.right, node.val, upper)\\n        return valid(root, None, None)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def valid(node, lower, upper):\\n            if not node:\\n                return True\\n            if lower is not None and node.val <= lower:\\n                return False\\n            if upper is not None and node.val >= upper:\\n                return False\\n            return valid(node.left, lower, node.val) and valid(node.right, node.val, upper)\\n        return valid(root, None, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32295,
                "title": "java-solution-with-recursion",
                "content": "    public class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       return isValidBST(root,null,null);\\n       \\n    }\\n    private boolean isValidBST(TreeNode root, Integer max, Integer min){\\n           if(root==null)   return true;\\n           if(max!=null&&root.val>=max)\\n             return false;\\n           if(min!=null&&root.val<=min)\\n             return false;\\n           return isValidBST(root.left,root.val,min)&&isValidBST(root.right,max,root.val); \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       return isValidBST(root,null,null);\\n       \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32312,
                "title": "clean-small-c-code-3-line-implementation-16ms",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool val(TreeNode* root,long long int minrange,long long int maxrange)\\n        {\\n            if(root==NULL)return true;\\n            if(root->val>minrange&&root->val<maxrange&&val(root->left,minrange,root->val)&&val(root->right,root->val,maxrange))return true;\\n            return false;\\n        }\\n        bool isValidBST(TreeNode* root) {\\n            return val(root,-2147483650,2147483650);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool val(TreeNode* root,long long int minrange,long long int maxrange)\\n        {\\n            if(root==NULL)return true;\\n            if(root->val>minrange&&root->val<maxrange&&val(root->left,minrange,root->val)&&val(root->right,root->val,maxrange))return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32314,
                "title": "very-short-and-concise-java-solution-easy-to-understand",
                "content": "        public boolean isValidBST(TreeNode root) {\\n            return validateRange(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }\\n     \\n        private boolean validateRange(TreeNode root, long min, long max) {\\n            if (root == null) return true;\\n            if (!(root.val > min && root.val < max)) return false;\\n            return validateRange(root.left, min, (long) root.val) \\n            && validateRange(root.right, (long) root.val, max);\\n        }\\n\\nWe take advantages on the constraint of the range for the value in a BST.",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "        public boolean isValidBST(TreeNode root) {\\n            return validateRange(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }\\n     \\n        private boolean validateRange(TreeNode root, long min, long max) {\\n            if (root == null) return true;\\n            if (!(root.val > min && root.val < max)) return false;\\n            return validateRange(root.left, min, (long) root.val) \\n            && validateRange(root.right, (long) root.val, max);\\n        }\\n\\nWe take advantages on the constraint of the range for the value in a BST.",
                "codeTag": "Unknown"
            },
            {
                "id": 32426,
                "title": "simple-and-10-lines-c-recurive-solution",
                "content": "    class Solution {\\n        public:\\n            bool isValidBST(TreeNode *root) {\\n                long long min = LLONG_MIN, max = LLONG_MAX;\\n                return isValidBST(root, min, max);\\n            }\\n            bool isValidBST(TreeNode *node, long long min, long long max){\\n                if(node == NULL)\\n                    return true;\\n                if(node->val <= min || node->val >= max)\\n                    return false;\\n                if(!isValidBST(node->left, min, node->val) || !isValidBST(node->right, node->val, max))\\n                    return false;\\n                return true;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            bool isValidBST(TreeNode *root) {\\n                long long min = LLONG_MIN, max = LLONG_MAX;\\n                return isValidBST(root, min, max);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3487254,
                "title": "simple-dfs-solution-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince all the nodes in the left-sub-tree should be less than the current node, and all the nodes in the right-sub-tree should be greater than the current node, we can iterate down to check if each node satisfies the condition, that is it should be in a range (min, max) where max for nodes in left-sub-tree and min for right-sub-tree is the parent node vlaue.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - as we need to visit all nodes once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we do not use any extra space\\n**But**, if we consider the space occupied in the memory by the stacking-recursive function call (function-call stack), we can it is O(n)\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return Evaluate(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool Evaluate(TreeNode node, long min, long max)\\n    {\\n        if (node == null)\\n        {\\n            return true;\\n        }\\n\\n        return (\\n            node.val > min &&\\n            node.val < max &&\\n            Evaluate(node.left, min, node.val) &&\\n            Evaluate(node.right, node.val, max)\\n        );\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return Evaluate(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool Evaluate(TreeNode node, long min, long max)\\n    {\\n        if (node == null)\\n        {\\n            return true;\\n        }\\n\\n        return (\\n            node.val > min &&\\n            node.val < max &&\\n            Evaluate(node.left, min, node.val) &&\\n            Evaluate(node.right, node.val, max)\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356533,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static boolean isValid(TreeNode root,TreeNode min ,TreeNode max){\\n        if(root==null){\\n            return true;\\n        }\\n        if(min!=null && root.val<=min.val){\\n            return false;\\n        }\\n        if(max!=null && root.val>=max.val){\\n            return false;\\n        }\\n        return isValid(root.left,min,root)&&isValid(root.right,root,max);\\n\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n    if(isValid(root,null,null)){\\n          return true;\\n      }\\n      else{\\n           return false;\\n    \\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static boolean isValid(TreeNode root,TreeNode min ,TreeNode max){\\n        if(root==null){\\n            return true;\\n        }\\n        if(min!=null && root.val<=min.val){\\n            return false;\\n        }\\n        if(max!=null && root.val>=max.val){\\n            return false;\\n        }\\n        return isValid(root.left,min,root)&&isValid(root.right,root,max);\\n\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n    if(isValid(root,null,null)){\\n          return true;\\n      }\\n      else{\\n           return false;\\n    \\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249901,
                "title": "python3-simple-solution-uwu",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode], min_val=float(\\'-inf\\'), max_val=float(\\'inf\\')) -> bool:\\n        if not root:\\n            return True\\n\\n        if root.val <= min_val or root.val >= max_val:\\n            return False\\n\\n        left_valid = self.isValidBST(root.left, min_val, root.val)\\n        right_valid = self.isValidBST(root.right, root.val, max_val)\\n\\n        return left_valid and right_valid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode], min_val=float(\\'-inf\\'), max_val=float(\\'inf\\')) -> bool:\\n        if not root:\\n            return True\\n\\n        if root.val <= min_val or root.val >= max_val:\\n            return False\\n\\n        left_valid = self.isValidBST(root.left, min_val, root.val)\\n        right_valid = self.isValidBST(root.right, root.val, max_val)\\n\\n        return left_valid and right_valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020203,
                "title": "0ms-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode pre=null;\\n    public boolean isValidBST(TreeNode root) {\\n    \\n     if(root!=null){\\n         if(!isValidBST(root.left)) return false;\\n         if(pre!=null && root.val<=pre.val) return false;\\n         pre=root;\\n         return isValidBST(root.right);\\n     }   \\n     return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode pre=null;\\n    public boolean isValidBST(TreeNode root) {\\n    \\n     if(root!=null){\\n         if(!isValidBST(root.left)) return false;\\n         if(pre!=null && root.val<=pre.val) return false;\\n         pre=root;\\n         return isValidBST(root.right);\\n     }   \\n     return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708912,
                "title": "java-easy-solution-using-recursion",
                "content": "\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n      return checker(root, null, null);  \\n    }\\n    public boolean checker(TreeNode root, Integer min, Integer max) {\\n        if(root == null) return true;\\n\\n        if((min != null && root.val <= min) || (max != null && root.val >= max))\\n        return false;\\n\\n        return checker(root.left, min, root.val) && checker(root.right, root.val, max);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n      return checker(root, null, null);  \\n    }\\n    public boolean checker(TreeNode root, Integer min, Integer max) {\\n        if(root == null) return true;\\n\\n        if((min != null && root.val <= min) || (max != null && root.val >= max))\\n        return false;\\n\\n        return checker(root.left, min, root.val) && checker(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431031,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.***\\n**Also you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\nhttps://www.youtube.com/watch?v=geBeUvcMMwo\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409352,
                "title": "c-2-methods-inorder-and-recursion-better-than-96-27-comments",
                "content": "Method 1: using InOrder Traversal\\n```\\nprivate:\\n\\tvector<int> tree;\\npublic:\\n\\tvoid inOrder(TreeNode* root) {\\n\\t// if root value is null\\n\\t\\tif (!root)\\n\\t\\t\\treturn;\\n\\t\\tinOrder(root->left);\\n\\t\\ttree.push_back(root->val);\\n\\t\\tinOrder(root->right);\\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif (!root)\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t// getting the inorder traversal of the tree\\n\\t\\tinOrder(root);\\n\\t\\tfor (int i=1; i<tree.size(); i++)\\n\\t\\t\\tif (tree[i] <= tree[i-1])\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true; \\n\\t}\\n```\\n![image](https://assets.leetcode.com/users/images/245bf7a5-b24a-4d1e-96cf-bba40d32fb61_1660189798.6316102.png)\\n\\nMethod 2: using Recursion\\n```\\nbool helper(TreeNode* root, long long low, long long high){\\n\\t\\tif(!root)   return true;\\n\\t\\tif(root->val<=low || root->val>=high)   return false;\\n\\t\\treturn helper(root->left, low, root->val) && \\n\\t\\t\\t\\thelper(root->right, root->val, high);            \\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif(!root)   return true;\\n\\t\\t// used long long \\n\\t\\treturn helper(root, -21474836470, 21474836470);\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nprivate:\\n\\tvector<int> tree;\\npublic:\\n\\tvoid inOrder(TreeNode* root) {\\n\\t// if root value is null\\n\\t\\tif (!root)\\n\\t\\t\\treturn;\\n\\t\\tinOrder(root->left);\\n\\t\\ttree.push_back(root->val);\\n\\t\\tinOrder(root->right);\\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif (!root)\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t// getting the inorder traversal of the tree\\n\\t\\tinOrder(root);\\n\\t\\tfor (int i=1; i<tree.size(); i++)\\n\\t\\t\\tif (tree[i] <= tree[i-1])\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true; \\n\\t}\\n```\n```\\nbool helper(TreeNode* root, long long low, long long high){\\n\\t\\tif(!root)   return true;\\n\\t\\tif(root->val<=low || root->val>=high)   return false;\\n\\t\\treturn helper(root->left, low, root->val) && \\n\\t\\t\\t\\thelper(root->right, root->val, high);            \\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif(!root)   return true;\\n\\t\\t// used long long \\n\\t\\treturn helper(root, -21474836470, 21474836470);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045697,
                "title": "js-simple-explained-in-order-traversal",
                "content": "# 98. Validate Binary Search Tree\\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n## The Question\\nFor this article we will be covering Leetcode \\'[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\\' question. This question is rated as a **Medium** question.\\n\\nQuestion:\\n\\n> Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).\\n> \\n> **A valid BST** is defined as follows:\\n> - The left subtree of a node contains only nodes with keys **less than** the `node`\\'s key.\\n> - The right subtree of a node contains only nodes with keys **greater than** the `node`\\'s key.\\n> - Both the left and right subtrees must also be binary search trees.\\n\\n\\n![BST](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\\n\\nExample:\\n```\\nInput: root = [2,1,3]\\nOutput: true\\n\\n```\\n\\n## Explaining The Question\\nThis Question is rated **Medium**. Which I believe is accurate. This question is fantastic for learning about [Binary Search Trees](https://en.wikipedia.org/wiki/Binary_search_tree) and [In order Tree Traversal](https://en.wikipedia.org/wiki/Tree_traversal). \\n\\nWhat we\\'re being asked is to validate if the given Binary Search Tree is valid or not. Meaning it comply with the rules of a Binary Search Tree. Meaning all the lesser values are on the left and all the greater values are on the right.\\n \\nMany of the solutions to this questions has you focus on the `min` and `max` values throughout the tree. This is a very common approach to solving this problem. As it checks if a min or max value is violated anywhere in the tree. Now, while this is a great approach, I think their is a simpler and better way to solve it. \\n\\nThe solution I am going to explain will have transferable knowledge to lots of other issues.\\n1. [99. Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)\\n\\n##  Recommended Knowledge\\n1. [Binary Tree](https://en.wikipedia.org/wiki/Binary_tree)\\n2. [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search)\\n3. [In-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order)\\n4. [Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree)\\n\\n## What do we know?\\n1. We have been given a ***Binary Search Tree***. It could be valid or not.\\n2. We need to validate it. \\n3. Their is always going to be at least 2 nodes. \\n\\n## How we\\'re going to do it:\\n\\nBasically, what we\\'re going to do is to traverse the Binary Tree in ***In-Order***. What this mean\\'s is that the ***NEXT*** node we visit should always be ***greater*** than the previous node. If it isn\\'t, then we know the tree is instantly invalid.\\n\\n1. Set a `flag` to `true`, this flag will be used to let us know if the tree is valid or not. By default its always valid. Until we find a node that is less than the previous node.\\n2. We will declare a previous node pointer, as we\\'re going to be keeping track of our previous node in the in-order traversal of the tree. \\n3. We will perform the in-order traversal of the tree, asking at each point in the traversal, \\'Is the current node less than the previous node?\\' If it is, then we know the tree is invalid. So we set the `flag` to `false`.\\n4. If no bad nodes are found, then we know the tree is valid and the flag remains untouched. \\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is the number of nodes in our ***Binary Search Tree*** | As we\\'re going to traverse all of the nodes within the tree.\\n* Space Complexity: *O(**h**)* | Where ***h*** is the height of the ***Binary Search Tree*** | Because we\\'re going to store the height of the tree within the [Call Stack](https://en.wikipedia.org/wiki/Call_stack) due to the [in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order).\\n\\n\\'***Could this be improved?***\\' Yes! [Morris Traversal](https://en.wikipedia.org/wiki/Tree_traversal#Morris_traversal) could do this problem in ***O(1) space complexity***. But [Morris Traversal](https://en.wikipedia.org/wiki/Tree_traversal#Morris_traversal) is tricky and tough to read. For the sake of simplicity, I don\\'t use it here. \\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 67 ms, faster than ***94.56%*** of JavaScript online submissions for Validate Binary Search Tree\\n* Memory Usage: 46.8 MB, less than ***22.46%*** of JavaScript online submissions for Validate Binary Search Tree\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/700878043/)\\n\\n\\n***\\n\\n# The Solution\\n```\\nvar isValidBST = function (root) {\\n    // This is the flag that will be returned\\n    // In the event we find a node that violates the BST property, we inverted the flag.\\n    let is_bst_valid = true;\\n\\n    // We will also be tracking the previous node.\\n    // This will be used to check if the current node is greater than the previous node.\\n    // As a valid BST, the previous node must be less than the current node.\\n    let prev_node = new TreeNode(-Infinity, null, null);\\n\\n    // We will traverse the tree in-order.\\n    // As a BST traversed in-order would result in something akin to a sorted array.\\n    // [1,2,3,4,5,6,7,8,9]\\n    // In the event we see something like this:\\n    // [1,2,3,4,*99,6,7,8,9,10]\\n    // We know it\\'s not a valid BST.\\n    const in_order_traverse = (node) => {\\n        \\n        // Empty tree. Base case.\\n        if (!node || !is_bst_valid) {\\n            return;\\n        }\\n\\n        // Get my left nodes.\\n        in_order_traverse(node.left);\\n\\n        // The in order section\\n        // Check if the current node is greater than the previous node.\\n        // If not, it\\'s a invalid tree\\n        if (node.val <= prev_node.val) {\\n            is_bst_valid = false;\\n        }\\n\\n        // Update the previous node.\\n        prev_node = node;\\n        in_order_traverse(node.right);\\n    };\\n\\n    in_order_traverse(root);\\n\\n    // Return the flag\\n    return is_bst_valid;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nInput: root = [2,1,3]\\nOutput: true\\n\\n```\n```\\nvar isValidBST = function (root) {\\n    // This is the flag that will be returned\\n    // In the event we find a node that violates the BST property, we inverted the flag.\\n    let is_bst_valid = true;\\n\\n    // We will also be tracking the previous node.\\n    // This will be used to check if the current node is greater than the previous node.\\n    // As a valid BST, the previous node must be less than the current node.\\n    let prev_node = new TreeNode(-Infinity, null, null);\\n\\n    // We will traverse the tree in-order.\\n    // As a BST traversed in-order would result in something akin to a sorted array.\\n    // [1,2,3,4,5,6,7,8,9]\\n    // In the event we see something like this:\\n    // [1,2,3,4,*99,6,7,8,9,10]\\n    // We know it\\'s not a valid BST.\\n    const in_order_traverse = (node) => {\\n        \\n        // Empty tree. Base case.\\n        if (!node || !is_bst_valid) {\\n            return;\\n        }\\n\\n        // Get my left nodes.\\n        in_order_traverse(node.left);\\n\\n        // The in order section\\n        // Check if the current node is greater than the previous node.\\n        // If not, it\\'s a invalid tree\\n        if (node.val <= prev_node.val) {\\n            is_bst_valid = false;\\n        }\\n\\n        // Update the previous node.\\n        prev_node = node;\\n        in_order_traverse(node.right);\\n    };\\n\\n    in_order_traverse(root);\\n\\n    // Return the flag\\n    return is_bst_valid;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828680,
                "title": "java-recursive-approach-100-faster",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        //for every node, maintain upper bound and lowerbound\\n        //helper func(root, lower bound, upper bound) - for recursion\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    boolean helper(TreeNode root, long min, long max){\\n        if(root==null)\\n            return true;\\n        if(root.val<=min || root.val>=max)\\n            return false;\\n        //update the lower bound for right subtree and upper bound for left subtree\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```\\nPlease upvote if it helps!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        //for every node, maintain upper bound and lowerbound\\n        //helper func(root, lower bound, upper bound) - for recursion\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    boolean helper(TreeNode root, long min, long max){\\n        if(root==null)\\n            return true;\\n        if(root.val<=min || root.val>=max)\\n            return false;\\n        //update the lower bound for right subtree and upper bound for left subtree\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628160,
                "title": "java-solution-inorder-traversal",
                "content": "We have used here the concept that if it a BST then while traversing it in inoder we will get an increasing order array or list whatever you have used in inorder to collect.\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        helper(root,list);\\n        System.out.println(list);\\n        for(int i =0;i<list.size()-1;i++){\\n            if(list.get(i+1)<=list.get(i)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public List<Integer> helper(TreeNode root,ArrayList<Integer> list){\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        \\n       helper(root.left,list);\\n        \\n        list.add(root.val);\\n      helper(root.right,list);\\n        \\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        helper(root,list);\\n        System.out.println(list);\\n        for(int i =0;i<list.size()-1;i++){\\n            if(list.get(i+1)<=list.get(i)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public List<Integer> helper(TreeNode root,ArrayList<Integer> list){\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        \\n       helper(root.left,list);\\n        \\n        list.add(root.val);\\n      helper(root.right,list);\\n        \\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382524,
                "title": "c-fast-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res; // to store inorder order traversal\\n    void solve(TreeNode* root) {\\n        if(root == NULL) return; // Base Condition\\n        solve(root->left); // Left subtree\\n        res.push_back(root->val); // Keep pushing elements in in-order manner\\n        solve(root->right); // Right subtree\\n    }\\n    bool isValidBST(TreeNode* root) {   \\n        solve(root); // fill the vector in in-order manner\\n        for(int i=1; i<res.size(); i++) {\\n            if(res[i] <= res[i-1]) // If this occurs, BST condition violates\\n                return false; // Not a valid BST\\n        }\\n        return true; // All fine if u reached here, BST is valid\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res; // to store inorder order traversal\\n    void solve(TreeNode* root) {\\n        if(root == NULL) return; // Base Condition\\n        solve(root->left); // Left subtree\\n        res.push_back(root->val); // Keep pushing elements in in-order manner\\n        solve(root->right); // Right subtree\\n    }\\n    bool isValidBST(TreeNode* root) {   \\n        solve(root); // fill the vector in in-order manner\\n        for(int i=1; i<res.size(); i++) {\\n            if(res[i] <= res[i-1]) // If this occurs, BST condition violates\\n                return false; // Not a valid BST\\n        }\\n        return true; // All fine if u reached here, BST is valid\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218926,
                "title": "intuition-explained-dfs-solution",
                "content": "This is a good problem that is based on a fundamental tree principle, which is the inorder traversal. The important take away of the inorder traversal is that it returns the values of a valid binary tree in sorted order. Keeping that in mind if a binary tree is invalid then it\\'s inordere traversal will also be unsorted. \\nThat is what we are doing in the solution we first store the inorder values of the binary tree using the inorder traversal into the inorder vector and then check if the vector is sorted or not and based on that we return true or false.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> &inorder) {\\n        \\n        if(root == NULL) \\n            return;\\n        helper(root->left, inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right, inorder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        vector<int> inorder;\\n        helper(root, inorder);\\n        \\n        int n = inorder.size();\\n        \\n        for(int i=1;i<n;i++) {\\n            if(inorder[i-1]  >= inorder[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> &inorder) {\\n        \\n        if(root == NULL) \\n            return;\\n        helper(root->left, inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right, inorder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        vector<int> inorder;\\n        helper(root, inorder);\\n        \\n        int n = inorder.size();\\n        \\n        for(int i=1;i<n;i++) {\\n            if(inorder[i-1]  >= inorder[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045913,
                "title": "python-bfs",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        \\n        while queue:\\n            currNode, min, max = queue.popleft()\\n            \\n            if currNode.val <= min or currNode.val >= max:\\n                return False\\n            \\n            if currNode.left:\\n                queue.append((currNode.left, min, currNode.val))\\n            if currNode.right:\\n                queue.append((currNode.right, currNode.val, max))\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        \\n        while queue:\\n            currNode, min, max = queue.popleft()\\n            \\n            if currNode.val <= min or currNode.val >= max:\\n                return False\\n            \\n            if currNode.left:\\n                queue.append((currNode.left, min, currNode.val))\\n            if currNode.right:\\n                queue.append((currNode.right, currNode.val, max))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044174,
                "title": "python-3-inorder-traversal-increasing-order-check-91",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        q = []\\n        def dfs(node):\\n            if not node:\\n                return \\n            dfs(node.left)\\n            q.append(node.val)\\n            dfs(node.right)\\n        dfs(root)\\n        \\n        for i in range(1,len(q)):\\n            if q[i-1]>=q[i]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        q = []\\n        def dfs(node):\\n            if not node:\\n                return \\n            dfs(node.left)\\n            q.append(node.val)\\n            dfs(node.right)\\n        dfs(root)\\n        \\n        for i in range(1,len(q)):\\n            if q[i-1]>=q[i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976329,
                "title": "my-simple-recursive-approach-in-python",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def check(root, low_range=float(\\'-inf\\'), high_range=float(\\'inf\\')):\\n            if not root:\\n                return True\\n            elif not low_range < root.val < high_range:\\n                return False\\n            \\n            return check(root.left, low_range, root.val) and check(root.right, root.val, high_range)\\n        \\n        return check(root)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def check(root, low_range=float(\\'-inf\\'), high_range=float(\\'inf\\')):\\n            if not root:\\n                return True\\n            elif not low_range < root.val < high_range:\\n                return False\\n            \\n            return check(root.left, low_range, root.val) and check(root.right, root.val, high_range)\\n        \\n        return check(root)\\n",
                "codeTag": "Java"
            },
            {
                "id": 885601,
                "title": "easy-js-solution",
                "content": "```\\n\\n/*\\nUse DFS to traverse all nodes.\\nAt each node, we check if it is a valid BST tree.\\nFor a tree to be a valid BST, its left subtree and right subtree must be valid BSTs and\\nits node value should be less than some value and greater than some value. These \\'some\\' values are updated at every node and passed to the next node.\\n*/\\nvar isValidBST = function(root) {\\n    return isValidBSTHelper(root, -Infinity, Infinity);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst isValidBSTHelper = (root, low, high) => {\\n    if (!root) {\\n        return true;\\n    }\\n    return root.val > low && root.val < high &&\\n        isValidBSTHelper(root.left, low, root.val) &&\\n        isValidBSTHelper(root.right, root.val, high);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/*\\nUse DFS to traverse all nodes.\\nAt each node, we check if it is a valid BST tree.\\nFor a tree to be a valid BST, its left subtree and right subtree must be valid BSTs and\\nits node value should be less than some value and greater than some value. These \\'some\\' values are updated at every node and passed to the next node.\\n*/\\nvar isValidBST = function(root) {\\n    return isValidBSTHelper(root, -Infinity, Infinity);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst isValidBSTHelper = (root, low, high) => {\\n    if (!root) {\\n        return true;\\n    }\\n    return root.val > low && root.val < high &&\\n        isValidBSTHelper(root.left, low, root.val) &&\\n        isValidBSTHelper(root.right, root.val, high);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819530,
                "title": "c-upper-and-lower-bound",
                "content": "\\nCan\\'t use INT_MIN and INT_MAX because of one beautiful test case :(\\n```\\nclass Solution {\\npublic:\\n    \\n    bool traverse(TreeNode* root,long long int lowerb,long long int upperb){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val<=lowerb || root->val>=upperb){\\n            return false;\\n        }\\n        return traverse(root->left,lowerb,root->val) && traverse(root->right,root->val,upperb);\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return traverse(root,LLONG_MIN,LLONG_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool traverse(TreeNode* root,long long int lowerb,long long int upperb){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val<=lowerb || root->val>=upperb){\\n            return false;\\n        }\\n        return traverse(root->left,lowerb,root->val) && traverse(root->right,root->val,upperb);\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return traverse(root,LLONG_MIN,LLONG_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265189,
                "title": "inorder-preorder-and-postorder-solution",
                "content": "In interview, it\\'s possible to be asked to implement this question in all of three tree traversal methods. If you like my solution, please upvote!\\n\\nPreorder maintains a interval in the search function\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    private boolean helper(TreeNode root, long lo, long hi) {\\n        if (root == null) return true;\\n        if (root.val >= hi || root.val <= lo) return false;\\n        return helper(root.left, lo, root.val) && helper(root.right, root.val, hi);\\n    }\\n}\\n```\\n\\nInorder maintains a previous node to compare with the current node\\n```\\nclass Solution {\\n    private TreeNode prev;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root);\\n    }\\n    \\n    private boolean helper(TreeNode root) {\\n        if (root == null) return true;\\n        if (!helper(root.left)) return false;\\n        if (prev != null && prev.val >= root.val) return false;\\n        prev = root;\\n        return helper(root.right);\\n    }\\n}\\n```\\n\\nPostorder should return a interval which represents the lower and upper bound of the subtree\\n```\\nclass Solution {\\n    private boolean ans;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        ans = true;\\n        postorder(root);\\n        return ans;\\n    }\\n    \\n    private int[] postorder(TreeNode root) {\\n        if (root == null) return null;\\n        int[] left = postorder(root.left);\\n        int[] right = postorder(root.right);\\n        if (left != null && left[1] >= root.val) ans = false;\\n        if (right != null && right[0] <= root.val) ans = false; \\n        int[] tmp = new int[2];\\n        tmp[0] = left == null ? root.val : left[0];\\n        tmp[1] = right == null ? root.val : right[1];\\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    private boolean helper(TreeNode root, long lo, long hi) {\\n        if (root == null) return true;\\n        if (root.val >= hi || root.val <= lo) return false;\\n        return helper(root.left, lo, root.val) && helper(root.right, root.val, hi);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private TreeNode prev;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root);\\n    }\\n    \\n    private boolean helper(TreeNode root) {\\n        if (root == null) return true;\\n        if (!helper(root.left)) return false;\\n        if (prev != null && prev.val >= root.val) return false;\\n        prev = root;\\n        return helper(root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private boolean ans;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        ans = true;\\n        postorder(root);\\n        return ans;\\n    }\\n    \\n    private int[] postorder(TreeNode root) {\\n        if (root == null) return null;\\n        int[] left = postorder(root.left);\\n        int[] right = postorder(root.right);\\n        if (left != null && left[1] >= root.val) ans = false;\\n        if (right != null && right[0] <= root.val) ans = false; \\n        int[] tmp = new int[2];\\n        tmp[0] = left == null ? root.val : left[0];\\n        tmp[1] = right == null ? root.val : right[1];\\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32114,
                "title": "pyhton-beats-99-77-iterative",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        stack = [None]\\n        prev = -float(\"inf\")\\n        while stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            x = stack.pop()\\n            if x:\\n                if x.val <= prev:\\n                    return False\\n                prev = x.val\\n                root = x.right\\n                \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        stack = [None]\\n        prev = -float(\"inf\")\\n        while stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            x = stack.pop()\\n            if x:\\n                if x.val <= prev:\\n                    return False\\n                prev = x.val\\n                root = x.right\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32350,
                "title": "share-my-java-inorder-simple-solution",
                "content": "    public class Solution {\\n        long tmp =Long.MIN_VALUE;\\n        public boolean isValidBST(TreeNode root) {\\n            if(root != null){\\n                boolean left = isValidBST(root.left);\\n                if(root.val<=tmp)\\n                    return false;\\n                tmp = root.val;\\n                boolean right = isValidBST(root.right);\\n                if(!left || !right)\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        long tmp =Long.MIN_VALUE;\\n        public boolean isValidBST(TreeNode root) {\\n            if(root != null){\\n                boolean left = isValidBST(root.left);\\n                if(root.val<=tmp)\\n                    return false;\\n                tmp = root.val;\\n                boolean right = isValidBST(root.right);\\n                if(!left || !right)\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32421,
                "title": "simple-java-recursion-solution",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root,null,null); \\n            \\n        }\\n        public boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\\n            if(root==null) return true;\\n            if(min!=null && root.val<=min.val) return false;\\n            if(max!=null && root.val>=max.val) return false;\\n            if(!isValidBST(root.left, min, root)) return false;\\n            if(!isValidBST(root.right, root, max)) return false;\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root,null,null); \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3344154,
                "title": "beats-100-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBs(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n\\n        public boolean isValidBs(TreeNode root, long min, long max){\\n        if(root == null)return true;\\n        if(root.val<= min || root.val >= max) return false;\\n        boolean left= isValidBs(root.left,min,root.val);\\n        boolean right = isValidBs(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBs(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n\\n        public boolean isValidBs(TreeNode root, long min, long max){\\n        if(root == null)return true;\\n        if(root.val<= min || root.val >= max) return false;\\n        boolean left= isValidBs(root.left,min,root.val);\\n        boolean right = isValidBs(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168283,
                "title": "without-inorder-easy-solution-o-n",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\n    bool isbst(TreeNode* root, long min, long max){\\n        // Base Case\\n        if( root == NULL) return true;\\n        \\n        if(root->val > min && root->val < max){\\n            bool left = isbst(root->left,min,root->val);\\n            bool right = isbst(root->right, root->val, max);\\n\\n            return left && right;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        return isbst(root, LONG_MIN,LONG_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isbst(TreeNode* root, long min, long max){\\n        // Base Case\\n        if( root == NULL) return true;\\n        \\n        if(root->val > min && root->val < max){\\n            bool left = isbst(root->left,min,root->val);\\n            bool right = isbst(root->right, root->val, max);\\n\\n            return left && right;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        return isbst(root, LONG_MIN,LONG_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823221,
                "title": "best-solution-java",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean check(TreeNode root , TreeNode min , TreeNode max){\\n        if(root == null ) return true;\\n        \\n        if(min!= null  && root.val<=min.val) return false;\\n        else if(max!=null && root.val>=max.val) return false;\\n        \\n        return check(root.left,min,root ) && check(root.right , root,max);\\n        }\\n    \\n    public boolean isValidBST(TreeNode root) {\\n       return check(root,null,null);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean check(TreeNode root , TreeNode min , TreeNode max){\\n        if(root == null ) return true;\\n        \\n        if(min!= null  && root.val<=min.val) return false;\\n        else if(max!=null && root.val>=max.val) return false;\\n        \\n        return check(root.left,min,root ) && check(root.right , root,max);\\n        }\\n    \\n    public boolean isValidBST(TreeNode root) {\\n       return check(root,null,null);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803203,
                "title": "java-solution",
                "content": "The idea is to check every node for lower and upper bound\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    public boolean helper(TreeNode root, long l, long r){\\n        if(root==null)return true;\\n\\n        if(root.val<=l || root.val>=r)return false;\\n\\n        return helper(root.right,root.val,r) && helper(root.left,l,root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    public boolean helper(TreeNode root, long l, long r){\\n        if(root==null)return true;\\n\\n        if(root.val<=l || root.val>=r)return false;\\n\\n        return helper(root.right,root.val,r) && helper(root.left,l,root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410319,
                "title": "dfs-post-order-full-visual-explanation-with-image",
                "content": "Take the time to read the post, it explains the intuition fully. Practice makes perfect :)\\n\\nIf you found this post helpful, please upvote <3\\n\\n<hr />\\n\\n# Terminology\\nFirst, let\\'s recall what is a `binary search tree`.\\n\\nBinary search tree is simply a binary tree where all values to the **left are smaller** than the current node\\'s value, and all values to the **right are bigger** than the current node\\'s value.\\n\\nSome examples of BSTs:\\n\\n![image](https://assets.leetcode.com/users/images/7c25afb7-1d9f-4ef4-a557-d08c948e309e_1660204948.035542.png)\\n\\nNow with this understanding, let\\'s tackle the problem.\\n\\n# Intuition\\n\\nKnowing what is a BST, we need to think about the **local constraints** for each subtree.\\n\\nWhenever we are working with binary trees (or any recursive data structure) we should think how to \"validate\" a subtree (subproblem), and return that answer to the parent to recursively continue the process.\\n\\n\\nLet\\'s take the previous tree as an example:\\n\\n**EDIT:** the arrows may confuse some readers. The current value must be smaller than the green arrow, and bigger than blue arrow.\\n\\n![image](https://assets.leetcode.com/users/images/621eb95b-9e0a-48c6-9a09-6a7ad11fd986_1660205256.1745734.png)\\n\\n\\nWe know that the current subtree of value 4, must bigger than 3, but also smaller than the parent that branched left (because all values on the left are smaller), which is 5.\\n\\nLet\\'s call them `parent_minimum` and `parent_maximum` values.\\n\\nLet\\'s take the another example:\\n\\n![image](https://assets.leetcode.com/users/images/8e00a212-89e9-489c-ad28-4cdee52174b6_1660205364.6228054.png)\\n\\nWe know that the subtree with value 6 must be smaller than 7, because 7 is located to the right of that subtree. But also 6 must be greater than 5, because 5 is located to the left, hence the values is smaller.\\n\\nWith this idea we have everything to write the code\\n\\n# Algorithm\\nThe algorithm will run a post order DFS traversal, to first validate left and right subtrees.\\n\\nIf both subtrees are valid, we will check the constraints discussed above.\\n\\nWhenever we branch left, the current node value is the `parent_maximum`, because all values to the left must be smaller.\\n\\nWhenever we branch right, the current node value is the `parent_minimum`, because all values to the right must be greater.\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def is_valid_root(node, parent_maximum, parent_minimum):\\n            if not node: return True\\n            \\n            # Check left side\\n            if not is_valid_root(node.left, node.val, parent_minimum): return False\\n            \\n            # Check right side\\n            if not is_valid_root(node.right, parent_maximum ,node.val): return False\\n            \\n            # Check constraints with current node\\n            if node.val >= parent_maximum or node.val <= parent_minimum: return False\\n            \\n            # Otherwise we are good\\n            return True\\n            \\n        \\n        return is_valid_root(root, float(\\'inf\\'), float(\\'-inf\\'))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def is_valid_root(node, parent_maximum, parent_minimum):\\n            if not node: return True\\n            \\n            # Check left side\\n            if not is_valid_root(node.left, node.val, parent_minimum): return False\\n            \\n            # Check right side\\n            if not is_valid_root(node.right, parent_maximum ,node.val): return False\\n            \\n            # Check constraints with current node\\n            if node.val >= parent_maximum or node.val <= parent_minimum: return False\\n            \\n            # Otherwise we are good\\n            return True\\n            \\n        \\n        return is_valid_root(root, float(\\'inf\\'), float(\\'-inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410270,
                "title": "c-3-approach",
                "content": "In this question we are given an Binary Tree and we have to create a program that check given Binary Tree is Binary Search Tree or not \\nA valid BST mean:\\n* Value of root should be greater than all left nodes\\n* Value of root should be lesser than all right nodes\\n## Approach1:\\n1.  Get maximum from leftsubtree and store it in leftmax variable.\\n2.  Get minimum from rightsubtree and store it in rightmin variable \\n3. leftmax should be smaller than node value and rightmin should be greater than node value if it is then we made two recursive call to check left subtree and right subtree for that node.\\n4. if this won\\'t happen or condition is false then our BST isn\\'t valid BST. \\n5. The reason why we use long long and LONG_MAX or LONG_MIN because of its constraint -2^31 <= Node.val <= 2^31 - 1 at testcase no. 72 that is [2147483647] that why our INT_MIN and INT_MAX won\\'t work for that testcase so we use long long , LONG_MAX , LONG_MIN.\\n5. Reason why we create min,max function it can work only for int , if value is not in integer range so it won\\'t work .\\n```\\nclass Solution {\\npublic:\\n\\n  long long functionmin(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long functionmax(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    \\n    long long Minimum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MAX;\\n        }\\n        return functionmin(root->val,functionmin(Minimum(root->left),Minimum(root->right)));\\n        \\n    }\\n    long long Maximum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MIN;\\n        }\\n        return functionmax(root->val,functionmax(Maximum(root->left),Maximum(root->right)));\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        long long  leftmax=Maximum(root->left);\\n        long long  rightmin=Minimum(root->right);\\n       \\n        return (root->val>leftmax)&&(root->val<rightmin)&&isValidBST(root->left)&&isValidBST(root->right);\\n        \\n        \\n    }\\n};\\n\\n```\\n\\n## Approach2\\n\\n1. This is similar as first approach but its Time Complexity is lesser than first appraoch because in this appraoch we\\'ll not call minimum and maximum function at every recursive call.\\n2. We\\'re creating a class that hold minimum ,maximum and isBst of tree .\\n3. Leftoutput and rightoutput contain max,min,isbst for respective subtrees.\\n4. Leftoutput->isBst and Rightoutput->isBst should be true , Rightoutput.minimum value should be greater than root value and Leftoutput.maximum value should be lesse than root value whether it is true or false ,we store it in output.bst and we also calculate  minimum and maximum for output.\\n```\\nclass Solution {\\npublic:\\n      long long min(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long max(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    class CheckBst\\n    {\\n        public:\\n        long long maximum;\\n        long long minimum;\\n        bool isbst;\\n    };\\n    CheckBst Helper(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            CheckBst output;\\n            output.maximum=LONG_MIN;\\n            output.minimum=LONG_MAX;\\n            output.isbst=true;\\n            return output;\\n        }\\n        CheckBst leftoutput=Helper(root->left);\\n        CheckBst rightoutput=Helper(root->right);\\n        CheckBst output;\\n        output.isbst=(leftoutput.isbst)&&(rightoutput.isbst)&&(leftoutput.maximum<root->val)&&(rightoutput.minimum>root->val);\\n        output.maximum=max(root->val,max(leftoutput.maximum,rightoutput.maximum));\\n        output.minimum=min(root->val,min(leftoutput.minimum,rightoutput.minimum));\\n        return output;\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\nCheckBst ans=Helper(root);\\n        return ans.isbst;\\n    }\\n};\\n```\\n\\n## Approach3\\n![image](https://assets.leetcode.com/users/images/60971896-df7f-478d-bbaa-63eba83be334_1660201230.3960164.jpeg =250x)`\\ncheck  \\u261D\\uFE0F image to understand more\\n1. Range of value of left node is between -\\u221E to root value\\n2. Range of value of right node is between  root value to \\u221E\\n3. Root value should be within the range of maxi and mini if it\\'s value out of the  bound then we we return false \\n```\\n\\nclass Solution {\\npublic:\\n\\n  \\n    bool isValidBST(TreeNode* root,long long maxi=LONG_MAX,long long mini=LONG_MIN) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->val>=maxi||root->val<=mini)\\n        {\\n            return false;\\n        }\\n        \\n        return isValidBST(root->left,root->val,mini)&&(isValidBST(root->right,maxi,root->val));          \\n        \\n    }\\n};\\n\\n```\\n\\nIf it helpful for you then make sure you upvote it\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n  long long functionmin(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long functionmax(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    \\n    long long Minimum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MAX;\\n        }\\n        return functionmin(root->val,functionmin(Minimum(root->left),Minimum(root->right)));\\n        \\n    }\\n    long long Maximum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MIN;\\n        }\\n        return functionmax(root->val,functionmax(Maximum(root->left),Maximum(root->right)));\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        long long  leftmax=Maximum(root->left);\\n        long long  rightmin=Minimum(root->right);\\n       \\n        return (root->val>leftmax)&&(root->val<rightmin)&&isValidBST(root->left)&&isValidBST(root->right);\\n        \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n      long long min(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long max(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    class CheckBst\\n    {\\n        public:\\n        long long maximum;\\n        long long minimum;\\n        bool isbst;\\n    };\\n    CheckBst Helper(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            CheckBst output;\\n            output.maximum=LONG_MIN;\\n            output.minimum=LONG_MAX;\\n            output.isbst=true;\\n            return output;\\n        }\\n        CheckBst leftoutput=Helper(root->left);\\n        CheckBst rightoutput=Helper(root->right);\\n        CheckBst output;\\n        output.isbst=(leftoutput.isbst)&&(rightoutput.isbst)&&(leftoutput.maximum<root->val)&&(rightoutput.minimum>root->val);\\n        output.maximum=max(root->val,max(leftoutput.maximum,rightoutput.maximum));\\n        output.minimum=min(root->val,min(leftoutput.minimum,rightoutput.minimum));\\n        return output;\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\nCheckBst ans=Helper(root);\\n        return ans.isbst;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n\\n  \\n    bool isValidBST(TreeNode* root,long long maxi=LONG_MAX,long long mini=LONG_MIN) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->val>=maxi||root->val<=mini)\\n        {\\n            return false;\\n        }\\n        \\n        return isValidBST(root->left,root->val,mini)&&(isValidBST(root->right,maxi,root->val));          \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197682,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Recursive solution:\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, min_val=float(\"-inf\"), max_val=float(\"inf\")):\\n            if root is None:\\n                return True\\n            \\n            return (min_val < root.val < max_val and helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val))\\n        return helper(root)\\n```\\n\\nIterative Solution:\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        queue = deque()\\n        queue.append((root, float(\"-inf\"), float(\"inf\")))\\n        \\n        while queue:\\n            node, min_val, max_val = queue.popleft()\\n            if node:\\n                if min_val >= node.val or node.val >= max_val:\\n                    return False\\n                if node.left:\\n                    queue.append((node.left, min_val, node.val))\\n                \\n                if node.right:\\n                    queue.append((node.right, node.val, max_val))\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, min_val=float(\"-inf\"), max_val=float(\"inf\")):\\n            if root is None:\\n                return True\\n            \\n            return (min_val < root.val < max_val and helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val))\\n        return helper(root)\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        queue = deque()\\n        queue.append((root, float(\"-inf\"), float(\"inf\")))\\n        \\n        while queue:\\n            node, min_val, max_val = queue.popleft()\\n            if node:\\n                if min_val >= node.val or node.val >= max_val:\\n                    return False\\n                if node.left:\\n                    queue.append((node.left, min_val, node.val))\\n                \\n                if node.right:\\n                    queue.append((node.right, node.val, max_val))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965947,
                "title": "c-with-explanation-inordertravrsal-recursion-98-validate-binary-search-tree",
                "content": "If The **Inorder** **traversal** of the given **BST** gives values in **Sorted** **order** then the given **BST** **will** **be** **valid** else BST will be invalid  \\n\\n\\t class Solution {\\n\\t\\tpublic:\\n\\t\\t   void inorder(TreeNode*root,vector<int>&ans)\\n\\t\\t   {\\n\\t\\t\\t   if(!root) return;\\n\\t\\t\\t   inorder(root->left,ans);\\n\\t\\t\\t   ans.push_back(root->val);\\n\\t\\t\\t   inorder(root->right,ans);\\n\\t\\t   }\\n\\t\\t\\tbool isValidBST(TreeNode* root) {\\n\\t\\t\\t\\tvector<int>v;\\n\\t\\t\\t\\tinorder(root,v);\\n\\t\\t\\t\\tfor(int i=1;i<v.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(v[i]<=v[i-1]) // if not in order  \\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if we can be able to come out of loop it means all elements are in order  \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t   void inorder(TreeNode*root,vector<int>&ans)\\n\\t\\t   {\\n\\t\\t\\t   if(!root) return;\\n\\t\\t\\t   inorder(root->left,ans);\\n\\t\\t\\t   ans.push_back(root->val);\\n\\t\\t\\t   inorder(root->right,ans);\\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1570606,
                "title": "python-3-simple-recursion",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, low, high):\\n            if root is None:\\n                return True\\n            \\n            if root.val <= low or root.val >= high:\\n                return False\\n            \\n            return helper(root.left, low, root.val) and helper(root.right, root.val, high)\\n        \\n        return helper(root, -math.inf, math.inf)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, low, high):\\n            if root is None:\\n                return True\\n            \\n            if root.val <= low or root.val >= high:\\n                return False\\n            \\n            return helper(root.left, low, root.val) and helper(root.right, root.val, high)\\n        \\n        return helper(root, -math.inf, math.inf)",
                "codeTag": "Java"
            },
            {
                "id": 1548781,
                "title": "c-solution-inorder-vector-method",
                "content": "```\\n    void getOrder(TreeNode* root, vector<int> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root->val);\\n        getOrder(root->right, inOrder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> inOrder;\\n        getOrder(root, inOrder);\\n        if(inOrder.size() == 1) return true;\\n        for(int i = 1; i < inOrder.size(); i++) {\\n            if(inOrder[i] <= inOrder[i-1]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void getOrder(TreeNode* root, vector<int> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root->val);\\n        getOrder(root->right, inOrder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> inOrder;\\n        getOrder(root, inOrder);\\n        if(inOrder.size() == 1) return true;\\n        for(int i = 1; i < inOrder.size(); i++) {\\n            if(inOrder[i] <= inOrder[i-1]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519922,
                "title": "python-o-nlogn-o-n-multiple-simple-solutions",
                "content": "## Solution 1 - O(nlogn)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def inorderTraversal(self, root, inorder):\\n        if root:\\n            self.inorderTraversal(root.left, inorder)\\n            inorder.append(root.val)\\n            self.inorderTraversal(root.right, inorder)\\n            \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        inorder = []\\n        self.inorderTraversal(root, inorder)\\n        \"\"\"\\n            Since inorder traversal of BST gives a sorted array so if inorder traversal of given BST is not sorted then it is not a valid BST.\\n            To overcome duplicates we need to verify the length of inorder array and inorder hash set as BST can\\'t have duplicates.\\n        \"\"\"\\n        return inorder == sorted(inorder) and len(inorder) == len(set(inorder))\\n```\\n\\n## Solution 2 - O(n)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def isValidBST(self, root: Optional[TreeNode], left=-sys.maxsize, right=sys.maxsize) -> bool:\\n        if not root:\\n            return True\\n        if left >= root.val or right <= root.val:\\n            return False\\n        return self.isValidBST(root.left, left, root.val) and self.isValidBST(root.right, root.val, right)\\n```\\n\\n***If you liked the above solutions then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def inorderTraversal(self, root, inorder):\\n        if root:\\n            self.inorderTraversal(root.left, inorder)\\n            inorder.append(root.val)\\n            self.inorderTraversal(root.right, inorder)\\n            \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        inorder = []\\n        self.inorderTraversal(root, inorder)\\n        \"\"\"\\n            Since inorder traversal of BST gives a sorted array so if inorder traversal of given BST is not sorted then it is not a valid BST.\\n            To overcome duplicates we need to verify the length of inorder array and inorder hash set as BST can\\'t have duplicates.\\n        \"\"\"\\n        return inorder == sorted(inorder) and len(inorder) == len(set(inorder))\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def isValidBST(self, root: Optional[TreeNode], left=-sys.maxsize, right=sys.maxsize) -> bool:\\n        if not root:\\n            return True\\n        if left >= root.val or right <= root.val:\\n            return False\\n        return self.isValidBST(root.left, left, root.val) and self.isValidBST(root.right, root.val, right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505663,
                "title": "java-solution-easy-short-clean",
                "content": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    private boolean valid(TreeNode root, long min, long max){\\n        if(root == null)    return true;\\n        if(root.val>min && root.val<max)    \\n            return(valid(root.left, min, root.val) && valid(root.right, root.val, max));\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    private boolean valid(TreeNode root, long min, long max){\\n        if(root == null)    return true;\\n        if(root.val>min && root.val<max)    \\n            return(valid(root.left, min, root.val) && valid(root.right, root.val, max));\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346591,
                "title": "c-3-solutions-efficient-simple-easy-to-understand",
                "content": "**1st Approach: Direct Implementation of Definition of BST using Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidBSTUtil(TreeNode* root, long long int maximum, long long int minimum){\\n        if(root == NULL)\\n            return true;\\n        if(root->val >= maximum || root->val <= minimum)\\n            return false;\\n        if(isValidBSTUtil(root->left, root->val, minimum) \\n           && isValidBSTUtil(root->right, maximum, root->val)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTUtil(root, LONG_MAX, LONG_MIN);\\n    }\\n};\\n```\\n\\n**2nd Approach: Using Inorder Traversal and Extra Space**\\n\\n```\\nclass Solution {\\n    vector<int> tree;\\npublic:\\n   void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**3rd Approach: Similar to 2nd Approach without storing all values**\\n\\n```\\nclass Solution {\\npublic:\\n    bool validateBST(TreeNode* root, TreeNode* &prev){\\n        if(root == NULL) return true;\\n        if(!(validateBST(root->left, prev))) return false;\\n        if(prev != NULL && prev->val >= root->val) return false;\\n        prev = root;\\n        return validateBST(root->right, prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return validateBST(root, prev);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBSTUtil(TreeNode* root, long long int maximum, long long int minimum){\\n        if(root == NULL)\\n            return true;\\n        if(root->val >= maximum || root->val <= minimum)\\n            return false;\\n        if(isValidBSTUtil(root->left, root->val, minimum) \\n           && isValidBSTUtil(root->right, maximum, root->val)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTUtil(root, LONG_MAX, LONG_MIN);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> tree;\\npublic:\\n   void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool validateBST(TreeNode* root, TreeNode* &prev){\\n        if(root == NULL) return true;\\n        if(!(validateBST(root->left, prev))) return false;\\n        if(prev != NULL && prev->val >= root->val) return false;\\n        prev = root;\\n        return validateBST(root->right, prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return validateBST(root, prev);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187373,
                "title": "90-faster-inorder-traversal-c",
                "content": "***Do upvote if you found the solution helpful to keep me motivated*** \\u270C\\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root , vector<int> &v)\\n    {\\n        if(root == NULL)\\n            return;\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\t\\n    bool isValidBST(TreeNode* root) {\\n     vector<int> v;\\n     solve(root,v);\\n     for(int i=0 ; i<v.size()-1 ;i++)\\n     {\\n         if(v[i] >= v[i+1])\\n          return false;\\n     }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root , vector<int> &v)\\n    {\\n        if(root == NULL)\\n            return;\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\t\\n    bool isValidBST(TreeNode* root) {\\n     vector<int> v;\\n     solve(root,v);\\n     for(int i=0 ; i<v.size()-1 ;i++)\\n     {\\n         if(v[i] >= v[i+1])\\n          return false;\\n     }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151410,
                "title": "python-recursion-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def helper(root, min_val, max_val):\\n            if not root:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\\n        return helper(root, -float(\\'inf\\'), float(\\'inf\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def helper(root, min_val, max_val):\\n            if not root:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\\n        return helper(root, -float(\\'inf\\'), float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144855,
                "title": "easy-inorder-traversal-using-vector-c",
                "content": "**Observation**: Inorder traversal (left subtree, root, right subtree) of a Binary Search Tree would always give the node values in an increasing order.\\nHence we store the values of the nodes in a vector and check if the vector is strictly increasing. If not, return false, else return true.\\n\\n```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root, vector<int>& res){\\n        if(root==NULL) return;\\n        inOrder(root->left, res);\\n        res.push_back(root->val);\\n        inOrder(root->right, res);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL) return true;\\n        vector<int> res;\\n        inOrder(root, res);\\n        for(int i=0; i<res.size()-1; i++){\\n            if(res[i]>=res[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root, vector<int>& res){\\n        if(root==NULL) return;\\n        inOrder(root->left, res);\\n        res.push_back(root->val);\\n        inOrder(root->right, res);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL) return true;\\n        vector<int> res;\\n        inOrder(root, res);\\n        for(int i=0; i<res.size()-1; i++){\\n            if(res[i]>=res[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052667,
                "title": "pair-approach-helpful-in-many-lc-problems",
                "content": "`Please give a upvote if you like else comment for any doubts.`\\n\\n**Approach:** The idea is to use traverse the tree recursively and in each recursive calls return a pair of minimum element, maximum element and the current subtree is BST or not. After each Left and Right recursive calls ends check if the root having these LST and RST follows the BST property or not. If found to be true then return the corresponding pairs to it\\'s parent.\\n\\nBelow is the implementation of the same:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // From each recursive calls return the\\n    // minimum, maximum and isBST flag for\\n    // each subtree\\n    pair<pair<long long int, long long int>, bool> dfs(TreeNode *root) {\\n        \\n        // If root is NULL then it is BST\\n        // return the MAX, MIN, true\\n        // and MAX is return as minimum value \\n        // to validate the BST property for node\\n        // having at least 1 leaf node`\\n        if(root == NULL) {\\n            return {{LLONG_MAX, LLONG_MIN}, true};\\n        }\\n        \\n        // Left and Right Calls\\n        pair<pair<long long int, long long int>, bool> P1 = dfs(root->left);\\n        pair<pair<long long int, long long int>, bool> P2 = dfs(root->right);\\n        \\n        // Find the if the current root is BST\\n        // LST and RST is also BST\\n        bool ans = P1.second && P2.second\\n                    && (root->val > P1.first.second\\n                        && root->val < P2.first.first);\\n        \\n        // Find the current minimum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int minimum = min(1LL*root->val,\\n                                    min(P1.first.first,\\n                                        P2.first.first));\\n        \\n        // Find the current maximum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int maximum = max(1LL*root->val,\\n                                    max(P1.first.second,\\n                                        P2.first.second));\\n        \\n        // Return the corresponding pair for\\n        // each recursive calls\\n        return {{minimum, maximum}, ans};\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        \\n        if(root->left == NULL\\n           and root->right == NULL) return true;\\n        \\n        pair<pair<long long int, long long int>, bool> P = dfs(root);\\n        return P.second;\\n    }\\n};\\n```\\n*Time Complexity: O(N)\\nAuxiliary Space: O(H), where H is the maximum height of the tree.*",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // From each recursive calls return the\\n    // minimum, maximum and isBST flag for\\n    // each subtree\\n    pair<pair<long long int, long long int>, bool> dfs(TreeNode *root) {\\n        \\n        // If root is NULL then it is BST\\n        // return the MAX, MIN, true\\n        // and MAX is return as minimum value \\n        // to validate the BST property for node\\n        // having at least 1 leaf node`\\n        if(root == NULL) {\\n            return {{LLONG_MAX, LLONG_MIN}, true};\\n        }\\n        \\n        // Left and Right Calls\\n        pair<pair<long long int, long long int>, bool> P1 = dfs(root->left);\\n        pair<pair<long long int, long long int>, bool> P2 = dfs(root->right);\\n        \\n        // Find the if the current root is BST\\n        // LST and RST is also BST\\n        bool ans = P1.second && P2.second\\n                    && (root->val > P1.first.second\\n                        && root->val < P2.first.first);\\n        \\n        // Find the current minimum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int minimum = min(1LL*root->val,\\n                                    min(P1.first.first,\\n                                        P2.first.first));\\n        \\n        // Find the current maximum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int maximum = max(1LL*root->val,\\n                                    max(P1.first.second,\\n                                        P2.first.second));\\n        \\n        // Return the corresponding pair for\\n        // each recursive calls\\n        return {{minimum, maximum}, ans};\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        \\n        if(root->left == NULL\\n           and root->right == NULL) return true;\\n        \\n        pair<pair<long long int, long long int>, bool> P = dfs(root);\\n        return P.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562349,
                "title": "simple-javascript-solution-recursive-clean",
                "content": "Runtime: 52 ms, faster than 99.19% of JavaScript online submissions for Validate Binary Search Tree.\\nMemory Usage: 37.1 MB, less than 100.00% of JavaScript online submissions for Validate Binary Search Tree.\\n```\\nfunction isValidBST(root, min, max) {\\n  if (!root) { \\n    return true;\\n  }\\n\\n  if (min !== undefined && root.val <= min) {\\n    return false;\\n  }\\n\\n  if (max !== undefined && root.val >= max) { \\n    return false;\\n  }\\n \\n  return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max); \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isValidBST(root, min, max) {\\n  if (!root) { \\n    return true;\\n  }\\n\\n  if (min !== undefined && root.val <= min) {\\n    return false;\\n  }\\n\\n  if (max !== undefined && root.val >= max) { \\n    return false;\\n  }\\n \\n  return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520381,
                "title": "c-really-easy-in-order-traversal-solution-90-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // base case\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        \\n        // visit the left sub-tree\\n        if (!isValidBST(root->left)) {\\n            return false;\\n        }\\n        \\n        // an in-order traversal of a valid binary search tree\\n        // will always process nodes in-order. if the pervious\\n        // node is larger than current value, this condition\\n        // fails and we can assume that the tree isn\\'t a valid BST\\n        if (previous && previous->val >= root->val) {\\n            return false;\\n        }\\n        \\n        // set the previous node to the current node\\n        previous = root;\\n        \\n        // visit the right sub-tree\\n        return isValidBST(root->right);\\n    }\\nprivate:\\n    TreeNode* previous = nullptr;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // base case\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        \\n        // visit the left sub-tree\\n        if (!isValidBST(root->left)) {\\n            return false;\\n        }\\n        \\n        // an in-order traversal of a valid binary search tree\\n        // will always process nodes in-order. if the pervious\\n        // node is larger than current value, this condition\\n        // fails and we can assume that the tree isn\\'t a valid BST\\n        if (previous && previous->val >= root->val) {\\n            return false;\\n        }\\n        \\n        // set the previous node to the current node\\n        previous = root;\\n        \\n        // visit the right sub-tree\\n        return isValidBST(root->right);\\n    }\\nprivate:\\n    TreeNode* previous = nullptr;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452792,
                "title": "inorder-traversal-c-solution-both-iterative-and-recursive",
                "content": "You can check if binary tree to be a BST by checking if the the inorder traversal is in sorted (ascending) order. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return isBST_inorder_iterative(root); \\n    }\\n    \\n    bool isBST_inorder_recurse(TreeNode* p, TreeNode* &prev) {\\n        if(p == NULL) return true;\\n        \\n        if(!isBST_inorder_recurse(p->left, prev)) return false;\\n        if(prev != NULL && prev->val >= p->val) return false;\\n        prev = p;\\n        return isBST_inorder_recurse(p->right, prev);\\n        \\n    }\\n    \\n    bool isBST_inorder_iterative(TreeNode* p) {\\n        if(p == NULL) return true;\\n        stack<TreeNode*> st;\\n        TreeNode *curr = p;\\n        TreeNode *prev = NULL;\\n        \\n        while(curr != NULL || !st.empty()) {\\n            \\n            while(curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            }\\n            curr = st.top(); st.pop();\\n            if(prev != NULL && prev->val >= curr->val) return false;\\n            prev = curr;\\n            curr = curr->right;\\n        }\\n        return true;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return isBST_inorder_iterative(root); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 357687,
                "title": "javascript-inorder-traverse-solution",
                "content": "```\\nvar isValidBST = function(root, lower = -Infinity, upper = Infinity) {\\n    let arr = []; \\n    var traverse = function(root) {\\n        if (!root) return; \\n        traverse(root.left); \\n        arr.push(root.val);\\n        traverse(root.right);\\n    }; \\n    \\n    traverse(root);\\n    \\n    for (let i = 0; i < arr.length-1; i++) {\\n        if (arr[i] >= arr[i+1]) return false;\\n    };\\n    \\n    return true;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidBST = function(root, lower = -Infinity, upper = Infinity) {\\n    let arr = []; \\n    var traverse = function(root) {\\n        if (!root) return; \\n        traverse(root.left); \\n        arr.push(root.val);\\n        traverse(root.right);\\n    }; \\n    \\n    traverse(root);\\n    \\n    for (let i = 0; i < arr.length-1; i++) {\\n        if (arr[i] >= arr[i+1]) return false;\\n    };\\n    \\n    return true;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258041,
                "title": "a-golang-solution",
                "content": "```\\nfunc isValidBST(root *TreeNode) bool {     \\n        return validate(root, math.MinInt64, math.MaxInt64)\\n}\\n        \\nfunc validate(root *TreeNode, min, max int) bool {\\n        if root == nil {   \\n                return true\\n        }                  \\n        \\n        if root.Val <= min || root.Val >= max {\\n                return false\\n        }\\n                                                                                                                                                                                                            \\n        return validate(root.Left, min, root.Val) && validate(root.Right, root.Val, max)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValidBST(root *TreeNode) bool {     \\n        return validate(root, math.MinInt64, math.MaxInt64)\\n}\\n        \\nfunc validate(root *TreeNode, min, max int) bool {\\n        if root == nil {   \\n                return true\\n        }                  \\n        \\n        if root.Val <= min || root.Val >= max {\\n                return false\\n        }\\n                                                                                                                                                                                                            \\n        return validate(root.Left, min, root.Val) && validate(root.Right, root.Val, max)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197536,
                "title": "c-4ms-100-simple-recursive-soln",
                "content": "I used a ```long``` instead of ```int``` to handle the edge cases with nodes in the tree that are already INT_MIN or INT_MAX.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValidRecur(root, LONG_MIN, LONG_MAX);\\n    }\\n    \\n    bool isValidRecur(TreeNode* root, long min, long max) {\\n        if (!root)\\n            return true;\\n        int val = root->val;\\n        if (val <= min || val >= max)\\n            return false;\\n        return isValidRecur(root->left, min, val) &&\\n               isValidRecur(root->right, val, max);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```long```\n```int```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValidRecur(root, LONG_MIN, LONG_MAX);\\n    }\\n    \\n    bool isValidRecur(TreeNode* root, long min, long max) {\\n        if (!root)\\n            return true;\\n        int val = root->val;\\n        if (val <= min || val >= max)\\n            return false;\\n        return isValidRecur(root->left, min, val) &&\\n               isValidRecur(root->right, val, max);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141734,
                "title": "concise-java-solutions",
                "content": "```\\n    public boolean isValidBST(TreeNode root) {\\n        List<Integer> inorder = inorder(root);\\n        return isSorted(inorder);\\n    }\\n    \\n    public List<Integer> inorder(TreeNode node){\\n        if(node == null) return new ArrayList<>();\\n        List<Integer> res = new ArrayList<>();\\n        res.addAll(inorder(node.left));\\n        res.add(node.val);\\n        res.addAll(inorder(node.right));\\n        return res;\\n    }\\n    \\n    public boolean isSorted(List<Integer> l){\\n        for(int i=1; i<l.size(); i++){\\n            if(l.get(i) <= l.get(i-1)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isValidBST(TreeNode root) {\\n        List<Integer> inorder = inorder(root);\\n        return isSorted(inorder);\\n    }\\n    \\n    public List<Integer> inorder(TreeNode node){\\n        if(node == null) return new ArrayList<>();\\n        List<Integer> res = new ArrayList<>();\\n        res.addAll(inorder(node.left));\\n        res.add(node.val);\\n        res.addAll(inorder(node.right));\\n        return res;\\n    }\\n    \\n    public boolean isSorted(List<Integer> l){\\n        for(int i=1; i<l.size(); i++){\\n            if(l.get(i) <= l.get(i-1)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32195,
                "title": "golang-concise-solution-using-dfs",
                "content": "We need to take care of not only the relation between a parent, but also the grandparent.\\nActually all nodes have their own both minimum and maximum value constraint.\\nThis article explains the common mistake we might make.\\nhttp://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/\\n\\n```\\nfunc isValidBST(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tres, v := true, root.Val\\n\\tdoValidateBST(&res, root.Left, &v, nil)\\n\\tdoValidateBST(&res, root.Right, nil, &v)\\n\\treturn res\\n}\\n\\nfunc doValidateBST(res *bool, node *TreeNode, upperBound, lowerBound *int) {\\n\\tif node == nil || !*res {\\n\\t\\treturn\\n\\t}\\n\\tif (upperBound != nil && node.Val >= *upperBound) ||\\n\\t\\t(lowerBound != nil && node.Val <= *lowerBound) {\\n\\t\\t*res = false\\n\\t\\treturn\\n\\t}\\n\\n\\tv := node.Val\\n\\tdoValidateBST(res, node.Left, &v, lowerBound)\\n\\tdoValidateBST(res, node.Right, upperBound, &v)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidBST(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tres, v := true, root.Val\\n\\tdoValidateBST(&res, root.Left, &v, nil)\\n\\tdoValidateBST(&res, root.Right, nil, &v)\\n\\treturn res\\n}\\n\\nfunc doValidateBST(res *bool, node *TreeNode, upperBound, lowerBound *int) {\\n\\tif node == nil || !*res {\\n\\t\\treturn\\n\\t}\\n\\tif (upperBound != nil && node.Val >= *upperBound) ||\\n\\t\\t(lowerBound != nil && node.Val <= *lowerBound) {\\n\\t\\t*res = false\\n\\t\\treturn\\n\\t}\\n\\n\\tv := node.Val\\n\\tdoValidateBST(res, node.Left, &v, lowerBound)\\n\\tdoValidateBST(res, node.Right, upperBound, &v)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32220,
                "title": "ruby-recursive-solution",
                "content": "```\\ndef is_valid_bst(root, min = -Float::INFINITY, max = Float::INFINITY)\\n    return true unless root\\n    if root.val <= min || root.val >= max\\n        return false\\n    else\\n        is_valid_bst(root.left, min, root.val) && is_valid_bst(root.right, root.val, max)\\n    end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_valid_bst(root, min = -Float::INFINITY, max = Float::INFINITY)\\n    return true unless root\\n    if root.val <= min || root.val >= max\\n        return false\\n    else\\n        is_valid_bst(root.left, min, root.val) && is_valid_bst(root.right, root.val, max)\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 32402,
                "title": "simple-java-solution-recursive-validation",
                "content": "    public class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, (long)Integer.MIN_VALUE, (long)Integer.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root, long min, long max) {\\n        if(root == null) return true;\\n        long val = root.val;\\n        return (val >= min && val <= max && isValidBST(root.left, min, val -1) && isValidBST(root.right, val+1, max));\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, (long)Integer.MIN_VALUE, (long)Integer.MAX_VALUE);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32411,
                "title": "8ms-c-solution",
                "content": "    bool isValidBST(struct TreeNode* root) {\\n\\tif (NULL == root)\\n\\t\\treturn true;\\n\\n\\tif (NULL != root->left)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->left;\\n\\t\\twhile (current->right != NULL)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->right;\\n\\t\\t}\\n\\t\\tif (current->val >= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif (NULL != root->right)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->right;\\n\\t\\twhile (NULL != current->left)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->left;\\n\\t\\t}\\n\\t\\tif ( current->val <= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !isValidBST(root->left))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (!isValidBST(root->right))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}",
                "solutionTags": [],
                "code": "    bool isValidBST(struct TreeNode* root) {\\n\\tif (NULL == root)\\n\\t\\treturn true;\\n\\n\\tif (NULL != root->left)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->left;\\n\\t\\twhile (current->right != NULL)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->right;\\n\\t\\t}\\n\\t\\tif (current->val >= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif (NULL != root->right)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->right;\\n\\t\\twhile (NULL != current->left)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->left;\\n\\t\\t}\\n\\t\\tif ( current->val <= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !isValidBST(root->left))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (!isValidBST(root->right))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 32419,
                "title": "my-c-solution-12ms-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            if(root==NULL)\\n            return true;\\n            if(root->left==NULL && root->right==NULL)\\n            return true;\\n            bool left=true;\\n            bool right=true;\\n            if(root->left)\\n            {\\n                left=isValidBST(root->left);\\n                TreeNode* rightest=root->left;\\n                while(rightest->right)\\n                {\\n                    rightest=rightest->right;\\n                }\\n                left=left&&(root->val>rightest->val);\\n            }\\n            if(root->right)\\n            {\\n                right=isValidBST(root->right);\\n                TreeNode* leftest=root->right;\\n                while(leftest->left)\\n                leftest=leftest->left;\\n                right=right&&(root->val<leftest->val);\\n            }\\n            return left&&right;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            if(root==NULL)\\n            return true;\\n            if(root->left==NULL && root->right==NULL)\\n            return true;\\n            bool left=true;\\n            bool right=true;\\n            if(root->left)\\n            {\\n                left=isValidBST(root->left);\\n                TreeNode* rightest=root->left;\\n                while(rightest->right)\\n                {\\n                    rightest=rightest->right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 32490,
                "title": "my-recursive-solution-no-passing-bounds",
                "content": "Inorder traversal, check valid in left->root->right order.\\nThe traversal should in strict ascending order.\\n\\n 1. leftchild subproblem is not valid, return false.\\n 2. current value is not greater than last value (if exists), return false. Otherwise, update the last.\\n 3. check rightchild subproblem\\n\\n\\nclass Solution \\n{\\npublic:\\n\\n    TreeNode* last = NULL;\\n    bool isValidBST(TreeNode *root) \\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            bool leftRes = isValidBST(root->left);\\n            //short cut\\n            if(leftRes == false)\\n                return false;\\n            if(last && last->val >= root->val)\\n                return false;\\n            last = root;\\n            return isValidBST(root->right);\\n        }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n\\n    TreeNode* last = NULL;\\n    bool isValidBST(TreeNode *root) \\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            bool leftRes = isValidBST(root->left);\\n            //short cut\\n            if(leftRes == false)\\n                return false;\\n            if(last && last->val >= root->val)\\n                return false;\\n            last = root;\\n            return isValidBST(root->right);\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575626,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570656,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568573,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1892160,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1572391,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1835136,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568018,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1574053,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570321,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1567009,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1575626,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570656,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568573,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1892160,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1572391,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1835136,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568018,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1574053,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570321,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1567009,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1573325,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1576712,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1567857,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1569782,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1569395,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1572371,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1795787,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1574415,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1573251,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 2053693,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1852868,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1852078,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1747915,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1732816,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1726671,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1575322,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1574073,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1573486,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1573344,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1573316,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1572959,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572839,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572790,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572762,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572687,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572514,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572308,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572210,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572132,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1571827,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1570413,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 1574701,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 1574503,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2066892,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2066748,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2064698,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2062539,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2050515,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2050467,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2031246,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2030796,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2027691,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2016068,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2013386,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2011238,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2009408,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2008817,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2004491,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 1969500,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 1967746,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 1956270,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1956125,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1950307,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1922696,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1912121,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1910894,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879552,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1873506,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1871866,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1864697,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1847227,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1842621,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1826913,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1826564,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1823971,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1820379,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1809953,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1794525,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1792486,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1782253,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1780545,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1777949,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1766315,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1761810,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1751961,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1728296,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1722428,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1714172,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1713120,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1711864,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            }
        ]
    }
]