[
    {
        "title": "Minimum Path Sum",
        "question_content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n\nExample 2:\n\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 200\n\t0 <= grid[i][j] <= 200",
        "solutions": [
            {
                "id": 23457,
                "title": "c-dp",
                "content": "This is a typical DP problem. Suppose the minimum path sum of arriving at point `(i, j)` is `S[i][j]`, then the state equation is `S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]`.\\n\\nWell, some boundary conditions need to be handled. The boundary conditions happen on the topmost row (`S[i - 1][j]` does not exist) and the leftmost column (`S[i][j - 1]` does not exist). Suppose `grid` is like `[1, 1, 1, 1]`, then the minimum sum to arrive at each point is simply an accumulation of previous points and the result is `[1, 2, 3, 4]`.\\n\\nNow we can write down the following (unoptimized) code.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size(); \\n            vector<vector<int> > sum(m, vector<int>(n, grid[0][0]));\\n            for (int i = 1; i < m; i++)\\n                sum[i][0] = sum[i - 1][0] + grid[i][0];\\n            for (int j = 1; j < n; j++)\\n                sum[0][j] = sum[0][j - 1] + grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                for (int j = 1; j < n; j++)\\n                    sum[i][j]  = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];\\n            return sum[m - 1][n - 1];\\n        }\\n    };\\n\\nAs can be seen, each time when we update `sum[i][j]`, we only need `sum[i - 1][j]` (at the current column) and `sum[i][j - 1]` (at the left column). So we need not maintain the full `m*n` matrix. Maintaining two columns is enough and now we have the following code.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> pre(m, grid[0][0]);\\n            vector<int> cur(m, 0);\\n            for (int i = 1; i < m; i++)\\n                pre[i] = pre[i - 1] + grid[i][0];\\n            for (int j = 1; j < n; j++) { \\n                cur[0] = pre[0] + grid[0][j]; \\n                for (int i = 1; i < m; i++)\\n                    cur[i] = min(cur[i - 1], pre[i]) + grid[i][j];\\n                swap(pre, cur); \\n            }\\n            return pre[m - 1];\\n        }\\n    };\\n\\nFurther inspecting the above code, it can be seen that maintaining `pre` is for recovering `pre[i]`, which is simply `cur[i]` before its update. So it is enough to use only one vector. Now the space is further optimized and the code also gets shorter.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> cur(m, grid[0][0]);\\n            for (int i = 1; i < m; i++)\\n                cur[i] = cur[i - 1] + grid[i][0]; \\n            for (int j = 1; j < n; j++) {\\n                cur[0] += grid[0][j]; \\n                for (int i = 1; i < m; i++)\\n                    cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n            }\\n            return cur[m - 1];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size(); \\n            vector<vector<int> > sum(m, vector<int>(n, grid[0][0]));\\n            for (int i = 1; i < m; i++)\\n                sum[i][0] = sum[i - 1][0] + grid[i][0];\\n            for (int j = 1; j < n; j++)\\n                sum[0][j] = sum[0][j - 1] + grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                for (int j = 1; j < n; j++)\\n                    sum[i][j]  = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];\\n            return sum[m - 1][n - 1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 344980,
                "title": "java-details-from-recursion-to-dp",
                "content": "I had been struggling for recursive and DP problems before. But now I feeling like I am getting better.\\nThis is a simple explanations for those who are still not that good at these just like me.\\n\\n1. Recursion:\\n\\nSo basically let\\'s begin with recursion because it is easier to understand and code. When we think about this problem, we could use a top down approach. To get a path, we need to travel from grid[0][0] to grid[row - 1][col - 1]. So let\\'s set grid[0][0] as the basic case. This is when we jump out of recursion. On the other hand, grid[row - 1][col - 1] would be the starting point. We write a helper function to do the recursion work. At the starting point, this function returns (value of the end cell + value of the cell that has the less one). But we need to consider that things could happen that we reached the first row or column and we gotta make sure that we stay within the array index limit.\\nAt last, when we reach grid[0][0], we are done!\\n\\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            return min(grid, height - 1, width - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int row, int col){\\n\\n            if(row == 0 && col == 0) return grid[row][col]; // this is the exit of the recursion\\n            if(row == 0) return grid[row][col] + min(grid, row, col - 1); /** when we reach the first row, we could only move horizontally.*/\\n            if(col == 0) return grid[row][col] + min(grid, row - 1, col); /** when we reach the first column, we could only move vertically.*/\\n            return grid[row][col] + Math.min(min(grid, row - 1, col), min(grid, row, col - 1)); /** we want the min sum path so we pick the cell with the less value */\\n\\t\\t\\t\\n}\\n```\\n\\n2. Dynamic Programming:\\n\\nNow, let\\'s upgrade this algorithm from recursion to DP since we don\\'t wanna get stackoverflow for large inputs. In fact, there is nothing fancy about DP. It is simply that we store or cache the results of every single calculation so that we don\\'t need to calculate the same thing again and again. The whole idea is almost the same. We just involve an array to store the values. Now let\\'s see the code:\\n\\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            for (int row = 0; row < height; row++) {\\n                for (int col = 0; col < width; col++) {\\n                    if(row == 0 && col == 0) grid[row][col] = grid[row][col];\\n                    else if(row == 0 && col != 0) grid[row][col] = grid[row][col] + grid[row][col - 1];\\n                    else if(col == 0 && row != 0) grid[row][col] = grid[row][col] + grid[row - 1][col];\\n                    else grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n                }\\n            }\\n            return grid[height - 1][width - 1];\\n        }\\n```\\n\\nLooks quite familiar, right? The idea is the same. It\\'s just we reused the grid to store each sum results to boost the whole process. See? That\\'s the difference from recursion and DP. Not that hard, right? I hope this could be helpful.",
                "solutionTags": [],
                "code": "```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            return min(grid, height - 1, width - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int row, int col){\\n\\n            if(row == 0 && col == 0) return grid[row][col]; // this is the exit of the recursion\\n            if(row == 0) return grid[row][col] + min(grid, row, col - 1); /** when we reach the first row, we could only move horizontally.*/\\n            if(col == 0) return grid[row][col] + min(grid, row - 1, col); /** when we reach the first column, we could only move vertically.*/\\n            return grid[row][col] + Math.min(min(grid, row - 1, col), min(grid, row, col - 1)); /** we want the min sum path so we pick the cell with the less value */\\n\\t\\t\\t\\n}\\n```\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            for (int row = 0; row < height; row++) {\\n                for (int col = 0; col < width; col++) {\\n                    if(row == 0 && col == 0) grid[row][col] = grid[row][col];\\n                    else if(row == 0 && col != 0) grid[row][col] = grid[row][col] + grid[row][col - 1];\\n                    else if(col == 0 && row != 0) grid[row][col] = grid[row][col] + grid[row - 1][col];\\n                    else grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n                }\\n            }\\n            return grid[height - 1][width - 1];\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3345656,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n\\n# Video Solution\\n**Search \\uD83D\\uDC49 `Minimum Path Sum by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (1).png](https://assets.leetcode.com/users/images/7f71add2-6efd-46d3-82a0-a94fa2243b84_1679883432.537066.png)\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\n- The code implements a dynamic programming approach to find the minimum path sum in a grid.\\n\\n- The algorithm uses a 2D array to store the minimum path sum to reach each position (i, j) in the grid, where i represents the row and j represents the column.\\n\\n- The minimum path sum to reach each position (i, j) is computed by taking the minimum of the path sum to reach the position above (i-1, j) and the position to the left (i, j-1), and adding the cost of the current position (i, j).\\n\\n- The minimum path sum to reach the bottom-right corner of the grid is stored in the last element of the array (grid[m-1][n-1]), where m is the number of rows and n is the number of columns in the grid.\\n\\n# Intuition:\\n\\n- The intuition behind the dynamic programming approach is that the minimum path sum to reach a position (i, j) in the grid can be computed by considering the minimum path sum to reach the positions (i-1, j) and (i, j-1).\\n\\n- This is because the only two possible ways to reach the position (i, j) are either by moving down from (i-1, j) or moving right from (i, j-1).\\n\\n- By computing the minimum path sum to reach each position in the grid, the algorithm can find the minimum path sum to reach the bottom-right corner of the grid by simply looking at the last element of the array (grid[m-1][n-1]).\\n\\n\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n            \\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n    \\n        # An Upvote will be encouraging\\n\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n            \\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n    \\n        # An Upvote will be encouraging\\n\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23466,
                "title": "simple-python-dp-70ms",
                "content": "\\n\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23471,
                "title": "dp-with-o-n-n-space-complexity",
                "content": "\\tpublic int minPathSum(int[][] grid) {\\n\\t\\tint m = grid.length;// row\\n\\t\\tint n = grid[0].length; // column\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == 0 && j != 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i][j - 1];\\n\\t\\t\\t\\t} else if (i != 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i - 1][j];\\n\\t\\t\\t\\t} else if (i == 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgrid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j])\\n\\t\\t\\t\\t\\t\\t\\t+ grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn grid[m - 1][n - 1];\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic int minPathSum(int[][] grid) {\\n\\t\\tint m = grid.length;// row\\n\\t\\tint n = grid[0].length; // column\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == 0 && j != 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i][j - 1];\\n\\t\\t\\t\\t} else if (i != 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i - 1][j];\\n\\t\\t\\t\\t} else if (i == 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgrid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j])\\n\\t\\t\\t\\t\\t\\t\\t+ grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn grid[m - 1][n - 1];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 584967,
                "title": "python-grid-reduction-sounds-fancy-but-a-simple-method-no-additional-space",
                "content": "Let\\'s think of this problem in a super simple manner.\\n\\nOne important thing to remember is you can only walk right and down.\\n*Notation I am going to use (row, column).*\\n\\nWe are going to walk over the cells (the two for loops in the code). And each time we step on a cell, we are going to ask a question to ourself, how can I get to this cell with minimum sum from the previous step? Well, for the first cell (0,0) we don\\'t need to do anything, right?\\n\\nNext, think of walking over cell (0,1). What is the minimum sum to get to this cell? Well, it is too simple, just add the current number in the cell with the number of the cell on the left (for the case of (0,1) add it with the number in (0,0). This behavior is same for all the cells in the topmost row.\\n\\nNow, we get to the second row, we ask the same qustion for the cell in (1,0). How can we get here with minimum sum? This is too simple, add the number in (1,0) with (0,0). But now, when we get to (1,1), we have to add the number in (1,1) with **minimum** number from the cell above and the cell on the left. By this time, your cell above and the one on the left already contains the minimum sum path up to that cell. How conveninet, right? ^_^\\n\\nThat\\'s all you gotta do. And whenever you step on the cell, update the cell accordingly.\\n\\nWe don\\'t even need to use any additional space, we will overwrite stuff in the original grid. Why can we do this? We can do this since we are processing the grid and every point that we are currently reaching at bascially has the minimum sum *up to that cell*. We are accumulating the minimum sum path as we walk over the grid.\\n\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) <= 0 or grid is None:\\n            return 0\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r==0 and c==0: # We just want to skip the top-left corner of the grid\\n                    continue\\n                if r-1<0: # Cases for elements in top row\\n                    grid[r][c] = grid[r][c] + grid[r][c-1]  \\n                elif c-1<0: # Cases for elements in leftmost column\\n                    grid[r][c] = grid[r][c] + grid[r-1][c]  \\n                else: # Normal cell\\n                    grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])               \\n        \\n        return grid[rows-1][cols-1] # We have got the minimum path accumaled at the bottom-right corner, just return this\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) <= 0 or grid is None:\\n            return 0\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r==0 and c==0: # We just want to skip the top-left corner of the grid\\n                    continue\\n                if r-1<0: # Cases for elements in top row\\n                    grid[r][c] = grid[r][c] + grid[r][c-1]  \\n                elif c-1<0: # Cases for elements in leftmost column\\n                    grid[r][c] = grid[r][c] + grid[r-1][c]  \\n                else: # Normal cell\\n                    grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])               \\n        \\n        return grid[rows-1][cols-1] # We have got the minimum path accumaled at the bottom-right corner, just return this\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23647,
                "title": "my-8-lines-simple-solution",
                "content": "    int m = grid.length, n = grid[0].length;\\n    for(int i = 0; i < m; i++){\\n    \\tfor(int j = 0; j < n; j++){\\n    \\tif(i == 0 && j != 0) grid[i][j] += grid[i][j-1];\\n    \\tif(i != 0 && j == 0) grid[i][j] += grid[i-1][j];\\n    \\tif (i != 0 && j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n    \\t}\\n    }\\n    return grid[m-1][n-1];",
                "solutionTags": [],
                "code": "    int m = grid.length, n = grid[0].length;\\n    for(int i = 0; i < m; i++){\\n    \\tfor(int j = 0; j < n; j++){\\n    \\tif(i == 0 && j != 0) grid[i][j] += grid[i][j-1];\\n    \\tif(i != 0 && j == 0) grid[i][j] += grid[i-1][j];\\n    \\tif (i != 0 && j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n    \\t}\\n    }\\n    return grid[m-1][n-1];",
                "codeTag": "Unknown"
            },
            {
                "id": 584892,
                "title": "c-crystal-clear-dp",
                "content": "Question Decoration:\\n* Consider the matrix as a rectangular plot,\\nand grids as houses\\n* Now, you have to go from top-left house to bottom right    house\\n* Also when you are in some house, you have to pay the rent\\n* You can move by only one house at a time, either to Right   house  or to Down house\\n* You have to find the minimum rent to reach the bottom-Right house\\n------------------------------------------------------------------------\\nSolution:\\nWhy DP???\\nBECAUSE this problem requires optimizing the rent(minimum rent),and at each step we have multiple options, therefore we will use DP\\nsteps:\\n* Create a dp array of same size as grid\\n* dp[0][0] = grid[0][0] , b\\'coz we are initially in this house\\n* dp[i][j] means minimum rent i need to pay to reach the house [i,j]\\n* for 0th row , there is only one way to reach any house, and that is by moving to right, therefore ,\\n          dp[0][i] = dp[0][i-1] + grid[0][i]  (rent paid so far + rent for this house)\\n* for 0th column, there is only one way to reach any house, and that is by moving down, therefore,\\n         dp[i][0] = dp[i-1][0] + grid[i][0]  (rent paid so far + rent for this house)\\n* And now for rest of the houses in the grid, say grid[i][j]\\n         * we can reach either from grid[i-1][j]\\n         * or from grid[i][j-1]\\n         * we will choose the one with minimum rent\\n         therefore, dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\\n* and .....\\nWe are Done \\uD83D\\uDE03\\n----------------------------------------\\nCODE:\\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<int>> dp(m,vector<int>(n,0));\\n    dp[0][0] = grid[0][0];\\n    for(int i=1;i<m;i++)\\n        dp[i][0] = dp[i-1][0] + grid[i][0];\\n    for(int j=1;j<n;j++)\\n        dp[0][j] = dp[0][j-1] + grid[0][j];\\n     for(int i=1;i<m;i++)\\n         for(int j=1;j<n;j++)\\n             dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j];\\n        return dp[m-1][n-1];\\n    }",
                "solutionTags": [],
                "code": "Question Decoration:\\n* Consider the matrix as a rectangular plot,\\nand grids as houses\\n* Now, you have to go from top-left house to bottom right    house\\n* Also when you are in some house, you have to pay the rent\\n* You can move by only one house at a time, either to Right   house  or to Down house\\n* You have to find the minimum rent to reach the bottom-Right house\\n------------------------------------------------------------------------\\nSolution:\\nWhy DP???\\nBECAUSE this problem requires optimizing the rent(minimum rent),and at each step we have multiple options, therefore we will use DP\\nsteps:\\n* Create a dp array of same size as grid\\n* dp[0][0] = grid[0][0] , b\\'coz we are initially in this house\\n* dp[i][j] means minimum rent i need to pay to reach the house [i,j]\\n* for 0th row , there is only one way to reach any house, and that is by moving to right, therefore ,\\n          dp[0][i] = dp[0][i-1] + grid[0][i]  (rent paid so far + rent for this house)\\n* for 0th column, there is only one way to reach any house, and that is by moving down, therefore,\\n         dp[i][0] = dp[i-1][0] + grid[i][0]  (rent paid so far + rent for this house)\\n* And now for rest of the houses in the grid, say grid[i][j]\\n         * we can reach either from grid[i-1][j]\\n         * or from grid[i][j-1]\\n         * we will choose the one with minimum rent\\n         therefore, dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\\n* and .....\\nWe are Done \\uD83D\\uDE03\\n----------------------------------------\\nCODE:\\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<int>> dp(m,vector<int>(n,0));\\n    dp[0][0] = grid[0][0];\\n    for(int i=1;i<m;i++)\\n        dp[i][0] = dp[i-1][0] + grid[i][0];\\n    for(int j=1;j<n;j++)\\n        dp[0][j] = dp[0][j-1] + grid[0][j];\\n     for(int i=1;i<m;i++)\\n         for(int j=1;j<n;j++)\\n             dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j];\\n        return dp[m-1][n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 856314,
                "title": "sequential-thought-recursion-memo-dp-faster-easy-understanding",
                "content": "```\\n// sequential thought process for this problem\\n\\n//The path to reach (m, n) must be through one of the 2 cells:(m-1, n) or (m, n-1). So minimum cost to reach (m, n) can be written as \\u201Cminimum of the 2 cells plus cost[m][n]\\u201D.\\n//minCost(m, n) =min(minCost(m-1, n), minCost(m, n-1) )+ cost[m][n]\\n\\n//1.Recursion(TLE) [time complexity of the code is exponential]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n        \\n      return cost[m][n]+min(minCost(cost,m-1,n),minCost(cost,m,n-1)); \\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int M=grid.size(),N=grid[0].size();\\n        return minCost(grid,M-1,N-1);\\n    }\\n    \\n};\\n\\n//2.memoization[faster than 71.35% ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>>& memo) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n      if(memo[m][n]!=-1)\\n          return memo[m][n];\\n      int r=cost[m][n]+min(minCost(cost,m-1,n,memo),minCost(cost,m,n-1,memo));\\n        memo[m][n]=r;\\n      return r;\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> memo(m,vector<int>(n, -1));\\n        return minCost(grid,m-1,n-1,memo);\\n    }\\n    \\n};\\n\\n//3. Dynamic Programming [ faster than 71.65% ] [ TC: (m*n) ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>> dp) { \\n      dp[m-1][n-1]=cost[m-1][n-1];\\n      for(int i=n-2;i>=0;i--){\\n          dp[m-1][i]=dp[m-1][i+1]+cost[m-1][i];\\n      } \\n      for(int i=m-2;i>=0;i--){\\n          dp[i][n-1]=dp[i+1][n-1]+cost[i][n-1];\\n      }\\n      for(int i=m-2;i>=0;i--){\\n          for(int j=n-2;j>=0;j--){\\n              dp[i][j]=cost[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n          }\\n      }\\n      return dp[0][0];\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n, 0));\\n        return minCost(grid,m,n,dp);\\n    }\\n    \\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// sequential thought process for this problem\\n\\n//The path to reach (m, n) must be through one of the 2 cells:(m-1, n) or (m, n-1). So minimum cost to reach (m, n) can be written as \\u201Cminimum of the 2 cells plus cost[m][n]\\u201D.\\n//minCost(m, n) =min(minCost(m-1, n), minCost(m, n-1) )+ cost[m][n]\\n\\n//1.Recursion(TLE) [time complexity of the code is exponential]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n        \\n      return cost[m][n]+min(minCost(cost,m-1,n),minCost(cost,m,n-1)); \\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int M=grid.size(),N=grid[0].size();\\n        return minCost(grid,M-1,N-1);\\n    }\\n    \\n};\\n\\n//2.memoization[faster than 71.35% ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>>& memo) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n      if(memo[m][n]!=-1)\\n          return memo[m][n];\\n      int r=cost[m][n]+min(minCost(cost,m-1,n,memo),minCost(cost,m,n-1,memo));\\n        memo[m][n]=r;\\n      return r;\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> memo(m,vector<int>(n, -1));\\n        return minCost(grid,m-1,n-1,memo);\\n    }\\n    \\n};\\n\\n//3. Dynamic Programming [ faster than 71.65% ] [ TC: (m*n) ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>> dp) { \\n      dp[m-1][n-1]=cost[m-1][n-1];\\n      for(int i=n-2;i>=0;i--){\\n          dp[m-1][i]=dp[m-1][i+1]+cost[m-1][i];\\n      } \\n      for(int i=m-2;i>=0;i--){\\n          dp[i][n-1]=dp[i+1][n-1]+cost[i][n-1];\\n      }\\n      for(int i=m-2;i>=0;i--){\\n          for(int j=n-2;j>=0;j--){\\n              dp[i][j]=cost[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n          }\\n      }\\n      return dp[0][0];\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n, 0));\\n        return minCost(grid,m,n,dp);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23477,
                "title": "dp-solution-linear-space",
                "content": "You can only reach a cell by going from its left or top neighbor.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int> > &grid) {\\n            if(!grid.size())return 0;\\n            const int rows=grid.size(),cols=grid[0].size();\\n            // r[i] == min path sum to previous row's column i.\\n            vector<int> r(cols,0);\\n            int i,j;\\n            r[0]=grid[0][0];\\n            for(j=1;j<cols;j++){\\n                r[j]=grid[0][j]+r[j-1];       \\n            }\\n            for(i=1;i<rows;i++){\\n                r[0]+=grid[i][0];\\n                for(j=1;j<cols;j++){\\n                    r[j]=min(r[j-1],r[j])+grid[i][j];\\n                }\\n            }\\n            return r[cols-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int> > &grid) {\\n            if(!grid.size())return 0;\\n            const int rows=grid.size(),cols=grid[0].size();\\n            // r[i] == min path sum to previous row's column i.\\n            vector<int> r(cols,0);\\n            int i,j;\\n            r[0]=grid[0][0];\\n            for(j=1;j<cols;j++){\\n                r[j]=grid[0][j]+r[j-1];       \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 23613,
                "title": "python-easy-to-understand-solutions-o-m-n-o-n-space",
                "content": "```\\nclass Solution(object):\\n    def minPathSum1(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [[grid[0][0] for _ in range(c)] for _ in range(r)]\\n        for i in range(1, r):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, c):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, r):\\n            for j in range(1, c):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[-1][-1]\\n    \\n    def minPathSum(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [grid[0][0] for _ in range(c)]\\n        for j in range(1, c):\\n            dp[j] = dp[j-1] + grid[0][j]\\n        for i in range(1, r):\\n            dp[0] += grid[i][0]\\n            for j in range(1, c):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPathSum1(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [[grid[0][0] for _ in range(c)] for _ in range(r)]\\n        for i in range(1, r):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, c):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, r):\\n            for j in range(1, c):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[-1][-1]\\n    \\n    def minPathSum(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [grid[0][0] for _ in range(c)]\\n        for j in range(1, c):\\n            dp[j] = dp[j-1] + grid[0][j]\\n        for i in range(1, r):\\n            dp[0] += grid[i][0]\\n            for j in range(1, c):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345999,
                "title": "python3-c-dp-91-ms-beats-94-21",
                "content": "This code is an implementation of the minimum path sum problem on a 2D grid. The problem requires finding the minimum sum of numbers along a path from the top-left corner to the bottom-right corner of the grid.\\n\\nThe function takes a 2D list of integers grid as input, which represents the values in the grid. The function uses dynamic programming approach to solve the problem.\\n\\nFirst, the function determines the dimensions of the grid using the len() function. Then, it iterates over the grid using two nested for loops to check each cell of the grid.\\n\\nFor each cell, the function checks if it is on the top row or the leftmost column of the grid. If the cell is on the top row, the function adds the value of the cell to the value of the cell immediately to its left. Similarly, if the cell is on the leftmost column, the function adds the value of the cell to the value of the cell immediately above it.\\n\\nFor all other cells, the function adds the value of the cell to the minimum value of the cells directly above and directly to the left of the current cell.\\n\\nFinally, the function returns the value in the bottom-right corner of the grid, which represents the minimum path sum.\\n![image.png](https://assets.leetcode.com/users/images/6e1928e7-6041-4e68-afbc-504275ec9b60_1679888401.7288485.png)\\n# Please Upvote \\uD83D\\uDE07\\n\\n## Python3\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if i==0:\\n                    if j!=0:\\n                        grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    if i!=0:\\n                        grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]+=min(grid[i-1][j],grid[i][j-1])\\n        return grid[n-1][m-1]\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 and j!=0) grid[i][j]+=grid[i][j-1];\\n                if(j==0 and i!=0) grid[i][j]+=grid[i-1][j];\\n                if(i!=0 and j!=0) grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if i==0:\\n                    if j!=0:\\n                        grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    if i!=0:\\n                        grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]+=min(grid[i-1][j],grid[i][j-1])\\n        return grid[n-1][m-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 and j!=0) grid[i][j]+=grid[i][j-1];\\n                if(j==0 and i!=0) grid[i][j]+=grid[i-1][j];\\n                if(i!=0 and j!=0) grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202628,
                "title": "c-three-solutions-recursion-top-down-bottom-up-easy-to-understand",
                "content": "**Recursive Solution**\\n\\n```\\nint getMinPath(vector <vector <int>> &grid, int i, int j) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j);\\n            m = min(m, s);\\n        }\\n        return m;\\n    }\\n    \\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Top Down DP - Memoization**\\n\\n```\\nint getMinPath(vector <vector <int>> &grid, int i, int j, vector <vector<int>> &dp) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        \\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1, dp);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j, dp);\\n            m = min(m, s);\\n        }\\n        \\n        dp[i][j] = m;\\n        return dp[i][j];\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Bottom Up DP - Table Filling**\\n\\n```\\nint getMinPath(vector <vector <int>> &grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n\\n        vector <vector <int>> dp(r, vector <int>(c, 0));\\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 1; i < c; i++) {\\n            dp[0][i] = grid[0][i] + dp[0][i - 1];\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            dp[i][0] = grid[i][0] + dp[i - 1][0];\\n        }\\n\\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n         \\n        return dp[r - 1][c - 1];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint getMinPath(vector <vector <int>> &grid, int i, int j) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j);\\n            m = min(m, s);\\n        }\\n        return m;\\n    }\\n    \\n```\n```\\nint getMinPath(vector <vector <int>> &grid, int i, int j, vector <vector<int>> &dp) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        \\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1, dp);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j, dp);\\n            m = min(m, s);\\n        }\\n        \\n        dp[i][j] = m;\\n        return dp[i][j];\\n    }\\n```\n```\\nint getMinPath(vector <vector <int>> &grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n\\n        vector <vector <int>> dp(r, vector <int>(c, 0));\\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 1; i < c; i++) {\\n            dp[0][i] = grid[0][i] + dp[0][i - 1];\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            dp[i][0] = grid[i][0] + dp[i - 1][0];\\n        }\\n\\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n         \\n        return dp[r - 1][c - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467216,
                "title": "python-bottom-up-dp-in-place-clean-concise",
                "content": "**Idea**\\n- For the current cell `[r, c]`, there are two options to choose:\\n\\t- Choose from up cell `[r-1, c]` go down to `[r, c]`.\\n\\t- Choose from left cell `[r, c-1]` go right to `[r, c]`.\\n- So, we need to choose minium cost between 2 above options.\\n```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 and c == 0:\\n                    pass\\n                elif r == 0:\\n                    grid[r][c] += grid[r][c-1]\\n                elif c == 0:\\n                    grid[r][c] += grid[r-1][c]\\n                else:\\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\\n        return grid[m-1][n-1]\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 and c == 0:\\n                    pass\\n                elif r == 0:\\n                    grid[r][c] += grid[r][c-1]\\n                elif c == 0:\\n                    grid[r][c] += grid[r-1][c]\\n                else:\\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\\n        return grid[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23532,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Minimum Path Sum**https://leetcode.com/problems/minimum-path-sum/\\n\\n**Dynamic Programming using Memoization**\\n* Start Point: 0, 0. Destination Point: M-1, N-1\\n* Cost[i,j]: The cost to reach destination from (i,j). Matrix is initialized to inf.\\n* The solution will be cost(0,0)\\n* Initialize the cost matrix with boundary condition. cost[M-1,N-1]=grid[M-1,N-1]\\n* Be careful with what you return for out of bound grid points. Make sure you return infinity so that they are ignored within the min equation\\n* Time and Space Complexity: O(MN)\\n```\\nclass Solution(object):\\n    def helper(self, x, y, grid, cost):\\n        M, N = len(grid), len(grid[0])\\n        if x == M or y == N:\\n            return float('inf')\\n        elif cost[x][y] != -1:\\n            return cost[x][y]\\n        else:\\n            right, down = self.helper(x,y+1,grid,cost), self.helper(x+1,y,grid,cost)\\n            cost[x][y] = min(right, down) + grid[x][y]\\n        return cost[x][y]\\n    \\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[-1]*N for _ in range(M)]\\n        cost[M-1][N-1] = grid[M-1][N-1]\\n        return self.helper(0, 0, grid, cost)\\n```\\n\\n**Dynamic Programming: O(MN) space**\\n* Start Point: 0, 0. Destination Point: M-1, N-1\\n* Cost[i,j]: The cost to reach (i,j) from (0,0). We initialize  \\n* The solution will be cost(M-1,N-1)\\n* Time & Space Complexity:O(MN)\\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[0]*N for _ in range(M)]\\n        cost[0][0] = grid[0][0]\\n        for j in range(1,N):\\n            cost[0][j] = grid[0][j] + cost[0][j-1]\\n        for i in range(1,M):\\n            cost[i][0] = grid[i][0] + cost[i-1][0]\\n        for i in range(1,M):\\n            for j in range(1,N):\\n                cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j]\\n        return cost[M-1][N-1]\\n```\\n\\n**Dynamic Programming: Using O(N) space**\\n* Space complexity can be reduced to O(N) since we only require the previous row to compute the current row.\\n* Note that we initialize the cost array to inf. Note how we initialize cost[0] at every row iteration.\\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [float('inf')]*N\\n        for i in range(M):\\n            cost[0] = grid[i][0] + cost[0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                cost[j] = min(cost[j-1], cost[j]) + grid[i][j]\\n        return cost[-1]\\n```\\n\\n**Dynamic Programming: Using O(1) space**\\n* Space complexity can be reduced to O(1) as grid can be reused as cost matrix\\n* Notice how we iterate the two loops and the special condition we use for i=0\\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        for i in range(M):\\n            grid[i][0] = grid[i][0] + grid[i-1][0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j] if i > 0 else grid[i][j-1]+grid[i][j]\\n        return grid[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, x, y, grid, cost):\\n        M, N = len(grid), len(grid[0])\\n        if x == M or y == N:\\n            return float('inf')\\n        elif cost[x][y] != -1:\\n            return cost[x][y]\\n        else:\\n            right, down = self.helper(x,y+1,grid,cost), self.helper(x+1,y,grid,cost)\\n            cost[x][y] = min(right, down) + grid[x][y]\\n        return cost[x][y]\\n    \\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[-1]*N for _ in range(M)]\\n        cost[M-1][N-1] = grid[M-1][N-1]\\n        return self.helper(0, 0, grid, cost)\\n```\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[0]*N for _ in range(M)]\\n        cost[0][0] = grid[0][0]\\n        for j in range(1,N):\\n            cost[0][j] = grid[0][j] + cost[0][j-1]\\n        for i in range(1,M):\\n            cost[i][0] = grid[i][0] + cost[i-1][0]\\n        for i in range(1,M):\\n            for j in range(1,N):\\n                cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j]\\n        return cost[M-1][N-1]\\n```\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [float('inf')]*N\\n        for i in range(M):\\n            cost[0] = grid[i][0] + cost[0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                cost[j] = min(cost[j-1], cost[j]) + grid[i][j]\\n        return cost[-1]\\n```\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        for i in range(M):\\n            grid[i][0] = grid[i][0] + grid[i-1][0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j] if i > 0 else grid[i][j-1]+grid[i][j]\\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502072,
                "title": "javascript-95-speed-o-mn-time-o-1-space-w-comments",
                "content": "```\\nvar minPathSum = function(grid) {\\n\\t// Get the two dimensions of the grid\\n    const n = grid.length;\\n    const m = grid[0].length;\\n    \\n\\t// Calculate the distance travelled within the first column\\n\\t// This is because each square depends on the one above\\n\\t// And the one to the left. However there is nothing left\\n\\t// of the first column so we can calculate it by adding\\n\\t// the current square to the square above it\\n    for(let i=1; i<n; i++) {\\n        grid[i][0] += grid[i-1][0];\\n    }\\n    \\n\\t// The same goes for the first row. There is nothing above the \\n\\t// first row. So we just calculate the distance by what is to the left\\n\\t// of it\\n    for(let j=1; j<m; j++) {\\n        grid[0][j] += grid[0][j-1];\\n    }\\n    \\n\\t// Start one row and one column in because we\\'ve precomputed\\n\\t// those above\\n    for(let i=1; i<n; i++) {\\n        for(let j=1; j<m; j++) {\\n\\t\\t\\t// The distance to the grid at i,j is equal to itself plus the minimum\\n\\t\\t\\t// of the two grid spaces (one above, one to the left)\\n            grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        }\\n    }\\n    \\n\\t// Return the distance bottom right corner\\n    return grid[n-1][m-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathSum = function(grid) {\\n\\t// Get the two dimensions of the grid\\n    const n = grid.length;\\n    const m = grid[0].length;\\n    \\n\\t// Calculate the distance travelled within the first column\\n\\t// This is because each square depends on the one above\\n\\t// And the one to the left. However there is nothing left\\n\\t// of the first column so we can calculate it by adding\\n\\t// the current square to the square above it\\n    for(let i=1; i<n; i++) {\\n        grid[i][0] += grid[i-1][0];\\n    }\\n    \\n\\t// The same goes for the first row. There is nothing above the \\n\\t// first row. So we just calculate the distance by what is to the left\\n\\t// of it\\n    for(let j=1; j<m; j++) {\\n        grid[0][j] += grid[0][j-1];\\n    }\\n    \\n\\t// Start one row and one column in because we\\'ve precomputed\\n\\t// those above\\n    for(let i=1; i<n; i++) {\\n        for(let j=1; j<m; j++) {\\n\\t\\t\\t// The distance to the grid at i,j is equal to itself plus the minimum\\n\\t\\t\\t// of the two grid spaces (one above, one to the left)\\n            grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        }\\n    }\\n    \\n\\t// Return the distance bottom right corner\\n    return grid[n-1][m-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3345863,
                "title": "image-explanation-recursion-dp-4-methods-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`)\\n`Minimum Path Sum` by `Aryan Mittal`\\n![meta5.png](https://assets.leetcode.com/users/images/ba681d93-09f3-4124-8452-da3ff1212d19_1679887228.3219895.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/1e83ac93-0c25-49f7-a1bc-5d19636b9c7c_1679883307.3522673.png)\\n![image.png](https://assets.leetcode.com/users/images/3d44f039-7517-4742-be15-675c7f45f7e4_1679883343.370807.png)\\n![image.png](https://assets.leetcode.com/users/images/7ec80aa0-711a-4e46-be05-33efca08da7e_1679883363.6013312.png)\\n![image.png](https://assets.leetcode.com/users/images/5df527f7-94c4-430d-b241-ba92925aa010_1679883392.19581.png)\\n![image.png](https://assets.leetcode.com/users/images/39a67687-3976-4fdd-a4e6-48ef70c2b867_1679883404.3252819.png)\\n![image.png](https://assets.leetcode.com/users/images/bf0d85ae-ff30-4140-a094-fbc4e5b10946_1679883414.034133.png)\\n![image.png](https://assets.leetcode.com/users/images/e98a682a-52a3-4e86-9a63-46f4408f3a04_1679883421.3524578.png)\\n![image.png](https://assets.leetcode.com/users/images/a03890d0-83f0-44dc-a008-2cac56151a9c_1679883428.471258.png)\\n![image.png](https://assets.leetcode.com/users/images/eb14045b-08d6-4774-b456-ff345390b3ee_1679883436.9386165.png)\\n\\n\\n\\n# Method1 Code: By Modifying the Grid O(1) Space\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n```\\n\\n# Method4 Code: Without Modifying the Grid O(m) Space\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] cur = new int[m];\\n        cur[0] = grid[0][0];\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0];\\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                cur[i] = Math.min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cur = [grid[0][0]] * m\\n        \\n        for i in range(1, m):\\n            cur[i] = cur[i - 1] + grid[i][0]\\n        \\n        for j in range(1, n):\\n            cur[0] += grid[0][j]\\n            for i in range(1, m):\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]\\n        \\n        return cur[m - 1]\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] cur = new int[m];\\n        cur[0] = grid[0][0];\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0];\\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                cur[i] = Math.min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cur = [grid[0][0]] * m\\n        \\n        for i in range(1, m):\\n            cur[i] = cur[i - 1] + grid[i][0]\\n        \\n        for j in range(1, n):\\n            cur[0] += grid[0][j]\\n            for i in range(1, m):\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]\\n        \\n        return cur[m - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825410,
                "title": "python3-dynamic-programming-90-w-explaination",
                "content": "Dynamic programming is all about breaking the whole problem into smaller problems in which you can then minimize, which will result in the whole problem being minimized. In this question, we should notice that the minimum path sum for each cell is the smaller value between the cell itself plus the cell above it or the the cell itself plus the cell to the left of it. So, as you visit each future cell and refer to previous cells to the left and above you, you know that those cells have been optimized to have the minimum path sum for that index - thus obtaining the most optimal path.\\n\\nFor example,\\n```\\n[1,3,1],\\n[1,5,1],\\n[4,2,1]\\n```\\n* **grid[0][1]**, there is a cell to the left of it (grid[0][0] = 1) and no cell above it, this means we know that the minimum path sum for this cell is at best 4 (3 + 1).\\n* **grid[0][2]**, similar to grid[0][1], at best is 5 (1 + 4)\\n* **grid[1][0]**, there is a cell above (grid[0][0] = 1) and no cell to the left of it, this means we know that the minimum path sum for this cell is at best 2 (1 + 1).\\n* **grid[1][1]**, there is a cell above and also a cell to the left of it, we will need to add a cell (grid[0][1] = 4 or grid[1][0] = 2) that will result in the current cell having the smallest sum possible. It is ideal to add grid[1][0], thus the minimum path sum for this cell is at best 7 (2 + 5).\\n* **grid[1][2]**, similar to grid[1][1], at best is 6 (1 + 5)\\n* **grid[2][0]**, similar to grid[1][0], at best is 6 (4 + 2)\\n* **grid[2][1]**, similar to grid[1][1], at best is 8 (2 + 6)\\n* **grid[2][2]**, similar to grid[1][1], at best is 7 (1 + 6)\\n\\nThe resulting DP array - you can put your calculated results for each cell in a seperate 2D array or do it in-place (which I did).\\n```\\n[1,4,5],\\n[2,7,6],\\n[6,8,7]\\n```\\nHere is the actual code:\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i > 0 and j > 0:\\n                    grid[i][j] = min(grid[i][j] + grid[i-1][j], grid[i][j] + grid[i][j-1])\\n                elif i > 0:\\n                    grid[i][j] += grid[i-1][j]\\n                elif j > 0:\\n                    grid[i][j] += grid[i][j-1]\\n        \\n        return grid[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n[1,3,1],\\n[1,5,1],\\n[4,2,1]\\n```\n```\\n[1,4,5],\\n[2,7,6],\\n[6,8,7]\\n```\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i > 0 and j > 0:\\n                    grid[i][j] = min(grid[i][j] + grid[i-1][j], grid[i][j] + grid[i][j-1])\\n                elif i > 0:\\n                    grid[i][j] += grid[i-1][j]\\n                elif j > 0:\\n                    grid[i][j] += grid[i][j-1]\\n        \\n        return grid[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180305,
                "title": "my-java-dp-solution-easy-to-understand-beats-96",
                "content": "The idea is to sum up the first row and first column as there is no way to reach to that point other than to go right or down respectively. For the rest of the grid[i][j] (for all i >1 and j >1) find the minimum of the grid-left (j-1) and grid-top (i-1) value and add to the current grid value. At the end, the minimum path sum would be the buttom last value in the grid.\n\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        \n        for(int i=1; i<grid.length; i++) {\n            grid[i][0] = grid[i-1][0] + grid[i][0];\n        }\n        for(int j=1; j<grid[0].length; j++) {\n            grid[0][j] = grid[0][j-1] + grid[0][j];\n        }\n        for(int i=1; i<grid.length; i++) {\n            for(int j=1; j<grid[0].length; j++) {\n                grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n            }\n        }\n        return grid[grid.length-1][grid[0].length-1];\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        \n        for(int i=1; i<grid.length; i++) {\n            grid[i][0] = grid[i-1][0] + grid[i][0];\n        }\n        for(int j=1; j<grid[0].length; j++) {\n            grid[0][j] = grid[0][j-1] + grid[0][j];\n        }\n        for(int i=1; i<grid.length; i++) {\n            for(int j=1; j<grid[0].length; j++) {\n                grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n            }\n        }\n        return grid[grid.length-1][grid[0].length-1];\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345894,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\nTo find the minimum sum path from the top left corner to the bottom right corner of the grid, we can use dynamic programming. We create a dp table to store the minimum sum path to each cell. The value in the (i, j) cell of the dp table represents the minimum sum path from the top left corner to that cell. We can then fill the dp table using the values from the grid.\\n\\n\\n\\n# Approach\\n- Initialize the dp table with the value of the top left corner of the grid.\\n- Fill the first row of the dp table by adding the values in the previous cell and the current cell in the grid.\\n- Fill the first column of the dp table by adding the values in the previous cell and the current cell in the grid.\\n- Fill the rest of the dp table by taking the minimum of the value above and the value to the left of the current cell in the dp table, and adding the value in the current cell of the grid.\\n- Return the value in the bottom right corner of the dp table, which represents the minimum sum path from the top left corner to the bottom right corner of the grid.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of nodes in the graph. We visit each node at most once, and perform constant-time operations on each node.\\n\\n- Space complexity: O(n), where n is the number of nodes in the graph. We use an array of size n to keep track of the time at which we visit each node.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // Fill the first row\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        \\n        // Fill the first row\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # Create a dp table to store the minimum sum path to each cell\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        \\n        # Fill the first row\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] + grid[0][i]\\n        \\n        # Fill the first column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        \\n        # Fill the rest of the dp table\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        \\n        return dp[m-1][n-1]\\n\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // Fill the first row\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        \\n        // Fill the first row\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # Create a dp table to store the minimum sum path to each cell\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        \\n        # Fill the first row\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] + grid[0][i]\\n        \\n        # Fill the first column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        \\n        # Fill the rest of the dp table\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        \\n        return dp[m-1][n-1]\\n\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329435,
                "title": "python-dijkstra-s-with-topological-sort-o-e-v-time",
                "content": "Because we can only move down or right, we are given a directional acyclic graph (DAG) and do not need to check for cycles.\\n\\nWe also do not need to use a priority queue to select our next minimum distance vertex to visit.\\n\\nInstead we can use topological sort to make the next vertex selection, and process vertices which have an indegree of 0. This results in a linear O(|E| + |V|) time solution instead of O(|E| log |V|) with priority queue.\\n\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n\\n        distances = {}\\n        adj_to = defaultdict(dict)\\n        indegree = defaultdict(int)\\n        \\n        for i, row in enumerate(grid):\\n            for j, dist in enumerate(row):\\n                distances[(i,j)] = float(\"inf\")\\n                if i > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i-1,j)][(i,j)] = dist\\n                if j > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i,j-1)][(i,j)] = dist\\n        \\n        to_visit = deque([((0,0), grid[0][0])])\\n        \\n        distances[(0,0)] = grid[0][0]\\n        \\n        while to_visit:\\n            cur, cur_dist = to_visit.popleft()\\n            \\n            for adj in adj_to[cur]:\\n                this_dist = cur_dist + adj_to[cur][adj]\\n                distances[adj] = min(this_dist,distances[adj])\\n                indegree[adj] -= 1\\n                if indegree[adj] == 0:\\n                    to_visit.append((adj, distances[adj]))\\n            \\n        return distances[max(distances)]\\n                \\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n\\n        distances = {}\\n        adj_to = defaultdict(dict)\\n        indegree = defaultdict(int)\\n        \\n        for i, row in enumerate(grid):\\n            for j, dist in enumerate(row):\\n                distances[(i,j)] = float(\"inf\")\\n                if i > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i-1,j)][(i,j)] = dist\\n                if j > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i,j-1)][(i,j)] = dist\\n        \\n        to_visit = deque([((0,0), grid[0][0])])\\n        \\n        distances[(0,0)] = grid[0][0]\\n        \\n        while to_visit:\\n            cur, cur_dist = to_visit.popleft()\\n            \\n            for adj in adj_to[cur]:\\n                this_dist = cur_dist + adj_to[cur][adj]\\n                distances[adj] = min(this_dist,distances[adj])\\n                indegree[adj] -= 1\\n                if indegree[adj] == 0:\\n                    to_visit.append((adj, distances[adj]))\\n            \\n        return distances[max(distances)]\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190409,
                "title": "java-best-recursive-memo-dp-solution",
                "content": "Start from basics and move forward.\\n\\n1. Recursive.\\n\\n```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        return find(grid, m, n);\\n\\t\\t}\\n    public int find(int grid[][], int m, int n)\\n    {\\n        if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        return grid[m][n] + Math.min(find(grid, m-1, n),find(grid, m, n-1)); \\n   }\\n}\\n```\\n\\n2. Memo Based Solution\\n\\n```\\nclass Solution \\n{\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        \\n        memo = new int[m+1][n+1];\\n        \\n        return find(grid, m, n, memo);\\n    }\\n    public int find(int grid[][], int m, int n, int[][] memo)\\n    {\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        \\n        else if(memo[m][n]!=0)\\n            return memo[m][n];\\n        else\\n            return memo[m][n] =  grid[m][n] + Math.min(find(grid, m-1, n, memo),find(grid, m, n-1, memo)); \\n}\\n    }\\n```\\n\\n3. Dp Based Solution\\n\\n```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        //Initialisation\\n        int[][] dp = new int[m][n];\\n        \\n        //Base Case Transformation\\n        \\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[0][i]  = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            dp[i][0]  = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        //Main logic\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j] = Math.min(dp[i][j-1] , dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\nI hope you get the solutions.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        return find(grid, m, n);\\n\\t\\t}\\n    public int find(int grid[][], int m, int n)\\n    {\\n        if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        return grid[m][n] + Math.min(find(grid, m-1, n),find(grid, m, n-1)); \\n   }\\n}\\n```\n```\\nclass Solution \\n{\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        \\n        memo = new int[m+1][n+1];\\n        \\n        return find(grid, m, n, memo);\\n    }\\n    public int find(int grid[][], int m, int n, int[][] memo)\\n    {\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        \\n        else if(memo[m][n]!=0)\\n            return memo[m][n];\\n        else\\n            return memo[m][n] =  grid[m][n] + Math.min(find(grid, m-1, n, memo),find(grid, m, n-1, memo)); \\n}\\n    }\\n```\n```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        //Initialisation\\n        int[][] dp = new int[m][n];\\n        \\n        //Base Case Transformation\\n        \\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[0][i]  = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            dp[i][0]  = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        //Main logic\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j] = Math.min(dp[i][j-1] , dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23555,
                "title": "ac-java-dp-solution-v-s-tle-dijstra-solution",
                "content": "When I looked at this question, the first thought was the Dijkstra solution, which is a very fast algorithm to calculate the shortest path. But this solution got TLE in this question, while DP solution worked fine.\\n\\nI will talk about the Dijkstra solution first, as it's the first though came into my mind, and there is already discussions on the DP solution. If you are not interested in the Dijkstra solution, you can jump to the latter part of this post, which is about the DP solution, which is accepted.\\n\\n**Dijkstra**\\nThe idea of Dijkstra algorithm is to divide the graph into 2 parts, visited and unvisited. \\nFor every node in the visited part has a *dist* value. Then we need to exam every edges across the visited part and the unvisited parts, which are edges that its start node is in the visited part, while its end node is in the unvisited part. What we are looking for is one edge, which has the minimum value of (dist(start node) + the edge's value). Then we put this node into the visited part and exam the edges again.\\n\\nFollowing is the code. It uses a Java Heap, PriorityQueue to keep track of the minimum (dist(start node) + the edge's value), but in this question, the edge value is in the node itself, which is the same for every edges ending to it, so actually the heap just keeps track of the mimimum dist(start node) of every unvisited nodes around the boarder between visited and unvisited.\\n\\n    public class Solution_dijkstra {\\n\\t\\n\\tclass PointComparator implements Comparator<int[]>{\\n    \\tint[][] dist;\\n    \\tpublic PointComparator(int[][] dist){\\n    \\t\\tthis.dist = dist;\\n    \\t}\\n    \\t@Override\\n    \\tpublic int compare(int[] o1, int[] o2) {\\n    \\t\\tint[] point1 = (int[])o1;\\n            int[] point2 = (int[])o2;\\n            return Integer.valueOf(dist[point1[0]][point1[1]])\\n                .compareTo(Integer.valueOf(dist[point2[0]][point2[1]]));\\n        }\\n    }\\n    \\t\\n    public int minPathSum(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        int[][] dist = new int[m][n];\\n        \\n        for(int x = 0; x < m; x++){\\n            for(int y = 0; y < n; y++){\\n                dist[x][y] = Integer.MAX_VALUE;\\n            }\\n        }\\n        \\n        dist[0][0] = grid[0][0];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>( m*n, new PointComparator(dist));\\n        \\n        pq.add(new int[]{0, 0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] point = pq.poll();\\n            int x = point[0];\\n            int y = point[1];\\n            int d = dist[x][y];\\n            \\n            if(x == n-1 && y == m-1){\\n                return d;\\n            }\\n            \\n            visited[x][y] = true;\\n            \\n            if((y+1 < n) && !visited[x][y+1]){\\n                dist[x][y+1] = min(\\n                    dist[x][y+1],\\n                    d + grid[x][y+1]);\\n                pq.add(new int[]{x, y+1});\\n            }\\n            \\n            if((x+1 < m ) && !visited[x+1][y]){\\n                dist[x+1][y] = min(\\n                    dist[x+1][y],\\n                    d + grid[x+1][y]);\\n                pq.add(new int[]{x+1, y});\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    private int min(int i1, int i2){\\n    \\treturn i1 < i2 ? i1 : i2;\\n    }\\n\\n\\n} \\n\\n\\nThis solution got LTE error, mostly because of the priority queue and doesn't consider the special condition here that it's a grid and directed, which means a node can only be accessed from it's left and upper nodes. Put all these into consideration, we have the DP solution. It's essentially formula is\\n\\ndist(node) = min( dist(upper node), dist(left node)) + node's value\\n\\n**DP**\\nhere is the code:\\n\\n    public class Solution_dp {\\n\\t\\n\\tprivate int getDist(int[][] dist, int x, int y){\\n\\t\\tif(x < 0 || y < 0){\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn dist[x][y];\\t\\t\\n\\t}\\n\\t\\n\\tprivate int min(int i1, int i2){\\n\\t\\treturn i1 < i2 ? i1 : i2;\\n\\t}\\n\\t\\n\\t\\n\\tpublic int minPathSum(int[][] grid) {\\n\\n\\t\\tif(grid == null || grid.length == 0) return 0;\\n\\t\\t\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\t\\n\\t\\tint[][] dist = new int[m][n];\\n\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\n\\t\\tfor(int x = 0; x < m; x++){\\n\\t\\t\\tfor(int y = 0; y < n; y++){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(x == 0 && y == 0){\\n\\t\\t\\t\\t\\tdist[0][0] = grid[0][0];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tdist[x][y] = min(getDist(dist, x-1, y), getDist(dist, x, y-1))  + grid[x][y];\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\t\\t\\n\\t\\t}\\n\\t\\n\\t\\treturn dist[m-1][n-1];\\n\\t\\t\\t\\t\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution_dijkstra {\\n\\t\\n\\tclass PointComparator implements Comparator<int[]>{\\n    \\tint[][] dist;\\n    \\tpublic PointComparator(int[][] dist){\\n    \\t\\tthis.dist = dist;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3345882,
                "title": "6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat",
                "content": "# Intuition\\nTry to reach every points with minimium path sum.\\n\\n# Approach\\nReach to each point but alwasy with minimum path sum possible \\n```\\n<!-- Assume we need to reach ar[i][j]  -->\\n<!-- always check minimum possiblle rach value near by it -->\\nar[i][j] = ar[i][j] + min(ar[i-1][j],ar[i][j-1])\\n```\\nThat is all aproch and there is given 6 ways\\n\\n# CODES\\n\\n# Simple recursion start from (0,0) to (n,n) filling (TLE)\\n- Time complexity: O(2^n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        int a = fun(gr,i+1,j);\\n        int b = fun(gr,i,j+1);\\n        return gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0);\\n    }\\n};\\n``` \\n# Simple recursion start from (n,n) to (0,0) filling (TLE)\\n- Time complexity: O(2^n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j  ){\\n        if(i==0 && j==0) return gr[i][j];\\n        if(i<0 || j<0) return 1e8;\\n        return gr[i][j] + min(fun(gr,i-1,j),fun(gr,i,j-1));\\n    }\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1);\\n    }\\n};\\n```\\n# Recursion + memoization (n,n) to (0,0) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ,vector<vector<int>> &dp ){\\n        if(i==0 && j==0) return gr[i][j];\\n\\n        if(i<0 || j<0)  return 1e8;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        return dp[i][j] = gr[i][j] + min(fun(gr,i-1,j,dp),fun(gr,i,j-1,dp));\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1,dp);\\n    }\\n};\\n```\\n# Recursion + memoization (0,0) to (n,n) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j, vector<vector<int>> &dp){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = fun(gr,i+1,j,dp);\\n        int b = fun(gr,i,j+1,dp);\\n        return dp[i][j] = gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0,dp);\\n    }\\n};\\n\\n```\\n# Tabulation (0,0) to (n,n) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i=0;i<gr.size();i++){\\n            for(int j=0; j<gr[0].size();j++){\\n                if(i==0 && j==0) dp[i][j] = gr[i][j];\\n                else{\\n                    int a=1e7,b=1e7;\\n                    if(i>0)\\n                        a= dp[i-1][j];\\n                    if(j>0)\\n                        b = dp[i][j-1];\\n                    dp[i][j] = gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[gr.size()-1][gr[0].size()-1];\\n    }\\n};\\n\\n```\\n# Tabulation (n,n) to (0,0) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i = gr.size()-1; i>=0;i--){\\n            for(int j= gr[0].size()-1;j>=0;j--){\\n                if(i==gr.size()-1 && j==gr[0].size()-1) dp[i][j] = gr[i][j];\\n                else{\\n                    int a= 1e8, b= 1e8;\\n                    if(i < gr.size()-1)\\n                        a = dp[i+1][j];\\n                    if(j < gr[0].size()-1)\\n                        b= dp[i][j+1];\\n                    dp[i][j]=gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n<!-- Assume we need to reach ar[i][j]  -->\\n<!-- always check minimum possiblle rach value near by it -->\\nar[i][j] = ar[i][j] + min(ar[i-1][j],ar[i][j-1])\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        int a = fun(gr,i+1,j);\\n        int b = fun(gr,i,j+1);\\n        return gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j  ){\\n        if(i==0 && j==0) return gr[i][j];\\n        if(i<0 || j<0) return 1e8;\\n        return gr[i][j] + min(fun(gr,i-1,j),fun(gr,i,j-1));\\n    }\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ,vector<vector<int>> &dp ){\\n        if(i==0 && j==0) return gr[i][j];\\n\\n        if(i<0 || j<0)  return 1e8;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        return dp[i][j] = gr[i][j] + min(fun(gr,i-1,j,dp),fun(gr,i,j-1,dp));\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j, vector<vector<int>> &dp){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = fun(gr,i+1,j,dp);\\n        int b = fun(gr,i,j+1,dp);\\n        return dp[i][j] = gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0,dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i=0;i<gr.size();i++){\\n            for(int j=0; j<gr[0].size();j++){\\n                if(i==0 && j==0) dp[i][j] = gr[i][j];\\n                else{\\n                    int a=1e7,b=1e7;\\n                    if(i>0)\\n                        a= dp[i-1][j];\\n                    if(j>0)\\n                        b = dp[i][j-1];\\n                    dp[i][j] = gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[gr.size()-1][gr[0].size()-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i = gr.size()-1; i>=0;i--){\\n            for(int j= gr[0].size()-1;j>=0;j--){\\n                if(i==gr.size()-1 && j==gr[0].size()-1) dp[i][j] = gr[i][j];\\n                else{\\n                    int a= 1e8, b= 1e8;\\n                    if(i < gr.size()-1)\\n                        a = dp[i+1][j];\\n                    if(j < gr[0].size()-1)\\n                        b= dp[i][j+1];\\n                    dp[i][j]=gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23493,
                "title": "my-java-solution-using-dp-with-memorization-beats-about-98-submissions",
                "content": "    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        return minPathSumHelper(grid, 0, 0, memo);\\n    }\\n    \\n    public int minPathSumHelper(int[][] grid, int row, int col, int[][] memo) {\\n        if(row == grid.length-1 && col == grid[0].length-1) return grid[row][col];\\n        if(memo[row][col] != 0) return memo[row][col];\\n\\n        int rowInc = Integer.MAX_VALUE, colInc = Integer.MAX_VALUE;\\n        if(row < grid.length-1) rowInc = minPathSumHelper(grid, row+1, col, memo);\\n        if(col < grid[0].length-1) colInc = minPathSumHelper(grid, row, col+1, memo);\\n        memo[row][col] = Math.min(rowInc, colInc) + grid[row][col];\\n        return memo[row][col];\\n    }\\n\\nUse a 2D array named memo to remember value which is calculated before to speed up.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        return minPathSumHelper(grid, 0, 0, memo);\\n    }\\n    \\n    public int minPathSumHelper(int[][] grid, int row, int col, int[][] memo) {\\n        if(row == grid.length-1 && col == grid[0].length-1) return grid[row][col];\\n        if(memo[row][col] != 0) return memo[row][col];\\n\\n        int rowInc = Integer.MAX_VALUE, colInc = Integer.MAX_VALUE;\\n        if(row < grid.length-1) rowInc = minPathSumHelper(grid, row+1, col, memo);\\n        if(col < grid[0].length-1) colInc = minPathSumHelper(grid, row, col+1, memo);\\n        memo[row][col] = Math.min(rowInc, colInc) + grid[row][col];\\n        return memo[row][col];\\n    }\\n\\nUse a 2D array named memo to remember value which is calculated before to speed up.",
                "codeTag": "Unknown"
            },
            {
                "id": 1513899,
                "title": "java-tc-o-r-c-sc-o-min-r-c-space-optimized-dynamic-programming-solution",
                "content": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j].\\n * If j == 0, then dp[i][0] = dp[i-1][0] + grid[i][0].\\n * If i == 0, then dp[0][j] = dp[0][j-1] + grid[0][j].\\n *\\n * We can just use 1D array of size rows or columns.\\n *\\n * Time Complexity: O(R * C)\\n *\\n * Space Complexity : O(min(R, C))\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0];\\n        }\\n\\n        if (cols <= rows) {\\n            return minPathSumHelper(grid, rows, cols, true);\\n        } else {\\n            return minPathSumHelper(grid, cols, rows, false);\\n        }\\n    }\\n\\n    private int minPathSumHelper(int[][] grid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        // Process 1st small column/row\\n        dp[0] = grid[0][0];\\n        for (int j = 1; j < small; j++) {\\n            dp[j] = dp[j - 1] + (isColsSmall ? grid[0][j] : grid[j][0]);\\n        }\\n        // Process remaining columns/rows\\n        for (int i = 1; i < big; i++) {\\n            dp[0] += isColsSmall ? grid[i][0] : grid[0][i];\\n            for (int j = 1; j < small; j++) {\\n                dp[j] = Math.min(dp[j], dp[j - 1]) + (isColsSmall ? grid[i][j] : grid[j][i]);\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Unique Path question on LeetCode:\\n- [62. Unique Paths](https://leetcode.com/problems/unique-paths/discuss/1513886/Java-or-TC:-O(M*N)-or-SC:-O(min(MN))-or-Space-optimized-Dynamic-Programming-solution)\\n- [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/discuss/1513891/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/discuss/1513906/Java-or-TC:-O(3(R*C))-or-SC:-O(R*C)-or-DFS-solution-with-Backtracking)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j].\\n * If j == 0, then dp[i][0] = dp[i-1][0] + grid[i][0].\\n * If i == 0, then dp[0][j] = dp[0][j-1] + grid[0][j].\\n *\\n * We can just use 1D array of size rows or columns.\\n *\\n * Time Complexity: O(R * C)\\n *\\n * Space Complexity : O(min(R, C))\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0];\\n        }\\n\\n        if (cols <= rows) {\\n            return minPathSumHelper(grid, rows, cols, true);\\n        } else {\\n            return minPathSumHelper(grid, cols, rows, false);\\n        }\\n    }\\n\\n    private int minPathSumHelper(int[][] grid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        // Process 1st small column/row\\n        dp[0] = grid[0][0];\\n        for (int j = 1; j < small; j++) {\\n            dp[j] = dp[j - 1] + (isColsSmall ? grid[0][j] : grid[j][0]);\\n        }\\n        // Process remaining columns/rows\\n        for (int i = 1; i < big; i++) {\\n            dp[0] += isColsSmall ? grid[i][0] : grid[0][i];\\n            for (int j = 1; j < small; j++) {\\n                dp[j] = Math.min(dp[j], dp[j - 1]) + (isColsSmall ? grid[i][j] : grid[j][i]);\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360106,
                "title": "python-5-approaches-dijkstra-a-dp-dfs-explained-and-visulaized",
                "content": "- Updated solutions 07/11/2021\\n------------------------------------------\\n\\n# [1] Dijkstra | 152 ms | faster than 12.02% \\n\\n------------------------------------------\\n- Cost to get to a cell is the value of the cell (the values of the cells will serve as weighted edges), while the nodes will only store the coordiantes of the cell.\\n\\t- nodes -> cells cooridinates\\n\\t- weighted edges -> costs -> values in cells\\n\\t- startNode = 0,0\\n\\t- endNode = len(grid)-1, len(grid[0])-1\\n\\n- Time: `O(Elogv)`\\n\\n![image](https://assets.leetcode.com/users/images/1c97142b-5137-4138-8c9c-151c9ab81cb8_1626646631.2057364.jpeg)\\n\\n\\n- the ultimate and only goal of Dijkstra is to populate the cost_so_far dict (or minWeights dict)\\nfor all nodes (aka min cost to get to each node)\\n- Dijkstra does not necessarlily have to wait until the entire weights dict is populated\\n- We can introduce an early exit if we are interesetd in a particular destination\\nthat we we might encounter in our search\\n\\n- we can also add a cameFrom dict to record parent:child relationships and\\nuse it to generate min path to any node we desire\\n\\n- heap frontier instead of queue\\n- find nei and add current cost to nei cost (cost to get to nei)\\n- For the nei we need to check:\\n\\t- [1] Is this the first time we are seeing this nei?\\n\\t- [2] Or, Did we see this nei before however this time we rached it via less expensive route?\\n\\n\\t- if the answer is yes to either [1] or [2]\\n\\t\\t- we update cost_so_far\\n\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n\\tfrom heapq import heappush, heappop\\n\\th = []\\n\\tstartNode = (grid[0][0], (0,0)) # cost, coor\\n\\theappush(h, startNode)\\n\\tdirs = [(1,0), (0,1)] # only right and down are allowed\\n\\tcost_so_far = {(0,0): grid[0][0]} # stores min cost to get to all nodes\\n\\t# cameFrom = {(0,0): None} # -- NOTE [1]\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\t\\tif x == len(grid)-1 and y == len(grid[0])-1: # destination found\\n\\t\\t\\tbreak\\n\\n\\t\\t# explore nei\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t# check bounds\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost, nei = grid[newX][newY], (newX, newY)\\n\\t\\t\\t\\tnewCost = cost + edgeCost \\n\\t\\t\\t\\t# check if weights needs to be updated\\n\\t\\t\\t\\tif ( nei not in cost_so_far or (nei in cost_so_far and cost_so_far[nei] > newCost) ):\\n\\t\\t\\t\\t\\tcost_so_far[nei] = newCost\\n\\t\\t\\t\\t\\theappush(h, (newCost, nei))\\n\\t\\t\\t\\t\\t# cameFrom[nei] = node # -- NOTE [1]\\n\\n\\t# return cost to reach destination\\n\\treturn cost_so_far[(x,y)]\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# Min path debugging:\\n\\t# path = []\\n\\t# trgt = (len(grid)-1, len(grid[0])-1)\\n\\t# while trgt in cameFrom:\\n\\t#\\tpath.insert(0, trgt)\\n\\t#\\ttrgt = cameFrom[trgt]\\n\\t# print(\"path = \", path)\\n        \\n ```\\n \\n ------------------------------------------\\n# [2] A* Algorithm | 176 ms | faster than 7.45% of Python3\\n ------------------------------------------\\n \\n- Dijkstra wastes some time exploring paths that seem promising initailly due to its high sensetivity to local miminma\\n\\t- for ex: grid = [[1,3,1],[1,5,1],[4,2,1]]\\n\\t- correct answer (global mimima is achived by) : 1 \\u2192 3 \\u2192 1 \\u2192 1 \\u2192 1\\n\\t- however dijkstra will waste some time in the begining exploring the path\\n\\t\\t1 -> 1 -> 4 -> 2\\n\\t\\tbecause initally it looked more promising from the heap\\'s point of view\\n\\n- Let\\'s see if we can speed it up by adding a heurstic function (estimation) using manhattan distance\\n\\t- A* f(n) = g(n) + h(n)\\n\\t- h(n) = straight line distance (or Manhattan distance)\\n\\n\\tknowledge + estimation\\n\\tg(n) = knowledge\\n\\th(n) = estimation -> Eucledian or Manhattan distance\\n\\t\\n\\t![image](https://assets.leetcode.com/users/images/2bd70406-7c7e-4c78-b1f7-0b3ad23e0fe9_1626646839.7684267.jpeg)\\n\\n\\n\\t\\n\\t- Notice how our heuristic function of choice is admissible (aka. optimistic) meaning it\\'s optimistic in estimating the distance to the destination. Satisfying this condition is a prerequsite for the A* algorithm to be stable (it guarantess A* will find the optimal answer)\\n\\t- h(n) is optimistic when h(n) is less than the actual cost endured from cell n to target. \\n\\t- h(n) is optimisitic (aka admissible) because it simply adds up the remaining nodes that we need to traverse to reach target (and it DOES NOT assign any weights to the indivdual steps) whereas we know the range for the actual cost of each step is from `(1 ~ 100)`\\nfrom the input `0 <= grid[i][j] <= 100 `\\n\\n- h(n) should speed the search by serving as a tie breaker in situations where g(n) (aka. cost) is the same for two different directions/steps\\nThis is specially true because our grid is rectangular ` m*n`. Thus distance h(n) will favor either (a step to the right, or a step downwards) based on the distance.\\n- Using h(n) would still make sense even if we had a square grid `n*n` because narrows down the explored space before the target is found. See comparsion below:\\n\\n**[ credit** : https://www.redblobgames.com/pathfinding/a-star/introduction.html **]**\\n![image](https://assets.leetcode.com/users/images/89c24a54-cecb-46b8-b5aa-6513e5b8f5fa_1626645746.9307761.png)\\n\\n\\n- One last detail to pay attention to is the fact that -unlike Dijkstra- A* is not a `shortest-path-algorithm`, but rather a `search-algorithm`\\n\\t- In other words:\\n\\t\\t- A* : Essentially, helps us find a target in a grid:\\n\\t\\t\\t-  Faster than BFS\\n\\t\\t\\t-  Guarantees correctness -unlike purely greedy algorthims- which do not gauarntee correctness (aka. does not always return the global min/max) )\\n\\t\\t-  Dijkstra : By nature, allows us to find the shortest path to all nodes (including of-course our target node)\\n\\t\\t-  That being said, we need to do some post-processing after A* finishes\\n\\t\\t\\t-  Remember when we added h(n) to speed up the search and make it waste less time exploring\\n\\t\\t\\t-  The output of A* is a weights dict `ex: {node A : minCostToReach node A}` (simialr to Dijkstra)\\n\\t\\t\\t\\t-  However, the values of that dict will be the sum of `h(n) + g(n)` hence we have to subtract h(n) in order to return the correct answer. See note [1]. This extra step most probably cancels out any speed we might have gained by adding h(n) and converting our algorithm from Dijkstra to A*, however it\\'s worth the learning process. \\n\\n ```                        \\ndef minPathSum(self, grid: List[List[int]]) -> int:        \\n        \\n\\t# helper to generate heuristic function h(n) based on Manhattan distance\\n        def generateHeuristics():\\n            trgtX, trgtY = len(grid[0])-1, len(grid)-1\\n            heuristics = {}\\n            for r in range(len(grid)):\\n                for c in range(len(grid[0])):\\n                    dist = abs(trgtY - r) + abs(trgtX - c) \\n                    heuristics[(r,c)] = dist\\n            return heuristics\\n        \\n        \\n        # main\\n        heuristics = generateHeuristics()\\n        h = []\\n        from heapq import heappush, heappop\\n        # cost = cost + estimation\\n        cost = grid[0][0] + heuristics[(0,0)]\\n        start = (cost, (0,0))\\n        cost_so_far = {(0,0): cost}\\n        cameFrom = {(0,0): None}\\n        heappush(h, start)\\n        trgtX, trgtY = len(grid)-1, len(grid[0])-1\\n        \\n        dirs = [(1,0), (0,1)]\\n        totalEstimationAdded = 0\\n        while h:\\n            cost, (x,y) = heappop(h)\\n            # print(cost, (x,y))\\n            if (x,y) == (trgtX, trgtY): # trgt found\\n                break\\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                \\n                if newX <= len(grid)-1 and newY <= len(grid[0])-1: # bounds\\n                    # print(\\'newX, newY = \\', newX, newY)\\n                    edgeCost = grid[newX][newY] \\n                    newCost = cost + edgeCost\\n\\n                    if (newX, newY) not in cost_so_far or ((newX, newY) in cost_so_far and newCost < cost_so_far[(newX, newY)] ):\\n                        cost_so_far[(newX, newY)] = newCost\\n                        heappush(h, (newCost + heuristics[(newX, newY)], (newX, newY)))\\n                        cameFrom[(newX, newY)] = (x, y)\\n\\n        \\n        costFunc = cost_so_far[(trgtX, trgtY)] # - NOTE [1]\\n\\n        \\n        # NOTE [1]\\n        # --------\\n        # Please notice that costFunc is a sum of (knowledge, estimation) along the shortest path\\n        # hence does not exactly match the desired ouput of this problem (problem is only asking for knoweldge based cost - free from heurtisitc or estimation)\\n        # Perhaps A* is not best suited for this probelm since the problem is not\\n        # asking to just find the target (a process that A* accelartes)\\n        # but rather, asks for the actual cost (knowledge free from estimation)\\n        \\n        # However, we can obtain the desired output bu doing some simple post-processing to the answer since the answer\\n        # (aka cost) is a sum of both knowledge and estimation\\n        # we have to subtract estimation to arrive at the wanted answer\\n        # totalEstimationAdded += (cost - grid[x][y]) # subtract knowledge from total \\n        # we can do that by building the shortest path and then subtract\\n        \\n        \\n        # Generate shortest path\\n        path = []\\n        trgt = (trgtX, trgtY)\\n        while trgt in cameFrom:\\n            path.insert(0, trgt)\\n            trgt = cameFrom[trgt]\\n        # print(\"path = \", path)\\n        \\n        actualCost = costFunc\\n        for (x,y) in path:\\n            actualCost -= heuristics[(x,y)]\\n        return actualCost\\n```\\n\\n\\n ------------------------------------------\\n# [3] Bottom up DP with in-place tabulation | 88 ms | faster than 97.41%\\n ------------------------------------------\\n- Similar to UniquePaths I/II : https://leetcode.com/problems/unique-paths-ii/discuss/1595001/Python3-4-approaches-(top-down-bottom-up-brute-force)\\n- bottom - up approach, solving the problem at a smaller scale first\\n- Instead of finding the min cost to get to the m,n cell right away, we first find the min cost to get to each cell, starting from the cells adjacent to the origin.\\n- cells at the top most row, can only be accessed from the left\\nwhich means the cost of visiting each one of them will be simply the sum of the\\ncurr cell and the cell the preceeded it\\n\\n- same concept applies for the cells in the left most col\\n\\n- for the rest of the grid, cost of visiting each cell:\\n\\n\\tg[i][j] = min(g[i-1][j], g[i][j-1])\\n\\n\\twhich is very similar to what we did in unique paths\\n\\n\\tg[i][j] = g[i-1][j] + g[i][j-1]\\n\\n- time: O(m-1)*(n-1) === O(m*n)\\n- space: O(1) in-place\\n\\n- starting from cell (1,1) -> min(left, top) aka the 2 direction we might have came from\\n- use the grid itself as a dp matrix\\n- this is a 2-dimensional dp problem since the steps could either be 1) horizontal 2) vertical\\n\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\t# top row\\n\\tfor i in range(1, len(grid[0])):\\n\\t\\tgrid[0][i] += grid[0][i-1]\\n\\n\\t# left most col\\n\\tfor i in range(1, len(grid)):\\n\\t\\tgrid[i][0] += grid[i-1][0]\\n\\n\\t# rest of the grid\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(1, len(grid[0])):\\n\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i][j-1]) \\n\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\treturn grid[trgtX][trgtY]\\n\\n```\\n\\n---------------------------------------------\\n# [4] Iterative brute-force DFS\\nTLE 20 / 61 test cases passed.\\n---------------------------------------------\\n---------------------------------------------\\n- a post discussing a simialr approach : https://leetcode.com/problems/all-paths-from-source-to-target/discuss/986429/Python-Iterative-DFS-with-detailed-time-complexity-and-visuals \\n- Examine each path individually till the end and return the one with min cost \\n- O(k-avg * N)\\nN = number of cells M*N\\nK-avg = the average of how many times a node is visited (due to not using a visited set)\\nk-min = 1\\nk-max = number of paths in the grid (number of times the (trgtX, trgtY) node is visited)\\nk-max = ( (m-1) + (n-1) ) / ( (m-1)! * (n-1)! )\\n\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\tminPathCost = float(\\'inf\\')\\n\\tstack = [( (0,0), grid[0][0] )]\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\tdirs = [(1,0), (0,1)]\\n\\twhile stack:\\n\\t\\t(x,y), pathCost = stack.pop()\\n\\n\\t\\tif (x,y) == (trgtX, trgtY): # only capture pathCost when path is fully traversed (aka rigt-bottm corner cell is reached)\\n\\t\\t\\tminPathCost = min(minPathCost, pathCost)\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= trgtX and newY <= trgtY:\\n\\t\\t\\t\\tstack.append( ( (newX, newY), pathCost+grid[newX][newY] ) )\\n\\n\\treturn minPathCost\\n\\n```\\n\\n---------------------------------------------\\n# [5] Recursive DFS with memoization\\n---------------------------------------------\\n\\n\\n```\\n def minPathSum(self, grid: List[List[int]]) -> int:         \\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif (i,j) == (len(grid)-1, len(grid[0])-1): # reachedt traget\\n\\t\\t\\treturn grid[i][j] # return the value of the cell to be added to the sum\\n\\n\\t\\tif i > len(grid)-1 or j > len(grid[0])-1: # out of bounds\\n\\t\\t\\treturn float(\\'inf\\') # return a huge number to cause the path to be disgarded\\n\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\n\\t\\t# if none of the above\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i, j+1))\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main:\\n\\tmemo = {}\\n\\treturn recurse(0,0) # starting Node\\n\\n\\t# NOTE\\n\\t# memo is going to start building from target \\n\\t# memo =  {}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7, (1, 2): 2, (1, 1): 7, (1, 0): 8}\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n\\tfrom heapq import heappush, heappop\\n\\th = []\\n\\tstartNode = (grid[0][0], (0,0)) # cost, coor\\n\\theappush(h, startNode)\\n\\tdirs = [(1,0), (0,1)] # only right and down are allowed\\n\\tcost_so_far = {(0,0): grid[0][0]} # stores min cost to get to all nodes\\n\\t# cameFrom = {(0,0): None} # -- NOTE [1]\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\t\\tif x == len(grid)-1 and y == len(grid[0])-1: # destination found\\n\\t\\t\\tbreak\\n\\n\\t\\t# explore nei\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t# check bounds\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost, nei = grid[newX][newY], (newX, newY)\\n\\t\\t\\t\\tnewCost = cost + edgeCost \\n\\t\\t\\t\\t# check if weights needs to be updated\\n\\t\\t\\t\\tif ( nei not in cost_so_far or (nei in cost_so_far and cost_so_far[nei] > newCost) ):\\n\\t\\t\\t\\t\\tcost_so_far[nei] = newCost\\n\\t\\t\\t\\t\\theappush(h, (newCost, nei))\\n\\t\\t\\t\\t\\t# cameFrom[nei] = node # -- NOTE [1]\\n\\n\\t# return cost to reach destination\\n\\treturn cost_so_far[(x,y)]\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# Min path debugging:\\n\\t# path = []\\n\\t# trgt = (len(grid)-1, len(grid[0])-1)\\n\\t# while trgt in cameFrom:\\n\\t#\\tpath.insert(0, trgt)\\n\\t#\\ttrgt = cameFrom[trgt]\\n\\t# print(\"path = \", path)\\n        \\n ```\n```                        \\ndef minPathSum(self, grid: List[List[int]]) -> int:        \\n        \\n\\t# helper to generate heuristic function h(n) based on Manhattan distance\\n        def generateHeuristics():\\n            trgtX, trgtY = len(grid[0])-1, len(grid)-1\\n            heuristics = {}\\n            for r in range(len(grid)):\\n                for c in range(len(grid[0])):\\n                    dist = abs(trgtY - r) + abs(trgtX - c) \\n                    heuristics[(r,c)] = dist\\n            return heuristics\\n        \\n        \\n        # main\\n        heuristics = generateHeuristics()\\n        h = []\\n        from heapq import heappush, heappop\\n        # cost = cost + estimation\\n        cost = grid[0][0] + heuristics[(0,0)]\\n        start = (cost, (0,0))\\n        cost_so_far = {(0,0): cost}\\n        cameFrom = {(0,0): None}\\n        heappush(h, start)\\n        trgtX, trgtY = len(grid)-1, len(grid[0])-1\\n        \\n        dirs = [(1,0), (0,1)]\\n        totalEstimationAdded = 0\\n        while h:\\n            cost, (x,y) = heappop(h)\\n            # print(cost, (x,y))\\n            if (x,y) == (trgtX, trgtY): # trgt found\\n                break\\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                \\n                if newX <= len(grid)-1 and newY <= len(grid[0])-1: # bounds\\n                    # print(\\'newX, newY = \\', newX, newY)\\n                    edgeCost = grid[newX][newY] \\n                    newCost = cost + edgeCost\\n\\n                    if (newX, newY) not in cost_so_far or ((newX, newY) in cost_so_far and newCost < cost_so_far[(newX, newY)] ):\\n                        cost_so_far[(newX, newY)] = newCost\\n                        heappush(h, (newCost + heuristics[(newX, newY)], (newX, newY)))\\n                        cameFrom[(newX, newY)] = (x, y)\\n\\n        \\n        costFunc = cost_so_far[(trgtX, trgtY)] # - NOTE [1]\\n\\n        \\n        # NOTE [1]\\n        # --------\\n        # Please notice that costFunc is a sum of (knowledge, estimation) along the shortest path\\n        # hence does not exactly match the desired ouput of this problem (problem is only asking for knoweldge based cost - free from heurtisitc or estimation)\\n        # Perhaps A* is not best suited for this probelm since the problem is not\\n        # asking to just find the target (a process that A* accelartes)\\n        # but rather, asks for the actual cost (knowledge free from estimation)\\n        \\n        # However, we can obtain the desired output bu doing some simple post-processing to the answer since the answer\\n        # (aka cost) is a sum of both knowledge and estimation\\n        # we have to subtract estimation to arrive at the wanted answer\\n        # totalEstimationAdded += (cost - grid[x][y]) # subtract knowledge from total \\n        # we can do that by building the shortest path and then subtract\\n        \\n        \\n        # Generate shortest path\\n        path = []\\n        trgt = (trgtX, trgtY)\\n        while trgt in cameFrom:\\n            path.insert(0, trgt)\\n            trgt = cameFrom[trgt]\\n        # print(\"path = \", path)\\n        \\n        actualCost = costFunc\\n        for (x,y) in path:\\n            actualCost -= heuristics[(x,y)]\\n        return actualCost\\n```\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\t# top row\\n\\tfor i in range(1, len(grid[0])):\\n\\t\\tgrid[0][i] += grid[0][i-1]\\n\\n\\t# left most col\\n\\tfor i in range(1, len(grid)):\\n\\t\\tgrid[i][0] += grid[i-1][0]\\n\\n\\t# rest of the grid\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(1, len(grid[0])):\\n\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i][j-1]) \\n\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\treturn grid[trgtX][trgtY]\\n\\n```\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\tminPathCost = float(\\'inf\\')\\n\\tstack = [( (0,0), grid[0][0] )]\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\tdirs = [(1,0), (0,1)]\\n\\twhile stack:\\n\\t\\t(x,y), pathCost = stack.pop()\\n\\n\\t\\tif (x,y) == (trgtX, trgtY): # only capture pathCost when path is fully traversed (aka rigt-bottm corner cell is reached)\\n\\t\\t\\tminPathCost = min(minPathCost, pathCost)\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= trgtX and newY <= trgtY:\\n\\t\\t\\t\\tstack.append( ( (newX, newY), pathCost+grid[newX][newY] ) )\\n\\n\\treturn minPathCost\\n\\n```\n```\\n def minPathSum(self, grid: List[List[int]]) -> int:         \\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif (i,j) == (len(grid)-1, len(grid[0])-1): # reachedt traget\\n\\t\\t\\treturn grid[i][j] # return the value of the cell to be added to the sum\\n\\n\\t\\tif i > len(grid)-1 or j > len(grid[0])-1: # out of bounds\\n\\t\\t\\treturn float(\\'inf\\') # return a huge number to cause the path to be disgarded\\n\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\n\\t\\t# if none of the above\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i, j+1))\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main:\\n\\tmemo = {}\\n\\treturn recurse(0,0) # starting Node\\n\\n\\t# NOTE\\n\\t# memo is going to start building from target \\n\\t# memo =  {}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7, (1, 2): 2, (1, 1): 7, (1, 0): 8}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 23678,
                "title": "c-easy-solution-using-dp-space-compexity-o-1",
                "content": "    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& a) {\\n            int m=a.size();\\n            if(m==0) return 0;\\n            int n= a[0].size();\\n            \\n            for(int i = 0 ; i<m; i++  ){\\n                for(int j=0; j<n ; j++){\\n                    int left= (j==0) ? INT_MAX : a[i][j-1];\\n                    int up = (i==0) ? INT_MAX : a[i-1][j];\\n                    if(i==0 && j==0) continue;\\n                    a[i][j] += min(left, up );\\n                }\\n            }\\n            return a[m-1][n-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& a) {\\n            int m=a.size();\\n            if(m==0) return 0;\\n            int n= a[0].size();\\n            \\n            for(int i = 0 ; i<m; i++  ){\\n                for(int j=0; j<n ; j++){\\n                    int left= (j==0) ? INT_MAX : a[i][j-1];\\n                    int up = (i==0) ? INT_MAX : a[i-1][j];\\n                    if(i==0 && j==0) continue;\\n                    a[i][j] += min(left, up );\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 23615,
                "title": "my-solution-beats-100-java-solutions",
                "content": "    public class Solution {\\n        public int minPathSum(int[][] grid) {\\n            if(grid.length == 0)  return 0;\\n            \\n            int r = grid.length;\\n            int c = grid[0].length;\\n            \\n            for(int i=0;i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n                    int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n                    if(i==0 && j==0) continue;\\n                    \\n                    grid[i][j] += Math.min(leftSum, topSum);\\n                }\\n            }\\n            return grid[r-1][c-1];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minPathSum(int[][] grid) {\\n            if(grid.length == 0)  return 0;\\n            \\n            int r = grid.length;\\n            int c = grid[0].length;\\n            \\n            for(int i=0;i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n                    int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n                    if(i==0 && j==0) continue;\\n                    \\n                    grid[i][j] += Math.min(leftSum, topSum);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3345712,
                "title": "complete-intuition-explained-recursion-memoization-tabulation-dp",
                "content": "![image](https://assets.leetcode.com/users/images/c87574f8-29ca-47eb-af34-a41610f4dee4_1679888406.0141091.png)\\n![image](https://assets.leetcode.com/users/images/60006acc-70fe-4065-b14f-7585a2875ddc_1679888413.6319273.png)\\n![image](https://assets.leetcode.com/users/images/80f0011b-c7fc-4f0e-89c9-85fc16ec6840_1679888421.8878033.png)\\n\\n\\n\\n### RECURSION \\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        int rightMin = solve(grid, currRow, currCol + 1);\\n        int downMin = solve(grid, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return (grid[currRow][currCol] + bestChoice);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        return solve(grid, 0, 0);\\n    }\\n};\\n```\\n//===========================================================================================================================================\\n\\n### MEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, vector<vector<int>>&dp, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        if (dp[currRow][currCol] !=  -1) return dp[currRow][currCol]; //use the already computed result\\n        int rightMin = solve(grid, dp, currRow, currCol + 1);\\n        int downMin = solve(grid, dp, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return dp[currRow][currCol] = (grid[currRow][currCol] + bestChoice); //store the result \\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, -1)); \\n        //\\'-1\\' to denote that subproblem result for that cell is not computed and not stored\\n        return solve(grid, dp, 0, 0);\\n    }\\n};\\n```\\n\\n//=========================================================================================================================================\\n\\n### BOTTOM-UP DYNAMIC PROGRAMMING \\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        //traverse from \\'bottom->top\\' and \\'right->left\\'\\n        //as for any cell we need computed result from \\'down\\' and \\'right\\'\\n        for (int i = m - 1; i >= 0; i--)\\n        {\\n            for (int j = n - 1; j >= 0; j--)\\n            {\\n                if (i == m - 1 && j == n - 1) continue;\\n                \\n                //grid[i][j + 1] and grid[i + 1][j] will already have stored the result of subproblem\\n                int rightMin = (j + 1 >= n)? INT_MAX : grid[i][j + 1]; //\\n                int downMin = (i + 1 >= m)? INT_MAX : grid[i + 1][j];\\n                grid[i][j] = grid[i][j] + (min(rightMin, downMin)); \\n                //rather than making a new \\'DP\\' grid store results of subproblems in the same grid\\n            }\\n        }\\n        return grid[0][0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        int rightMin = solve(grid, currRow, currCol + 1);\\n        int downMin = solve(grid, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return (grid[currRow][currCol] + bestChoice);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        return solve(grid, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, vector<vector<int>>&dp, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        if (dp[currRow][currCol] !=  -1) return dp[currRow][currCol]; //use the already computed result\\n        int rightMin = solve(grid, dp, currRow, currCol + 1);\\n        int downMin = solve(grid, dp, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return dp[currRow][currCol] = (grid[currRow][currCol] + bestChoice); //store the result \\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, -1)); \\n        //\\'-1\\' to denote that subproblem result for that cell is not computed and not stored\\n        return solve(grid, dp, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        //traverse from \\'bottom->top\\' and \\'right->left\\'\\n        //as for any cell we need computed result from \\'down\\' and \\'right\\'\\n        for (int i = m - 1; i >= 0; i--)\\n        {\\n            for (int j = n - 1; j >= 0; j--)\\n            {\\n                if (i == m - 1 && j == n - 1) continue;\\n                \\n                //grid[i][j + 1] and grid[i + 1][j] will already have stored the result of subproblem\\n                int rightMin = (j + 1 >= n)? INT_MAX : grid[i][j + 1]; //\\n                int downMin = (i + 1 >= m)? INT_MAX : grid[i + 1][j];\\n                grid[i][j] = grid[i][j] + (min(rightMin, downMin)); \\n                //rather than making a new \\'DP\\' grid store results of subproblems in the same grid\\n            }\\n        }\\n        return grid[0][0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453856,
                "title": "beautiful-tasty-java-dp-solution-w-comments",
                "content": "```java\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        // get mxn sizes\\n        int m = grid.length; int n = grid[0].length;\\n        \\n        // dp array\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // handle first column\\n        for (int i = 1; i < m; i++) {\\n            // add one before it\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }\\n        \\n        // handle first row\\n        for (int i = 1; i < n; i++) {\\n            // add one before it\\n            dp[0][i] = grid[0][i] + dp[0][i-1];\\n        }\\n        \\n        // starting from (1,1) iterate thru array taking min path choices along the way\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                // dp value at this coordinate is lesser of the two possible paths\\n                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        \\n        // the result should be at the bottom right corner of DP array\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        // get mxn sizes\\n        int m = grid.length; int n = grid[0].length;\\n        \\n        // dp array\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // handle first column\\n        for (int i = 1; i < m; i++) {\\n            // add one before it\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }\\n        \\n        // handle first row\\n        for (int i = 1; i < n; i++) {\\n            // add one before it\\n            dp[0][i] = grid[0][i] + dp[0][i-1];\\n        }\\n        \\n        // starting from (1,1) iterate thru array taking min path choices along the way\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                // dp value at this coordinate is lesser of the two possible paths\\n                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        \\n        // the result should be at the bottom right corner of DP array\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848341,
                "title": "python-solution-greedy-recursive-memorization-bottom-up-approach",
                "content": "### Solution by Ranjal (Leetcode username: ranjal_omer)\\n\\t\\n\\timport sys\\n\\tclass Solution:\\n\\t\\tdef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n### ___ Greedy Approach___\\n        \"\"\"\\n        \\n        @ Lets Discuss why not to follow greedy technique in this problem:\\n        \\n        1- Because if we follow greedy we might endup choosing the wrong path which rather\\n        \\n        giving us the minimum value will give us some another higher value\\n        \\n        for example if we take a grid \\n            \\n            1 2 6 4\\n            5 8 5 85\\n            1 3 2 1\\n            \\n            if we follow the greedy method and starting from 0,0 we will choose minimum of (2,5)\\n            since 2 will be the minimum we will move in the direction of 2\\n            as we can only move downwards and right\\n            \\n            and so on we will get the path like 1-> 2 -> 6 -> 4 -> 85 ->1 === 99\\n            \\n            but because of the greeedy nature we have missed the optimum path which gives us the minimum\\n            sum that is\\n            \\n            1-> 5 -> 1 -> 3 -> 2 -> 1 ==== 13 \\n            \\n            Therefore the greedy Technique fails here\\n        \\n        \"\"\"\\n        #-----------------------------------------------------------------------------------------#\\n        \"\"\"\\n        \\n        Time Complexity : O(m*n)\\n        Stack Space : O(m*n)+ O(path length)\\n        \\n        \\n### ___ Recursive Approach___\\n        # Now moving towards the recursive solution\\n        \\n        # which will gives us all the possible path from which we can find the min path (Exploring all paths)\\n        \"\"\"\\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            return min(up,left)\\n        \\n        # return f(len(grid)-1,len(grid[0])-1)\\n        \\n        #-----------------------------------------------------------------------------------------#\\n### ___ Memoizing the Recursive Approach___   \\n        \"\"\"\\n        \\n        Now memoizing the recursive code:---->\\n        \\n        \\n        \"\"\"\\n        n=len(grid)\\n        m= len(grid[0])\\n        \\n        dp=[[-1]*m for i in range(n)]\\n        \\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            dp[i][j]=min(up,left)\\n            return dp[i][j]\\n        # return f(n-1,m-1)\\n        \\n        \\n        \\n        \\n        #-----------------------------------------------------------------------------------------#\\n        \\n### ___ Bottom-Up Approach___\\n        \"\"\"\\n        \\n        Now Converting  the memoized code into bottom up:---->\\n        \\n        \\n        \"\"\"\\n        \\n        dp=[[0]*m for i in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i==0 and j==0:\\n                    dp[i][j]= grid[i][j]\\n                    \\n                else:\\n                    up=grid[i][j]\\n                    left=grid[i][j]\\n                    \\n                    if i>0:\\n                        up+= dp[i-1][j]\\n                    else:\\n                        up+=sys.maxsize\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=sys.maxsize\\n                    \\n                    dp[i][j]= min(up,left)\\n                    \\n        return dp[n-1][m-1]\\n\\t\\n## Thankyou for visiting!! \\n### Please upvote the solution and share it with your friends :) <3",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "### Solution by Ranjal (Leetcode username: ranjal_omer)\\n\\t\\n\\timport sys\\n\\tclass Solution:\\n\\t\\tdef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n### ___ Greedy Approach___\\n        \"\"\"\\n        \\n        @ Lets Discuss why not to follow greedy technique in this problem:\\n        \\n        1- Because if we follow greedy we might endup choosing the wrong path which rather\\n        \\n        giving us the minimum value will give us some another higher value\\n        \\n        for example if we take a grid \\n            \\n            1 2 6 4\\n            5 8 5 85\\n            1 3 2 1\\n            \\n            if we follow the greedy method and starting from 0,0 we will choose minimum of (2,5)\\n            since 2 will be the minimum we will move in the direction of 2\\n            as we can only move downwards and right\\n            \\n            and so on we will get the path like 1-> 2 -> 6 -> 4 -> 85 ->1 === 99\\n            \\n            but because of the greeedy nature we have missed the optimum path which gives us the minimum\\n            sum that is\\n            \\n            1-> 5 -> 1 -> 3 -> 2 -> 1 ==== 13 \\n            \\n            Therefore the greedy Technique fails here\\n        \\n        \"\"\"\\n        #-----------------------------------------------------------------------------------------#\\n        \"\"\"\\n        \\n        Time Complexity : O(m*n)\\n        Stack Space : O(m*n)+ O(path length)\\n        \\n        \\n### ___ Recursive Approach___\\n        # Now moving towards the recursive solution\\n        \\n        # which will gives us all the possible path from which we can find the min path (Exploring all paths)\\n        \"\"\"\\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            return min(up,left)\\n        \\n        # return f(len(grid)-1,len(grid[0])-1)\\n        \\n        #-----------------------------------------------------------------------------------------#\\n### ___ Memoizing the Recursive Approach___   \\n        \"\"\"\\n        \\n        Now memoizing the recursive code:---->\\n        \\n        \\n        \"\"\"\\n        n=len(grid)\\n        m= len(grid[0])\\n        \\n        dp=[[-1]*m for i in range(n)]\\n        \\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            dp[i][j]=min(up,left)\\n            return dp[i][j]\\n        # return f(n-1,m-1)\\n        \\n        \\n        \\n        \\n        #-----------------------------------------------------------------------------------------#\\n        \\n### ___ Bottom-Up Approach___\\n        \"\"\"\\n        \\n        Now Converting  the memoized code into bottom up:---->\\n        \\n        \\n        \"\"\"\\n        \\n        dp=[[0]*m for i in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i==0 and j==0:\\n                    dp[i][j]= grid[i][j]\\n                    \\n                else:\\n                    up=grid[i][j]\\n                    left=grid[i][j]\\n                    \\n                    if i>0:\\n                        up+= dp[i-1][j]\\n                    else:\\n                        up+=sys.maxsize\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=sys.maxsize\\n                    \\n                    dp[i][j]= min(up,left)\\n                    \\n        return dp[n-1][m-1]\\n\\t\\n## Thankyou for visiting!! \\n### Please upvote the solution and share it with your friends :) <3",
                "codeTag": "Java"
            },
            {
                "id": 1145356,
                "title": "memoization",
                "content": "```\\nclass Solution \\n{\\n  public:\\n    int minPathSumHelper(vector<vector<int>> &grid,vector<vector<int>> &dp,int m, int n, int i, int j){\\n        //base case \\n        \\n        if(i==m-1 && j==n-1){\\n            return grid[i][j];\\n        }\\n        if(i>=m || j>=n){\\n            return INT_MAX; \\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        //recusrive call\\n        int x = minPathSumHelper(grid,dp,m,n,i+1,j);\\n        int y = minPathSumHelper(grid,dp,m,n,i,j+1);\\n        \\n        //small calculation for recursion\\n        int ans = min(x,y) + grid[i][j];\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    int minPathSum(vector<vector<int>> &grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n\\n       return minPathSumHelper(grid,dp,m,n,0,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution \\n{\\n  public:\\n    int minPathSumHelper(vector<vector<int>> &grid,vector<vector<int>> &dp,int m, int n, int i, int j){\\n        //base case \\n        \\n        if(i==m-1 && j==n-1){\\n            return grid[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 644784,
                "title": "c-easy-to-understand-using-dp-with-explanation-must-see-for-beginners",
                "content": "Pls upvote if you find this helpful :))\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n```\\n        int row=grid.size();\\n        int column=grid[0].size();\\n        int sum=0;\\n        for(int i=0;i<column;i++) {\\t\\n\\t\\t\\tsum+=grid[0][i];                                      //Filling the first row ,only movement in right is possible here\\n            grid[0][i]=sum;\\n            }\\n        sum=0;\\n        for(int i=0;i<row;i++) {                                            \\n            sum+=grid[i][0];                                    //Filling the first column ,only movement in downward direction  \\n            grid[i][0]=sum;\\n            }\\n        for(int i=1;i<row;i++)\\n\\t\\t\\t{\\n            for(int j=1;j<column;j++)\\n\\t\\t\\t{                                                                            \\n            grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j];//Filling the remaining cells using the minimum value and adding to the current cell value   \\n            }\\n        }\\n        return grid[row-1][column-1];                  //Return the last grid\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584871,
                "title": "very-easy-c-solution-without-using-space-explained",
                "content": "We can think of solving this problem recursively. We are standing at a current cell then the cost of reaching that cell is minimum of ( cost of reaching upper cell, cost of reaching the left cell ) + cost of current cell.\\n\\nSuppose we have a fiunction called getMinSum which return minimum cost to reach. Suppose We are at 2,2 then,\\ngetMinCost(2,2) = grid[2,2] + min(getMinCost(2,1), getMinCost(1,2));\\nRecursive Call, getMinCost(2,1) = grid[2,1] + min(getMinCost(2,0), getMinCost(1,1));\\nRecursive Call, getMinCost(2,0) = grid[2,0] + getMinCost(1,0);\\nRecursive Call, getMinCost(1,0) = grid[1,0] + getMinCost(0,0);\\nRecursive Call, getMinCost(1,0) = grid[0,0];\\nRecursive Call, getMinCost(1,1) = grid[1,1] + min(**getMinCost(1,0)**, getMinCost(0,1));\\nRecursive Call, getMinCost(0,1) = grid[0,1] + **getMinCost(0,0)** ;\\nRecursive Call, getMinCost(1,2) = grid[1,2] + min(**getMinCost(1,1)**, **getMinCost(0,2)**);\\n\\nNow as we can see direct recursive solution is making us to calculate the same cost of reaching a cell again and again(shown in bold above). For large matrix this can make the complexity of finding a solution to be exponential.\\n\\nWe need to store these results of subsolutions.\\n\\nFor the first row and column the path sum will only be the sum of the cells till that point as there is no other way to reach the other cells.\\n```\\ngrid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        if(m==0)    return 0;\\n        int n = grid[0].size();\\n        if(n==0)    return 0;\\n        for(int i=1; i<m; i++)\\n            grid[i][0] += grid[i-1][0];\\n        \\n        for(int i=1; i<n; i++)\\n            grid[0][i] += grid[0][i-1];\\n        for(int i=1; i<m; i++)\\n            for(int j=1; j<n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            \\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ngrid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        if(m==0)    return 0;\\n        int n = grid[0].size();\\n        if(n==0)    return 0;\\n        for(int i=1; i<m; i++)\\n            grid[i][0] += grid[i-1][0];\\n        \\n        for(int i=1; i<n; i++)\\n            grid[0][i] += grid[0][i-1];\\n        for(int i=1; i<m; i++)\\n            for(int j=1; j<n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            \\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23589,
                "title": "minimum-path-sum-how-can-i-reduce-the-memory",
                "content": "Here is the idea:\\n\\n 1. f[m][n] is a matrix store the min value of every location we can\\n    get.\\n 2. f[0][0] =grid[0][0], f[i][0]=f[i-1][0]+grid[i][0],\\n    f[0][j]=f[0][j-1]+grid[0][j]\\n 3. f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j].\\n 4. at last return the f[m-1][n-1]\\n\\n----------\\n\\n\\n    class Solution {\\n            public:\\n                int minPathSum(vector<vector<int> > &grid) {\\n                    // IMPORTANT: Please reset any member data you declared, as\\n                    // the same Solution instance will be reused for each test case.\\n                    int m=grid.size();\\n                    int n=grid[0].size();\\n                    int** f;\\n                    f=new int*[m];\\n                    for(int i=0;i<m;i){\\n                        f[i]=new int[n];\\n                    }\\n                    f[0][0]=grid[0][0];\\n                    for(int i=1;i<m;i++){\\n                        f[i][0]=f[i-1][0]+grid[i][0];\\n                    }\\n                    for(int i=1;i<n;i++){\\n                        f[0][i]=f[0][i-1]+grid[0][i];\\n                    }\\n                    for(int i=1;i<m;i++){\\n                        for(int j=1;j<n;j++)\\n                            f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j];\\n                    }\\n                    return f[m-1][n-1];\\n                }\\n                int min(int a,int b){\\n                    if(a>b)\\n                        return b;\\n                    else\\n                        return a;\\n                }\\n            };",
                "solutionTags": [],
                "code": "class Solution {\\n            public:\\n                int minPathSum(vector<vector<int> > &grid) {\\n                    // IMPORTANT: Please reset any member data you declared, as\\n                    // the same Solution instance will be reused for each test case.\\n                    int m=grid.size();\\n                    int n=grid[0].size();\\n                    int** f;\\n                    f=new int*[m];\\n                    for(int i=0;i<m;i){\\n                        f[i]=new int[n];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3347989,
                "title": "c-easy-dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++){\\n         dp[i][1] =g[i-1][0] + dp[i-1][1];\\n        }\\n        for(int j=1;j<=m;j++){\\n         dp[1][j] = g[0][j-1] + dp[1][j-1];   \\n        }\\n        for(int i=2;i<=n;i++){\\n            for(int j=2;j<=m;j++){\\n                dp[i][j] = g[i-1][j-1] + min(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/38a2afd8-6fc2-4079-bb12-4e653512ffed_1679927263.2603066.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++){\\n         dp[i][1] =g[i-1][0] + dp[i-1][1];\\n        }\\n        for(int j=1;j<=m;j++){\\n         dp[1][j] = g[0][j-1] + dp[1][j-1];   \\n        }\\n        for(int i=2;i<=n;i++){\\n            for(int j=2;j<=m;j++){\\n                dp[i][j] = g[i-1][j-1] + min(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346108,
                "title": "day-86-dp-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe intuition behind the approach is that, in order to find the minimum path sum from the top left corner to the bottom right corner of the grid, we can consider the subproblems of finding the minimum path sum to reach each cell of the grid. We can then use the solutions to these subproblems to solve the original problem.\\n\\nTo calculate the minimum path sum to reach a cell (i, j), we can take the minimum of the minimum path sum to reach the cell above (i-1, j) and the cell to the left (i, j-1), and add it to the value of the current cell. This is because we can only move either down or right, so the minimum path sum to reach the current cell is the minimum of the minimum path sum to reach the cell above and the cell to the left, plus the value of the current cell.\\n\\nWe can use this approach to calculate the minimum path sum to reach each cell of the grid, starting from the top left corner and working our way down and to the right. By the time we reach the bottom right corner, the minimum path sum to reach that cell will be the solution to the original problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize variables row and col to the number of rows and columns of the grid, respectively.\\n2. Traverse the first row of the grid and set each element to be the cumulative sum of the previous elements in the row.\\n3. Traverse the first column of the grid and set each element to be the cumulative sum of the previous elements in the column.\\n4. Traverse the remaining cells of the grid using two nested loops, starting from the second row and second column.\\n5. For each cell (i, j), set the value of the cell to be the sum of the current cell\\'s value and the minimum of the values of the cells above (i-1, j) and to the left (i, j-1).\\n6. After traversing all cells, the minimum sum of all numbers along the path from top left to bottom right of the grid is stored in the bottom right cell (i.e., grid[row-1][col-1]).\\n7. Return the value of the bottom right cell as the output.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //we will modify the same array and return the last index grid[row-1][col-1]\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row = len(grid)\\n        col = len(grid[0])\\n        for i in range(1, row):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, col):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, row):\\n            for j in range(1, col):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[row-1][col-1]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(mn)**, where m is number of rows and n is number of column\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //we will modify the same array and return the last index grid[row-1][col-1]\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row = len(grid)\\n        col = len(grid[0])\\n        for i in range(1, row):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, col):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, row):\\n            for j in range(1, col):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[row-1][col-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677369,
                "title": "recursion-to-space-optimized-in-java",
                "content": "**upvote if it helped, feeel free to ask queries**\\n`IDEA : ALWAYS REMEMBER WHENEVER YOU FEEL LIKE THERE IS A NEED TO FIND ALL POSSIBLE WAYS, THERE\\'S A RECURSION(which can further be improved).`\\n**the state equation is S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]**\\n\\nhere, to get a path, we need to travel from grid[0][0] to grid[row - 1][col - 1]. So let\\'s set grid[0][0] as the basic case. This is when we jump out of recursion. On the other hand, grid[row - 1][col - 1] would be the starting point.  we need to consider that things could happen that we reached the first row or column and we gotta make sure that we stay within the array index limit.\\nWe will move in grid for every row and column, looking for minimum path sum\\n\\n**Recursion**\\n------------------------------------------time complexity in exponential----------\\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int m = grid.length;\\n            int n = grid[0].length;\\n            return min(grid, m - 1, n - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int m, int n){\\n\\n// this is the exit of the recursion\\n            if(m == 0 && n == 0) return grid[m][n]; \\n/** when we reach the first row, we could only move horizontally.*/\\n            if(m == 0) return grid[m][n] + min(grid, m, n - 1); \\n/** when we reach the first column, we could only move vertically.*/\\n            if(n == 0) return grid[m][n] + min(grid, m - 1, n); \\n/** we want the min sum path so we pick the cell with the less value */\\n            return grid[m][n] + Math.min(min(grid, m - 1, n), min(grid, m, n - 1)); \\n\\t\\t\\t\\n}\\n```\\n\\n**Memoization:**\\n*simply memoization to handle the recursion*\\n----------------------100% faster-----------------------1ms---------------------------\\n```\\nclass Solution {\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        memo = new int[m][n];\\n        return find(grid, m-1, n-1, memo);\\n    }\\n    \\n    private int find(int[][] grid, int m, int n, int[][] memo){\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        else if(memo[m][n]!=0)\\n           return memo[m][n];\\n        return memo[m][n] = grid[m][n] + Math.min(find(grid, m-1, n, memo), find(grid, m, n-1, memo));\\n    }\\n}\\n```\\n**Tabulation:**\\n*now properly using pre-calculated values to enhance the performance*\\n-------------------------------------------------with 2-d array-----------\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<m;i++)\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int j=1;j<n;j++)\\n            dp[0][j] = dp[0][j-1] + grid[0][j];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n**always remember** \\n*if tabulation approach contains something like (i+1) or(i-1), that means u can always space optimized it\\ni+1 or i-1 means we are using last calculated results, which we can store in the input array itself too, and very easily*\\n\\n------------------------------------------------------space optimized----------------\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=1;i<m;i++)\\n            grid[i][0] += grid[i-1][0];\\n        for(int j=1;j<n;j++)\\n            grid[0][j] += grid[0][j-1];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n**upvote if u learned something**\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/18dc01d9-d41f-40db-9b5a-1988158c2a07_1679893506.8129675.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int m = grid.length;\\n            int n = grid[0].length;\\n            return min(grid, m - 1, n - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int m, int n){\\n\\n// this is the exit of the recursion\\n            if(m == 0 && n == 0) return grid[m][n]; \\n/** when we reach the first row, we could only move horizontally.*/\\n            if(m == 0) return grid[m][n] + min(grid, m, n - 1); \\n/** when we reach the first column, we could only move vertically.*/\\n            if(n == 0) return grid[m][n] + min(grid, m - 1, n); \\n/** we want the min sum path so we pick the cell with the less value */\\n            return grid[m][n] + Math.min(min(grid, m - 1, n), min(grid, m, n - 1)); \\n\\t\\t\\t\\n}\\n```\n```\\nclass Solution {\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        memo = new int[m][n];\\n        return find(grid, m-1, n-1, memo);\\n    }\\n    \\n    private int find(int[][] grid, int m, int n, int[][] memo){\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        else if(memo[m][n]!=0)\\n           return memo[m][n];\\n        return memo[m][n] = grid[m][n] + Math.min(find(grid, m-1, n, memo), find(grid, m, n-1, memo));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<m;i++)\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int j=1;j<n;j++)\\n            dp[0][j] = dp[0][j-1] + grid[0][j];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=1;i<m;i++)\\n            grid[i][0] += grid[i-1][0];\\n        for(int j=1;j<n;j++)\\n            grid[0][j] += grid[0][j-1];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054796,
                "title": "simple-understandable-c-code-dp-recursive-iterative",
                "content": "Recursion+Memoization\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = grid[x][y];\\n        if(x==m && y<n) ans += fun(x, y+1, grid);\\n        else if(x<m && y==n) ans += fun(x+1, y, grid);\\n        else if(x<m && y<n) ans += min (fun(x+1, y, grid), fun(x, y+1, grid));\\n        return dp[x][y] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        m = grid.size()-1, n = grid[0].size()-1;\\n        dp.resize(m+1, vector<int>(n+1, -1));\\n        return fun(0, 0, grid);\\n    }\\n};\\n```\\n\\n\\nIterative Approach\\n```\\nclass Solution {\\npublic:\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = grid[i][j];\\n                if(i>0 && j>0) dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n                else if(i>0) dp[i][j] += dp[i-1][j];\\n                else if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = grid[x][y];\\n        if(x==m && y<n) ans += fun(x, y+1, grid);\\n        else if(x<m && y==n) ans += fun(x+1, y, grid);\\n        else if(x<m && y<n) ans += min (fun(x+1, y, grid), fun(x, y+1, grid));\\n        return dp[x][y] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        m = grid.size()-1, n = grid[0].size()-1;\\n        dp.resize(m+1, vector<int>(n+1, -1));\\n        return fun(0, 0, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = grid[i][j];\\n                if(i>0 && j>0) dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n                else if(i>0) dp[i][j] += dp[i-1][j];\\n                else if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915672,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows in the grid, and m is the number of columns in the grid.\\n    //   - space: O(m), where m is the number of columns in the grid.\\n\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = grid\\n        let n = grid.count - 1\\n        let m = grid[0].count - 1\\n        \\n        for i in 0...n {\\n            for j in 0...m {\\n                var step = matrix[i][j]\\n        \\n                if i > 0 && j > 0 {\\n                    step += min(matrix[i - 1][j], matrix[i][j - 1])\\n                } else if i > 0 && j == 0 {\\n                    step += matrix[i - 1][j]\\n                } else if j > 0 && i == 0 {\\n                    step += matrix[i][j - 1]\\n                }\\n                \\n                matrix[i][j] = step\\n            }\\n        }\\n        \\n        return matrix[n][m]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows in the grid, and m is the number of columns in the grid.\\n    //   - space: O(m), where m is the number of columns in the grid.\\n\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = grid\\n        let n = grid.count - 1\\n        let m = grid[0].count - 1\\n        \\n        for i in 0...n {\\n            for j in 0...m {\\n                var step = matrix[i][j]\\n        \\n                if i > 0 && j > 0 {\\n                    step += min(matrix[i - 1][j], matrix[i][j - 1])\\n                } else if i > 0 && j == 0 {\\n                    step += matrix[i - 1][j]\\n                } else if j > 0 && i == 0 {\\n                    step += matrix[i][j - 1]\\n                }\\n                \\n                matrix[i][j] = step\\n            }\\n        }\\n        \\n        return matrix[n][m]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554297,
                "title": "python-in-place-dp-with-explanatory-comments-92ms-or-faster-than-97",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # get dimensions\\n        n = len(grid) # no of cells in each col\\n        m = len(grid[0]) # no of cells in each row\\n        \\n        # populate first row using m for no of cells in row\\n        for i in range(1,m):\\n            grid[0][i] = grid[0][i] + grid[0][i-1]\\n        \\n        # populate first col using n for no of cells in col\\n        for j in range(1,n):\\n            grid[j][0] = grid[j-1][0] + grid[j][0]\\n        \\n        # populate the rest\\n        for i in range(1,n):\\n            for j in range(1,m):\\n\\t\\t\\t\\t# get min seen so far plus curr cell value\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1]) + grid[i][j]\\n        \\n        # return last cell\\n        return grid[-1][-1]\\n            \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # get dimensions\\n        n = len(grid) # no of cells in each col\\n        m = len(grid[0]) # no of cells in each row\\n        \\n        # populate first row using m for no of cells in row\\n        for i in range(1,m):\\n            grid[0][i] = grid[0][i] + grid[0][i-1]\\n        \\n        # populate first col using n for no of cells in col\\n        for j in range(1,n):\\n            grid[j][0] = grid[j-1][0] + grid[j][0]\\n        \\n        # populate the rest\\n        for i in range(1,n):\\n            for j in range(1,m):\\n\\t\\t\\t\\t# get min seen so far plus curr cell value\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1]) + grid[i][j]\\n        \\n        # return last cell\\n        return grid[-1][-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 23617,
                "title": "c-solution-beat-98-59",
                "content": "    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        vector<int> res(grid[0].size(),INT_MAX);\\n        res[0] = 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(j > 0)\\n                    res[j] = min(res[j-1],res[j]) + grid[i][j];\\n                else\\n                    res[j] = res[j] + grid[i][j];\\n        \\n        return res[grid[0].size()-1];\\n    }",
                "solutionTags": [],
                "code": "    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        vector<int> res(grid[0].size(),INT_MAX);\\n        res[0] = 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(j > 0)\\n                    res[j] = min(res[j-1],res[j]) + grid[i][j];\\n                else\\n                    res[j] = res[j] + grid[i][j];\\n        \\n        return res[grid[0].size()-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23611,
                "title": "my-java-clean-code-dp-no-extra-space",
                "content": "\\n    public int minPathSum(int[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(i == 0 && j == 0) continue;\\n                if(i == 0) grid[i][j] += grid[i][j - 1];\\n                else if(j == 0) grid[i][j] += grid[i - 1][j];\\n                else grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n            }\\n        }\\n        return grid[grid.length - 1][grid[0].length - 1];\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n    public int minPathSum(int[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(i == 0 && j == 0) continue;\\n                if(i == 0) grid[i][j] += grid[i][j - 1];\\n                else if(j == 0) grid[i][j] += grid[i - 1][j];\\n                else grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n            }\\n        }\\n        return grid[grid.length - 1][grid[0].length - 1];\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3225715,
                "title": "dynamic-programming-finding-the-minimum-path-sum-in-a-grid",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe problem asks to find the minimum sum of a path from the top-left corner to the bottom-right corner of a grid. Since we are only allowed to move right and down, the possible paths we can take are limited. Hence, we can use dynamic programming to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can create a 2D array `dp` that stores the minimum sum of a path from the top-left corner to the current cell (i, j). We can initialize `dp[0][0]` as the first element of the grid. We can then populate the first row and column of the `dp` array by adding the current element of the grid to the previous element in the row/column.\\n\\nAfter initializing the first row and column, we can iterate through the rest of the `dp` array and calculate the minimum sum of the path to the current cell (i, j). We can calculate this by taking the minimum of the previous minimum path sum of the cell above (i-1, j) and the cell to the left (i, j-1). We then add the current element of the grid to the minimum sum.\\n\\nThe minimum sum of the path from the top-left corner to the bottom-right corner of the grid will be stored in `dp[m-1][n-1]`, where `m` and `n` are the dimensions of the grid.\\n# Complexity\\n- Time complexity: $$O(mn)$$, where m and n are the dimensions of the grid. We iterate through each cell in the `dp` array exactly once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(mn)$$, where m and n are the dimensions of the grid. We create a 2D array of size m x n to store the minimum path sum to each cell.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949291,
                "title": "simple-java-solution-with-tabulation-100-beat",
                "content": "\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n    if(grid.length == 0) return 0;\\n    int row = grid.length;\\n    int col = grid[0].length;\\n    \\n    for(int i=0;i<row; i++) {\\n        for(int j=0; j<col; j++) {\\n            int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n            int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n            if(i==0 && j==0) continue;\\n            \\n            grid[i][j] += Math.min(leftSum, topSum);\\n        }\\n    }\\n    return grid[row-1][col-1];\\n }\\n}\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n    if(grid.length == 0) return 0;\\n    int row = grid.length;\\n    int col = grid[0].length;\\n    \\n    for(int i=0;i<row; i++) {\\n        for(int j=0; j<col; j++) {\\n            int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n            int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n            if(i==0 && j==0) continue;\\n            \\n            grid[i][j] += Math.min(leftSum, topSum);\\n        }\\n    }\\n    return grid[row-1][col-1];\\n }\\n}\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323556,
                "title": "java-recursive-memoization-tabulization",
                "content": "```\\n**RECURSIVE APPROACH **\\n(gives TLE)\\n\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        return minPathSum(0,0,n,m,grid);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        \\n        return grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid), minPathSum(i, j+1, n,m,grid));\\n    }\\n}\\n```\\n**Memoization**\\n***ACCEPTED***\\n```\\npublic int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] num : memo)\\n            Arrays.fill(num, -1);\\n        return minPathSum(0,0,n,m,grid, memo);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid, int[][] memo){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        \\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        return memo[i][j] = grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid, memo), minPathSum(i, j+1, n,m,grid,memo));\\n    }\\n```\\n**Tabulization**\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 0; i<grid.length; i++){\\n            for(int j = 0; j<grid[0].length; j++){ \\n                if(i == 0 && j == 0)\\n                    grid[i][j] = grid[i][j];\\n \\n                else if(i == 0 && j != 0){\\n                    grid[i][j] = grid[i][j] + grid[i][j-1];\\n                }\\n                else if(i!= 0 && j == 0)\\n                    grid[i][j] = grid[i][j] + grid[i-1][j];\\n                else\\n                    grid[i][j] = grid[i][j] + Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n**RECURSIVE APPROACH **\\n(gives TLE)\\n\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        return minPathSum(0,0,n,m,grid);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        \\n        return grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid), minPathSum(i, j+1, n,m,grid));\\n    }\\n}\\n```\n```\\npublic int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] num : memo)\\n            Arrays.fill(num, -1);\\n        return minPathSum(0,0,n,m,grid, memo);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid, int[][] memo){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        \\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        return memo[i][j] = grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid, memo), minPathSum(i, j+1, n,m,grid,memo));\\n    }\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 0; i<grid.length; i++){\\n            for(int j = 0; j<grid[0].length; j++){ \\n                if(i == 0 && j == 0)\\n                    grid[i][j] = grid[i][j];\\n \\n                else if(i == 0 && j != 0){\\n                    grid[i][j] = grid[i][j] + grid[i][j-1];\\n                }\\n                else if(i!= 0 && j == 0)\\n                    grid[i][j] = grid[i][j] + grid[i-1][j];\\n                else\\n                    grid[i][j] = grid[i][j] + Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998855,
                "title": "backtracking-recursive-dp-java-solution-explained",
                "content": "**1. Backtracking**\\n\\tBacktracking template is Goal, Search Space & Constraint.\\n\\t\\n\\t```\\n\\t\\tpublic void backTracking() {\\n\\t\\t\\t// GOAL(Here we need to check what do we want in the end, \\n\\t\\t\\t// in our question the GOAL is to reach the bottom right index)\\n\\t\\t\\t\\n\\t\\t\\t// SEARCH SPACE(Here we basically iterate through \\n\\t\\t\\t// every possible move from current position, \\n\\t\\t\\t// in our question it is either moving to right or down)\\n\\t\\t\\t\\n\\t\\t\\t// CONSTRAINT(Here we need to check \\n\\t\\t\\t// whether the above chosen move is valid or not, here in our question \\n\\t\\t\\t// the CONSTRAINT is that the chosen move should be within the boundaries)\\n\\t\\t}\\n\\t```\\n\\t\\nWith the above being said, BackTracking Solution below\\n``` \\nclass Solution {\\n    private int res;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        res = Integer.MAX_VALUE;\\n        backTrack(arr, 0, 0, m-1, n-1, arr[0][0]);\\n        return res;\\n    }\\n    \\n    private int x[] = new int[]{0, 1};\\n    private int y[] = new int[]{1, 0};\\n    private void backTrack(int arr[][], int a, int b, int c, int d, int cur) {\\n\\t\\t// GOAL\\n        if(a == c && b == d) {\\n            res = Math.min(res, cur);\\n            return ;\\n        }\\n\\t\\t\\n\\t\\t// SEARCH SPACE\\n        for(int i=0;i<2;i++) {\\n            int nx = a + x[i];\\n            int ny = b + y[i];\\n\\t\\t\\t// CONSTRAINT\\n            if(isSafe(nx, ny, c, d)) {\\n                backTrack(arr, nx, ny, c, d, cur+arr[nx][ny]);\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(int a, int b, int c, int d) {\\n        return a >= 0 && b >= 0 && a <= c && b <= d;\\n    }\\n}\\n```\\n\\nThe above solution gives **TLE** because it takes every possible path into consideration.\\n\\n2. **Recursive** approach\\n\\n\\tThis problem pattern is similar to **\"With, Without\"** classic principle.\\n\\t\\n\\tAt each and every position , we have 2 choices in our given question. We can either go to the right or we can go to down. And we need to take the minimum of those 2 choices.\\n\\t\\n\\tLet\\'s just say that we are at position (a, b) & the array is arr[][] & the number of rows as m and the number of columns as n.\\n\\t\\n\\tThe recursive function goes like this:\\n\\t```\\n\\tfunction(int a, int b, int m, int n, int arr[][]) {\\n\\t\\n\\t\\t// Handle base case \\n\\t\\t// which is when we reach our desired bottom right position\\n\\t\\tif(a == m-1 && b == n-1) {\\n\\t\\t\\treturn arr[a][b];\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Handle out of boundary cases\\n\\t\\tif(a >= m || b >= n)\\n            return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t\\n\\t\\t// Below means that we can take the current pos value \\n\\t\\t// and we are taking the minimum of right & down\\n\\t\\treturn arr[a][b] + Math.min(function(a, b+1, m, n, arr), function(a+1, b, m, n, arr));\\n\\t}\\n\\t```\\n\\t\\n\\tI have used a Map to cache the already calculated results\\n\\t\\n\\tWith that being said , Recursive solution below\\n\\t\\n\\t```\\n\\tclass Solution {\\n    private Map<String, Integer> map;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        map = new HashMap<>();\\n        return recur(arr, 0, 0, m, n);\\n    }\\n\\t\\n    private int recur(int arr[][], int a, int b, int c, int d) {\\n        if(a == c-1 && b == d-1)\\n            return arr[a][b];\\n        if(a >= c || b >= d)\\n            return Integer.MAX_VALUE;\\n        String key = String.valueOf(a) + \",\" + String.valueOf(b);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        int res = arr[a][b] + Math.min(\\n            recur(arr, a, b+1, c, d),\\n            recur(arr, a+1, b, c, d)\\n        );\\n        map.put(key, res);\\n        return res;\\n    }\\n}\\n\\t```\\n3. **Dynamic Programming** approach\\n\\nOnce we write the recursive approach, DP is easy to write.\\n\\nDP Solution below.\\n```\\nclass Solution {\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        return dy(arr);\\n    }\\n    \\n    private int dy(int arr[][]) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if( i == 0 && j == 0) {\\n                    dp[i][j] = arr[i][j];\\n                    continue;\\n                }\\n                dp[i][j] = arr[i][j] + Math.min(j > 0 ? dp[i][j-1] : Integer.MAX_VALUE, i > 0 ? dp[i-1][j] : Integer.MAX_VALUE);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\t\\tpublic void backTracking() {\\n\\t\\t\\t// GOAL(Here we need to check what do we want in the end, \\n\\t\\t\\t// in our question the GOAL is to reach the bottom right index)\\n\\t\\t\\t\\n\\t\\t\\t// SEARCH SPACE(Here we basically iterate through \\n\\t\\t\\t// every possible move from current position, \\n\\t\\t\\t// in our question it is either moving to right or down)\\n\\t\\t\\t\\n\\t\\t\\t// CONSTRAINT(Here we need to check \\n\\t\\t\\t// whether the above chosen move is valid or not, here in our question \\n\\t\\t\\t// the CONSTRAINT is that the chosen move should be within the boundaries)\\n\\t\\t}\\n\\t```\n``` \\nclass Solution {\\n    private int res;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        res = Integer.MAX_VALUE;\\n        backTrack(arr, 0, 0, m-1, n-1, arr[0][0]);\\n        return res;\\n    }\\n    \\n    private int x[] = new int[]{0, 1};\\n    private int y[] = new int[]{1, 0};\\n    private void backTrack(int arr[][], int a, int b, int c, int d, int cur) {\\n\\t\\t// GOAL\\n        if(a == c && b == d) {\\n            res = Math.min(res, cur);\\n            return ;\\n        }\\n\\t\\t\\n\\t\\t// SEARCH SPACE\\n        for(int i=0;i<2;i++) {\\n            int nx = a + x[i];\\n            int ny = b + y[i];\\n\\t\\t\\t// CONSTRAINT\\n            if(isSafe(nx, ny, c, d)) {\\n                backTrack(arr, nx, ny, c, d, cur+arr[nx][ny]);\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(int a, int b, int c, int d) {\\n        return a >= 0 && b >= 0 && a <= c && b <= d;\\n    }\\n}\\n```\n```\\n\\tfunction(int a, int b, int m, int n, int arr[][]) {\\n\\t\\n\\t\\t// Handle base case \\n\\t\\t// which is when we reach our desired bottom right position\\n\\t\\tif(a == m-1 && b == n-1) {\\n\\t\\t\\treturn arr[a][b];\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Handle out of boundary cases\\n\\t\\tif(a >= m || b >= n)\\n            return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t\\n\\t\\t// Below means that we can take the current pos value \\n\\t\\t// and we are taking the minimum of right & down\\n\\t\\treturn arr[a][b] + Math.min(function(a, b+1, m, n, arr), function(a+1, b, m, n, arr));\\n\\t}\\n\\t```\n```\\n\\tclass Solution {\\n    private Map<String, Integer> map;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        map = new HashMap<>();\\n        return recur(arr, 0, 0, m, n);\\n    }\\n\\t\\n    private int recur(int arr[][], int a, int b, int c, int d) {\\n        if(a == c-1 && b == d-1)\\n            return arr[a][b];\\n        if(a >= c || b >= d)\\n            return Integer.MAX_VALUE;\\n        String key = String.valueOf(a) + \",\" + String.valueOf(b);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        int res = arr[a][b] + Math.min(\\n            recur(arr, a, b+1, c, d),\\n            recur(arr, a+1, b, c, d)\\n        );\\n        map.put(key, res);\\n        return res;\\n    }\\n}\\n\\t```\n```\\nclass Solution {\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        return dy(arr);\\n    }\\n    \\n    private int dy(int arr[][]) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if( i == 0 && j == 0) {\\n                    dp[i][j] = arr[i][j];\\n                    continue;\\n                }\\n                dp[i][j] = arr[i][j] + Math.min(j > 0 ? dp[i][j-1] : Integer.MAX_VALUE, i > 0 ? dp[i-1][j] : Integer.MAX_VALUE);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226798,
                "title": "javascript",
                "content": "**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u57FA\\u672C\\u601D\\u8DEF\\u4E3A: (i, j) = (i, j) + min((i - 1, j), (i, j - 1)).\\n2. \\u4F46\\u662F\\u7B2C\\u4E00\\u5217\\u548C\\u7B2C\\u4E00\\u884C\\u7684\\u6BCF\\u4E00\\u4E2A\\u5143\\u7D20, \\u5747\\u9700\\u8981\\u52A0\\u4E0A\\u524D\\u9762\\u4E00\\u4E2A\\u5143\\u7D20.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar minPathSum = function(grid) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  \\n  for (let i = 1; i < m; i++) {\\n    grid[i][0] += grid[i - 1][0];\\n  }\\n  for (let i = 1; i < n; i++) {\\n    grid[0][i] += grid[0][i - 1];\\n  }\\n  \\n  for (let i = 1; i < m; i++) {\\n    for (let j = 1; j < n; j++) {\\n      grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n    }\\n  }\\n  \\n  return grid[m - 1][n - 1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minPathSum = function(grid) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  \\n  for (let i = 1; i < m; i++) {\\n    grid[i][0] += grid[i - 1][0];\\n  }\\n  for (let i = 1; i < n; i++) {\\n    grid[0][i] += grid[0][i - 1];\\n  }\\n  \\n  for (let i = 1; i < m; i++) {\\n    for (let j = 1; j < n; j++) {\\n      grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n    }\\n  }\\n  \\n  return grid[m - 1][n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3117215,
                "title": "c-recursion-dp-memoization-tabulation-space-optimization",
                "content": "# \\uD83D\\uDCA1Intuition and Approach :-\\n\\nhttps://www.youtube.com/watch?v=_rgTlyky1uQ&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=11\\n\\n#### This video helped me understand the Solution. Thanks to TUF and Striver \\uD83D\\uDE4F\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83D\\uDCA1Code\\n# \\uD83D\\uDCA5Recursion :-\\n```\\nTC:O(2^n) SC:O((m-1)+(n-1))\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 ||j<0) return INT_MAX;\\n\\n        int up = grid[i][j] + f(i-1, j, grid);\\n        int left = grid[i][j] + f(i, j-1, grid);\\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        return f(n-1, m-1, grid);\\n    }\\n};\\n```\\n# \\uD83D\\uDCA5Memoization :-\\n```\\nTC:O(m*n) SC:O((m-1)+(n-1))+O(m*n)\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp){\\n        if(i==0 && j==0) return grid[0][0];\\n        if(i<0 ||j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int up = grid[i][j] + f(i-1, j, grid, dp);\\n        int left = grid[i][j] + f(i, j-1, grid, dp);\\n        return dp[i][j] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        return f(n-1,m-1, grid, dp);\\n    }\\n};\\n```\\n# \\uD83D\\uDCA5Tabulation :-\\n```\\nTC:O(m*n) SC:O(m*n)\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n\\n```\\n\\n# \\uD83D\\uDCA5Space Optimization :-\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<int> prev(m,0);\\n        for(int i=0; i<n; i++){\\n            vector<int> temp(m,0);\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    temp[0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= temp[j-1];\\n                    else left+= 1e9;\\n\\n                    temp[j] = min(up, left);\\n                }\\n            }\\n            prev = temp;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nTC:O(2^n) SC:O((m-1)+(n-1))\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 ||j<0) return INT_MAX;\\n\\n        int up = grid[i][j] + f(i-1, j, grid);\\n        int left = grid[i][j] + f(i, j-1, grid);\\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        return f(n-1, m-1, grid);\\n    }\\n};\\n```\n```\\nTC:O(m*n) SC:O((m-1)+(n-1))+O(m*n)\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp){\\n        if(i==0 && j==0) return grid[0][0];\\n        if(i<0 ||j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int up = grid[i][j] + f(i-1, j, grid, dp);\\n        int left = grid[i][j] + f(i, j-1, grid, dp);\\n        return dp[i][j] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        return f(n-1,m-1, grid, dp);\\n    }\\n};\\n```\n```\\nTC:O(m*n) SC:O(m*n)\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<int> prev(m,0);\\n        for(int i=0; i<n; i++){\\n            vector<int> temp(m,0);\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    temp[0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= temp[j-1];\\n                    else left+= 1e9;\\n\\n                    temp[j] = min(up, left);\\n                }\\n            }\\n            prev = temp;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405052,
                "title": "recursion-to-dp-memoization",
                "content": "Recursion:\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n                \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n            return grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            \\n        \\n        return helper(0,0)\\n```\\n\\nAdding memoization:\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cache = {}\\n        \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n\\t\\t\\t# return from cache if present\\n            if (i,j) in cache :\\n                return cache[(i,j)]\\n\\t\\t\\t\\n\\t\\t\\t# populate cache\\n            cache[(i,j)] = grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            return cache[(i,j)]\\n            \\n        return helper(0,0)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n                \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n            return grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            \\n        \\n        return helper(0,0)\\n```\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cache = {}\\n        \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n\\t\\t\\t# return from cache if present\\n            if (i,j) in cache :\\n                return cache[(i,j)]\\n\\t\\t\\t\\n\\t\\t\\t# populate cache\\n            cache[(i,j)] = grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            return cache[(i,j)]\\n            \\n        return helper(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23637,
                "title": "passed-c-code-only-need-o-n-extra-space-and-don-t-change-the-original-data",
                "content": "    int minPathSum(vector<vector<int> > &grid) {\\n        int rows = grid.size();\\n        if (rows==0) return 0;\\n        int cols = grid[0].size();\\n        vector<int> vi(cols, INT_MAX);\\n\\n        int i, j;\\n        vi[0] = 0;\\n        for (i=0; i<rows; i++) {\\n            vi[0] += grid[i][0];\\n            for (j=1; j<cols; j++) {\\n                vi[j] = min(vi[j-1], vi[j])+grid[i][j];\\n            }\\n        }\\n        return vi[cols-1];\\n    }",
                "solutionTags": [],
                "code": "    int minPathSum(vector<vector<int> > &grid) {\\n        int rows = grid.size();\\n        if (rows==0) return 0;\\n        int cols = grid[0].size();\\n        vector<int> vi(cols, INT_MAX);\\n\\n        int i, j;\\n        vi[0] = 0;\\n        for (i=0; i<rows; i++) {\\n            vi[0] += grid[i][0];\\n            for (j=1; j<cols; j++) {\\n                vi[j] = min(vi[j-1], vi[j])+grid[i][j];\\n            }\\n        }\\n        return vi[cols-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3856514,
                "title": "most-optimized-2-methods-explained-dry-run-1d-dp-beats-100",
                "content": "# Method #1\\n# Intuition & Approach \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We are creating a vector of size rows and storing grid[i][0] in cur[i]\\n- Cur vector is used as dp vector in this method.\\n- Now update cur as if we are following the downward path only. \\n- Use nested loop and dry run the code,\\n- Here we are comparing the two possibilities(Right or Downward direction)\\n- For reaching the cell[i][j] in matrix and update it with minimum.\\n- Return the answer.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m): m(Rows)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n\\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\\n### Dry Run:\\n![#dryRunMethod1(MinimumPathSum).jpeg](https://assets.leetcode.com/users/images/073a6b38-7fbd-4c14-be48-bb2ae1a7e872_1691043144.5424638.jpeg)\\n\\n# Method #2\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In any matrix where dp is involved this is the **generic** way to solve the problem.\\n- Create DP vector of n*m, initialize it by -1.\\n- Call it recursively.\\n- Check for valid indices, if we are at destination return dp[i][j]\\n- Store results of possible way, like(down, right, left, up)\\n- Store the required result like max/min OR sum/multiplication of it in dp[i][j]\\n- Return the answer.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int f(int i, int j,vector<vector<int>> &grid, vector<vector<int>> &dp){\\n    if(i<0 || j<0 ) return 1e9;\\n    if(i==0 && j==0) return grid[0][0];\\n    if(dp[i][j] != -1) return dp[i][j];\\n    \\n    int up = grid[i][j] + f(i-1, j, grid, dp);\\n    int left = grid[i][j] + f(i,j-1, grid, dp);\\n    return dp[i][j] = min(left,up); \\n  }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int> (n, -1));\\n\\n        return f(m-1, n-1,grid, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n\\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int f(int i, int j,vector<vector<int>> &grid, vector<vector<int>> &dp){\\n    if(i<0 || j<0 ) return 1e9;\\n    if(i==0 && j==0) return grid[0][0];\\n    if(dp[i][j] != -1) return dp[i][j];\\n    \\n    int up = grid[i][j] + f(i-1, j, grid, dp);\\n    int left = grid[i][j] + f(i,j-1, grid, dp);\\n    return dp[i][j] = min(left,up); \\n  }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int> (n, -1));\\n\\n        return f(m-1, n-1,grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345991,
                "title": "try-ones-more-using-my-hints-easy-java-solution-2-approaches-recursive-and-iterative",
                "content": "# Approach 1 Using recursion(Brute force)\\n\\n# Hints \\n- Use recursion \\n- Start from Destination grid[n][m] \\n- Each time check :- \\n    - If we reach source(i.e. n == 0 && m == 0) return grid[0][0]\\n    - Else if index is not valid return Integer.MAX_VALUE\\n    - Else return cost of current node(grid[n][m]) sum with mininum of cost to reach (n-1, m) and (n, m-1).\\n\\n# Note \\n- It will give Time Limit Exceeded as time is 2^n\\n\\n# Complexity\\n- Time complexity: O(2^(n*m))\\n\\n# Code \\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        return minPathSum(grid, grid.length-1, grid[0].length-1);\\n    }\\n    private int minPathSum(int[][] grid, int n, int m){\\n        if(n == 0 && m == 0) return grid[n][m];\\n        if(n < 0 || m < 0) return Integer.MAX_VALUE;\\n        return grid[n][m] + Math.min(minPathSum(grid, n-1, m), minPathSum(grid, n, m-1));\\n    }\\n}\\n```\\n\\n# Approach 2 Using DP\\n- Same approach in dp\\n- Try to frame dp solution yourself\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n                else if(i == 0) dp[i][j] = dp[i][j-1] + grid[i][j];\\n                else if(j == 0) dp[i][j] = dp[i-1][j] + grid[i][j];\\n                else {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j-1], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        return minPathSum(grid, grid.length-1, grid[0].length-1);\\n    }\\n    private int minPathSum(int[][] grid, int n, int m){\\n        if(n == 0 && m == 0) return grid[n][m];\\n        if(n < 0 || m < 0) return Integer.MAX_VALUE;\\n        return grid[n][m] + Math.min(minPathSum(grid, n-1, m), minPathSum(grid, n, m-1));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n                else if(i == 0) dp[i][j] = dp[i][j-1] + grid[i][j];\\n                else if(j == 0) dp[i][j] = dp[i-1][j] + grid[i][j];\\n                else {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j-1], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345808,
                "title": "java-easy-solution-fully-explained-100-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    /**\\n     * Space Complexity O(m*n) -- for dp matrix\\n     * Time Complexity O(m*n)\\n     * @param grid\\n     * @return\\n     */\\n    public int minPathSum(int[][] grid) {\\n        //initialise a dp with size same as original array\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                //start counting the cost from the bottom right cell(bottom up approach) this is base condition\\n                //Cost of going to destination from destination is the lowest subset problem\\n                //then expand with the computed value to other cells gradually\\n                //when solving bigger subsets other than base condition, remember we can only go right or bottom\\n                if (i + 1 > m - 1 && j + 1 > n - 1) //base condition\\n                    dp[i][j] = grid[i][j];\\n\\n                else if (i + 1 > m - 1)//boundary condition: handles the bottom most row\\n                    dp[i][j] = dp[i][j + 1] + grid[i][j];\\n\\n                else if (j + 1 > n - 1)//boundary condition: handles the right most column\\n                    dp[i][j] = dp[i + 1][j] + grid[i][j];\\n                else {// normal cells : get the min of 1 horizontal  right travel and 1 vertical bottom travel\\n                    dp[i][j] = Math.min(dp[i][j + 1] + grid[i][j], dp[i + 1][j] + grid[i][j]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Space Complexity O(m*n) -- for dp matrix\\n     * Time Complexity O(m*n)\\n     * @param grid\\n     * @return\\n     */\\n    public int minPathSum(int[][] grid) {\\n        //initialise a dp with size same as original array\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                //start counting the cost from the bottom right cell(bottom up approach) this is base condition\\n                //Cost of going to destination from destination is the lowest subset problem\\n                //then expand with the computed value to other cells gradually\\n                //when solving bigger subsets other than base condition, remember we can only go right or bottom\\n                if (i + 1 > m - 1 && j + 1 > n - 1) //base condition\\n                    dp[i][j] = grid[i][j];\\n\\n                else if (i + 1 > m - 1)//boundary condition: handles the bottom most row\\n                    dp[i][j] = dp[i][j + 1] + grid[i][j];\\n\\n                else if (j + 1 > n - 1)//boundary condition: handles the right most column\\n                    dp[i][j] = dp[i + 1][j] + grid[i][j];\\n                else {// normal cells : get the min of 1 horizontal  right travel and 1 vertical bottom travel\\n                    dp[i][j] = Math.min(dp[i][j + 1] + grid[i][j], dp[i + 1][j] + grid[i][j]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240046,
                "title": "c-solution-recursion-memoization-tabulation-with-tc-and-sc",
                "content": "**Normal Recursion (Result in TLE)**\\n```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        return min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int ans = rec(0,0,m,n,grid);\\n        return ans;\\n    }\\n};\\n```\\nTC: O(2^mxn)\\nSC: O(n {which is the largest path}) (stack space)\\n<hr style=\"margin:2rem 0;\">\\n\\n**Memoization**\\n```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        \\n        return dp[r][c] = min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans = rec(0,0,m,n,grid,dp);\\n        return ans;\\n    }\\n};\\n```\\nTC: O(mxn)\\nSC: O(n)(Stack space) + O(m x n) (DP array)\\n<hr style=\"margin:2rem 0;\">\\n\\n**Tabulation**\\n```\\n// Tabulation\\n// See Notes for recursion and memoization\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), down, right;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                down = right = 1000; // Random large number\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[0][0];\\n                else\\n                {\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    \\n                    dp[i][j] = min(down,right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\nTC: O(mxn)\\nSC: O(mxn) (DP array)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        return min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int ans = rec(0,0,m,n,grid);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        \\n        return dp[r][c] = min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans = rec(0,0,m,n,grid,dp);\\n        return ans;\\n    }\\n};\\n```\n```\\n// Tabulation\\n// See Notes for recursion and memoization\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), down, right;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                down = right = 1000; // Random large number\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[0][0];\\n                else\\n                {\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    \\n                    dp[i][j] = min(down,right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985866,
                "title": "c-dp-6-ms-faster-than-94-05-o-n-2",
                "content": "Simple DP solution in O(n^2)\\n\\nStep 1: Initialize a dp array\\nStep 2: Fill the 0th row and 0th column of dp array where, the value at any position of row or column is the sum of all the elements from 0 to that index in the grid vector.\\nStep 3: Using two for loops iterate the whole dp array except the 0th row and col as we have already filled them in Step 2.\\nStep 4: The value of the dp[ i ][ j ] will be the value of grid[ i ][ j ] + min(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) i.e.\\nthe value will be sum of the current value at grid, plus the minimum of the element at the top or element at the left side of the current element in the array.\\nStep 5: At the end return the value of the dp[ row-1 ][ col-1 ] i.e the last element of the matrix dp.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n\\t\\t// Step 1: Initialize a dp array\\n\\n        int dp[row][col];\\n        \\n\\t\\t// Step 2: Fill the 0th row and 0th column of dp array where, the value at any position of row or\\n\\t\\t// column is the sum of all the elements from 0 to that index in the grid vector.\\n\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<col;i++)\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        for(int i=1;i<row;i++)\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        \\n\\t\\t// Step 3: Using two for loops iterate the whole dp array except the 0th row and col as we have already \\n\\t\\t// filled them in Step 2.\\n\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=1;j<grid[0].size();j++){\\n\\t\\t\\t\\n\\t\\t\\t// Step 4: The value of the dp[ i ][ j ] will be the value of grid[ i ][ j ] + min(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) i.e.\\n\\t\\t\\t// the value will be sum of the current value at grid plus the minimum of the element at the top or \\n\\t\\t\\t// element at the left side of the current element in the array.\\n\\t\\t\\t\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Step 5: At the end return the value of the dp[ row-1 ][ col-1 ] i.e the last element of the matrix dp.\\n        \\n        return dp[row-1][col-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n\\t\\t// Step 1: Initialize a dp array\\n\\n        int dp[row][col];\\n        \\n\\t\\t// Step 2: Fill the 0th row and 0th column of dp array where, the value at any position of row or\\n\\t\\t// column is the sum of all the elements from 0 to that index in the grid vector.\\n\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<col;i++)\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        for(int i=1;i<row;i++)\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        \\n\\t\\t// Step 3: Using two for loops iterate the whole dp array except the 0th row and col as we have already \\n\\t\\t// filled them in Step 2.\\n\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=1;j<grid[0].size();j++){\\n\\t\\t\\t\\n\\t\\t\\t// Step 4: The value of the dp[ i ][ j ] will be the value of grid[ i ][ j ] + min(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) i.e.\\n\\t\\t\\t// the value will be sum of the current value at grid plus the minimum of the element at the top or \\n\\t\\t\\t// element at the left side of the current element in the array.\\n\\t\\t\\t\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Step 5: At the end return the value of the dp[ row-1 ][ col-1 ] i.e the last element of the matrix dp.\\n        \\n        return dp[row-1][col-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510686,
                "title": "javascript-solution-faster-than-98-91-o-n-easy-method",
                "content": "```\\n// Optimized Implementation  | Runtime O(n) | space O(1)\\n// Runtime: 68 ms, faster than 98.91 % of JavaScript online submissions for Minimum Path Sum.\\n// Memory Usage: 41 MB, less than 46.37 % of JavaScript online submissions for Minimum Path Sum.\\n\\n//By doing this method, we can find the shortest distance for all the cell in the grid from the starting point.\\n\\nvar minPathSum = function (grid) {\\n    //loops through all the cell in the grid:\\n    for (let i = 0; i < grid.length; i++)\\n        for (let j = 0; j < grid[0].length; j++)\\n            // if the position is (0,0) ,pass it...\\n            if (i == 0 && j == 0)\\n                continue\\n            // if i=0 then update the grid[0][j] position value by (0,j) + (0,j-1) position\\'s value  { other_words:: current cell value + left cell of the current cell\\'s value in the grid }\\n            else if (i == 0)\\n                grid[i][j] += grid[i][j - 1];\\n            // if j=0 then update the grid[i][0] position value by (i,0) + (i-1,0) position\\'s value { other_words:: current cell value + top cell of the current cell\\'s value in the grid }\\n            else if (j == 0)\\n                grid[i][j] += grid[i - 1][j];\\n            // else (both i and j are not equal to zero)\\n            else\\n                // current cell value + left cell of the current cell\\'s value in the grid is smaller { < } then  current cell value + top cell of the current cell\\'s value in the grid\\n                //if true ,update the grid[i][j] value by current cell value + left cell of the current cell\\'s value in the grid\\n                if (grid[i][j] + grid[i][j - 1] < grid[i][j] + grid[i - 1][j])\\n                    grid[i][j] += grid[i][j - 1];\\n                //else ,update the grid[i][j] value by current cell value + top cell of the current cell\\'s value in the grid\\n                else\\n                    grid[i][j] += grid[i - 1][j];\\n    //return the last cell value \\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n\\nFor Example :\\n\\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___3____|___1____|\\n    |        |        |        |\\n    |___1____|___5____|___1____|\\n    |        |        | finish |\\n    |___4____|___2____|___1____|\\n\\t\\n\\tAt the end , grid is updated to the shortest distance sum from the starting point :\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___4____|___5____|\\n    |        |        |        |\\n    |___2____|___7____|___6____|\\n    |        |        | finish |\\n    |___6____|___8____|___7____|   return the last cell value  (7 in this case)\\n\\t\\n\\t\\tOutput: 7\\n\\t\\tExplanation: Because the path 1 \\u2192 3 \\u2192 1 \\u2192 1 \\u2192 1 minimizes the sum.\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Optimized Implementation  | Runtime O(n) | space O(1)\\n// Runtime: 68 ms, faster than 98.91 % of JavaScript online submissions for Minimum Path Sum.\\n// Memory Usage: 41 MB, less than 46.37 % of JavaScript online submissions for Minimum Path Sum.\\n\\n//By doing this method, we can find the shortest distance for all the cell in the grid from the starting point.\\n\\nvar minPathSum = function (grid) {\\n    //loops through all the cell in the grid:\\n    for (let i = 0; i < grid.length; i++)\\n        for (let j = 0; j < grid[0].length; j++)\\n            // if the position is (0,0) ,pass it...\\n            if (i == 0 && j == 0)\\n                continue\\n            // if i=0 then update the grid[0][j] position value by (0,j) + (0,j-1) position\\'s value  { other_words:: current cell value + left cell of the current cell\\'s value in the grid }\\n            else if (i == 0)\\n                grid[i][j] += grid[i][j - 1];\\n            // if j=0 then update the grid[i][0] position value by (i,0) + (i-1,0) position\\'s value { other_words:: current cell value + top cell of the current cell\\'s value in the grid }\\n            else if (j == 0)\\n                grid[i][j] += grid[i - 1][j];\\n            // else (both i and j are not equal to zero)\\n            else\\n                // current cell value + left cell of the current cell\\'s value in the grid is smaller { < } then  current cell value + top cell of the current cell\\'s value in the grid\\n                //if true ,update the grid[i][j] value by current cell value + left cell of the current cell\\'s value in the grid\\n                if (grid[i][j] + grid[i][j - 1] < grid[i][j] + grid[i - 1][j])\\n                    grid[i][j] += grid[i][j - 1];\\n                //else ,update the grid[i][j] value by current cell value + top cell of the current cell\\'s value in the grid\\n                else\\n                    grid[i][j] += grid[i - 1][j];\\n    //return the last cell value \\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n\\nFor Example :\\n\\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___3____|___1____|\\n    |        |        |        |\\n    |___1____|___5____|___1____|\\n    |        |        | finish |\\n    |___4____|___2____|___1____|\\n\\t\\n\\tAt the end , grid is updated to the shortest distance sum from the starting point :\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___4____|___5____|\\n    |        |        |        |\\n    |___2____|___7____|___6____|\\n    |        |        | finish |\\n    |___6____|___8____|___7____|   return the last cell value  (7 in this case)\\n\\t\\n\\t\\tOutput: 7\\n\\t\\tExplanation: Because the path 1 \\u2192 3 \\u2192 1 \\u2192 1 \\u2192 1 minimizes the sum.\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369639,
                "title": "swift-minimum-path-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var dp = grid\\n        let rs = grid.count, cs = grid[0].count\\n        (1..<cs).forEach {\\n            dp[0][$0] += dp[0][$0-1]\\n        }\\n        (1..<rs).forEach {\\n            dp[$0][0] += dp[$0-1][0]\\n            for i in 1..<cs {\\n                dp[$0][i] += min(dp[$0-1][i], dp[$0][i-1])\\n            }\\n        }\\n        return dp[rs-1][cs-1]\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.036 (0.038) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.minPathSum([[1,3,1],[1,5,1],[4,2,1]])\\n        XCTAssertEqual(res, 7)\\n    }\\n    func test1() {\\n        let res = s.minPathSum([[1,2,3],[4,5,6]])\\n        XCTAssertEqual(res, 12)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var dp = grid\\n        let rs = grid.count, cs = grid[0].count\\n        (1..<cs).forEach {\\n            dp[0][$0] += dp[0][$0-1]\\n        }\\n        (1..<rs).forEach {\\n            dp[$0][0] += dp[$0-1][0]\\n            for i in 1..<cs {\\n                dp[$0][i] += min(dp[$0-1][i], dp[$0][i-1])\\n            }\\n        }\\n        return dp[rs-1][cs-1]\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.036 (0.038) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.minPathSum([[1,3,1],[1,5,1],[4,2,1]])\\n        XCTAssertEqual(res, 7)\\n    }\\n    func test1() {\\n        let res = s.minPathSum([[1,2,3],[4,5,6]])\\n        XCTAssertEqual(res, 12)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819102,
                "title": "evolve-from-recursion-to-dp",
                "content": "1.  brute force O(2^min(m,n)), dfs returns the min cost from i, j to bottom right.\\n```\\n\\tpublic int minPathSum(int[][] grid) {\\n        return dfs(0,0,grid);\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        int down=dfs(i+1,j,grid), right=dfs(i,j+1,grid);\\n        return Math.min(down,right)+grid[i][j];\\n    }\\n```\\n2. Memoization O(mn) \\n```\\n\\tpublic int minPathSum(int[][] grid) {\\n        Integer[][] mem=new Integer[grid.length][grid[0].length];\\n        return dfs(0,0,grid,mem);\\n    }\\n    private int dfs(int i, int j, int[][] grid, Integer[][] mem) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        if(mem[i][j]!=null) return mem[i][j];\\n        int down=dfs(i+1,j,grid,mem), right=dfs(i,j+1,grid,mem);\\n        return mem[i][j]=Math.min(down,right)+grid[i][j];\\n    }\\n```\\n3. dp O(mn) Time, O(mn) Space. From #1, f[i][j] = min(f[i+1][j],f[i][j+1]) + grid[i][j] \\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[][] dp=new int[r+1][c+1];\\n\\t\\tfor(int i=0;i<r-1;i++) dp[i][c]=Integer.MAX_VALUE;// dp[r-1][c]=0\\n        for(int i=0;i<c-1;i++) dp[r][i]=Integer.MAX_VALUE;// dp[r][c-1]=0\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[i][j]=Math.min(dp[i+1][j],dp[i][j+1])+grid[i][j];\\n        return dp[0][0];\\n    }\\n```\\n4. O(mn) Time, O(n) space dp\\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[] dp=new int[c+1];\\n\\t\\tArrays.fill(dp,Integer.MAX_VALUE);//row r\\n        dp[c-1]=0;\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[j]=Math.min(dp[j],dp[j+1])+grid[i][j];\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minPathSum(int[][] grid) {\\n        return dfs(0,0,grid);\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        int down=dfs(i+1,j,grid), right=dfs(i,j+1,grid);\\n        return Math.min(down,right)+grid[i][j];\\n    }\\n```\n```\\n\\tpublic int minPathSum(int[][] grid) {\\n        Integer[][] mem=new Integer[grid.length][grid[0].length];\\n        return dfs(0,0,grid,mem);\\n    }\\n    private int dfs(int i, int j, int[][] grid, Integer[][] mem) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        if(mem[i][j]!=null) return mem[i][j];\\n        int down=dfs(i+1,j,grid,mem), right=dfs(i,j+1,grid,mem);\\n        return mem[i][j]=Math.min(down,right)+grid[i][j];\\n    }\\n```\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[][] dp=new int[r+1][c+1];\\n\\t\\tfor(int i=0;i<r-1;i++) dp[i][c]=Integer.MAX_VALUE;// dp[r-1][c]=0\\n        for(int i=0;i<c-1;i++) dp[r][i]=Integer.MAX_VALUE;// dp[r][c-1]=0\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[i][j]=Math.min(dp[i+1][j],dp[i][j+1])+grid[i][j];\\n        return dp[0][0];\\n    }\\n```\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[] dp=new int[c+1];\\n\\t\\tArrays.fill(dp,Integer.MAX_VALUE);//row r\\n        dp[c-1]=0;\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[j]=Math.min(dp[j],dp[j+1])+grid[i][j];\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 585111,
                "title": "javascript-solution",
                "content": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minPathSum = function(grid) {\\n    const i = grid.length - 1\\n    const j = grid[0].length - 1\\n    \\n    for(let k = 0; k <= i; ++k) {\\n        for(let l = 0; l <= j; ++l) {\\n            if(k > 0 && l > 0)\\n                grid[k][l] = Math.min(grid[k][l] + grid[k][l - 1], grid[k - 1][l] + grid[k][l])\\n            else if(k > 0 || l > 0) {\\n                if(l > 0)\\n                    grid[k][l] += grid[k][l - 1]\\n                else\\n                    grid[k][l] += grid[k - 1][l]\\n                }   \\n        }\\n    }\\n    \\n    return grid[i][j]\\n};\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minPathSum = function(grid) {\\n    const i = grid.length - 1\\n    const j = grid[0].length - 1\\n    \\n    for(let k = 0; k <= i; ++k) {\\n        for(let l = 0; l <= j; ++l) {\\n            if(k > 0 && l > 0)\\n                grid[k][l] = Math.min(grid[k][l] + grid[k][l - 1], grid[k - 1][l] + grid[k][l])\\n            else if(k > 0 || l > 0) {\\n                if(l > 0)\\n                    grid[k][l] += grid[k][l - 1]\\n                else\\n                    grid[k][l] += grid[k - 1][l]\\n                }   \\n        }\\n    }\\n    \\n    return grid[i][j]\\n};\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324419,
                "title": "java-solution-using-bfs-priorityqueue",
                "content": "Should be more efficient when m >> n or n >> m.\\n```\\nclass Solution {\\n    \\n    final int[][] dirs = new int[][]{{0, 1},{1, 0}};\\n    \\n    public int minPathSum(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n]; // dp[i][j] min sum to reach grid[i][j].\\n        boolean[][] visited = new boolean[m][n];\\n        pq.add(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            for(int[] dir : dirs) {\\n                int row = curr[0] + dir[0];\\n                int col = curr[1] + dir[1];\\n                if(row < 0 || row >= m || col < 0 || col >= n || visited[row][col])\\n                    continue;\\n                int[] next = new int[]{row, col, curr[2] + grid[row][col]};\\n                if(next[0] == m - 1 && next[1] == n - 1)\\n                    return next[2];\\n                visited[row][col] = true;\\n                pq.add(next);\\n            }\\n        }\\n        return grid[0][0]; // never reach unless m == n == 1.\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    final int[][] dirs = new int[][]{{0, 1},{1, 0}};\\n    \\n    public int minPathSum(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n]; // dp[i][j] min sum to reach grid[i][j].\\n        boolean[][] visited = new boolean[m][n];\\n        pq.add(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            for(int[] dir : dirs) {\\n                int row = curr[0] + dir[0];\\n                int col = curr[1] + dir[1];\\n                if(row < 0 || row >= m || col < 0 || col >= n || visited[row][col])\\n                    continue;\\n                int[] next = new int[]{row, col, curr[2] + grid[row][col]};\\n                if(next[0] == m - 1 && next[1] == n - 1)\\n                    return next[2];\\n                visited[row][col] = true;\\n                pq.add(next);\\n            }\\n        }\\n        return grid[0][0]; // never reach unless m == n == 1.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132430,
                "title": "top-down-dp",
                "content": "```\\n// Iteratively - hard to implement:\\nfor each path from (0,0) to (m-1,n-1)\\n    maintain min sum path\\n\\n// Recursively - recursion formula:\\nminPathSumFrom(x, y) = min(grid[x][y] + minPathSumFrom(nx, ny))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\_ move down or right from (x, y)\\nreturn minPathSumFrom(0, 0)\\n\\n// Add memoization because:\\nminPathSumFrom(nx, ny) will be calculated for multiple times since we have different paths to reach (x, y)\\n```\\n****\\n**Top-down DP**\\n```\\nclass Solution {\\n    // Assume we can only move either down or right at any point in time\\n    private final int[][] dirs = {{0, 1}, {1, 0}};\\n    private Integer[][] memo;\\n    \\n    public int minPathSum(int[][] grid) {\\n        memo = new Integer[grid.length][grid[0].length];\\n        return minPathSumFrom(grid, 0, 0);\\n    }\\n    \\n    private int minPathSumFrom(int[][] grid, int x, int y) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1){\\n            return grid[x][y];\\n        } else {\\n            if (memo[x][y] != null)\\n                return memo[x][y];\\n            \\n            int min = Integer.MAX_VALUE;\\n            for (int[] dir : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx < grid.length && ny < grid[0].length) {\\n                    min = Math.min(grid[x][y] + minPathSumFrom(grid, nx, ny), min);\\n                }\\n            }\\n            \\n            memo[x][y] = min;\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Iteratively - hard to implement:\\nfor each path from (0,0) to (m-1,n-1)\\n    maintain min sum path\\n\\n// Recursively - recursion formula:\\nminPathSumFrom(x, y) = min(grid[x][y] + minPathSumFrom(nx, ny))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\_ move down or right from (x, y)\\nreturn minPathSumFrom(0, 0)\\n\\n// Add memoization because:\\nminPathSumFrom(nx, ny) will be calculated for multiple times since we have different paths to reach (x, y)\\n```\n```\\nclass Solution {\\n    // Assume we can only move either down or right at any point in time\\n    private final int[][] dirs = {{0, 1}, {1, 0}};\\n    private Integer[][] memo;\\n    \\n    public int minPathSum(int[][] grid) {\\n        memo = new Integer[grid.length][grid[0].length];\\n        return minPathSumFrom(grid, 0, 0);\\n    }\\n    \\n    private int minPathSumFrom(int[][] grid, int x, int y) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1){\\n            return grid[x][y];\\n        } else {\\n            if (memo[x][y] != null)\\n                return memo[x][y];\\n            \\n            int min = Integer.MAX_VALUE;\\n            for (int[] dir : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx < grid.length && ny < grid[0].length) {\\n                    min = Math.min(grid[x][y] + minPathSumFrom(grid, nx, ny), min);\\n                }\\n            }\\n            \\n            memo[x][y] = min;\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23610,
                "title": "go-golang-solution",
                "content": "    func minPathSum(grid [][]int) int {\\n        var m int = len(grid)\\n        var n int = len(grid[0])\\n        for i := 1; i < m; i++{\\n        \\tgrid[i][0] += grid[i-1][0];\\n        }\\n        for j := 1; j < n; j++{\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for i:= 1; i < m; i++{\\n            for j:=1; j<n; j++{\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n        \\n    }\\n    func min(a, b int) int {\\n        if a < b {\\n            return a\\n        }\\n        return b\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func minPathSum(grid [][]int) int {\\n        var m int = len(grid)\\n        var n int = len(grid[0])\\n        for i := 1; i < m; i++{\\n        \\tgrid[i][0] += grid[i-1][0];\\n        }\\n        for j := 1; j < n; j++{\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for i:= 1; i < m; i++{\\n            for j:=1; j<n; j++{\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n        \\n    }\\n    func min(a, b int) int {\\n        if a < b {\\n            return a\\n        }\\n        return b\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23621,
                "title": "python-solution-dp-52-ms",
                "content": "The fastest time: `52 ms,beats 100.00% ` . \\n\\n    def minPathSum(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        for i in xrange(m):\\n            dp[0] += grid[i][0]\\n            for j in xrange(1, n):\\n                dp[j] = (min(dp[j], dp[j-1]) or dp[j-1]) + grid[i][j]\\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "The fastest time: `52 ms,beats 100.00% ` . \\n\\n    def minPathSum(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        for i in xrange(m):\\n            dp[0] += grid[i][0]\\n            for j in xrange(1, n):\\n                dp[j] = (min(dp[j], dp[j-1]) or dp[j-1]) + grid[i][j]\\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23715,
                "title": "my-accepted-solution-in-java",
                "content": "In order to get the minimum sum to get to grid(m-1,n-1);\\n\\nSo we should get the minimum sum both  grid(m-1,n-1-1) and grid(m-1-1,n-1),\\n\\nSo that could convert to(I using every space in grid to hold the minimum sum get to grid(i,j))\\n\\n                               min( grid(i-1,j) , grid(i,j-1) ) + grid(i,j)                 i>0 && j>0\\n                       /  \\n          grid(i,j)=   |       grid(i,j-1)+grid(i,j)                                        i=0 && j>0\\n                       |  \\n                       |       grid(i-1,j)+grid(i,j)                                        i>0 && j=0 \\n                       \\\\  \\n                               grid(0,0)                                                    i=0 && j=0\\n                          \\n\\nFinally, the grid(m-1,n-1) is the result\\n\\nHope you can get my point :)\\n\\n\\n\\n    public class Solution {\\n        \\n        public int min(int a,int b)\\n        {\\n            return a>b?b:a;\\n        }\\n        \\n        public int minPathSum(int[][] grid) {\\n            if(grid.length==0) return 0;\\n            int m=grid.length;\\n            int n=grid[0].length;\\n            int[][] res=new int[grid.length][];\\n            for(int i=0;i<res.length;i++)\\n            {\\n                res[i]=Arrays.copyOf(grid[i],grid[i].length);\\n            }\\n            for(int i=1;i<n;i++)\\n            {\\n                res[0][i]+=res[0][i-1];\\n            }\\n            for(int i=1;i<m;i++)\\n            {\\n                res[i][0]+=res[i-1][0];\\n            }\\n            for(int i=1;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    res[i][j]+=min(res[i][j-1],res[i-1][j]);\\n                }\\n            }\\n            return res[m-1][n-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public int min(int a,int b)\\n        {\\n            return a>b?b:a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3771191,
                "title": "unlocking-optimal-time-complexity-with-memoization-tabulation-and-space-optimization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // below is the function for recusion+memoization\\n    int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& DP)\\n    {\\n        if(i==0 && j==0)\\n            return grid[0][0];\\n        if(i<0 || j<0)\\n            return INT_MAX;\\n        if(DP[i][j] != -1)\\n            return DP[i][j];\\n        //here we need to take care if our solve function is returning INT_MAX and we adds grid[i][0] to it there will be integer overflow so I handled that only\\n        int up = (solve(i-1,j,grid,DP)==INT_MAX)?INT_MAX:(solve(i-1,j,grid,DP)+grid[i][j]);\\n        int left = (solve(i,j-1,grid,DP)==INT_MAX)?INT_MAX:(solve(i,j-1,grid,DP)+grid[i][j]);\\n\\n        return DP[i][j] = min(up,left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> DP(m,vector<int> (n,-1));\\n        // return solve(m-1,n-1,grid,DP);\\n\\n        // this below code if of tabulation\\n        // for(int i=0;i<m;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         if(i==0 && j==0)\\n        //         {\\n        //             DP[i][j] = grid[0][0];\\n        //         }\\n        //         else\\n        //         {\\n        //             int up = INT_MAX;\\n        //             int left = INT_MAX;\\n        //             if(i>0)\\n        //                 up = DP[i-1][j] + grid[i][j]; \\n        //             if(j>0)\\n        //                 left = DP[i][j-1] + grid[i][j]; \\n        //             DP[i][j] = min(up,left);\\n        //         }\\n        //     }\\n        // }\\n        // return DP[m-1][n-1];\\n\\n\\n        // below is the code for space optimization\\n        // all we need is prev row and the current row on which we are doing operations\\n        vector<int> prev(n,-1);\\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int> curr(n,-1);\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    curr[j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    int up = INT_MAX;\\n                    int left = INT_MAX;\\n                    if(i>0)\\n                        up = prev[j] + grid[i][j]; \\n                    if(j>0)\\n                        left = curr[j-1] + grid[i][j]; \\n                    curr[j] = min(up,left);\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // below is the function for recusion+memoization\\n    int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& DP)\\n    {\\n        if(i==0 && j==0)\\n            return grid[0][0];\\n        if(i<0 || j<0)\\n            return INT_MAX;\\n        if(DP[i][j] != -1)\\n            return DP[i][j];\\n        //here we need to take care if our solve function is returning INT_MAX and we adds grid[i][0] to it there will be integer overflow so I handled that only\\n        int up = (solve(i-1,j,grid,DP)==INT_MAX)?INT_MAX:(solve(i-1,j,grid,DP)+grid[i][j]);\\n        int left = (solve(i,j-1,grid,DP)==INT_MAX)?INT_MAX:(solve(i,j-1,grid,DP)+grid[i][j]);\\n\\n        return DP[i][j] = min(up,left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> DP(m,vector<int> (n,-1));\\n        // return solve(m-1,n-1,grid,DP);\\n\\n        // this below code if of tabulation\\n        // for(int i=0;i<m;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         if(i==0 && j==0)\\n        //         {\\n        //             DP[i][j] = grid[0][0];\\n        //         }\\n        //         else\\n        //         {\\n        //             int up = INT_MAX;\\n        //             int left = INT_MAX;\\n        //             if(i>0)\\n        //                 up = DP[i-1][j] + grid[i][j]; \\n        //             if(j>0)\\n        //                 left = DP[i][j-1] + grid[i][j]; \\n        //             DP[i][j] = min(up,left);\\n        //         }\\n        //     }\\n        // }\\n        // return DP[m-1][n-1];\\n\\n\\n        // below is the code for space optimization\\n        // all we need is prev row and the current row on which we are doing operations\\n        vector<int> prev(n,-1);\\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int> curr(n,-1);\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    curr[j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    int up = INT_MAX;\\n                    int left = INT_MAX;\\n                    if(i>0)\\n                        up = prev[j] + grid[i][j]; \\n                    if(j>0)\\n                        left = curr[j-1] + grid[i][j]; \\n                    curr[j] = min(up,left);\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346652,
                "title": "cpp-solution-using-graph-bfs-dijkstra-greedy",
                "content": "I used the greedy approach along with Dijkstra to reach the destination node with lowest path sum possible.\\n\\n* Used the Priority Queue (to create min-heap) to get the lowest possible path sum node out from the queue.\\n* Priority Queue store in the format: `{pathSum,{row,col}}`\\n* Created the **vis** array to store the lowest path sum along each path.\\n* Then a simple **BFS** along every possible node and storing the min pathSum for the node in **vis** array.\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,1e9));\\n        typedef pair<int,pair<int,int>> pi;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n\\t\\tint pathSum0 = grid[0][0];\\n        pq.push({pathSum0,{0,0}});\\n        \\n        int delr[] = {1,0};\\n        int delc[] = {0,1};\\n        \\n        while(!pq.empty()){\\n            int val = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n            \\n\\t\\t\\t// Destination Node\\n            if(row==n-1 and col==m-1) return val;\\n            \\n\\t\\t\\t// checking for adjacent possible node\\n            for(int i=0;i<2;i++){\\n                int newr = row+delr[i];\\n                int newc = col+delc[i];\\n                \\n\\t\\t\\t\\t// Checking for valid nodes\\n                if(newr>=0 and newr<n and newc>=0 and newc<m){\\n\\t\\t\\t\\t\\tint pathSum=val+grid[newr][newc];\\n                    if(pathSum<vis[newr][newc]){\\n                        vis[newr][newc]=pathSum;\\n                        pq.push({pathSum,{newr,newc}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,1e9));\\n        typedef pair<int,pair<int,int>> pi;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n\\t\\tint pathSum0 = grid[0][0];\\n        pq.push({pathSum0,{0,0}});\\n        \\n        int delr[] = {1,0};\\n        int delc[] = {0,1};\\n        \\n        while(!pq.empty()){\\n            int val = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n            \\n\\t\\t\\t// Destination Node\\n            if(row==n-1 and col==m-1) return val;\\n            \\n\\t\\t\\t// checking for adjacent possible node\\n            for(int i=0;i<2;i++){\\n                int newr = row+delr[i];\\n                int newc = col+delc[i];\\n                \\n\\t\\t\\t\\t// Checking for valid nodes\\n                if(newr>=0 and newr<n and newc>=0 and newc<m){\\n\\t\\t\\t\\t\\tint pathSum=val+grid[newr][newc];\\n                    if(pathSum<vis[newr][newc]){\\n                        vis[newr][newc]=pathSum;\\n                        pq.push({pathSum,{newr,newc}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345844,
                "title": "python-3-7-lines-prefix-array-w-explanation-t-m-95-81",
                "content": "For this discussion, let`grid = [[1,3,1,2],[1,5,1,2],[4,2,1,3]]`(Figure 1 below). The general plan is to overwrite`grid`with a prefix array based on the minimum cost at each cell in`grid`.\\n\\nHere are the steps:\\n\\n1. We start with the first row and first column. Because only down and right moves are permitted, the paths to the [2,0] and [0,3] are straightforward. (Figure 2).\\n\\n2. Finally we iterate through`grid`, updating each cell with the sum of the cell\\'s value and the minimum of the cell above and the cell to the left of it (Figure 3).\\n3. The value at the end cell is returned as the minimum path sum (Figure 4).\\n\\n \\n![Untitled.jpg](https://assets.leetcode.com/users/images/8bf67e06-c194-4b35-9718-a5803e0e843f_1679890563.3292673.jpeg)\\n\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid), len(grid[0])\\n        M, N = range(1,m),range(1,n)\\n\\n        for i in N: grid[0][i] += grid[0][i - 1]            #  \\n                                                            # <\\u2013\\u2013 1.\\n        for j in M: grid[j][0] += grid[j - 1][0]            #\\n\\n        for i, j in product(M,N):\\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])   # <\\u2013\\u2013 2.\\n\\n        return grid[m-1][n-1]                               # <\\u2013\\u2013 3.\\n```\\n[https://leetcode.com/problems/minimum-path-sum/submissions/922719112/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid), len(grid[0])\\n        M, N = range(1,m),range(1,n)\\n\\n        for i in N: grid[0][i] += grid[0][i - 1]            #  \\n                                                            # <\\u2013\\u2013 1.\\n        for j in M: grid[j][0] += grid[j - 1][0]            #\\n\\n        for i, j in product(M,N):\\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])   # <\\u2013\\u2013 2.\\n\\n        return grid[m-1][n-1]                               # <\\u2013\\u2013 3.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345625,
                "title": "daily-leetcoding-challenge-march-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming 2D\n\n  \n**Approach 3:** Dynamic Programming 1D\n\n  \n**Approach 4:** Dynamic Programming (Without Extra Space)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 4:** Dynamic Programming (Without Extra Space)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3055440,
                "title": "beats-100-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& v) {\\n         int n = v.size(), m= v[0].size();\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    curr[j] = v[0][0];\\n                }\\n                else{\\n              int up =v[i][j] , left = v[i][j] ;\\n              if(i>0) up += prev[j];\\n\\n              else up += 1e9;\\n\\n        \\t   if(j>0) left += curr[j-1];\\n\\n        \\t   else left += 1e9;\\n        \\t  \\n        \\t    curr[j] = min(up,left) ;\\n            }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& v) {\\n         int n = v.size(), m= v[0].size();\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    curr[j] = v[0][0];\\n                }\\n                else{\\n              int up =v[i][j] , left = v[i][j] ;\\n              if(i>0) up += prev[j];\\n\\n              else up += 1e9;\\n\\n        \\t   if(j>0) left += curr[j-1];\\n\\n        \\t   else left += 1e9;\\n        \\t  \\n        \\t    curr[j] = min(up,left) ;\\n            }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810588,
                "title": "accepted-worst-to-most-optimised-approaches-easy-to-understand",
                "content": "# Approach 1: Recursion (TLE)\\n\\nStep 1: Take i and j variable initilaise both as 0, That will be or starting path for given matrix. Call solve fucntion.\\n\\nStep 2: (Base case) check if i and j are last box index then return grid [i][j];\\n\\nStep 3: Take down and right int variable initialize both as INT_MAX\\n* Check if we can jump to right side in our matrix range then check for right path and call same fuction with j+1\\n* Check if we can jump to down side in our matrix range then check for down path and call same fuction with i+1.\\n\\nStep 4: return sum of current grid[i][j] and min of either down or right value.\\n \\n\\n**Time Complexity: O(N * M)**\\n* **Reason:** At max, there will be N*M calls of recursion.\\n\\n**Space Complexity: O((M-1)+(N-1)) + O(N*M)**\\n* **Reason:** We are using a recursion stack space:O((M-1)+(N-1)), here (M-1)+(N-1) is the path length\\n\\n**Recrusive Tree**\\n![MicrosoftTeams-image (69).png](https://assets.leetcode.com/users/images/6a545a74-9c08-4ae1-91f7-47ed1ab11761_1668339452.307515.jpeg)\\n\\n\\n**C++ Code: (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n\\n        int down=INT_MAX,right=INT_MAX;\\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid);\\n\\n        return grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        return solve(0,0,n,m,grid);\\n    }\\n};\\n```\\n\\n**Approach 2: Memoization (Accepted)**\\nwe have see that there are overlapping subproblems in recursive. In order to convert a recursive solution the following steps will be taken:\\n\\n1. Create a dp array of size [n][m]\\n2. Whenever we want to find the answer of a particular row and column (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.\\n3. If not, then we are finding the answer for the given values for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.\\n\\n**Time Complexity: O(N*M)**\\n* **Reason:** At max, there will be N*M calls of recursion.\\n\\n**Space Complexity: O((M-1)+(N-1)) + O(N*M)**\\n* **Reason:** We are using a recursion stack space:O((M-1)+(N-1)), here (M-1)+(N-1) is the path length and an external DP Array of size \\u2018N*M\\u2019\\n\\n**C++ Code (Accepted)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down=INT_MAX,right=INT_MAX;\\n        \\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid,dp);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid,dp);\\n\\n        return dp[i][j]=grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,grid,dp);\\n    }\\n};\\n```\\n\\n**Approach 3: Tabulation (Accepted)**\\nTabulation is the bottom-up approach, which means we will go from the base case to the main problem.\\n\\nThe steps to convert to the tabular solution are given below:\\n\\n1. Declare a dp[] array of size [n][m].\\n2. First initialize the base condition values, i.e dp[n-1][m-1] = matrix[n-1][m-1]\\n3. Our answer should get stored in dp[0][0]. We want to move from (n-1,m-1) to (0,0). But we can\\u2019t move arbitrarily, we should move such that at a particular i and j, we have all the values required to compute dp[i][j].\\n4. If we see the memoized code, values required for dp[i][j] are: dp[i+1][j] and dp[i][j+1]. So we only use the next row and column value.\\n5. We have already filled the bottom-right corner (i=n-1 and j=m-1), if we move in any of the two following ways(given below), at every cell we do have all the previous values required to compute its value.\\n5. We can use two nested loops to have this traversal\\n6. Whenever i<n , j<n, we will simply mark dp[i][j] = matric[i][j] + min(dp[i+1][j],dp[i][j+1]), according to our recursive relation.\\n7. When i=n or j=m, we add to down OR right as INT_MAX, so that this path can be rejected.\\n\\n**Time Complexity: O(N*M)**\\n- **Reason:** There are two nested loops\\n\\n**Space Complexity: O(N*M)**\\n- **Reason:** We are using an external array of size \\u2018N*M\\u2019\\u2019.\\n\\n**Paper Dry run:**\\n![MicrosoftTeams-image (67).png](https://assets.leetcode.com/users/images/5645c7e7-bdd7-464a-8595-42391ac8c27c_1668338853.526015.jpeg)\\n\\n\\n**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=dp[i+1][j];\\n                    if(j+1<m)\\n                        right=dp[i][j+1];\\n                    dp[i][j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n**Approach 4: Space optimised (Accepted most Optimised)**\\nIf we closely look the relation,\\n- dp[i][j] = grid[i][j] + min(dp[i+1][j] + dp[i][j+1]))\\n\\nWe see that we only need the next row and column, in order to calculate dp[i][j]. Therefore we can space optimize it.\\n\\n1. Initially, we can take a dummy row ( say prevRow) and initialize it as 0.\\n2. Now the current row(say CurrRow) only needs the next row value and the current row\\u2019s value in order to calculate dp[i][j].\\n\\n![MicrosoftTeams-image (68).png](https://assets.leetcode.com/users/images/b2caf957-e9d4-4a87-bc3b-75e66d420245_1668339394.1703806.jpeg)\\n\\n3. At the next step, the currRow array becomes the prevRow of the next step and using its values we can still calculate the next row\\u2019s values.\\n4. At last prevRow[0] will give us the required answer.\\n\\n**Time Complexity: O(M*N)**\\n- **Reason:** There are two nested loops\\n\\n**Space Complexity: O(N)**\\n- **Reason:** We are using an external array of size \\u2018N\\u2019 to store only one row.\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> prevRow(m+1,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            vector<int> currRow(m+1,0);\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    currRow[j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=prevRow[j];\\n                    if(j+1<m)\\n                        right=currRow[j+1];\\n                    currRow[j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n            prevRow=currRow;\\n        }\\n        \\n        return prevRow[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n\\n        int down=INT_MAX,right=INT_MAX;\\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid);\\n\\n        return grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        return solve(0,0,n,m,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down=INT_MAX,right=INT_MAX;\\n        \\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid,dp);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid,dp);\\n\\n        return dp[i][j]=grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,grid,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=dp[i+1][j];\\n                    if(j+1<m)\\n                        right=dp[i][j+1];\\n                    dp[i][j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> prevRow(m+1,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            vector<int> currRow(m+1,0);\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    currRow[j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=prevRow[j];\\n                    if(j+1<m)\\n                        right=currRow[j+1];\\n                    currRow[j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n            prevRow=currRow;\\n        }\\n        \\n        return prevRow[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693577,
                "title": "c-easy-fast-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693571,
                "title": "c-easy-and-fast-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766321,
                "title": "c-3-solutions-recursive-memoization-tabulation",
                "content": "**1. Recursion**\\n```\\nint calculate(int row, int col, vector<vector<int>> &grid) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return 101;\\n    int left = calculate(row, col - 1, grid) + grid[row][col];\\n    int up = calculate(row - 1, col, grid) + grid[row][col];\\n    return min(left, up);\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    return calculate(row - 1, col - 1, grid);\\n}\\n```\\n\\n**2. Memoization**\\n```\\nint calculate(int row, int col, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return INT_MAX;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = calculate(row, col - 1, grid, dp);\\n    int up = calculate(row - 1, col, grid, dp);\\n    return dp[row][col] = min(left, up) + grid[row][col];\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return calculate(row - 1, col - 1, grid, dp);\\n}\\n```\\n\\n**3. Tabulation**\\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n            else {\\n                int left = INT_MAX, up = INT_MAX;\\n                if(i > 0) up = min(up, dp[i - 1][j]);\\n                if(j > 0) left = min(left, dp[i][j - 1]);\\n                \\n                dp[i][j] = min(up, left) + grid[i][j];\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint calculate(int row, int col, vector<vector<int>> &grid) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return 101;\\n    int left = calculate(row, col - 1, grid) + grid[row][col];\\n    int up = calculate(row - 1, col, grid) + grid[row][col];\\n    return min(left, up);\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    return calculate(row - 1, col - 1, grid);\\n}\\n```\n```\\nint calculate(int row, int col, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return INT_MAX;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = calculate(row, col - 1, grid, dp);\\n    int up = calculate(row - 1, col, grid, dp);\\n    return dp[row][col] = min(left, up) + grid[row][col];\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return calculate(row - 1, col - 1, grid, dp);\\n}\\n```\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n            else {\\n                int left = INT_MAX, up = INT_MAX;\\n                if(i > 0) up = min(up, dp[i - 1][j]);\\n                if(j > 0) left = min(left, dp[i][j - 1]);\\n                \\n                dp[i][j] = min(up, left) + grid[i][j];\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401676,
                "title": "c-dp-space-o-1-time-o-m-n",
                "content": "Please upvote if it was helpful.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minPathSum(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size(), n = grid[0].size();\\n\\t\\t\\tfor(int i=1; i<m; i++){\\n\\t\\t\\t\\tgrid[i][0] += grid[i-1][0];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int j=1; j<n; j++){\\n\\t\\t\\t\\tgrid[0][j] += grid[0][j-1];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1; i<m; i++){\\n\\t\\t\\t\\tfor(int j=1; j<n; j++){\\n\\t\\t\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn grid[m-1][n-1];\\n\\t\\t}\\n\\t};\\nThank You!!",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minPathSum(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size(), n = grid[0].size();\\n\\t\\t\\tfor(int i=1; i<m; i++){\\n\\t\\t\\t\\tgrid[i][0] += grid[i-1][0];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1361958,
                "title": "c-solution-for-64-minimum-path-sum-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {   \\n        int m = grid.size(); int n = grid[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0 && j==0){ dp[0][0] = grid[0][0]; }\\n                else if(i==0){ dp[0][j] = dp[0][j-1] + grid[0][j]; }\\n                else if(j==0){ dp[i][0] = dp[i-1][0] + grid[i][0]; }\\n                else\\n                {\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] ; \\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {   \\n        int m = grid.size(); int n = grid[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0 && j==0){ dp[0][0] = grid[0][0]; }\\n                else if(i==0){ dp[0][j] = dp[0][j-1] + grid[0][j]; }\\n                else if(j==0){ dp[i][0] = dp[i-1][0] + grid[i][0]; }\\n                else\\n                {\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] ; \\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231754,
                "title": "c-dynamic-programming-short-and-easy-approach",
                "content": "class Solution {\\npublic:\\n**The idea is to traverse from right to left (starting from bottom to top).\\nEach cell of the dp will contain cost to reach the end cell.**\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int dp[row][col];\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1 ; j>=0 ; j--){\\n                if(i==row-1 and j==col-1){ //means we are at end cell\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else if(i==row-1){  //means we are at last row\\n                    dp[i][j]=grid[i][j]+dp[i][j+1];\\n                }\\n                else if(j==col-1){ //means we are at last col\\n                    dp[i][j]=grid[i][j]+dp[i+1][j];\\n                }\\n                else{  //rest of the cell\\n                    dp[i][j] = grid[i][j] + min(dp[i+1][j],dp[i][j+1]);\\n                }\\n                \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n**The idea is to traverse from right to left (starting from bottom to top).\\nEach cell of the dp will contain cost to reach the end cell.**\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int dp[row][col];\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1 ; j>=0 ; j--){\\n                if(i==row-1 and j==col-1){ //means we are at end cell\\n                    dp[i][j]=grid[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1111685,
                "title": "c-dp-minimum-path-sum",
                "content": "```int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        dp[n-1][m-1]=grid[n-1][m-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[n-1][i]=grid[n-1][i]+dp[n-1][i+1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[i][m-1]=grid[i][m-1]+dp[i+1][m-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=grid[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n            }\\n        }\\n        return dp[0][0];```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        dp[n-1][m-1]=grid[n-1][m-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[n-1][i]=grid[n-1][i]+dp[n-1][i+1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[i][m-1]=grid[i][m-1]+dp[i+1][m-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=grid[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n            }\\n        }\\n        return dp[0][0];```",
                "codeTag": "Unknown"
            },
            {
                "id": 652173,
                "title": "python-dp",
                "content": "Python version:\\n\\n``` \\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n    \\n        n = len(grid)\\n        m = len(grid[0])\\n       \\n        # Edit the first row:\\n        for i in range(1, m):\\n            grid[0][i] = grid[0][i-1] + grid[0][i]\\n        \\n        # Edit the first col:\\n        for i in range(1, n):\\n            grid[i][0] = grid[i-1][0] + grid[i][0]\\n        \\n        # Edit the remaining values in the grid accordingly!\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]\\n        \\n        \\n        return grid[-1][-1]\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n    \\n        n = len(grid)\\n        m = len(grid[0])\\n       \\n        # Edit the first row:\\n        for i in range(1, m):\\n            grid[0][i] = grid[0][i-1] + grid[0][i]\\n        \\n        # Edit the first col:\\n        for i in range(1, n):\\n            grid[i][0] = grid[i-1][0] + grid[i][0]\\n        \\n        # Edit the remaining values in the grid accordingly!\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]\\n        \\n        \\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645575,
                "title": "all-possible-solution-with-c-code-brute-force-memoization-and-bottom-up",
                "content": "***Brute Force***\\n```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    return grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1),findMinSumInGrid(grid,row,col,currRow+1,currCol));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        return findMinSumInGrid(grid,row,col,0,0);\\n    \\n    }\\n};\\n```\\n\\n***memoization***\\n```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol,vector<vector<int>>& dp){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    if(dp[currRow][currCol] != -1)  return dp[currRow][currCol];\\n    \\n    return dp[currRow][currCol] = grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1,dp),findMinSumInGrid(grid,row,col,currRow+1,currCol,dp));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return findMinSumInGrid(grid,row,col,0,0,dp);\\n    \\n    }\\n};\\n```\\n***Bottom up***\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //bottom up approach for the problem\\n        //space complexity will be O(n*m)\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> dp(row,vector<int> (col,0));\\n        \\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                \\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }else{\\n                    if(i == 0){\\n                        dp[i][j] = grid[i][j] + dp[i][j-1];\\n                    }else{\\n                        if(j == 0){\\n                            dp[i][j] = grid[i][j] + dp[i-1][j];\\n                        }else{\\n                            dp[i][j] = grid[i][j] + min(dp[i-1][j],dp[i][j-1]);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[row-1][col-1];\\n    }\\n};\\n```\\nhope it helps!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    return grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1),findMinSumInGrid(grid,row,col,currRow+1,currCol));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        return findMinSumInGrid(grid,row,col,0,0);\\n    \\n    }\\n};\\n```\n```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol,vector<vector<int>>& dp){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    if(dp[currRow][currCol] != -1)  return dp[currRow][currCol];\\n    \\n    return dp[currRow][currCol] = grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1,dp),findMinSumInGrid(grid,row,col,currRow+1,currCol,dp));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return findMinSumInGrid(grid,row,col,0,0,dp);\\n    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //bottom up approach for the problem\\n        //space complexity will be O(n*m)\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> dp(row,vector<int> (col,0));\\n        \\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                \\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }else{\\n                    if(i == 0){\\n                        dp[i][j] = grid[i][j] + dp[i][j-1];\\n                    }else{\\n                        if(j == 0){\\n                            dp[i][j] = grid[i][j] + dp[i-1][j];\\n                        }else{\\n                            dp[i][j] = grid[i][j] + min(dp[i-1][j],dp[i][j-1]);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[row-1][col-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586683,
                "title": "c-iterative-dp",
                "content": "```\\n/*I\\'m going to solve it by iterative dynamic programming\\n\\nfor iterative DP base cases shuld be filled \\n\\nbase cases are in this problem is that you can fill first row and first column the reson behind it is that you don\\'t have multiple path to reach there\\n\\nso for sample test case dp array would be look like\\n\\n1 4 5 (1,1+3,1+3+1)\\n2 \\n6\\n(\\n1,\\n1+1,\\n1+1+4\\n)\\n\\nnow iteratively I\\'m going to fell other enteries if I want to fill dp[i][j] it is obvious that i reach i,j from i-1,j or i,j-1 so I will take min of them and add it into grid[i][j]\\n\\n1 4 5\\n2 7\\n6\\n\\n1 4 5\\n2 7 6\\n6\\n\\n1 4 5\\n2 7 6\\n6 8 \\n\\n1 4 5\\n2 7 6\\n6 8 7\\n\\n7 is answer\\n\\n*/\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int** dp=new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i]=new int[n];\\n        }\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+grid[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n        int ans=dp[m-1][n-1];\\n        for(int i=0;i<grid.size();i++){\\n            delete[] dp[i];\\n        }\\n        delete[] dp;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*I\\'m going to solve it by iterative dynamic programming\\n\\nfor iterative DP base cases shuld be filled \\n\\nbase cases are in this problem is that you can fill first row and first column the reson behind it is that you don\\'t have multiple path to reach there\\n\\nso for sample test case dp array would be look like\\n\\n1 4 5 (1,1+3,1+3+1)\\n2 \\n6\\n(\\n1,\\n1+1,\\n1+1+4\\n)\\n\\nnow iteratively I\\'m going to fell other enteries if I want to fill dp[i][j] it is obvious that i reach i,j from i-1,j or i,j-1 so I will take min of them and add it into grid[i][j]\\n\\n1 4 5\\n2 7\\n6\\n\\n1 4 5\\n2 7 6\\n6\\n\\n1 4 5\\n2 7 6\\n6 8 \\n\\n1 4 5\\n2 7 6\\n6 8 7\\n\\n7 is answer\\n\\n*/\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int** dp=new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i]=new int[n];\\n        }\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+grid[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n        int ans=dp[m-1][n-1];\\n        for(int i=0;i<grid.size();i++){\\n            delete[] dp[i];\\n        }\\n        delete[] dp;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584858,
                "title": "python-straightforward-recursion-with-caching",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        maxx,maxy = len(grid),len(grid[0])\\n        cache={}\\n        \\n        def mPS(x,y):\\n            if x+1==maxx and y+1==maxy:\\n                return grid[x][y]            \\n            if x+1<maxx and y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+min(mPS(x+1,y),mPS(x,y+1))\\n            elif x+1<maxx:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x+1,y)\\n            elif y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x,y+1)\\n            return cache[(x,y)]\\n            \\n        return mPS(0,0)  \\n```\\n\\nPretty much self explanatory.\\n\\nRecursion ends when we hit the last cell. Otherwise we recursively try cells caching results along the way.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        maxx,maxy = len(grid),len(grid[0])\\n        cache={}\\n        \\n        def mPS(x,y):\\n            if x+1==maxx and y+1==maxy:\\n                return grid[x][y]            \\n            if x+1<maxx and y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+min(mPS(x+1,y),mPS(x,y+1))\\n            elif x+1<maxx:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x+1,y)\\n            elif y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x,y+1)\\n            return cache[(x,y)]\\n            \\n        return mPS(0,0)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 574715,
                "title": "java-o-n-in-place-no-recursion-simple-with-explaination",
                "content": "Since we don\\'t have any blocked squares, we can iterate through the entire array of arrays and find the minimum possible ways to reach from everywhere.\\nInstead of using another storage block, here we cumulatively add the values to the next cells and initialize the first row and first columns.\\nFor all the internal cells, we add the minimum value to reach from top or left, whichever is smaller.\\nAt the end, return the last cell which was our destination.\\n\\nThe time complexity is O(n) where n is the number of cells in the matrix. The space complexity is O(1) because no additional space is used.\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 1; i < grid.length; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j = 1; j < grid[0].length; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i = 1; i < grid.length; i++){\\n            for(int j = 1; j < grid[0].length; j++){\\n                grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```\\n\\n**Please upvote the solution if you found it helpful.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 1; i < grid.length; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j = 1; j < grid[0].length; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i = 1; i < grid.length; i++){\\n            for(int j = 1; j < grid[0].length; j++){\\n                grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321325,
                "title": "java-two-solutions-memorization-and-dp",
                "content": "1. Recursion with memorization\\n```java\\n    public int minPathSum(int[][] grid) {\\n        // boundary check\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        for (int[] r : cache) Arrays.fill(r, -1);\\n        \\n        // fill cache\\n        cache[0][0] = grid[0][0];\\n        dfs(row - 1, col - 1, grid, cache);\\n\\t\\t\\n\\t\\t// return result\\n        return cache[row - 1][col - 1];\\n    }\\n    \\n    public int dfs(int m, int n, int[][] grid, int[][] cache) {\\n        // reach to edge row or col, just return the max int to get row or col value\\n        if (m < 0 || n < 0) return Integer.MAX_VALUE; \\n\\t\\t// return grid[0][0]\\n        if (m == 0 && n == 0) return grid[m][n]; \\n\\t\\t// recursively compute min value if it\\'s not recorded in cache\\n        if (cache[m][n] == -1) \\n            cache[m][n] = grid[m][n] + Math.min(dfs(m - 1, n, grid, cache), dfs(m, n - 1, grid, cache));\\n        return cache[m][n];\\n    }\\n```\\n\\n2. DP\\n```java\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        cache[0][0] = grid[0][0];\\n\\n        // fill first row\\n        for (int i = 1; i < col; i++) {\\n            cache[0][i] = cache[0][i - 1] + grid[0][i];\\n        }\\n\\n        // fill first col\\n        for (int i = 1; i < row; i++) {\\n            cache[i][0] = cache[i - 1][0] + grid[i][0];\\n        }\\n\\n        // fill intermediate grid\\n        for(int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                cache[i][j] = grid[i][j] + Math.min(cache[i - 1][j], cache[i][j - 1]);\\n            }\\n        }\\n        return cache[row - 1][col - 1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int minPathSum(int[][] grid) {\\n        // boundary check\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        for (int[] r : cache) Arrays.fill(r, -1);\\n        \\n        // fill cache\\n        cache[0][0] = grid[0][0];\\n        dfs(row - 1, col - 1, grid, cache);\\n\\t\\t\\n\\t\\t// return result\\n        return cache[row - 1][col - 1];\\n    }\\n    \\n    public int dfs(int m, int n, int[][] grid, int[][] cache) {\\n        // reach to edge row or col, just return the max int to get row or col value\\n        if (m < 0 || n < 0) return Integer.MAX_VALUE; \\n\\t\\t// return grid[0][0]\\n        if (m == 0 && n == 0) return grid[m][n]; \\n\\t\\t// recursively compute min value if it\\'s not recorded in cache\\n        if (cache[m][n] == -1) \\n            cache[m][n] = grid[m][n] + Math.min(dfs(m - 1, n, grid, cache), dfs(m, n - 1, grid, cache));\\n        return cache[m][n];\\n    }\\n```\n```java\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        cache[0][0] = grid[0][0];\\n\\n        // fill first row\\n        for (int i = 1; i < col; i++) {\\n            cache[0][i] = cache[0][i - 1] + grid[0][i];\\n        }\\n\\n        // fill first col\\n        for (int i = 1; i < row; i++) {\\n            cache[i][0] = cache[i - 1][0] + grid[i][0];\\n        }\\n\\n        // fill intermediate grid\\n        for(int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                cache[i][j] = grid[i][j] + Math.min(cache[i - 1][j], cache[i][j - 1]);\\n            }\\n        }\\n        return cache[row - 1][col - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 185358,
                "title": "easy-recursive-solution-with-memo-java",
                "content": "```\\n    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < memo.length; i++){\\n            Arrays.fill(memo[i],Integer.MAX_VALUE);\\n        }\\n        return dfs(grid,0,0,memo);\\n\\n    }\\n    \\n    private int dfs(int[][] grid,int i, int j, int[][] memo){\\n        if( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length )\\n            return Integer.MAX_VALUE;\\n        else if(memo[i][j] != Integer.MAX_VALUE)\\n            return memo[i][j];\\n        else if(i == grid.length - 1  && j == grid[0].length -1)\\n            return grid[i][j];\\n         else \\n            memo[i][j] = grid[i][j] + Math.min(dfs(grid, i + 1, j,memo),dfs(grid, i, j + 1,memo));\\n        \\n        return memo[i][j];\\n        \\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < memo.length; i++){\\n            Arrays.fill(memo[i],Integer.MAX_VALUE);\\n        }\\n        return dfs(grid,0,0,memo);\\n\\n    }\\n    \\n    private int dfs(int[][] grid,int i, int j, int[][] memo){\\n        if( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length )\\n            return Integer.MAX_VALUE;\\n        else if(memo[i][j] != Integer.MAX_VALUE)\\n            return memo[i][j];\\n        else if(i == grid.length - 1  && j == grid[0].length -1)\\n            return grid[i][j];\\n         else \\n            memo[i][j] = grid[i][j] + Math.min(dfs(grid, i + 1, j,memo),dfs(grid, i, j + 1,memo));\\n        \\n        return memo[i][j];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23600,
                "title": "share-my-java-solution",
                "content": "    public int minPathSum(int[][] grid) {\\n        if(grid==null||grid.length<1)\\n            return 0;\\n            \\n        int[][] minsum = new int[grid.length][grid[0].length];\\n        //initialize\\n        minsum[0][0] = grid[0][0];\\n        \\n        for(int j=1;j<minsum[0].length;j++){\\n            minsum[0][j] = minsum[0][j-1]+grid[0][j];\\n        }\\n        \\n        for(int i=1;i<minsum.length;i++){\\n            minsum[i][0] = minsum[i-1][0] + grid[i][0];\\n        }\\n        // calculate sum along the path\\n        for(int i = 1;i<minsum.length;i++){\\n            for(int j = 1;j<minsum[0].length;j++){\\n                minsum[i][j] = Math.min(minsum[i-1][j], minsum[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return minsum[minsum.length-1][minsum[0].length-1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int minPathSum(int[][] grid) {\\n        if(grid==null||grid.length<1)\\n            return 0;\\n            \\n        int[][] minsum = new int[grid.length][grid[0].length];\\n        //initialize\\n        minsum[0][0] = grid[0][0];\\n        \\n        for(int j=1;j<minsum[0].length;j++){\\n            minsum[0][j] = minsum[0][j-1]+grid[0][j];\\n        }\\n        \\n        for(int i=1;i<minsum.length;i++){\\n            minsum[i][0] = minsum[i-1][0] + grid[i][0];\\n        }\\n        // calculate sum along the path\\n        for(int i = 1;i<minsum.length;i++){\\n            for(int j = 1;j<minsum[0].length;j++){\\n                minsum[i][j] = Math.min(minsum[i-1][j], minsum[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return minsum[minsum.length-1][minsum[0].length-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23593,
                "title": "beats-100-with-o-n-space",
                "content": "    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> dp(n);\\n            \\n            dp[0] = grid[0][0];\\n            for (int j = 1; j < n; j++) {   // init\\n                dp[j] = dp[j-1] + grid[0][j];\\n            }\\n            \\n            for (int i = 1; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[j] = (j == 0 ? dp[j] : min(dp[j], dp[j-1])) + grid[i][j];\\n                }   \\n            }\\n            return dp[n-1];\\n        }\\n    };\\n\\n\\nIn usual provide O(mn) solution first, then try to optimize it. From dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j], you can see it only depends on previous row and current row value, we waste a lot space if use mn space. \\n\\ndp[i][j] is row i, column j; \\ndp[i][j-1] is row i, column j-1; \\ndp[i-1][j] is row i-1, column j;\\n\\nif we just use row to represent dp[i], then it should be \\n\\nrow[j] = min(row[j-1], row[j]) + grid[i][j]; \\n\\nwhy dp[i-1][j] is row[j], because before we set new value for row[j], it saves old value, which is dp[i-1][j].\\n\\nSo the new transition formula is:\\n\\nrow[j] = min(row[j-1], row[j]) + grid[i][j];\\n\\nstill use dp variable to replace row, it is:\\n\\ndp[j] = min(dp[j-1], dp[j]) + grid[i][j];\\n\\nvariable j is from 0 to n, same as before. But the i is not used in two dimension row number, just use iteration number. We need do m-1 iterations, because we don't need do it for first row, which is init value.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> dp(n);\\n            \\n            dp[0] = grid[0][0];\\n            for (int j = 1; j < n; j++) {   // init\\n                dp[j] = dp[j-1] + grid[0][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 23679,
                "title": "python-recursive-solution-with-cache-114ms",
                "content": "    class Solution:\\n        # @param {integer[][]} grid\\n        # @return {integer}\\n        def minPathSum(self, grid):\\n            if not len(grid) or not len(grid[0]):\\n                return 0\\n    \\n            m, n, cache = len(grid) - 1, len(grid[0]) - 1, {}\\n    \\n            return self.findMinSum(grid, m, n, cache)\\n    \\n        def findMinSum(self, grid, m, n, cache):\\n            if (m, n) in cache:\\n                return cache[(m, n)]\\n            elif m < 0 or n < 0:\\n                return float('inf')\\n            elif m == 0 and n == 0:\\n                return grid[0][0]\\n            else:\\n                cache[(m, n)] = grid[m][n] + min(self.findMinSum(grid, m - 1, n, cache), self.findMinSum(grid, m, n - 1, cache))\\n    \\n                return cache[(m, n)]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n        # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 3988970,
                "title": "easy-dp-solution",
                "content": "\\n# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe minPathSum function initializes a 2D vector dp with dimensions n x m+1 and initializes all elements to -1. This dp array will be used to memoize the results of subproblems to avoid redundant calculations.\\n\\nIt calls the solve function with the given grid, the starting indices (n-1, m-1), and the dp array.\\n\\nThe solve function is a recursive function with memoization. It takes the current cell (i, j) in the grid and calculates the minimum path sum from the top-left corner to that cell.\\n\\nIf (i, j) is the top-left corner (i.e., i == 0 and j == 0), it returns the value in that cell because there\\'s only one path to reach that cell.\\n\\nIf (i, j) is out of bounds (i.e., i < 0 or j < 0), it returns a large value (1e9) to indicate that this path is not valid.\\n\\nIf the result for (i, j) is already calculated and stored in the dp array, it returns that result to avoid redundant computation.\\n\\nIf the result for (i, j) is not calculated, it recursively calculates the minimum path sum by considering two possible moves:\\n\\nMoving up (i.e., (i-1, j)) and adding the current cell\\'s value to it.\\nMoving left (i.e., (i, j-1)) and adding the current cell\\'s value to it.\\nIt stores the minimum of these two values in the dp array at position (i, j) and returns that minimum value.\\n\\nFinally, the minPathSum function returns the result obtained by calling solve with the bottom-right corner cell (n-1, m-1).\\n\\nThis approach effectively uses memoization to avoid redundant calculations and finds the minimum path sum efficiently. The result returned by minPathSum is the minimum sum required to reach the bottom-right corner of the grid while moving only right or down.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>>& grid ,int i,int j,vector<vector<int>>& dp)\\n{\\n    if(i==0 && j==0 )\\n    {\\n        return grid[i][j];\\n    }\\n    if(i<0 || j<0)\\n    {\\n        return 1e9;\\n    } \\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    int up= grid[i][j]+solve(grid, i-1,j,dp);\\n    int left= grid[i][j]+solve(grid, i,j-1,dp);\\n    return dp[i][j] = min(up,left);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m= grid[0].size(); \\n        vector<vector<int>>dp(n,vector<int>(m+1,-1));\\n        return solve(grid,n-1,m-1,dp);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>>& grid ,int i,int j,vector<vector<int>>& dp)\\n{\\n    if(i==0 && j==0 )\\n    {\\n        return grid[i][j];\\n    }\\n    if(i<0 || j<0)\\n    {\\n        return 1e9;\\n    } \\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    int up= grid[i][j]+solve(grid, i-1,j,dp);\\n    int left= grid[i][j]+solve(grid, i,j-1,dp);\\n    return dp[i][j] = min(up,left);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m= grid[0].size(); \\n        vector<vector<int>>dp(n,vector<int>(m+1,-1));\\n        return solve(grid,n-1,m-1,dp);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775468,
                "title": "4-steps-of-optimization-naive-recursion-optimization-dp",
                "content": "# 1. Naive Recursive approach (TLE)\\n- **Time complexity: O(mn)**\\n In the worst case, the recursive calls will visit all cells in the grid except the first cell (grid[0][0]). Therefore, the total number of function calls will be (m-1) * (n-1). Each function call performs constant time operations, so the time complexity is O(mn).\\n- **Space complexity: O(m + n)**\\nIn the worst case, the recursive calls will visit all cells in the grid except the first cell (grid[0][0]). Therefore, the maximum depth of recursion will be m + n - 2. Since each recursive call requires constant space, the space complexity is O(m + n).\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1);\\n        int up=f(grid, row-1, col);\\n        return res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        return f(grid, m, n);\\n    }\\n};\\n\\n```\\n# 2. Memoization(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col, vector<vector<int>>&dp){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1, dp);\\n        int up=f(grid, row-1, col, dp);\\n        return dp[row][col] = res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(grid, m, n, dp);\\n    }\\n};\\n\\n```\\n\\n# 3. Tabulation(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, 40001));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1){\\n                    dp[1][1]=grid[0][0];\\n                }\\n                else dp[i][j]=grid[i-1][j-1] + min(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n\\n```\\n\\n# 4. Optimized Space (Best Code)\\n- Time complexity: O(m*n)\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>dp(n+1, 40001);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1) dp[1]=grid[0][0];\\n                else dp[j]=grid[i-1][j-1] + min(dp[j-1], dp[j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1);\\n        int up=f(grid, row-1, col);\\n        return res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        return f(grid, m, n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col, vector<vector<int>>&dp){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1, dp);\\n        int up=f(grid, row-1, col, dp);\\n        return dp[row][col] = res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(grid, m, n, dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, 40001));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1){\\n                    dp[1][1]=grid[0][0];\\n                }\\n                else dp[i][j]=grid[i-1][j-1] + min(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>dp(n+1, 40001);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1) dp[1]=grid[0][0];\\n                else dp[j]=grid[i-1][j-1] + min(dp[j-1], dp[j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704034,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(i==n-1 && j==m-1){\\n        return grid[i][j];\\n\\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int r=INT_MAX;\\n    int d=INT_MAX;\\n    if(i+1<n ){\\n        d=solve(i+1,j,grid,dp);\\n    }\\n    if(j+1<m) r=solve(i,j+1,grid,dp);\\n   \\n    return dp[i][j]=grid[i][j]+min(r,d);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n    int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(i==n-1 && j==m-1){\\n        return grid[i][j];\\n\\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int r=INT_MAX;\\n    int d=INT_MAX;\\n    if(i+1<n ){\\n        d=solve(i+1,j,grid,dp);\\n    }\\n    if(j+1<m) r=solve(i,j+1,grid,dp);\\n   \\n    return dp[i][j]=grid[i][j]+min(r,d);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n    int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349044,
                "title": "java-memoized-dfs-and-dp-beats-99",
                "content": "# Approach 1: DFS\\nIn DFS we need to traverse all possibilities up to [m-1][n-1] and then compute the minimal path on our way from bottom up.\\nThere will be a lot of duplicated computations, so we need to memoize our dfs at i,j.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int[][] memo;\\n    private int[][] grid;\\n    private int m = 0;\\n    private int n = 0;\\n\\n    public int minPathSum(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new int[m][n];\\n        this.grid = grid;\\n        for (int[] row: memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, 0);\\n    }\\n\\n    private int dfs(int i, int j) {\\n        if (i == m || j == n) return Integer.MAX_VALUE;\\n        if (i == m-1 && j == n-1) return grid[i][j];\\n        if (memo[i][j] != -1) return memo[i][j];\\n        memo[i][j] = grid[i][j] + Math.min(\\n            dfs(i+1, j),\\n            dfs(i, j+1)\\n        );\\n        return memo[i][j];\\n    }\\n}\\n```\\n\\n# Approach 2: Dynamic programming\\nThis is a little more complicated and less straightforward as memoized DFS. We need to somehow tell what is the optimal previous path for index i,j. That means we need to memoize the best paths up to [i-1][j] and [i][j-1].\\n\\nThis means that our loop at i,j must do the following:\\n1. get previous at [i-1][j] or Infinity if it doesnt exist\\n2. get previous at [i][j-1] or Infinity\\n3. get minimum of these values (spec case is if they are both infinity, then we need to make them zero, because there is no previous path)\\n4. minPrev + grid[i][j] is our optimal value at i,j\\n5. the minimum in [m-1][n-1] is our answer\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] memo = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? memo[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? memo[i][j-1] : Integer.MAX_VALUE\\n                );\\n                memo[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return memo[m-1][n-1];\\n    }\\n}\\n```\\nBonus:\\nIf we are allowed to modify the input, we can solve it in O(1) space\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? grid[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? grid[i][j-1] : Integer.MAX_VALUE\\n                );\\n                grid[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n\\n---\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] memo;\\n    private int[][] grid;\\n    private int m = 0;\\n    private int n = 0;\\n\\n    public int minPathSum(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new int[m][n];\\n        this.grid = grid;\\n        for (int[] row: memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, 0);\\n    }\\n\\n    private int dfs(int i, int j) {\\n        if (i == m || j == n) return Integer.MAX_VALUE;\\n        if (i == m-1 && j == n-1) return grid[i][j];\\n        if (memo[i][j] != -1) return memo[i][j];\\n        memo[i][j] = grid[i][j] + Math.min(\\n            dfs(i+1, j),\\n            dfs(i, j+1)\\n        );\\n        return memo[i][j];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] memo = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? memo[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? memo[i][j-1] : Integer.MAX_VALUE\\n                );\\n                memo[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return memo[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? grid[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? grid[i][j-1] : Integer.MAX_VALUE\\n                );\\n                grid[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347990,
                "title": "easy-solution-in-js-beat-91-just-loop-through-grid",
                "content": "Please UPVOTE!!!!\\n```\\nvar minPathSum = function(grid) {\\n    let row = grid.length;\\n    let col = grid[0].length;\\n    for(let i=0;i<row;i++) {\\n        for(let j=0;j<col;j++) {\\n            if(i == 0 && j== 0) {\\n                continue\\n            } else if( i== 0) {\\n                grid[i][j] += grid[i][j-1]\\n            } else if ( j== 0) {\\n                grid[i][j] += grid[i-1][j]\\n            } else {\\n                grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1])\\n            }\\n        }\\n    }\\n    return grid[row-1][col-1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathSum = function(grid) {\\n    let row = grid.length;\\n    let col = grid[0].length;\\n    for(let i=0;i<row;i++) {\\n        for(let j=0;j<col;j++) {\\n            if(i == 0 && j== 0) {\\n                continue\\n            } else if( i== 0) {\\n                grid[i][j] += grid[i][j-1]\\n            } else if ( j== 0) {\\n                grid[i][j] += grid[i-1][j]\\n            } else {\\n                grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1])\\n            }\\n        }\\n    }\\n    return grid[row-1][col-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3347067,
                "title": "easy-solutions-with-explanation-in-java-dp",
                "content": "# Intuition\\nTo find minimum path sum we need result of our previous choices that we took, so this gives us intution of storing previous data and hence we choose DP\\nConsidering testcase 1\\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\\nOutput: 7\\n\\n# Approach\\n***Beginner -> Space O(n^2)***\\n\\n1) Begin by taking same size 2D and fill the first element from grid[0][0] to our new matrix dp[][];\\n2) Prefill first row and first column, because \\n\\n- ROW\\nWe can reach row 0 elements from only side i.e grid[0][0] will contribute to grid[0][1]  and so on\\nintially grid : 1 --> 3 ---> 1\\nso first row will look like \\nafter operation dp: 1 --> 4 --> 5\\n\\n- COL\\nWe can reach row 0 elements only from top as left indexes are out of bound\\ngrid --after operation-->  dp\\n1  ---->  1\\n5  ---->  6\\n1  ---->  7\\n\\n3) Now for any other element will is not part of corner case, we can reach from top or from same row left side so \\ndp[i][j] = Math.min(element from top, element from side) + current value\\ndp[i][j] = Math.min(dp[i][j-1], dp[i-1][j])\\n\\nand we return the last element of dp[n][n] which is the answer\\n\\n---\\n\\n\\n*Space O(n)*\\nWe can also solve the problem by using a 1D array, the array will always store the upper row values ( i.e the values that we fetch via dp[i-1][j]).\\nSo initially we will prefill it with 1 row same as in 2nd step row part.\\n\\nMin path of any element is\\ndp[j] = elements values will be added + min of ( top, side)\\n- top row data is already in the dp array and side we can calculate via dp[j-1]\\ndp[j]=  grid[i][j] +Math.min(dp[j], dp[j-1])+\\n\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) Since we visit all element of the matrix.\\n\\n# Code Space O(n^2)\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if(grid==null || grid.length==0 )\\n            return 0;\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        /* prefilling the first row and first column */\\n        for(int i=1;i<col;i++)\\n            grid[0][i]+=grid[0][i-1];\\n        \\n        for(int i=1;i<row;i++)\\n            grid[i][0]+=grid[i-1][0];\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                grid[i][j]+=Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n```\\n\\n# Code Space O(n)\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row= grid.length;\\n        int col= grid[0].length;\\n        int [] dp = new int[col];\\n        \\n        dp[0]= grid[0][0];\\n        \\n        for(int i=1; i<col;i++)\\n            dp[i]=dp[i-1] + grid[0][i];\\n        \\n        for(int i=1; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                if(j>0){\\n                    dp[j]=Math.min(dp[j], dp[j-1])+ grid[i][j];\\n                }else{\\n                    dp[j]+=grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[col-1];\\n        \\n    }\\n}\\n```\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging.\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/839efe73-c747-4529-80da-c693220bcf93_1679908593.3237262.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if(grid==null || grid.length==0 )\\n            return 0;\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        /* prefilling the first row and first column */\\n        for(int i=1;i<col;i++)\\n            grid[0][i]+=grid[0][i-1];\\n        \\n        for(int i=1;i<row;i++)\\n            grid[i][0]+=grid[i-1][0];\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                grid[i][j]+=Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row= grid.length;\\n        int col= grid[0].length;\\n        int [] dp = new int[col];\\n        \\n        dp[0]= grid[0][0];\\n        \\n        for(int i=1; i<col;i++)\\n            dp[i]=dp[i-1] + grid[0][i];\\n        \\n        for(int i=1; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                if(j>0){\\n                    dp[j]=Math.min(dp[j], dp[j-1])+ grid[i][j];\\n                }else{\\n                    dp[j]+=grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[col-1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347028,
                "title": "minimum-pathsum-recursion-memoisation-tabulation-space-optimized-in-o-m-instead-of-o-n-m",
                "content": "# Intuition\\nJust go from bottom right corner to top left and check the minimum cost to reach the top left of the grid.\\nfun(i,j):\\n    if(i<0 || j<0) return INT_MAX;  (returning int_max is preferrable for finding the minimum)\\n    if(i==0 && j==0) return grid[i][j];\\n    return grid[i][j]+min(fun(i-1,j),fun(i,j-1));\\n\\n\\n# Code\\nBasic recursion code which will give TLE\\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid){\\n            //just do a normal index shift which willl be useful during tabulation if you want to  do from this intuition\\n\\n            if(i==0 ||j==0) return INT_MAX;\\n\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid);\\n            int lef=fun(i,j-1,grid);\\n\\n                //here returning that grid cost +min(getfrom left recursuon ,getfrom up recursioj)\\n            return grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n\\n        return fun(n,m,grid);\\n    }\\n};\\n```\\nMemosiation\\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n\\n        return fun(n,m,grid,dp);\\n    }\\n};\\n```\\nTabulation which reduce our axuliary space complexity\\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                if(i==0 && j==0){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int up=grid[i][j];\\n        //just handling arror of indexing / runtime error\\n                   if(i>0) up+=dp[i-1][j];\\n                   else{\\n                       up+=1e5;\\n                   }\\n                   int lef=grid[i][j];\\n                   if(j>0) lef+=dp[i][j-1];\\n                   else{\\n                       lef+=1e5;\\n                   }\\n                   dp[i][j]=min(up,lef);\\n                }\\n                 \\n            }\\n        }\\n\\n        // return fun(n,m,grid,dp);\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\nTablulation space optimized O(n)\\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // vector<vector<int>> dp(n,vector<int>(m,0));\\n     vector<int> prev(m, 0), cur(m, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) cur[j] = grid[i][j];\\n                else {\\n                    int up = i >= 1 ? grid[i][j] + prev[j] : INT_MAX;\\n                    int left = j >= 1 ? grid[i][j] + cur[j - 1] : INT_MAX;\\n                    cur[j] = min(up, left);\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[m - 1];\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid){\\n            //just do a normal index shift which willl be useful during tabulation if you want to  do from this intuition\\n\\n            if(i==0 ||j==0) return INT_MAX;\\n\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid);\\n            int lef=fun(i,j-1,grid);\\n\\n                //here returning that grid cost +min(getfrom left recursuon ,getfrom up recursioj)\\n            return grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n\\n        return fun(n,m,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n\\n        return fun(n,m,grid,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                if(i==0 && j==0){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int up=grid[i][j];\\n        //just handling arror of indexing / runtime error\\n                   if(i>0) up+=dp[i-1][j];\\n                   else{\\n                       up+=1e5;\\n                   }\\n                   int lef=grid[i][j];\\n                   if(j>0) lef+=dp[i][j-1];\\n                   else{\\n                       lef+=1e5;\\n                   }\\n                   dp[i][j]=min(up,lef);\\n                }\\n                 \\n            }\\n        }\\n\\n        // return fun(n,m,grid,dp);\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // vector<vector<int>> dp(n,vector<int>(m,0));\\n     vector<int> prev(m, 0), cur(m, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) cur[j] = grid[i][j];\\n                else {\\n                    int up = i >= 1 ? grid[i][j] + prev[j] : INT_MAX;\\n                    int left = j >= 1 ? grid[i][j] + cur[j - 1] : INT_MAX;\\n                    cur[j] = min(up, left);\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332681,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^S)$$ --> S = m * n\\n\\n- Space complexity:\\n$$O(m + n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return INT_MAX;\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        return min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return solve(m-1, n-1, grid);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return 1e9;\\n        if (dp[row][col] != -1)\\n            return dp[row][col];    \\n        int left = grid[row][col] + solve(row, col-1, grid, dp);\\n        int up = grid[row][col] + solve(row-1, col, grid, dp);\\n        return dp[row][col] = min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, grid, dp);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += dp[i][j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += dp[i-1][j];\\n                else\\n                    up += 1e9;    \\n                dp[i][j] = min (left, up);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    cur[j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += cur[j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += prev[j];\\n                else\\n                    up += 1e9;    \\n                cur[j] = min (left, up);\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return INT_MAX;\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        return min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return solve(m-1, n-1, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return 1e9;\\n        if (dp[row][col] != -1)\\n            return dp[row][col];    \\n        int left = grid[row][col] + solve(row, col-1, grid, dp);\\n        int up = grid[row][col] + solve(row-1, col, grid, dp);\\n        return dp[row][col] = min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, grid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += dp[i][j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += dp[i-1][j];\\n                else\\n                    up += 1e9;    \\n                dp[i][j] = min (left, up);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    cur[j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += cur[j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += prev[j];\\n                else\\n                    up += 1e9;    \\n                cur[j] = min (left, up);\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974540,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DP\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N * M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dp[n][m];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1; i<m; i++) dp[0][i] = dp[0][i-1] + grid[0][i];\\n        for(int i=1; i<n; i++) dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=1; j<m; j++) {\\n                dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dp[n][m];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1; i<m; i++) dp[0][i] = dp[0][i-1] + grid[0][i];\\n        for(int i=1; i<n; i++) dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=1; j<m; j++) {\\n                dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937659,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if(m==0 && n==0)\\n            return dp[m][n];\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        if(m==0 && n!=0)\\n            return dp[m][n] = grid[m][n]+solve(grid, m, n-1, dp);\\n        \\n        if(n==0 && m!=0)\\n            return dp[m][n] =grid[m][n]+solve(grid, m-1, n, dp);\\n        \\n        else\\n            return dp[m][n] =grid[m][n] + min(solve(grid, m-1, n, dp), solve(grid, m, n-1, dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j!=0)\\n                    grid[i][j]+=grid[i][j-1];\\n                else if(j==0 && i!=0)\\n                    grid[i][j]+=grid[i-1][j];\\n                else if(i && j)\\n                    grid[i][j]+=min(grid[i][j-1], grid[i-1][j]);\\n                // cout<<grid[i][j]<<\" \";\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if(m==0 && n==0)\\n            return dp[m][n];\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        if(m==0 && n!=0)\\n            return dp[m][n] = grid[m][n]+solve(grid, m, n-1, dp);\\n        \\n        if(n==0 && m!=0)\\n            return dp[m][n] =grid[m][n]+solve(grid, m-1, n, dp);\\n        \\n        else\\n            return dp[m][n] =grid[m][n] + min(solve(grid, m-1, n, dp), solve(grid, m, n-1, dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j!=0)\\n                    grid[i][j]+=grid[i][j-1];\\n                else if(j==0 && i!=0)\\n                    grid[i][j]+=grid[i-1][j];\\n                else if(i && j)\\n                    grid[i][j]+=min(grid[i][j-1], grid[i-1][j]);\\n                // cout<<grid[i][j]<<\" \";\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1771810,
                "title": "python-dp-solution-easy-and-simple",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        Approach:\\n        1. Compute the sum to reach untill each element in first column\\n        2. Compute the sum to reach untill each element in first row\\n        3. Then traverse from index 1,1 to untill end and only take the minimum path at each location \\n        \\n        Minimum path comes from either from previous element(previous row and column).\\n        \\'\\'\\'\\n        m, n = len(grid), len(grid[0]) \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, n):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        Approach:\\n        1. Compute the sum to reach untill each element in first column\\n        2. Compute the sum to reach untill each element in first row\\n        3. Then traverse from index 1,1 to untill end and only take the minimum path at each location \\n        \\n        Minimum path comes from either from previous element(previous row and column).\\n        \\'\\'\\'\\n        m, n = len(grid), len(grid[0]) \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, n):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643189,
                "title": "c-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = m-1; j >= 0; j--){\\n                if(i == n-1 && j == m-1) // bottom right element\\n                    dp[i][j] = grid[i][j];\\n                else if(i == n-1)        // In last row we can\\'t go downwards\\n                    dp[i][j] = dp[i][j+1] + grid[i][j];\\n                else if(j == m-1)        // In last column we can\\'t go rightwards\\n                    dp[i][j] = dp[i+1][j] + grid[i][j];\\n                else\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = m-1; j >= 0; j--){\\n                if(i == n-1 && j == m-1) // bottom right element\\n                    dp[i][j] = grid[i][j];\\n                else if(i == n-1)        // In last row we can\\'t go downwards\\n                    dp[i][j] = dp[i][j+1] + grid[i][j];\\n                else if(j == m-1)        // In last column we can\\'t go rightwards\\n                    dp[i][j] = dp[i+1][j] + grid[i][j];\\n                else\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496137,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # square becomes minimum of the thing above it or to the left of it\\n        # plus its own value\\n        \\n        \\n        # bfs right then down\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return grid[0][0]\\n        \\n        \\n        q = deque()\\n        visited = set()\\n        q.append((0,0))\\n        \\n        while(q):\\n            row, col = q.popleft()\\n            if (row, col) in visited:\\n                continue\\n            if row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0]):\\n                q.append((row, col+1))\\n                q.append((row+1, col))\\n                visited.add((row,col))\\n                if row == 0 and col == 0:\\n                    continue\\n                elif row == 0 and col > 0:\\n                    grid[row][col] += grid[row][col-1]\\n                elif col == 0:\\n                    grid[row][col] += grid[row-1][col]\\n                else:\\n                    grid[row][col] += min(grid[row-1][col], grid[row][col-1])\\n       \\n            \\n        return grid[-1][-1]\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # square becomes minimum of the thing above it or to the left of it\\n        # plus its own value\\n        \\n        \\n        # bfs right then down\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return grid[0][0]\\n        \\n        \\n        q = deque()\\n        visited = set()\\n        q.append((0,0))\\n        \\n        while(q):\\n            row, col = q.popleft()\\n            if (row, col) in visited:\\n                continue\\n            if row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0]):\\n                q.append((row, col+1))\\n                q.append((row+1, col))\\n                visited.add((row,col))\\n                if row == 0 and col == 0:\\n                    continue\\n                elif row == 0 and col > 0:\\n                    grid[row][col] += grid[row][col-1]\\n                elif col == 0:\\n                    grid[row][col] += grid[row-1][col]\\n                else:\\n                    grid[row][col] += min(grid[row-1][col], grid[row][col-1])\\n       \\n            \\n        return grid[-1][-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1476146,
                "title": "generalized-way-of-using-recursion-on-matrix-solution-for-this-problem-recursive-and-top-down",
                "content": "**WHAT IS RECURSION?**\\n=> just a lazy guy who will take help from others  to get the work done.{calling same function on smaller inputs eventually reaching base case where we will get our answer}\\n\\n**RECURSON IN MATRIX**\\n1) In a matrix we have to figure out the way to traverse, if I am at (0,0) and i have to go down then(1,0), up(-1,0),   right(0, 1) and left(0, -1). Generalizing this from (i, j) -> down(i+1, j), up(i-1, j), left(i, j-1), right(i, j+1).\\n2) While traversing we have to take care that we are inside out matrix, generalizing this if we go below 0 we are going out from two sides(left and top), if we go above n, m (considering n x m matrix) then we are going outside from other two sides.\\n3) At last we have to figure out the logic according to the question through which we will calculate the output.\\n\\n\\n**RECURSIVE SOLUTION (will result in TLE):**\\n```\\nclass Solution {\\nprivate:\\n    int recursion(int i, int j, int n, int m, vector<vector<int>> &grid){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.(conditions for returning will change according to question)\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        int down = recursion(i+1, j, n, m, grid); // value which i will get when i go down\\n        int right = recursion(i, j+1, n, m, grid);// value which i will get when i go right\\n        \\n        return grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell.\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        return recursion(0, 0, row, col, grid); // at index (0, 0) we will have the total min cost to reach end from (0,0).\\n    }\\n};\\n```\\n\\n**TOP-DOWN DP(AC):**\\n```\\nclass Solution {\\nprivate:\\n    int topDown(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]; // if not -1 then the value is already computed no need to calculate again\\n        \\n        int down = topDown(i+1, j, n, m, grid, dp); // value which function will return when we go down\\n        int right = topDown(i, j+1, n, m, grid, dp);// value which function will get when return we go right\\n        \\n        return dp[i][j] = grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell and store it in dp matrix\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row, vector<int>(col, -1)); // declaring 2d matrix initialized as -1 to store values\\n        return topDown(0, 0, row, col, grid, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int recursion(int i, int j, int n, int m, vector<vector<int>> &grid){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.(conditions for returning will change according to question)\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        int down = recursion(i+1, j, n, m, grid); // value which i will get when i go down\\n        int right = recursion(i, j+1, n, m, grid);// value which i will get when i go right\\n        \\n        return grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell.\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        return recursion(0, 0, row, col, grid); // at index (0, 0) we will have the total min cost to reach end from (0,0).\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int topDown(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]; // if not -1 then the value is already computed no need to calculate again\\n        \\n        int down = topDown(i+1, j, n, m, grid, dp); // value which function will return when we go down\\n        int right = topDown(i, j+1, n, m, grid, dp);// value which function will get when return we go right\\n        \\n        return dp[i][j] = grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell and store it in dp matrix\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row, vector<int>(col, -1)); // declaring 2d matrix initialized as -1 to store values\\n        return topDown(0, 0, row, col, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450433,
                "title": "1-ms-faster-than-99-of-java-online-submissions-for-minimum-path-sum",
                "content": "// It is much similar problem to Unique paths problem.\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n       \\n        \\n        for(int i=1;i<grid[0].length;i++){\\n            \\n            grid[0][i]+=grid[0][i-1];\\n        }\\n        for(int j=1;j<grid.length;j++){\\n            \\n            grid[j][0]+=grid[j-1][0];\\n        }\\n        for(int i=1;i<grid.length;i++){\\n            for(int j=1;j<grid[0].length;j++){\\n                grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minPathSum(int[][] grid) {\\n       \\n        \\n        for(int i=1;i<grid[0].length;i++){\\n            \\n            grid[0][i]+=grid[0][i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1266207,
                "title": "top-down-recursion-memoization-c-beginners",
                "content": "Simplest top down approach\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    int rec(vector<vector<int> > &A,int i,int j)\\n    {\\n        int m=A.size(),n=A[0].size();\\n\\n        if(i>=m or j>=n) return INT_MAX;\\n        if(i==m-1 and j==n-1) return A[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        return dp[i][j]=min(rec(A,i+1,j),rec(A,i,j+1))+A[i][j];\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(grid,0,0);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    int rec(vector<vector<int> > &A,int i,int j)\\n    {\\n        int m=A.size(),n=A[0].size();\\n\\n        if(i>=m or j>=n) return INT_MAX;\\n        if(i==m-1 and j==n-1) return A[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        return dp[i][j]=min(rec(A,i+1,j),rec(A,i,j+1))+A[i][j];\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(grid,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585513,
                "title": "python-bottom-up-dynamic-programming",
                "content": "You only have two choices when determining the the minimum for a particular cell. Either you take the value above you or the value left from you. Choose the the minimum between them and add the value from the cell you\\'re currently on. Keep doing that untill you make it to the end of the grid.\\n\\n```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(1, len(grid)):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for j in range(1, len(grid[0])):\\n            grid[0][j] += grid[0][j-1]\\n        \\n        for i in range(1, len(grid)):\\n            for j in range(1, len(grid[0])):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n                \\n        return grid[-1][-1]\\n```\\n\\n**Time:** `O(m*n)`\\n**Space:** `O(1)`",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(1, len(grid)):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for j in range(1, len(grid[0])):\\n            grid[0][j] += grid[0][j-1]\\n        \\n        for i in range(1, len(grid)):\\n            for j in range(1, len(grid[0])):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n                \\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585035,
                "title": "java-linear-time-constant-space-easy-to-understand-dp-solution",
                "content": "```\\npublic int minPathSum(int[][] grid) {\\n        int xlen = grid.length;\\n        if(xlen == 0) return 0;\\n        int ylen = grid[0].length;\\n        //using grid as dp grid\\n        for(int i=1;i<xlen;i++) {\\n            grid[i][0]+=grid[i-1][0];\\n        }\\n        for(int i=1;i<ylen;i++) {\\n            grid[0][i]+=grid[0][i-1];\\n        }\\n        for(int i=1;i<xlen;i++){\\n            for(int j=1; j<ylen;j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[xlen-1][ylen-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minPathSum(int[][] grid) {\\n        int xlen = grid.length;\\n        if(xlen == 0) return 0;\\n        int ylen = grid[0].length;\\n        //using grid as dp grid\\n        for(int i=1;i<xlen;i++) {\\n            grid[i][0]+=grid[i-1][0];\\n        }\\n        for(int i=1;i<ylen;i++) {\\n            grid[0][i]+=grid[0][i-1];\\n        }\\n        for(int i=1;i<xlen;i++){\\n            for(int j=1; j<ylen;j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[xlen-1][ylen-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482511,
                "title": "dijkstra-s-algorithm-with-python-3-pictures",
                "content": "\\nPracticing on problems in which people have tagged with Dijkstra\\'s algorithm.\\n\\nSteps\\n* Convert to graph\\n* inf on unseen nodes\\n* start 0,0\\n* Loop\\n\\t* relax node\\n\\t* add cost to seen edge\\n\\t* mark node as visit\\n\\t* find min value cost on seen but not visited nodes\\n* Return value end  n, n\\n\\nThings I found\\n* Building graphs is expensive\\n* Didn\\'t see much improvement using a heap but could be smaller test sets.\\n* There\\'s still a lot I don\\'t know about Python.  First time using heaps and multi-key defaultdict\\n* Amazon youtube instructors like Abdul Bari https://youtu.be/XB4MIexjvY0\\n\\nVisual walk through \\n1.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222011.png)\\n2.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222457.png)\\n3.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222525.png)\\n4.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222551.png)\\n5.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222573.png)\\n6.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222609.png)\\n7.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222625.png)\\n8.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222657.png)\\n9.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222691.png)\\n10. ![image](https://assets.leetcode.com/users/dentedghost/image_1579222744.png)\\n11. ![image](https://assets.leetcode.com/users/dentedghost/image_1579222763.png)\\n\\nCode:\\n```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row =  len(grid)\\n        column = len(grid[0])\\n        \\n        # Craft graphs\\n        heap = []\\n        sum = defaultdict(list)\\n        cost = defaultdict(list)\\n        graph = defaultdict(list)\\n        seen = defaultdict(list)\\n        for r in range (0, row):\\n            for c in range (0, column):\\n                sum[r,c] = float(\\'inf\\')\\n                cost[r,c].append(grid[r][c])\\n                # check right\\n                if c < column - 1:\\n                    graph[r,c].append([r,c+1])\\n                # check down\\n                if r < row - 1:\\n                    graph[r,c].append([r+1,c])\\n  \\n        # Setup for start and end\\n        min_node = (0,0)\\n        end_node = ((row-1),(column-1))   \\n        sum[(min_node)] = cost.get(min_node)[0]\\n        seen[(min_node)] = True\\n        \\n        while len(seen) > 0:\\n            # check attached nodes\\n            if graph.get(min_node):\\n                # Visit next mini-value node and relax it\\'s edge\\n                for node in graph.get(min_node):\\n                    n = tuple(node)\\n                    visit_cost = cost.get(n)[0] + (sum.get(min_node))\\n                    # Check if relaxing has reduced the cost\\n                    if visit_cost < sum.get(n):\\n                        # Update the cost for each updated node\\n                        sum[(n)] = visit_cost\\n                        # Add to head future nodes to visit\\n                        heappush(heap, (visit_cost, n))\\n                        seen[(n)] = True\\n\\n            seen.pop(min_node)\\n\\n            # Check Next Cost Optimized with a heap\\n            if len(heap) > 0:\\n                next_min_node = heappop(heap)[1]\\n                min_node = next_min_node\\n\\n        return sum.get(end_node)\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row =  len(grid)\\n        column = len(grid[0])\\n        \\n        # Craft graphs\\n        heap = []\\n        sum = defaultdict(list)\\n        cost = defaultdict(list)\\n        graph = defaultdict(list)\\n        seen = defaultdict(list)\\n        for r in range (0, row):\\n            for c in range (0, column):\\n                sum[r,c] = float(\\'inf\\')\\n                cost[r,c].append(grid[r][c])\\n                # check right\\n                if c < column - 1:\\n                    graph[r,c].append([r,c+1])\\n                # check down\\n                if r < row - 1:\\n                    graph[r,c].append([r+1,c])\\n  \\n        # Setup for start and end\\n        min_node = (0,0)\\n        end_node = ((row-1),(column-1))   \\n        sum[(min_node)] = cost.get(min_node)[0]\\n        seen[(min_node)] = True\\n        \\n        while len(seen) > 0:\\n            # check attached nodes\\n            if graph.get(min_node):\\n                # Visit next mini-value node and relax it\\'s edge\\n                for node in graph.get(min_node):\\n                    n = tuple(node)\\n                    visit_cost = cost.get(n)[0] + (sum.get(min_node))\\n                    # Check if relaxing has reduced the cost\\n                    if visit_cost < sum.get(n):\\n                        # Update the cost for each updated node\\n                        sum[(n)] = visit_cost\\n                        # Add to head future nodes to visit\\n                        heappush(heap, (visit_cost, n))\\n                        seen[(n)] = True\\n\\n            seen.pop(min_node)\\n\\n            # Check Next Cost Optimized with a heap\\n            if len(heap) > 0:\\n                next_min_node = heappop(heap)[1]\\n                min_node = next_min_node\\n\\n        return sum.get(end_node)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 352726,
                "title": "java-dp-inplace-with-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // corner case \\n        if(grid == null || m == 0 || grid[0] == null || n == 0) return Integer.MIN_VALUE;\\n        // initialization -> overwrite 1st row & 1st col\\n        for(int i = 1; i < m; i++){\\n            grid[i][0] = grid[i][0] + grid[i-1][0];\\n        }\\n        for(int j = 1; j < n; j++){\\n            grid[0][j] = grid[0][j] + grid[0][j-1];\\n        }\\n        for(int i = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // corner case \\n        if(grid == null || m == 0 || grid[0] == null || n == 0) return Integer.MIN_VALUE;\\n        // initialization -> overwrite 1st row & 1st col\\n        for(int i = 1; i < m; i++){\\n            grid[i][0] = grid[i][0] + grid[i-1][0];\\n        }\\n        for(int j = 1; j < n; j++){\\n            grid[0][j] = grid[0][j] + grid[0][j-1];\\n        }\\n        for(int i = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267314,
                "title": "c-96-100",
                "content": "```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for (var i = 0; i < grid.Length; i++)\\n        {\\n            for (var j = 0; j < grid[0].Length; j++)\\n            {\\n                if (i == 0 && j == 0) continue;\\n\\n                grid[i][j] += Math.Min( i > 0 ? grid[i - 1][j] : int.MaxValue, j > 0 ? grid[i][j - 1] : int.MaxValue);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for (var i = 0; i < grid.Length; i++)\\n        {\\n            for (var j = 0; j < grid[0].Length; j++)\\n            {\\n                if (i == 0 && j == 0) continue;\\n\\n                grid[i][j] += Math.Min( i > 0 ? grid[i - 1][j] : int.MaxValue, j > 0 ? grid[i][j - 1] : int.MaxValue);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200981,
                "title": "straight-forward-javascript-solution-beats-100",
                "content": "Very easy to understand. It is an Bottom-Up dynamic programming.\\n\\nTime Complexity: **O(n * m)**\\n\\n```javascript\\nvar minPathSum = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (i === 0 && j === 0) {\\n                continue;\\n            } else if (i === 0) {\\n                grid[i][j] = grid[i][j] + grid[i][j - 1];\\n            } else if (j === 0) {\\n                grid[i][j] = grid[i][j] + grid[i - 1][j];\\n            } else {\\n                grid[i][j] =  grid[i][j] + Math.min(grid[i - 1][j],  grid[i][j - 1]);\\n            }\\n        }\\n    }\\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minPathSum = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (i === 0 && j === 0) {\\n                continue;\\n            } else if (i === 0) {\\n                grid[i][j] = grid[i][j] + grid[i][j - 1];\\n            } else if (j === 0) {\\n                grid[i][j] = grid[i][j] + grid[i - 1][j];\\n            } else {\\n                grid[i][j] =  grid[i][j] + Math.min(grid[i - 1][j],  grid[i][j - 1]);\\n            }\\n        }\\n    }\\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132703,
                "title": "dijkstra-s-shortest-path-algorithm",
                "content": "We can convert the given input to a DAG by number the vertices 0, 1, 2... and the edge weight to be the value at the sink node.\\nFor the sample input:\\n[\\n  [1,3,1],\\n  [1,5,1],\\n  [4,2,1]\\n]\\n\\nThe corresponding graph would be.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/charansingh/image_1526912419.png)\\n\\nNow our problem reduces to finding the shortest path from top-left vertex to the bottom-right vertex.\\n\\n```\\n vector<int> adj(vector<vector<int>>& grid, int i) {\\n      vector<int> res;\\n      int cols = grid[0].size();\\n      int rows = grid.size();\\n      int row = i / cols;\\n      int col = i % cols;\\n      if ( row < rows - 1)\\n         res.push_back(i + cols);\\n      if ( col < cols - 1)\\n         res.push_back(i + 1);\\n      return res;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       const unsigned int INF = 0x3f3f3f3f;\\n       int V = grid.size() * grid[0].size();\\n       // Create a vector for distances and initialize all distances as infinity\\n       vector<int> dist(V, INF);\\n       // Find shortest path from src(top-left vertex) to dst(bottom-right) vertex;\\n       int src = 0;\\n       dist[src] = 0;\\n       priority_queue<pair<int,int>, vector <pair<int,int>> , greater<pair<int,int>>> pq;\\n       pq.push(make_pair(0, src));\\n       while (!pq.empty()) {\\n          int u = pq.top().second;\\n          pq.pop();\\n          // weight is nothing but the value of grid[row][col]\\n          for (int v : adj(grid, u)) {\\n            int weight = grid[v / grid[0].size()][v % grid[0].size()];\\n            if (dist[v] > dist[u] + weight) {\\n               dist[v] = dist[u] + weight;\\n               pq.push(make_pair(dist[v], v));\\n            }\\n          }\\n       }\\n\\t\\t\\t // Account for the value at [0][0]\\n       return dist[grid.size() * grid[0].size() - 1] + grid[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> adj(vector<vector<int>>& grid, int i) {\\n      vector<int> res;\\n      int cols = grid[0].size();\\n      int rows = grid.size();\\n      int row = i / cols;\\n      int col = i % cols;\\n      if ( row < rows - 1)\\n         res.push_back(i + cols);\\n      if ( col < cols - 1)\\n         res.push_back(i + 1);\\n      return res;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       const unsigned int INF = 0x3f3f3f3f;\\n       int V = grid.size() * grid[0].size();\\n       // Create a vector for distances and initialize all distances as infinity\\n       vector<int> dist(V, INF);\\n       // Find shortest path from src(top-left vertex) to dst(bottom-right) vertex;\\n       int src = 0;\\n       dist[src] = 0;\\n       priority_queue<pair<int,int>, vector <pair<int,int>> , greater<pair<int,int>>> pq;\\n       pq.push(make_pair(0, src));\\n       while (!pq.empty()) {\\n          int u = pq.top().second;\\n          pq.pop();\\n          // weight is nothing but the value of grid[row][col]\\n          for (int v : adj(grid, u)) {\\n            int weight = grid[v / grid[0].size()][v % grid[0].size()];\\n            if (dist[v] > dist[u] + weight) {\\n               dist[v] = dist[u] + weight;\\n               pq.push(make_pair(dist[v], v));\\n            }\\n          }\\n       }\\n\\t\\t\\t // Account for the value at [0][0]\\n       return dist[grid.size() * grid[0].size() - 1] + grid[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23644,
                "title": "c-dp-solutions-o-m-n-and-o-n-space",
                "content": "       \\n    // O(m*n) space\\n    int minPathSum1(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp = grid;\\n        int row = dp.size(), col = dp[0].size();\\n        for (unsigned int i = 1; i < row; i++)\\n            dp[i][0] += dp[i-1][0];\\n        for (unsigned int j = 1; j < col;  j++) \\n            dp[0][j] += dp[0][j-1];\\n        for (unsigned int i = 1; i < row; i++) \\n            for (unsigned int j = 1; j < col; j++) \\n                dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        vector<int> dp = grid[0];\\n        for (unsigned int j = 1; j < col; j++)\\n            dp[j] += dp[j-1];\\n        for (unsigned int i = 1; i < row; i++) {\\n            dp[0] += grid[i][0];\\n            for (unsigned int j = 1; j < col; j++)\\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j]);\\n        }\\n        return dp[col-1];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "       \\n    // O(m*n) space\\n    int minPathSum1(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp = grid;\\n        int row = dp.size(), col = dp[0].size();\\n        for (unsigned int i = 1; i < row; i++)\\n            dp[i][0] += dp[i-1][0];\\n        for (unsigned int j = 1; j < col;  j++) \\n            dp[0][j] += dp[0][j-1];\\n        for (unsigned int i = 1; i < row; i++) \\n            for (unsigned int j = 1; j < col; j++) \\n                dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        vector<int> dp = grid[0];\\n        for (unsigned int j = 1; j < col; j++)\\n            dp[j] += dp[j-1];\\n        for (unsigned int i = 1; i < row; i++) {\\n            dp[0] += grid[i][0];\\n            for (unsigned int j = 1; j < col; j++)\\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j]);\\n        }\\n        return dp[col-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3693641,
                "title": "c-solution-dp-memorization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int mini(int m, int n, vector<vector<int>> &arr, vector<vector<int>> &memo){\\n        if(m==0 && n==0){\\n            return arr[0][0];\\n        }\\n        if(m<0 || n<0) return 1e9;\\n\\n        if(memo[m][n]!= -1) return memo[m][n];\\n\\n        int up = arr[m][n] + mini( m-1, n,arr, memo);\\n        int left = arr[m][n] + mini(m, n-1, arr, memo);\\n        memo[m][n] = min(up,  left);\\n        return memo[m][n];\\n    }\\n  \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>( n, -1));\\n        return mini(m-1, n-1, grid, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mini(int m, int n, vector<vector<int>> &arr, vector<vector<int>> &memo){\\n        if(m==0 && n==0){\\n            return arr[0][0];\\n        }\\n        if(m<0 || n<0) return 1e9;\\n\\n        if(memo[m][n]!= -1) return memo[m][n];\\n\\n        int up = arr[m][n] + mini( m-1, n,arr, memo);\\n        int left = arr[m][n] + mini(m, n-1, arr, memo);\\n        memo[m][n] = min(up,  left);\\n        return memo[m][n];\\n    }\\n  \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>( n, -1));\\n        return mini(m-1, n-1, grid, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639702,
                "title": "ekdm-garda-simpul-solution-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive --> memoize\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursive logic-> YOU ARE ON Nth row and Mth column \\n1. Assume recursion will give minimum sum till (row-1)th and (col-1)th position\\n2. Add current cell value to it.\\n3. Memoize \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n                     O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n                     O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&grid,int row,int col,vector<vector<int>>&dp){\\n       \\n        if(row==0 && col==0) return grid[row][col];\\n        if(row<0 || col<0) return 1e9;\\n         if(dp[row][col]!=-1) {\\n            return dp[row][col];\\n        }\\n        return dp[row][col]=grid[row][col]+min(solve(grid,row-1,col,dp),solve(grid,row,col-1,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.size()==0) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(grid,n-1,m-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&grid,int row,int col,vector<vector<int>>&dp){\\n       \\n        if(row==0 && col==0) return grid[row][col];\\n        if(row<0 || col<0) return 1e9;\\n         if(dp[row][col]!=-1) {\\n            return dp[row][col];\\n        }\\n        return dp[row][col]=grid[row][col]+min(solve(grid,row-1,col,dp),solve(grid,row,col-1,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.size()==0) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(grid,n-1,m-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354349,
                "title": "minimum-path-sum-dijikstra-python-3",
                "content": "If you had solved binary path in a maze, you\\'ll deduce its Intaution\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dis = [[inf] * len(grid[0]) for _ in range(len(grid))]\\n        dis[0][0] = grid[0][0]\\n        \\n        pq = [(grid[0][0], 0, 0)]\\n        directions = [[0,1],[1,0]]\\n        \\n        while pq :\\n            distance,row,col = heappop(pq)\\n            \\n            for dx,dy in directions :\\n                vis_row = row + dx\\n                vis_col = col + dy\\n                if vis_row < len(grid)   and vis_row >=0 and vis_col >= 0 and vis_col< len(grid[0])  :\\n                    if distance + grid[vis_row][vis_col] < dis[vis_row][vis_col] :\\n                        dis[vis_row][vis_col]  = distance + grid[vis_row][vis_col]\\n                        heappush(pq, (distance + grid[vis_row][vis_col],vis_row,vis_col))\\n                        \\n        return dis[-1][-1]\\n",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "If you had solved binary path in a maze, you\\'ll deduce its Intaution\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dis = [[inf] * len(grid[0]) for _ in range(len(grid))]\\n        dis[0][0] = grid[0][0]\\n        \\n        pq = [(grid[0][0], 0, 0)]\\n        directions = [[0,1],[1,0]]\\n        \\n        while pq :\\n            distance,row,col = heappop(pq)\\n            \\n            for dx,dy in directions :\\n                vis_row = row + dx\\n                vis_col = col + dy\\n                if vis_row < len(grid)   and vis_row >=0 and vis_col >= 0 and vis_col< len(grid[0])  :\\n                    if distance + grid[vis_row][vis_col] < dis[vis_row][vis_col] :\\n                        dis[vis_row][vis_col]  = distance + grid[vis_row][vis_col]\\n                        heappush(pq, (distance + grid[vis_row][vis_col],vis_row,vis_col))\\n                        \\n        return dis[-1][-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3352633,
                "title": "simple-solution-well-explained-c",
                "content": "# Intuition\\nThe very simple approach is to try all paths to reach the destination from source and find the minimum path. Here i started from destionation and found the ways to reach source. (We can not apply grredy here because the elements are not uniform).\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first approach that hit my brain is recursion, The question allowed to moves right and down, as i am moving backwards(dest. to source) so I\\'m alloweded left or up moves, so the idea is to explore all the paths and find that path which has minimum sum. \\nBase Condition of recursion-\\n1-> Suppose i reached (0,0), in this case I have to add the value present at this index.\\n2-> Suppose a path which takes me to an invalid index, so I did not reach to my destination, In that case I have to return something that this answer never considered in my answer, because we have to find minimum path sum here that\\'s why i returned a big integer.\\nAs I previously said I have two move left and up and they will be called recursively. At last minimum of them will be returned.\\n\\nSo the recursive solution gives TLE, then I opptimized it by using Memoization(saving recursive calls), it further reduced the time complexity but it increased the space complexity because we are using extra space(dp array).\\n\\nTabulation method is more optimized beacuse there is no recursion involved, and we saved the space taken by recursive calls in the programming stack.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Recursive solution(it will give TLE)\\n    int solve(vector<vector<int>>& grid, int i, int j){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );\\n        return min(left, up);\\n    }\\n    // MEMOIZATION\\n    int memo(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );  \\n        return dp[i][j] = min(left, up);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // int row= grid.size();\\n        // int col= grid[0].size();\\n        // // return solve(grid,row-1, col-1);\\n        // vector<vector<int>> dp(row,vector<int>(col,-1));\\n        // return memo(grid,row-1, col-1, dp);\\n\\n        // TABULATION\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<m ;j++){\\n                if(i==0 && j==0) dp[i][j]= grid[i][j];\\n                else{\\n                    int up= grid[i][j];\\n                    int left= grid[i][j];\\n                    if(i>0)\\n                        up += dp[i-1][j];\\n                    else up += 1e9;\\n                    if(j>0)\\n                        left += dp[i][j-1];\\n                    else left+=1e9;\\n                    dp[i][j]= min(up, left);\\n                }\\n            }    \\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Recursive solution(it will give TLE)\\n    int solve(vector<vector<int>>& grid, int i, int j){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );\\n        return min(left, up);\\n    }\\n    // MEMOIZATION\\n    int memo(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );  \\n        return dp[i][j] = min(left, up);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // int row= grid.size();\\n        // int col= grid[0].size();\\n        // // return solve(grid,row-1, col-1);\\n        // vector<vector<int>> dp(row,vector<int>(col,-1));\\n        // return memo(grid,row-1, col-1, dp);\\n\\n        // TABULATION\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<m ;j++){\\n                if(i==0 && j==0) dp[i][j]= grid[i][j];\\n                else{\\n                    int up= grid[i][j];\\n                    int left= grid[i][j];\\n                    if(i>0)\\n                        up += dp[i-1][j];\\n                    else up += 1e9;\\n                    if(j>0)\\n                        left += dp[i][j-1];\\n                    else left+=1e9;\\n                    dp[i][j]= min(up, left);\\n                }\\n            }    \\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348274,
                "title": "python-easy-dp-beats-90-tc-o-m-n-sc-o-1",
                "content": "# Intuition\\nIteratively add minimum of upper or left cell to the current cell and return the last cell of last row.\\n\\n# Approach\\nFor 0th row, start from (0, 1) position and add the left cell value to the current cell.\\nFor 0th col, start from (1, 0) position and add the upper cell value to the current cell.\\n\\nNow for every other cell starting from (1, 1) position, choose the minimum of the upper cell value or the left cell value and add it to the current cell (as we can only go down or right).\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346941,
                "title": "c-time-o-m-n-space-o-1-short-sweet-easy-to-understand-tabulation",
                "content": "````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(i = 1; i < n; i++){\\n            grid[0][i] += grid[0][i-1];\\n        }\\n        for(j = 1; j < m; j++){\\n            grid[j][0] += grid[j-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(i = 1; i < n; i++){\\n            grid[0][i] += grid[0][i-1];\\n        }\\n        for(j = 1; j < m; j++){\\n            grid[j][0] += grid[j-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346886,
                "title": "python-elegant-short-dp-top-down-bottom-up-o-1-memory",
                "content": "# Top-Down DP\\n\\n## Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(n*m)$$\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or j < 0:\\n                return maxsize\\n            if i == j == 0:\\n                return grid[0][0]\\n            return grid[i][j] + min(dp(i - 1, j), dp(i, j - 1))\\n\\n        return dp(len(grid) - 1, len(grid[0]) - 1)\\n```\\n\\n\\n# Dottom-Up DP\\n\\n## Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(1)$$\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(1, n):\\n            grid[i][0] += grid[i - 1][0]\\n\\n        for j in range(1, m):\\n            grid[0][j] += grid[0][j - 1]\\n\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\\n\\n        return grid[n - 1][m - 1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or j < 0:\\n                return maxsize\\n            if i == j == 0:\\n                return grid[0][0]\\n            return grid[i][j] + min(dp(i - 1, j), dp(i, j - 1))\\n\\n        return dp(len(grid) - 1, len(grid[0]) - 1)\\n```\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(1, n):\\n            grid[i][0] += grid[i - 1][0]\\n\\n        for j in range(1, m):\\n            grid[0][j] += grid[0][j - 1]\\n\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\\n\\n        return grid[n - 1][m - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346205,
                "title": "easy-java-explained-dp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm works by first initializing the first row and the first column of the **grid** array with the cumulative sum of the numbers in each row and column, respectively. Then, for each cell in the **grid** array that is not in the first row or column, the minimum path sum to reach that cell is the sum of the current cell value and the minimum of the path sum to reach the cell above and the cell to the left. This is computed using the formula **grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);**. Finally, the minimum path sum to reach the bottom-right corner of the **grid** array is returned.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for(int i=1;i<m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j=1; j<n; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n![a.jpg](https://assets.leetcode.com/users/images/4fcb60b5-156a-4322-bea7-9eaa100b4e78_1679892022.773603.jpeg)\\n\\n# **If you like the Solution Please Upvote me...**\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for(int i=1;i<m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j=1; j<n; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345904,
                "title": "c-very-simple-and-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nTime Complexity: o(m*n)\\n\\n- Space complexity:\\nSpace Complexity: o(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for(int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[i].Length; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n\\n                if (i == 0) {\\n                    grid[i][j] += grid[i][j - 1];\\n                    continue;\\n                }\\n\\n                if (j == 0) {\\n                    grid[i][j] += grid[i - 1][j];\\n                    continue;\\n                }\\n\\n                grid[i][j] += Math.Min(grid[i][j - 1], grid[i - 1][j]);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for(int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[i].Length; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n\\n                if (i == 0) {\\n                    grid[i][j] += grid[i][j - 1];\\n                    continue;\\n                }\\n\\n                if (j == 0) {\\n                    grid[i][j] += grid[i - 1][j];\\n                    continue;\\n                }\\n\\n                grid[i][j] += Math.Min(grid[i][j - 1], grid[i - 1][j]);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345767,
                "title": "3-approaches-recursive-to-most-optimised",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n// SOLUTION 1 : RECURSIVE APPROACH\\n    int solve(int row, int col, vector<vector<int>>&grid){\\n        // base case\\n        if(row == 0 && col == 0){\\n            return grid[0][0];\\n        }\\n        \\n        // out of bound case\\n        if(row < 0 || col < 0){\\n            return 1e9;\\n        }\\n        \\n        // recursive calls\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int ans = min(up , left);\\n        \\n        return ans;\\n    }\\n    \\n// SOLUTION 2 : RECURSIVE + MEMOIZATION APPROACH\\n    int solve2(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&dp){\\n        // base case\\n        if(i == 0 && j == 0){\\n            return grid[0][0];\\n        }\\n        \\n        if( i < 0 || j < 0){\\n            return 1e9;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        // recursive calls\\n        int up = grid[i][j] + solve2(i-1, j, grid, dp);\\n        int left = grid[i][j] + solve2(i, j-1, grid, dp);\\n        int ans = min(up, left);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n// SOLUTION 3 : TABULATION METHOD (BOTTOM UP APPORACH)\\n    int solve3(vector<vector<int>>& grid){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        vector<vector<int>>dp(row, vector<int>(col, 0));\\n\\n        for(int i = 0; i<row; i++){\\n            for(int j = 0; j<col; j++){\\n\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }\\n\\n                else{\\n\\n                    int up = grid[i][j];\\n                    if(i > 0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j > 0) left+= dp[i][j-1];\\n                    else left += 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n\\n        return dp[row-1][col-1];\\n    }\\n\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // recursive solution \\n        // int row = grid.size();\\n        // int col = grid[0].size();\\n        // return solve(row-1, col-1, grid);\\n        \\n        // recursion + memoization\\n        //    int row = grid.size();\\n        //    int col = grid[0].size();\\n        //    vector<vector<int>>dp(row, vector<int>(col, -1));\\n        //    return solve2(row-1, col-1, grid, dp);\\n\\n        // tabulation method\\n           return solve3(grid);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n// SOLUTION 1 : RECURSIVE APPROACH\\n    int solve(int row, int col, vector<vector<int>>&grid){\\n        // base case\\n        if(row == 0 && col == 0){\\n            return grid[0][0];\\n        }\\n        \\n        // out of bound case\\n        if(row < 0 || col < 0){\\n            return 1e9;\\n        }\\n        \\n        // recursive calls\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int ans = min(up , left);\\n        \\n        return ans;\\n    }\\n    \\n// SOLUTION 2 : RECURSIVE + MEMOIZATION APPROACH\\n    int solve2(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&dp){\\n        // base case\\n        if(i == 0 && j == 0){\\n            return grid[0][0];\\n        }\\n        \\n        if( i < 0 || j < 0){\\n            return 1e9;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        // recursive calls\\n        int up = grid[i][j] + solve2(i-1, j, grid, dp);\\n        int left = grid[i][j] + solve2(i, j-1, grid, dp);\\n        int ans = min(up, left);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n// SOLUTION 3 : TABULATION METHOD (BOTTOM UP APPORACH)\\n    int solve3(vector<vector<int>>& grid){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        vector<vector<int>>dp(row, vector<int>(col, 0));\\n\\n        for(int i = 0; i<row; i++){\\n            for(int j = 0; j<col; j++){\\n\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }\\n\\n                else{\\n\\n                    int up = grid[i][j];\\n                    if(i > 0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j > 0) left+= dp[i][j-1];\\n                    else left += 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n\\n        return dp[row-1][col-1];\\n    }\\n\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // recursive solution \\n        // int row = grid.size();\\n        // int col = grid[0].size();\\n        // return solve(row-1, col-1, grid);\\n        \\n        // recursion + memoization\\n        //    int row = grid.size();\\n        //    int col = grid[0].size();\\n        //    vector<vector<int>>dp(row, vector<int>(col, -1));\\n        //    return solve2(row-1, col-1, grid, dp);\\n\\n        // tabulation method\\n           return solve3(grid);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345695,
                "title": "java-dp-o-1-space-7-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minPathSum(int[][] grid) {\\n    var m = grid.length;\\n    var n = grid[0].length;\\n\\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        if (i == 0 && j == 0) continue;\\n\\n        grid[i][j] +=\\n          Math.min(i == 0 ? 1000 : grid[i-1][j],\\n                   j == 0 ? 1000 : grid[i][j-1]);\\n      }\\n    }\\n    return grid[m-1][n-1];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  public int minPathSum(int[][] grid) {\\n    var m = grid.length;\\n    var n = grid[0].length;\\n\\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        if (i == 0 && j == 0) continue;\\n\\n        grid[i][j] +=\\n          Math.min(i == 0 ? 1000 : grid[i-1][j],\\n                   j == 0 ? 1000 : grid[i][j-1]);\\n      }\\n    }\\n    return grid[m-1][n-1];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335810,
                "title": "tabulation-approach-based-explanation-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince there can be numerous number of ways using which we can reach from (0,0) to (m-1, n-1), recursion is evident that it needs to be applied here. Also, after applying some basic recursion, we accordingly optimise our code using memoization, tabulation and space optimisation techniques.\\n![image.png](https://assets.leetcode.com/users/images/59a709e2-b2db-4dbe-bf2a-37cc20ef5f27_1679660889.3993416.png)\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n=Declare a dp[] array of size [n][m].\\n=First initialize the base condition values, i.e dp[0][0] = matrix[0][0]\\n=Our answer should get stored in dp[n-1][m-1]. We want to move from (0,0) to (n-1,m-1). But we can\\u2019t move arbitrarily, we should move such that at a particular i and j, we have all the values required to compute dp[i][j].\\n=If we see the memoized code, values required for dp[i][j] are: dp[i-1][j] and dp[i][j-1]. So we only use the previous row and column value.\\n=We have already filled the top-left corner (i=0 and j=0), if we move in any of the two following ways(given below), at every cell we do have all the previous values required to compute its value.\\n=We can use two nested loops to have this traversal\\n=Whenever i>0 , j>0, we will simply mark dp[i][j] = matric[i][j] + min(dp[i-1][j],dp[i][j-1]), according to our recursive relation.\\n=When i=0 or j=0, we add to up( or left) 1e9, so that this path can be rejected.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m) {as there are two nested loops}\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m) {as we are using an array of size n*m}\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0 && j==0) dp[i][j] = grid[i][j];\\n                \\n                else{\\n                    int up = grid[i][j];\\n                    if(i>0) up+=dp[i-1][j];\\n                    else up+=1e9;\\n                    \\n                    int left = grid[i][j];\\n                    if(j>0) left+=dp[i][j-1];\\n                    else left+=1e9;\\n                    \\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0 && j==0) dp[i][j] = grid[i][j];\\n                \\n                else{\\n                    int up = grid[i][j];\\n                    if(i>0) up+=dp[i-1][j];\\n                    else up+=1e9;\\n                    \\n                    int left = grid[i][j];\\n                    if(j>0) left+=dp[i][j-1];\\n                    else left+=1e9;\\n                    \\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287986,
                "title": "java-memoization-solution-99-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\n# Code\\n```\\nclass Solution {\\n    public int f(int i , int j , int[][] grid,int n , int m , int[][] dp) {\\n        if(i == n-1 && j == m-1) return grid[i][j]; \\n        if(i == n || j== m) return (int)1e9;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int right = grid[i][j] + f(i,j+1,grid,n,m,dp);\\n        int down = grid[i][j] + f(i+1,j,grid,n,m,dp);\\n        return dp[i][j] = Math.min(right,down);\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length,m = grid[0].length;\\n        int[][] dp = new int[n][m];\\n        for(int[] d : dp) Arrays.fill(d,-1);\\n        return f(0,0,grid,n,m,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int f(int i , int j , int[][] grid,int n , int m , int[][] dp) {\\n        if(i == n-1 && j == m-1) return grid[i][j]; \\n        if(i == n || j== m) return (int)1e9;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int right = grid[i][j] + f(i,j+1,grid,n,m,dp);\\n        int down = grid[i][j] + f(i+1,j,grid,n,m,dp);\\n        return dp[i][j] = Math.min(right,down);\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length,m = grid[0].length;\\n        int[][] dp = new int[n][m];\\n        for(int[] d : dp) Arrays.fill(d,-1);\\n        return f(0,0,grid,n,m,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182290,
                "title": "time-o-m-n-space-o-1-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180672,
                "title": "beats-96-4-64-minimum-path-sum-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Initialize m and n as the number of rows and columns of the grid.\\n- Initialize dp list of size n with the first element of dp being the first element of the first row of the grid.\\n- Loop through the remaining columns of the first row, updating each dp[i] as dp[i-1] + grid[0][i].\\n- Loop through the remaining rows of the grid, updating the first column of each row as dp[0] + grid[i][0].\\n- Loop through the remaining columns of the current row, updating each dp[j] as the minimum of dp[j-1] and dp[j] plus the current grid element.\\n- Return the last element of dp which is the minimum path sum from top left to bottom right.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        dp[0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1] + grid[0][i]\\n        for i in range(1, m):\\n            dp[0] += grid[i][0]\\n            for j in range(1, n):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[n-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        dp[0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1] + grid[0][i]\\n        for i in range(1, m):\\n            dp[0] += grid[i][0]\\n            for j in range(1, n):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164319,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        sols = [[x for x in row] for row in grid]\\n\\n        for row in range(1, len(grid)):\\n            sols[row][0] += sols[row - 1][0]\\n\\n        for col in range(1, len(grid[0])):\\n            sols[0][col] += sols[0][col - 1]\\n        \\n        for row in range(1, len(grid)):\\n            for col in range(1, len(grid[0])):\\n                sols[row][col] += min(sols[row - 1][col], sols[row][col - 1])\\n\\n        return sols[-1][-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        fill(0, 0, grid);\\n        return grid[grid.length - 1][grid[0].length - 1];\\n    }\\n\\n    public void fill(int row, int col, int[][] grid) {\\n        if (row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        if (row != 0 && col != 0) {\\n            grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n        }\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (col == 0) {\\n                grid[i][col] = grid[i - 1][col] + grid[i][col];\\n            } else {\\n                grid[i][col] = grid[i][col] + Math.min(grid[i - 1][col], grid[i][col - 1]);\\n            }\\n        }\\n\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (row == 0) {\\n                grid[row][i] = grid[row][i - 1] + grid[row][i];\\n            } else {\\n            grid[row][i] = grid[row][i] + Math.min(grid[row][i - 1], grid[row - 1][i]);\\n            }\\n        } \\n        fill(row + 1, col + 1, grid);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        sols = [[x for x in row] for row in grid]\\n\\n        for row in range(1, len(grid)):\\n            sols[row][0] += sols[row - 1][0]\\n\\n        for col in range(1, len(grid[0])):\\n            sols[0][col] += sols[0][col - 1]\\n        \\n        for row in range(1, len(grid)):\\n            for col in range(1, len(grid[0])):\\n                sols[row][col] += min(sols[row - 1][col], sols[row][col - 1])\\n\\n        return sols[-1][-1]\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        fill(0, 0, grid);\\n        return grid[grid.length - 1][grid[0].length - 1];\\n    }\\n\\n    public void fill(int row, int col, int[][] grid) {\\n        if (row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        if (row != 0 && col != 0) {\\n            grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n        }\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (col == 0) {\\n                grid[i][col] = grid[i - 1][col] + grid[i][col];\\n            } else {\\n                grid[i][col] = grid[i][col] + Math.min(grid[i - 1][col], grid[i][col - 1]);\\n            }\\n        }\\n\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (row == 0) {\\n                grid[row][i] = grid[row][i - 1] + grid[row][i];\\n            } else {\\n            grid[row][i] = grid[row][i] + Math.min(grid[row][i - 1], grid[row - 1][i]);\\n            }\\n        } \\n        fill(row + 1, col + 1, grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096502,
                "title": "2-ms-fastest-ever-java-python-bottom-up-dp-space-optimized",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n// 2D Dp\\nExcept boundary cases :\\n *   dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j]\\n\\n// 1D space optimized\\nPreprocess the dp[] array with the first rwo of the grid.\\nThen iterate through remaining elements and choose :\\n*    dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j]\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# In-place \\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i==0 and j==0:\\n                    continue\\n                elif i==0:\\n                    grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j]\\n        return grid[-1][-1]\\n```\\n# Space optimized (Not in-place)\\n```\\nclass Solution { // 1D space optimized\\n    public int minPathSum(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[]=new int[n];\\n        dp[0]=grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        {\\n            if(j==0) dp[j]=grid[i][j]+dp[j];\\n            else\\n            dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j];\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i==0 and j==0:\\n                    continue\\n                elif i==0:\\n                    grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j]\\n        return grid[-1][-1]\\n```\n```\\nclass Solution { // 1D space optimized\\n    public int minPathSum(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[]=new int[n];\\n        dp[0]=grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        {\\n            if(j==0) dp[j]=grid[i][j]+dp[j];\\n            else\\n            dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j];\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060624,
                "title": "dynamic-programming-solution-in-python3",
                "content": "# | Dynamic Programming Solution in Python3:\\n\\n![solution.png](https://assets.leetcode.com/users/images/c42cc536-3e54-4245-a93d-7d0b4bdcbaf1_1673897684.0651052.png)\\n\\n### Complexity\\n***Time complexity =>***  \\nO(n^2)\\n***Space complexity =>***  \\nO(n^2)\\n\\n## Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        m = len(grid)\\n        \\n        dp = [[0]*(n) for x in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[i][j] = grid[i][j]\\n                elif i == 0:\\n                    dp[i][j] = grid[i][j] + dp[i][j - 1]\\n                elif j == 0:\\n                    dp[i][j] = grid[i][j] + dp[i - 1][j]\\n                else:\\n                    dp[i][j] = min(grid[i][j] + dp[i-1][j], grid[i][j] + dp[i][j - 1])\\n        \\n        return dp[m-1][n-1]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        m = len(grid)\\n        \\n        dp = [[0]*(n) for x in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[i][j] = grid[i][j]\\n                elif i == 0:\\n                    dp[i][j] = grid[i][j] + dp[i][j - 1]\\n                elif j == 0:\\n                    dp[i][j] = grid[i][j] + dp[i - 1][j]\\n                else:\\n                    dp[i][j] = min(grid[i][j] + dp[i-1][j], grid[i][j] + dp[i][j - 1])\\n        \\n        return dp[m-1][n-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041086,
                "title": "recursion-to-space-optimization-all-solutions",
                "content": "**DO UPVOTE IF YOU FIND IT HELPFUL**\\n\\n**RECURSION**\\n```\\n  int solve(int i,int j,vector<vector<int>>& grid)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         int up=grid[i][j] + solve(i-1,j,grid);\\n         int left=grid[i][j] + solve(i,j-1,grid);\\n         return min(left,up);\\n     }\\n```\\n**MEMOIZATION**\\n```\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&dp)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         if(dp[i][j]!=-1)\\n         return dp[i][j];\\n\\n         int up=grid[i][j] + solve(i-1,j,grid,dp);\\n         int left=grid[i][j] + solve(i,j-1,grid,dp);\\n         return dp[i][j]= min(left,up);\\n    }\\n```\\n**TABULATION**\\n```\\n vector<vector<int>>dp(n,vector<int>(m,0));\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<m;j++)\\n         {\\n             if(i==0&&j==0)\\n              dp[i][j]=grid[i][j];\\n              else\\n              {\\n                  int up=1e9,left=1e9;\\n                  if(i>0)\\n                  up=grid[i][j]+dp[i-1][j];\\n                  if(j>0)\\n                  left=grid[i][j]+dp[i][j-1];\\n                  dp[i][j]=min(up,left);\\n              }\\n         }\\n     }\\n     return dp[n-1][m-1];\\n```\\n**SPACE OPTIMIZATION**\\n\\n```\\nvector<int>prev(m,0),curr(m,0);\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==0&&j==0)\\n               curr[j]=grid[i][j];\\n               else\\n               {\\n                   int up=1e9,left=1e9;\\n                   if(i>0)\\n                   up=grid[i][j]+prev[j];\\n                   if(j>0)\\n                   left=grid[i][j]+curr[j-1];\\n                   curr[j]=min(up,left);\\n               }\\n          }\\n          prev=curr;\\n      }\\n      return prev[m-1];\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n  int solve(int i,int j,vector<vector<int>>& grid)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         int up=grid[i][j] + solve(i-1,j,grid);\\n         int left=grid[i][j] + solve(i,j-1,grid);\\n         return min(left,up);\\n     }\\n```\n```\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&dp)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         if(dp[i][j]!=-1)\\n         return dp[i][j];\\n\\n         int up=grid[i][j] + solve(i-1,j,grid,dp);\\n         int left=grid[i][j] + solve(i,j-1,grid,dp);\\n         return dp[i][j]= min(left,up);\\n    }\\n```\n```\\n vector<vector<int>>dp(n,vector<int>(m,0));\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<m;j++)\\n         {\\n             if(i==0&&j==0)\\n              dp[i][j]=grid[i][j];\\n              else\\n              {\\n                  int up=1e9,left=1e9;\\n                  if(i>0)\\n                  up=grid[i][j]+dp[i-1][j];\\n                  if(j>0)\\n                  left=grid[i][j]+dp[i][j-1];\\n                  dp[i][j]=min(up,left);\\n              }\\n         }\\n     }\\n     return dp[n-1][m-1];\\n```\n```\\nvector<int>prev(m,0),curr(m,0);\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==0&&j==0)\\n               curr[j]=grid[i][j];\\n               else\\n               {\\n                   int up=1e9,left=1e9;\\n                   if(i>0)\\n                   up=grid[i][j]+prev[j];\\n                   if(j>0)\\n                   left=grid[i][j]+curr[j-1];\\n                   curr[j]=min(up,left);\\n               }\\n          }\\n          prev=curr;\\n      }\\n      return prev[m-1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015988,
                "title": "easy-java-solution-recursive-dp-beginner-friendly",
                "content": "# Intuition\\n1. Handle base cases\\n2. Get down and right value recursive\\n3. Return min(down, right) + self value\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid, int row, int col, int[][] dp) {\\n        if(row < 0 || row >= grid.length || col < 0 || col >=grid[0].length){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(dp[row][col] != 0) {\\n            return dp[row][col];\\n        }\\n        if(row == grid.length -1 && col == grid[0].length - 1) {\\n            return grid[row][col];\\n        }\\n\\n        int rightSum = minPathSum(grid, row, col + 1, dp);\\n        int downSum = minPathSum(grid, row + 1, col, dp);\\n        return dp[row][col] = Math.min(rightSum, downSum) + grid[row][col];\\n        \\n    }\\n    public int minPathSum(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        return minPathSum(grid, 0 ,0, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid, int row, int col, int[][] dp) {\\n        if(row < 0 || row >= grid.length || col < 0 || col >=grid[0].length){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(dp[row][col] != 0) {\\n            return dp[row][col];\\n        }\\n        if(row == grid.length -1 && col == grid[0].length - 1) {\\n            return grid[row][col];\\n        }\\n\\n        int rightSum = minPathSum(grid, row, col + 1, dp);\\n        int downSum = minPathSum(grid, row + 1, col, dp);\\n        return dp[row][col] = Math.min(rightSum, downSum) + grid[row][col];\\n        \\n    }\\n    public int minPathSum(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        return minPathSum(grid, 0 ,0, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970608,
                "title": "memoization-tabulation-space-optimization-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(!i && !j) return grid[i][j];\\n        if(i < 0 || j < 0) return INT_MAX;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, grid, dp);\\n        int l = dfs(i, j - 1, grid, dp);\\n\\n        return dp[i][j] = grid[i][j] + min(u, l);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        return dfs(n - 1, m - 1, grid, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        dp[0][0] = grid[0][0];\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(!i && !j) continue;\\n                int u = INT_MAX, l = INT_MAX;\\n                if(i > 0) u = dp[i - 1][j];\\n                if(j > 0) l = dp[i][j - 1];\\n                dp[i][j] = grid[i][j] + min(u, l);\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> dp(m, INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int i=0; i<n; i++) {\\n            vector<int> temp(m);\\n            for(int j=0; j<m; j++) {\\n                temp[j] = grid[i][j] + min(dp[j], (j > 0 ? temp[j - 1] : INT_MAX));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(!i && !j) return grid[i][j];\\n        if(i < 0 || j < 0) return INT_MAX;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, grid, dp);\\n        int l = dfs(i, j - 1, grid, dp);\\n\\n        return dp[i][j] = grid[i][j] + min(u, l);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        return dfs(n - 1, m - 1, grid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        dp[0][0] = grid[0][0];\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(!i && !j) continue;\\n                int u = INT_MAX, l = INT_MAX;\\n                if(i > 0) u = dp[i - 1][j];\\n                if(j > 0) l = dp[i][j - 1];\\n                dp[i][j] = grid[i][j] + min(u, l);\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> dp(m, INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int i=0; i<n; i++) {\\n            vector<int> temp(m);\\n            for(int j=0; j<m; j++) {\\n                temp[j] = grid[i][j] + min(dp[j], (j > 0 ? temp[j - 1] : INT_MAX));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912143,
                "title": "c-recursion-memorization-tabulation-space-optimization-teache-by-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(m*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(N) + O(M-1 N-1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n*********************RECURSION********************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      long long up = grid[i][j] + func(i-1,j,grid);\\n      long long  left = grid[i][j] + func(i,j-1,grid);\\n      return min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        return func(m-1,n-1,grid);\\n        \\n    }\\n};\\n\\n****************************MEMORIZATION*************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      if(dp[i][j] != -1) return dp[i][j];\\n      long long up = grid[i][j] + func(i-1,j,grid,dp);\\n      long long  left = grid[i][j] + func(i,j-1,grid,dp);\\n      return dp[i][j] = min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return func(m-1,n-1,grid,dp);\\n        \\n    }\\n};\\n******************************TABULATION********************************\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=dp[i-1][j];\\n                    else up +=1e9;\\n                    if(j>0) left +=dp[i][j-1];\\n                    else left +=1e9;\\n\\n                    dp[i][j] = min(up,left);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n************************SPACE OPTIMIZATION*************************\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>prev(n,0);\\n        for(int i=0;i<m;i++){\\n            vector<int>temp(n,0);\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    temp[j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=prev[j];\\n                    else up +=1e9;\\n                    if(j>0) left +=temp[j-1];\\n                    else left +=1e9;\\n\\n                    temp[j] = min(up,left);\\n                }\\n            }\\n            prev =temp;\\n        }\\n        return prev[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n*********************RECURSION********************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      long long up = grid[i][j] + func(i-1,j,grid);\\n      long long  left = grid[i][j] + func(i,j-1,grid);\\n      return min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        return func(m-1,n-1,grid);\\n        \\n    }\\n};\\n\\n****************************MEMORIZATION*************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      if(dp[i][j] != -1) return dp[i][j];\\n      long long up = grid[i][j] + func(i-1,j,grid,dp);\\n      long long  left = grid[i][j] + func(i,j-1,grid,dp);\\n      return dp[i][j] = min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return func(m-1,n-1,grid,dp);\\n        \\n    }\\n};\\n******************************TABULATION********************************\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=dp[i-1][j];\\n                    else up +=1e9;\\n                    if(j>0) left +=dp[i][j-1];\\n                    else left +=1e9;\\n\\n                    dp[i][j] = min(up,left);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n************************SPACE OPTIMIZATION*************************\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>prev(n,0);\\n        for(int i=0;i<m;i++){\\n            vector<int>temp(n,0);\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    temp[j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=prev[j];\\n                    else up +=1e9;\\n                    if(j>0) left +=temp[j-1];\\n                    else left +=1e9;\\n\\n                    temp[j] = min(up,left);\\n                }\\n            }\\n            prev =temp;\\n        }\\n        return prev[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880796,
                "title": "c-memoization-dp-recursion-with-clean-comments",
                "content": "At every step, we have **two choices** - to move *right* **or** to move *down*, and we need **min** from both the recursive calls.\\n\\nso, first add the current cell\\'s value and then go to the next cell, either right or down, and return minimum.\\n\\nthen just memoize the recursion, to optimise it.\\n```\\nclass Solution {\\nprivate:\\n    int dp[201][201];\\n    \\n    int rec(vector<vector<int>>& grid, int i, int j) {\\n        // pruning statement to check out of bounds\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            return 1e9;\\n        \\n        // base case, reached at destination\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1)\\n            return grid[i][j];\\n        \\n        // cache check\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // compute and store/memoize\\n        return dp[i][j] = min(\\n            grid[i][j] + rec(grid, i + 1, j), \\n            grid[i][j] + rec(grid, i, j + 1)\\n        );\\n    }\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        return rec(grid, 0, 0);\\n    }\\n};\\n```\\nif you have any doubts, *feel free to ask* :)\\nplease **UpVote** \\uD83D\\uDD3C , if it helped",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[201][201];\\n    \\n    int rec(vector<vector<int>>& grid, int i, int j) {\\n        // pruning statement to check out of bounds\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            return 1e9;\\n        \\n        // base case, reached at destination\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1)\\n            return grid[i][j];\\n        \\n        // cache check\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // compute and store/memoize\\n        return dp[i][j] = min(\\n            grid[i][j] + rec(grid, i + 1, j), \\n            grid[i][j] + rec(grid, i, j + 1)\\n        );\\n    }\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        return rec(grid, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819398,
                "title": "how-to-print-the-path-if-asked",
                "content": "[ShadyCoder](https://leetcode.com/ShadyCoder/) in the [Discuss section]() asked -> \\n\\n\"What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?\"\\n\\nIt is implemented in `minPath()` Function below...\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n// function for minPath getting the minPath string....\\n    string minPath(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<vector<string>> path(m, vector<string>(n));\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n            path[i][0] += path[i - 1][0] + \"D\";\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n            path[0][j] += path[0][j - 1] + \"R\";\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n                if (dp[i][j] == grid[i][j] + dp[i - 1][j])\\n                    path[i][j] = path[i - 1][j] + \"D\";\\n                else\\n                    path[i][j] = path[i][j - 1] + \"R\";\\n            }\\n        }\\n        return path[m - 1][n - 1];\\n    }\\n};\\n\\n// driver code \\nint main()\\n{\\n    vector<vector<vector<int>>> TestCases(3);\\n    TestCases[0] = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};\\n    TestCases[1] = {{1, 2, 3}, {4, 5, 6}};\\n    TestCases[2] = {{1, 15, 3, 10}, {2, 2, 10, 32}, {3, 6, 1, 1}, {10, 5, 3, 5}, {3, 4, 2, 10}};\\n    Solution S;\\n    for (int i = 0; i < TestCases.size(); i++)\\n    {\\n        cout << \"Test Case #\" << i + 1 << endl;\\n        for (auto &v : TestCases[i])\\n        {\\n            for (auto &x : v)\\n                cout << x << \"\\\\t\";\\n            cout << endl;\\n        }\\n        cout << \"Min Path Sum = \" << S.minPathSum(TestCases[i]) << endl;\\n        cout << \"Min Path = \" << S.minPath(TestCases[i]) << endl;\\n        cout << endl;\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n// function for minPath getting the minPath string....\\n    string minPath(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<vector<string>> path(m, vector<string>(n));\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n            path[i][0] += path[i - 1][0] + \"D\";\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n            path[0][j] += path[0][j - 1] + \"R\";\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n                if (dp[i][j] == grid[i][j] + dp[i - 1][j])\\n                    path[i][j] = path[i - 1][j] + \"D\";\\n                else\\n                    path[i][j] = path[i][j - 1] + \"R\";\\n            }\\n        }\\n        return path[m - 1][n - 1];\\n    }\\n};\\n\\n// driver code \\nint main()\\n{\\n    vector<vector<vector<int>>> TestCases(3);\\n    TestCases[0] = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};\\n    TestCases[1] = {{1, 2, 3}, {4, 5, 6}};\\n    TestCases[2] = {{1, 15, 3, 10}, {2, 2, 10, 32}, {3, 6, 1, 1}, {10, 5, 3, 5}, {3, 4, 2, 10}};\\n    Solution S;\\n    for (int i = 0; i < TestCases.size(); i++)\\n    {\\n        cout << \"Test Case #\" << i + 1 << endl;\\n        for (auto &v : TestCases[i])\\n        {\\n            for (auto &x : v)\\n                cout << x << \"\\\\t\";\\n            cout << endl;\\n        }\\n        cout << \"Min Path Sum = \" << S.minPathSum(TestCases[i]) << endl;\\n        cout << \"Min Path = \" << S.minPath(TestCases[i]) << endl;\\n        cout << endl;\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2577847,
                "title": "python-90-solution-dp",
                "content": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dp=[[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                dp[row][col]=grid[row][col]\\n                if row==0 and col==0:\\n                    continue\\n                candidates=set()\\n                if col>0:\\n                    candidates.add(dp[row][col-1])\\n                if row>0:\\n                    candidates.add(dp[row-1][col])\\n                dp[row][col]+=min(candidates)\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dp=[[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                dp[row][col]=grid[row][col]\\n                if row==0 and col==0:\\n                    continue\\n                candidates=set()\\n                if col>0:\\n                    candidates.add(dp[row][col-1])\\n                if row>0:\\n                    candidates.add(dp[row-1][col])\\n                dp[row][col]+=min(candidates)\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455017,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=694ITcSBySY",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=694ITcSBySY",
                "codeTag": "Unknown"
            },
            {
                "id": 2410066,
                "title": "python-solution-from-recursion-to-dp-and-then-dp-space-optimisation-o-n",
                "content": "**Please Upvote if you liked it**\\n\\n**Recursion : TLE**\\n```\\nclass Solution:\\n    def solve(self,i,j,a):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        up=a[i][j]+self.solve(i-1,j,a)\\n        down=a[i][j]+self.solve(i,j-1,a)\\n        return min(up,down)\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        return self.solve(m-1,n-1,grid)\\n```\\n**Memoization : Accepted**\\n```\\nclass Solution:\\n    def solve(self,i,j,a,dp):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        \\n        up = a[i][j] + self.solve(i-1,j,a,dp)\\n        down = a[i][j] + self.solve(i,j-1,a,dp)\\n        dp[i][j] = min(up,down)\\n        return dp[i][j]\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        return self.solve(m-1,n-1,grid,dp)\\n```\\n***Dynamic Programming(tabulation): Accepted***\\n```\\nclass Solution:\\n\\t    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[0][0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=dp[i-1][j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    dp[i][j]=min(up,left)\\n                    \\n        return dp[m-1][n-1]\\n```\\n# *Space Optimization O(N)+O(N)*\\n```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid[0])\\n        prev=[-1]*n\\n        for i in range(m):\\n            curr=[-1]*n\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    curr[0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=prev[j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=curr[j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    curr[j]=min(up,left)\\n            prev=curr\\n                    \\n        return prev[n-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self,i,j,a):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        up=a[i][j]+self.solve(i-1,j,a)\\n        down=a[i][j]+self.solve(i,j-1,a)\\n        return min(up,down)\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        return self.solve(m-1,n-1,grid)\\n```\n```\\nclass Solution:\\n    def solve(self,i,j,a,dp):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        \\n        up = a[i][j] + self.solve(i-1,j,a,dp)\\n        down = a[i][j] + self.solve(i,j-1,a,dp)\\n        dp[i][j] = min(up,down)\\n        return dp[i][j]\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        return self.solve(m-1,n-1,grid,dp)\\n```\n```\\nclass Solution:\\n\\t    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[0][0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=dp[i-1][j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    dp[i][j]=min(up,left)\\n                    \\n        return dp[m-1][n-1]\\n```\n```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid[0])\\n        prev=[-1]*n\\n        for i in range(m):\\n            curr=[-1]*n\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    curr[0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=prev[j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=curr[j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    curr[j]=min(up,left)\\n            prev=curr\\n                    \\n        return prev[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375062,
                "title": "explained-java-solution-easy-to-understand-2ms-90-faster-full-explanation",
                "content": "**NOTE** : Please do try **UNIQUE PATH** problem before trying this problem : https://leetcode.com/problems/unique-paths/\\nand my solution and explanation to that problem is : https://leetcode.com/problems/unique-paths/discuss/2364894/JAVA-SOLUTION-or-0MS-100-FASTER-or-FULL-EXPLANATION\\n\\nNow coming to this problem :\\n* we can move either down or right \\n* for the grid[0][0] we don\\'t update it.\\n* so for the 0th row or column we will update the cost by adding the cost before that column i.e\\n1.  \\t\\t\\tfor the 0th row --> grid[i][j] += grid[i][j-1]\\n1.  \\t\\t\\tfor the 0th col --> grid[i][j] += grid[i-1][j];\\n\\n\\n\\n* Now for the other elements we update them adding that block value to **MIN** of the value from top element above them and the left element to that block (since we can from either down or right , therefor to reach any element we enter in it either from top of it of left of it )\\n\\n```\\npublic int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n= grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                else if (i == 0){\\n                    grid[i][j] += grid[i][j-1];\\n                }\\n                else if(j == 0){\\n                    grid[i][j] += grid[i-1][j];\\n                }\\n                else {\\n                    grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]);\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n```\\n\\n\\n\\n\\n.\\n.\\n.\\n.\\n* Let\\'s see how a grid looks like after all these operations \\n```\\n1\\t3\\t1                              1     4     5\\n1\\t5\\t1           -->                2     7     6\\n4\\t2\\t1                              6     8     7\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n= grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                else if (i == 0){\\n                    grid[i][j] += grid[i][j-1];\\n                }\\n                else if(j == 0){\\n                    grid[i][j] += grid[i-1][j];\\n                }\\n                else {\\n                    grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]);\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n```\n```\\n1\\t3\\t1                              1     4     5\\n1\\t5\\t1           -->                2     7     6\\n4\\t2\\t1                              6     8     7\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2334414,
                "title": "recursive-memoization-tabulation-c",
                "content": "**1) RECURSION**\\n\\nThis solution will give **TLE (ONLY 23 / 61 TEST CASES PASSED)**\\n\\n```\\n// Recursive Solution\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid);\\n        \\n        return min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        return solve(m - 1, n - 1, grid);\\n    }\\n};\\n```\\n\\n\\n**2) MEMOIZATION**\\n\\n  This solution passes all the test cases\\n```\\n// Memoization\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid, vector<vector<long long int>> &dp)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid, dp);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid, dp);\\n        \\n        return dp[i][j] = min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, -1));\\n        \\n        return solve(m - 1, n - 1, grid, dp);\\n    }\\n};\\n```\\n\\n\\n**3) TABULATION**\\n This solution passes all the test cases\\n \\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, 0));\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    long long int up = grid[i][j];\\n                    if(i > 0)\\n                        up += dp[i - 1][j];\\n                    else\\n                        up += 1e9; // to neglect this path  \\n                    \\n                    long long int left = grid[i][j];                    \\n                    if(j > 0)\\n                        left += dp[i][j - 1];\\n                    else\\n                        left += 1e9; // to neglect this path\\n                    \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// Recursive Solution\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid);\\n        \\n        return min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        return solve(m - 1, n - 1, grid);\\n    }\\n};\\n```\n```\\n// Memoization\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid, vector<vector<long long int>> &dp)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid, dp);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid, dp);\\n        \\n        return dp[i][j] = min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, -1));\\n        \\n        return solve(m - 1, n - 1, grid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, 0));\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    long long int up = grid[i][j];\\n                    if(i > 0)\\n                        up += dp[i - 1][j];\\n                    else\\n                        up += 1e9; // to neglect this path  \\n                    \\n                    long long int left = grid[i][j];                    \\n                    if(j > 0)\\n                        left += dp[i][j - 1];\\n                    else\\n                        left += 1e9; // to neglect this path\\n                    \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093326,
                "title": "easy-to-understand-cpp-solution",
                "content": "go through the matrix from (1,1);\\n\\n````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        \\n        for(int j=1; j<m; j++){\\n            arr[0][j]+=arr[0][j-1];\\n        }\\n        for(int j=1; j<n; j++){\\n            arr[j][0]+=arr[j-1][0];\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                arr[i][j]+=min(arr[i-1][j],arr[i][j-1]);\\n            }\\n        }\\n        return arr[n-1][m-1];\\n    }\\n};\\n````\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        \\n        for(int j=1; j<m; j++){\\n            arr[0][j]+=arr[0][j-1];\\n        }\\n        for(int j=1; j<n; j++){\\n            arr[j][0]+=arr[j-1][0];\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                arr[i][j]+=min(arr[i-1][j],arr[i][j-1]);\\n            }\\n        }\\n        return arr[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072550,
                "title": "all-c-solutions-brute-memoization-dp-dp-optimised-dp-constant-space",
                "content": "### Approach 1 - Recursion\\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid);\\n        \\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return helper(m-1, n-1, grid);\\n    }\\n};\\n```\\n\\nTime Complexity - O(2^(M+N)) \\nSpace Complexity - O(M+N)\\n\\n### Approach 2 - Memoization\\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& memo){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        if(memo[x][y] != -1) return memo[x][y];\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid, memo);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid, memo);\\n        \\n        return memo[x][y] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        return helper(m-1, n-1, grid, memo);\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O((M+N) + M\\\\*N) - Recursice Stack Space + Memo table\\n\\n### Approach 3 - DP\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp (m, vector<int>(n, 0));\\n        dp[0][0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + dp[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y] + dp[x][y-1];\\n                \\n                dp[x][y] = min(up, left);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O(M\\\\*N) - DP table\\n\\n### Approach 4 - DP optimised\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> prevRow(n, 0), curRow(n, 0);\\n        curRow[0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + prevRow[y];\\n                if(y-1 >= 0) left = grid[x][y] + curRow[y-1];\\n                \\n                curRow[y] = min(up, left);\\n            }\\n            prevRow = curRow;\\n        }\\n        return curRow[n-1];\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O(N) - DP table\\n\\n### Approach 5 - DP with constant space\\n##### The approach involves modification of the input array and the solution will fail if the input array is immutable\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y-1];\\n                \\n                grid[x][y] += min(up, left);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid);\\n        \\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return helper(m-1, n-1, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& memo){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        if(memo[x][y] != -1) return memo[x][y];\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid, memo);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid, memo);\\n        \\n        return memo[x][y] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        return helper(m-1, n-1, grid, memo);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp (m, vector<int>(n, 0));\\n        dp[0][0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + dp[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y] + dp[x][y-1];\\n                \\n                dp[x][y] = min(up, left);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> prevRow(n, 0), curRow(n, 0);\\n        curRow[0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + prevRow[y];\\n                if(y-1 >= 0) left = grid[x][y] + curRow[y-1];\\n                \\n                curRow[y] = min(up, left);\\n            }\\n            prevRow = curRow;\\n        }\\n        return curRow[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y-1];\\n                \\n                grid[x][y] += min(up, left);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967500,
                "title": "dp-solution-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) {\\n                    dp[i][j]=grid[i][j]; //filling top-left cell\\n                }\\n                if(i==0 && j!=0){\\n                    dp[i][j]=dp[i][j-1]+grid[i][j]; //filling first row\\n                }\\n                if(j==0 && i!=0){\\n                    dp[i][j]=dp[i-1][j]+grid[i][j]; //filling first column\\n                }\\n                if(i!=0 && j!=0){\\n                    dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; //filling rest of the cells\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) {\\n                    dp[i][j]=grid[i][j]; //filling top-left cell\\n                }\\n                if(i==0 && j!=0){\\n                    dp[i][j]=dp[i][j-1]+grid[i][j]; //filling first row\\n                }\\n                if(j==0 && i!=0){\\n                    dp[i][j]=dp[i-1][j]+grid[i][j]; //filling first column\\n                }\\n                if(i!=0 && j!=0){\\n                    dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; //filling rest of the cells\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879199,
                "title": "c-very-very-easy-simple-8-line-code-tc-o-n-m-sc-o-1",
                "content": "```\\n\\tint minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) grid[i][j]+=grid[i][j-1];\\n                else if(j==0) grid[i][j]+=grid[i-1][j];\\n                else grid[i][j]+=min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n```\\n\\nThe extension of this problem is [174. Dungeon Game](https://leetcode.com/problems/dungeon-game/). The solution of this question is similar to this.\\nSolution link - https://leetcode.com/problems/dungeon-game/discuss/1879082/c-very-very-easy-simple-9-line-code-tc-o-nm-sc-o-1",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tint minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) grid[i][j]+=grid[i][j-1];\\n                else if(j==0) grid[i][j]+=grid[i-1][j];\\n                else grid[i][j]+=min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1837560,
                "title": "c-very-easy-recursive-memoization-tabulation-solution",
                "content": "Just upvote to make a little effort for your motivation \\n// Memoization \\n```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int find(vector<vector<int>>& grid, int m,int n, int i,int j){\\n            \\n        if(i == m-1 and j == n-1) return grid[i][j]; \\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int right=INT_MAX, bottom = INT_MAX;\\n        if(i<m-1) right= grid[i][j]+find(grid,m,n,i+1,j);\\n        if(j<n-1) bottom = grid[i][j]+find(grid,m,n,i,j+1);\\n        \\n        return dp[i][j]=min(right, bottom);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n       int m= grid.size(),n= grid[0].size();\\n        return find(grid,m,n,0,0);\\n    }\\n};\\n```\\n\\n// DP tabulation\\n```\\nclass Solution{\\npublic:\\nint minPathSum(vector<vector<int>>& grid) {\\n        \\n       int m= grid.size(),n= grid[0].size();\\n  \\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1; i<m ; i++) dp[i][0]= dp[i-1][0]+grid[i][0];\\n        for(int j=1; j<n ; j++) dp[0][j]= dp[0][j-1]+grid[0][j];\\n        \\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                dp[i][j]= grid[i][j]+min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int find(vector<vector<int>>& grid, int m,int n, int i,int j){\\n            \\n        if(i == m-1 and j == n-1) return grid[i][j]; \\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int right=INT_MAX, bottom = INT_MAX;\\n        if(i<m-1) right= grid[i][j]+find(grid,m,n,i+1,j);\\n        if(j<n-1) bottom = grid[i][j]+find(grid,m,n,i,j+1);\\n        \\n        return dp[i][j]=min(right, bottom);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n       int m= grid.size(),n= grid[0].size();\\n        return find(grid,m,n,0,0);\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\nint minPathSum(vector<vector<int>>& grid) {\\n        \\n       int m= grid.size(),n= grid[0].size();\\n  \\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1; i<m ; i++) dp[i][0]= dp[i-1][0]+grid[i][0];\\n        for(int j=1; j<n ; j++) dp[0][j]= dp[0][j-1]+grid[0][j];\\n        \\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                dp[i][j]= grid[i][j]+min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803657,
                "title": "recursion-memorization-c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>>&dp){\\n        if(i == m-1 and j == n-1) return grid[i][j];\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int down = INT_MAX, right = INT_MAX;\\n        \\n        if(i+1 < grid.size())    down = solve(i+1,j,m,n,grid,dp);\\n        \\n        if(j+1 < grid[0].size()) right = solve(i,j+1,m,n,grid,dp);\\n        \\n        int ans = grid[i][j] + min(down,right);\\n        return dp[i][j] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return solve(0,0,m,n,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>>&dp){\\n        if(i == m-1 and j == n-1) return grid[i][j];\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int down = INT_MAX, right = INT_MAX;\\n        \\n        if(i+1 < grid.size())    down = solve(i+1,j,m,n,grid,dp);\\n        \\n        if(j+1 < grid[0].size()) right = solve(i,j+1,m,n,grid,dp);\\n        \\n        int ans = grid[i][j] + min(down,right);\\n        return dp[i][j] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return solve(0,0,m,n,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783719,
                "title": "java-top-down-dp-simple-code-explained",
                "content": "class Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n       // Create DP matrix // Following Top Down Approach\\n       int[][] result = new int[grid.length][grid[0].length];\\n        \\n    \\t\\n    \\tfor(int i=0; i<grid.length; i++) {\\n    \\t\\tfor(int j=0; j<grid[0].length; j++) {\\n                \\n                \\n    \\t\\t\\tif(i==0 && j==0) { // For 1st element // Directly add\\n    \\t\\t\\t\\tresult[i][j]= grid[i][j];\\n    \\t\\t\\t}\\n                \\n                \\n                //\\u2192\\n                else if(i==0 ) { // For 1st Row \\n                    result[i][j] = result[i][j-1] + grid[i][j];\\n    \\t\\t\\t}\\n                \\n                \\n                // \\u2193\\n    \\t\\t\\telse if(j==0) { // For 1st Column\\n    \\t\\t\\t\\tresult[i][j] = result[i-1][j] + grid[i][j];\\n    \\t\\t\\t}\\n                \\n                // \\u2192                \\n                //\\u2193\\n    \\t\\t\\telse { // Except 1st row and 1st column\\n    \\t\\t\\t\\tresult[i][j] = Math.min(result[i-1][j],result[i][j-1]) + grid[i][j];\\n    \\t\\t\\t}\\t\\t\\t\\n    \\t}\\n        \\n      }\\n    return result[grid.length - 1][grid[0].length- 1]; // Return result[2][2]  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n       // Create DP matrix // Following Top Down Approach\\n       int[][] result = new int[grid.length][grid[0].length];\\n        \\n    \\t\\n    \\tfor(int i=0; i<grid.length; i++) {\\n    \\t\\tfor(int j=0; j<grid[0].length; j++) {\\n                \\n                \\n    \\t\\t\\tif(i==0 && j==0) { // For 1st element // Directly add\\n    \\t\\t\\t\\tresult[i][j]= grid[i][j];\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1768077,
                "title": "c-dp-recursive-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n//Recusrive-> TLE\\n//Time and Space: O(2^(n+m)) and O(N)stack + O(m-1, n-1);\\n    int func(int i, int j, vector<vector<int>>& a){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        int up = a[i][j] + func(i-1,j,a);\\n        int left = a[i][j] + func(i,j-1,a);\\n        \\n        return min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        return func(n-1,m-1,a);\\n    }\\n    \\n//Memoization-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(N)stack + O(n*m);\\n   int func(int i, int j, vector<vector<int>>& a,vector<vector<int>> &dp){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int up = a[i][j] + func(i-1,j,a,dp);\\n        int left = a[i][j] + func(i,j-1,a,dp);\\n        \\n        return dp[i][j] = min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        return func(n-1,m-1,a,dp);\\n    }\\n    \\n//Tabulation-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(n*m);\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) dp[i][j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e8;\\n                \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n    \\n// Space Optimiztion->Accepted\\uD83D\\uDD25\\n// Time: O(n*m)\\n// Space: O(m)\\nint minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int>prev(m,0), curr(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) curr[j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= curr[j-1];\\n                    else left+= 1e8;\\n                \\n                    curr[j] = min(left, up);\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Recusrive-> TLE\\n//Time and Space: O(2^(n+m)) and O(N)stack + O(m-1, n-1);\\n    int func(int i, int j, vector<vector<int>>& a){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        int up = a[i][j] + func(i-1,j,a);\\n        int left = a[i][j] + func(i,j-1,a);\\n        \\n        return min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        return func(n-1,m-1,a);\\n    }\\n    \\n//Memoization-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(N)stack + O(n*m);\\n   int func(int i, int j, vector<vector<int>>& a,vector<vector<int>> &dp){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int up = a[i][j] + func(i-1,j,a,dp);\\n        int left = a[i][j] + func(i,j-1,a,dp);\\n        \\n        return dp[i][j] = min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        return func(n-1,m-1,a,dp);\\n    }\\n    \\n//Tabulation-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(n*m);\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) dp[i][j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e8;\\n                \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n    \\n// Space Optimiztion->Accepted\\uD83D\\uDD25\\n// Time: O(n*m)\\n// Space: O(m)\\nint minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int>prev(m,0), curr(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) curr[j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= curr[j-1];\\n                    else left+= 1e8;\\n                \\n                    curr[j] = min(left, up);\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1844924,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844935,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844856,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1568882,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567180,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844809,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567830,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1780572,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1569788,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1800731,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844924,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844935,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844856,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1568882,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567180,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844809,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567830,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1780572,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1569788,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1800731,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1732247,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1845396,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1569523,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1845071,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1845039,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2069231,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2066589,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2062807,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2046516,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2044908,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2044546,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1991689,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1970176,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1968499,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1963540,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1922475,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1910311,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845593,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845487,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845410,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845351,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1845074,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1845032,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1845018,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844992,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844962,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844954,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844952,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844923,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844904,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844902,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844895,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844858,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844855,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844841,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844840,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844330,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1842951,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1835620,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810558,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1795151,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1754116,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1740933,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729388,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1722996,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1718321,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1713015,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1694940,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1675957,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1670947,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Gap",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the maximum difference between two successive elements in its sorted form</em>. If the array contains less than two elements, return <code>0</code>.</p>\n\n<p>You must write an algorithm that runs in linear time and uses linear extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,9,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The array contains less than 2 elements, therefore return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 50643,
                "title": "bucket-sort-java-solution-with-explanation-o-n-time-and-space",
                "content": "Suppose there are N elements in the array, the min value is ***min*** and the max value is ***max***. Then the maximum gap will be no smaller than ceiling[(***max*** - ***min*** ) / (N - 1)].\\n\\nLet gap = ceiling[(***max*** - ***min*** ) / (N - 1)]. We divide all numbers in the array into n-1 buckets, where k-th bucket contains all numbers in [***min***  + (k-1)gap, ***min***  + k*gap). Since there are n-2 numbers that are not equal ***min***  or ***max*** and there are n-1 buckets, at least one of the buckets are empty. We only need to store the largest number and the smallest number in each bucket. \\n\\nAfter we put all the numbers into the buckets. We can scan the buckets sequentially and get the max gap.\\n[my blog for this problem][1]\\n\\n    public class Solution {\\n    public int maximumGap(int[] num) {\\n        if (num == null || num.length < 2)\\n            return 0;\\n        // get the max and min value of the array\\n        int min = num[0];\\n        int max = num[0];\\n        for (int i:num) {\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }\\n        // the minimum possibale gap, ceiling of the integer division\\n        int gap = (int)Math.ceil((double)(max - min)/(num.length - 1));\\n        int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket\\n        int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket\\n        Arrays.fill(bucketsMIN, Integer.MAX_VALUE);\\n        Arrays.fill(bucketsMAX, Integer.MIN_VALUE);\\n        // put numbers into buckets\\n        for (int i:num) {\\n            if (i == min || i == max)\\n                continue;\\n            int idx = (i - min) / gap; // index of the right position in the buckets\\n            bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);\\n            bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);\\n        }\\n        // scan the buckets for the max gap\\n        int maxGap = Integer.MIN_VALUE;\\n        int previous = min;\\n        for (int i = 0; i < num.length - 1; i++) {\\n            if (bucketsMIN[i] == Integer.MAX_VALUE && bucketsMAX[i] == Integer.MIN_VALUE)\\n                // empty bucket\\n                continue;\\n            // min value minus the previous value is the current gap\\n            maxGap = Math.max(maxGap, bucketsMIN[i] - previous);\\n            // update previous bucket value\\n            previous = bucketsMAX[i];\\n        }\\n        maxGap = Math.max(maxGap, max - previous); // updata the final max value gap\\n        return maxGap;\\n    }\\n}\\n\\n\\n  [1]: http://zkfairytale.blogspot.ca/2014/12/maximum-gap.html",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumGap(int[] num) {\\n        if (num == null || num.length < 2)\\n            return 0;\\n        // get the max and min value of the array\\n        int min = num[0];\\n        int max = num[0];\\n        for (int i:num) {\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240543,
                "title": "python-bucket-sort-explained",
                "content": "This is quite difficult problem if you never used the idea of bucket sort. Let us divide all range of numbers into `n-1` cells. We will talk a bit later, why it is `n-1` and not other number. It is simpler to look at example:\\n\\n`nums = [3,14,15,83,6,4,19,20,40]`. Then we have 8 buckets, with numbers `0,1,2,3,4,5,6,7`, some of them are empty:\\n\\n`0: [3, 6, 4]`\\n`1: [14, 15, 19, 20]`\\n`3: [40]`\\n`7: [83]`\\n\\nHow we choose what to put where: we have range `[3-----83]`, which we separated into `n-1` groups: `[3--13), [13--23), ..., [73--83]`. Note, that numbers are not sorted inside groups. Now, let us notice one simple thing: there can not be maximum gap between sorted values of array inside each bucket. Why? Because there is `n-1` gaps with total difference `hi - lo`, so by pigeonhole principle, there is difference which is bigger or equal than `(hi - lo)/(n-1)`: indeed if all differences are smaller than this value, than total sum will be smaller than `(hi - lo)`. So, it suffies to look only at the differences between adjacent buckets and moreover it is difference between smallest number of one buckets and biggest value of previous bucket.\\n\\nSo, here are to following steps of our algorithm:\\n\\n1. Distribute numbers to buckets. Be careful with the biggest one, I put it to `n-2`-th bucket, but if you put it to `n-1` th, it will also be OK.\\n2. Find minimum and maximum in each buckets, we do not need anything else.\\n3. Iterate through buckets and check every difference between smallest element in one bucket and biggest in previous. Note, that here we also will check differences between say `1`-st and `3`-rd buckets if we have empty `2`-nd bucket.\\n\\n#### Complexity\\nTime complexity is `O(n)`: we traversed our data several times, space complexity is `O(n)` to keep buckets.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maximumGap(self, nums):\\n        lo, hi, n = min(nums), max(nums), len(nums)\\n        if n <= 2 or hi == lo: return hi - lo\\n        B = defaultdict(list)\\n        for num in nums:\\n            ind = n-2 if num == hi else (num - lo)*(n-1)//(hi-lo)\\n            B[ind].append(num)\\n            \\n        cands = [[min(B[i]), max(B[i])] for i in range(n-1) if B[i]]\\n        return max(y[0]-x[1] for x,y in zip(cands, cands[1:]))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bucket Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumGap(self, nums):\\n        lo, hi, n = min(nums), max(nums), len(nums)\\n        if n <= 2 or hi == lo: return hi - lo\\n        B = defaultdict(list)\\n        for num in nums:\\n            ind = n-2 if num == hi else (num - lo)*(n-1)//(hi-lo)\\n            B[ind].append(num)\\n            \\n        cands = [[min(B[i]), max(B[i])] for i in range(n-1) if B[i]]\\n        return max(y[0]-x[1] for x,y in zip(cands, cands[1:]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241681,
                "title": "java-python-bucket-idea-with-picture-clean-concise-o-n",
                "content": "**Idea**\\n- Suppose in our integer array `N` elements, the min value is **min** and the max value is **max**. Then the maximum gap will be **greater or equal** to `ceiling[(max - min ) / (N - 1)]`.\\n- Let `bucketSize = ceiling[(max - min ) / (N - 1)]`. \\n- We divide all numbers in the array into `N` buckets, each bucket has size of `bucketSize`, where `i-th` (zero-based index) bucket contains all numbers in range `[min + i*bucketSize, min + (i+1)*bucketSize)`. \\n- Because maximum gap is always **greater or equal** to `bucketSize` so in each bucket, we only need to store max element and min element, skip middle elements (min < middle < max) in the same bucket.\\n- Finally, we only need to compare max number in current bucket and min number in next bucket to get the relatively large gap and find out which two bucket have the maximum gap.\\n\\n**Example picture**\\n![image](https://assets.leetcode.com/users/images/f555af3f-496f-4c42-b57f-4701fd276f82_1622433690.1145518.png)\\n\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        mi, ma, n = min(nums), max(nums), len(nums)\\n        if mi == ma: return 0  # All elements are the same\\n        bucketSize = math.ceil((ma - mi) / (n - 1))\\n        minBucket = [math.inf] * n\\n        maxBucket = [-math.inf] * n\\n        for x in nums:\\n            idx = (x - mi) // bucketSize\\n            minBucket[idx] = min(minBucket[idx], x)\\n            maxBucket[idx] = max(maxBucket[idx], x)\\n\\n        maxGap = bucketSize  # Maximum gap is always greater or equal to bucketSize\\n        prev = maxBucket[0]  # We always have 0th bucket\\n        for i in range(1, n):\\n            if minBucket[i] == math.inf: continue  # Skip empty bucket\\n            maxGap = max(maxGap, minBucket[i] - prev)\\n            prev = maxBucket[i]\\n        return maxGap\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int min = nums[0], max = nums[0], n = nums.length;\\n        for (int x : nums) {\\n            min = Math.min(min, x);\\n            max = Math.max(max, x);\\n        }\\n        if (min == max) return 0; // All elements are the same\\n        int bucketSize = (int) Math.ceil((double) (max - min) / (n - 1));\\n        int[] minBucket = new int[n];\\n        int[] maxBucket = new int[n];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        Arrays.fill(maxBucket, Integer.MIN_VALUE);\\n        for (int x : nums) {\\n            int idx = (x - min) / bucketSize;\\n            minBucket[idx] = Math.min(x, minBucket[idx]);\\n            maxBucket[idx] = Math.max(x, maxBucket[idx]);\\n        }\\n        int maxGap = bucketSize; // Maximum gap is always greater or equal to bucketSize\\n        int previous = maxBucket[0]; // We always have 0th bucket\\n        for (int i = 1; i < n; i++) {\\n            if (minBucket[i] == Integer.MAX_VALUE) continue; // Skip empty bucket\\n            maxGap = Math.max(maxGap, minBucket[i] - previous);\\n            previous = maxBucket[i];\\n        }\\n        return maxGap;\\n    }\\n}\\n```\\n*This post is inspired by @zkfairytale and @DyXrLxSTAOadoD from this [post](https://leetcode.com/problems/maximum-gap/discuss/50643/)*\\n\\nIf you found this post useful, please **give it a vote**. If you have any questions, **feel free to comment** below. Thanks.\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        mi, ma, n = min(nums), max(nums), len(nums)\\n        if mi == ma: return 0  # All elements are the same\\n        bucketSize = math.ceil((ma - mi) / (n - 1))\\n        minBucket = [math.inf] * n\\n        maxBucket = [-math.inf] * n\\n        for x in nums:\\n            idx = (x - mi) // bucketSize\\n            minBucket[idx] = min(minBucket[idx], x)\\n            maxBucket[idx] = max(maxBucket[idx], x)\\n\\n        maxGap = bucketSize  # Maximum gap is always greater or equal to bucketSize\\n        prev = maxBucket[0]  # We always have 0th bucket\\n        for i in range(1, n):\\n            if minBucket[i] == math.inf: continue  # Skip empty bucket\\n            maxGap = max(maxGap, minBucket[i] - prev)\\n            prev = maxBucket[i]\\n        return maxGap\\n```\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int min = nums[0], max = nums[0], n = nums.length;\\n        for (int x : nums) {\\n            min = Math.min(min, x);\\n            max = Math.max(max, x);\\n        }\\n        if (min == max) return 0; // All elements are the same\\n        int bucketSize = (int) Math.ceil((double) (max - min) / (n - 1));\\n        int[] minBucket = new int[n];\\n        int[] maxBucket = new int[n];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        Arrays.fill(maxBucket, Integer.MIN_VALUE);\\n        for (int x : nums) {\\n            int idx = (x - min) / bucketSize;\\n            minBucket[idx] = Math.min(x, minBucket[idx]);\\n            maxBucket[idx] = Math.max(x, maxBucket[idx]);\\n        }\\n        int maxGap = bucketSize; // Maximum gap is always greater or equal to bucketSize\\n        int previous = maxBucket[0]; // We always have 0th bucket\\n        for (int i = 1; i < n; i++) {\\n            if (minBucket[i] == Integer.MAX_VALUE) continue; // Skip empty bucket\\n            maxGap = Math.max(maxGap, minBucket[i] - previous);\\n            previous = maxBucket[i];\\n        }\\n        return maxGap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50644,
                "title": "pigeon-hole-principle",
                "content": "Suppose you have n pigeons with labels and you put them into m holes based on their label with each hole of the same size. Why bother putting pigeons into holes? Because you want to disregard the distance between pigeons **within** each one hole. \\n\\nOnly when at least one hole is empty can we disregard the distance between pigeons within each one hole and compute the maximum gap solely by the distance between pigeons **in adjacent holes**. We make sure that at least one hole is empty by using m=n-1 (i.e. n-2 pigeons in n-1 holes => at least one hole is empty).\\n\\n    int maximumGap(vector<int>& nums) {\\n            const int n = nums.size();\\n            if(n<=1) return 0;\\n            int maxE = *max_element(nums.begin(),nums.end());\\n            int minE = *min_element(nums.begin(),nums.end());\\n            double len = double(maxE-minE)/double(n-1);\\n            vector<int> maxA(n,INT_MIN);\\n            vector<int> minA(n,INT_MAX);\\n            for(int i=0; i<n; i++) {\\n                int index = (nums[i]-minE)/len;\\n                maxA[index] = max(maxA[index],nums[i]);\\n                minA[index] = min(minA[index],nums[i]);\\n            }\\n            int gap = 0, prev = maxA[0];\\n            for(int i=1; i<n; i++) {\\n                if(minA[i]==INT_MAX) continue;\\n                gap = max(gap,minA[i]-prev);\\n                prev = maxA[i];\\n            }\\n            return gap;\\n        }",
                "solutionTags": [],
                "code": "Suppose you have n pigeons with labels and you put them into m holes based on their label with each hole of the same size. Why bother putting pigeons into holes? Because you want to disregard the distance between pigeons **within** each one hole. \\n\\nOnly when at least one hole is empty can we disregard the distance between pigeons within each one hole and compute the maximum gap solely by the distance between pigeons **in adjacent holes**. We make sure that at least one hole is empty by using m=n-1 (i.e. n-2 pigeons in n-1 holes => at least one hole is empty).\\n\\n    int maximumGap(vector<int>& nums) {\\n            const int n = nums.size();\\n            if(n<=1) return 0;\\n            int maxE = *max_element(nums.begin(),nums.end());\\n            int minE = *min_element(nums.begin(),nums.end());\\n            double len = double(maxE-minE)/double(n-1);\\n            vector<int> maxA(n,INT_MIN);\\n            vector<int> minA(n,INT_MAX);\\n            for(int i=0; i<n; i++) {\\n                int index = (nums[i]-minE)/len;\\n                maxA[index] = max(maxA[index],nums[i]);\\n                minA[index] = min(minA[index],nums[i]);\\n            }\\n            int gap = 0, prev = maxA[0];\\n            for(int i=1; i<n; i++) {\\n                if(minA[i]==INT_MAX) continue;\\n                gap = max(gap,minA[i]-prev);\\n                prev = maxA[i];\\n            }\\n            return gap;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 50642,
                "title": "radix-sort-solution-in-java-with-explanation",
                "content": "You can look at radix sort visualization here before reading the code:\\nhttps://www.cs.usfca.edu/~galles/visualization/RadixSort.html\\n\\n    public class Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }\\n        \\n        // m is the maximal number in nums\\n        int m = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            m = Math.max(m, nums[i]);\\n        }\\n        \\n        int exp = 1; // 1, 10, 100, 1000 ...\\n        int R = 10; // 10 digits\\n\\n        int[] aux = new int[nums.length];\\n        \\n        while (m / exp > 0) { // Go through all digits from LSB to MSB\\n            int[] count = new int[R];\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                count[(nums[i] / exp) % 10]++;\\n            }\\n            \\n            for (int i = 1; i < count.length; i++) {\\n                count[i] += count[i - 1];\\n            }\\n            \\n            for (int i = nums.length - 1; i >= 0; i--) {\\n                aux[--count[(nums[i] / exp) % 10]] = nums[i];\\n            }\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                nums[i] = aux[i];\\n            }\\n            exp *= 10;\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i < aux.length; i++) {\\n            max = Math.max(max, aux[i] - aux[i - 1]);\\n        }\\n         \\n        return max;\\n    }\\n}\\n\\n 1. The first step is to find the maximum value in nums array, it will\\n     be the threshold to end while loop.    \\n 2. Then use the radix sort algorithm to sort based on each digit from Least Significant Bit\\n        (LSB) to Most Significant Bit (MSB), that's exactly what's showing\\n        in the link.\\n 3. `(nums[i] / exp) % 10` is used to get the digit, for each digit, basically the digit itself serves as the index to\\n    access the count array. Count array stores the index to access aux\\n    array which stores the numbers after sorting based on the current\\n    digit.\\n 4. Finally, find the maximum gap from sorted array.\\n\\nTime and space complexities are both O(n). (Actually time is O(10n) at worst case for Integer.MAX_VALUE 2147483647)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240838,
                "title": "js-python-java-c-simple-bucket-sort-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we don\\'t need to actually sort every element, which would take longer than **O(N) time**. What we need to do is to find a way to group together numbers in such a way as to allow us to check the larger gaps between consecutive numbers. For this, we can turn to a **bucket sort**.\\n\\nA bucket sort involves creating an array (**buckets**) in which the elements represent buckets that cover the spread of the numbers to be sorted. Imagine trying to sort a deck of cards; it would only take once through the deck to sort it entirely into **13** \"buckets\", one for each value. Then we could go through the individual buckets and perform another, smaller sort before joining the entire deck together.\\n\\nIn this situation, however, we only need to perform the first part of the bucket sort. The idea is to define the size of our buckets such that the maximum gap will necessarily be larger than a single bucket. That would mean that our answer could then be found by comparing the highest value in each bucket with the lowest value in the next occupied bucket.\\n\\nTo achieve the right bucket size (**bsize**) for this to work, we\\'ll need to iterate through **nums** once to find the total range (**hi - lo**), then use that to figure out the absolute smallest possible maximum gap value (**(hi - lo) / (nums.length - 1)**). If we make sure to define the bucket size _smaller_ than this value, then as stated earlier, the two numbers that form the maximum gap will have to be found in separate buckets.\\n\\nSince there are exactly **N** numbers spread throughout the buckets, and since it only requires a single iteration of each number in a bucket to observe the local high and lo values (**currhi, currlo**), then it will take a total of **O(N) time** to perform this process for the entire **buckets** array. And since we only need to make one comparison per pair of buckets with consecutive numbers, and as there are only a maximum of **2 * N** buckets, the comparisons will only take **O(N) time**, as well.\\n\\nWe\\'ll just need to make sure that we remember the previous occupied bucket\\'s high value (**prevhi**) for the next comparison, as well as keeping track of the best result found so far (**ans**). Then, once we reach the end of our **buckets** array, we can simply **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **nums**_\\n    - _finding **hi** and **lo** in **nums**: **O(N)**_\\n    - _fill **buckets**: **O(N)**_\\n    - _finding all bucket **hi**\\'s and **lo**\\'s: **O(N)**_\\n    - _comparing all bucket gaps: **O(N)** for up to **2 * N** buckets_\\n - _**Space Complexity: O(N)** for **N** numbers spread among at most **2 * N** buckets_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2: return 0\\n        hi, lo, ans = max(nums), min(nums), 0\\n        bsize = (hi - lo) // (len(nums) - 1) or 1\\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\\n        for n in nums:\\n            buckets[(n - lo) // bsize].append(n)\\n        currhi = 0\\n        for b in buckets:\\n            if not len(b): continue\\n            prevhi, currlo = currhi or b[0], b[0]\\n            for n in b: \\n                currhi, currlo = max(currhi, n), min(currlo, n)\\n            ans = max(ans, currlo - prevhi)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\\n        for (int n : nums) {\\n            hi = Math.max(hi, n);\\n            lo = Math.min(lo, n);\\n        }\\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\\n            buckets.add(new ArrayList<>());\\n        for (int n : nums)\\n            buckets.get((n - lo) / bsize).add(n);\\n        int currhi = 0;\\n        for (List<Integer> b : buckets) {\\n            if (b.isEmpty()) continue;\\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\\n            for (int n : b) {\\n                currhi = Math.max(currhi, n);\\n                currlo = Math.min(currlo, n);\\n            }\\n            ans = Math.max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size() < 2) return 0;\\n        int hi = 0, lo = INT_MAX, ans = 0;\\n        for (auto& n : nums)\\n            hi = max(hi, n), lo = min(lo, n);\\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\\n        for (auto& n : nums)\\n            buckets[(n - lo) / bsize].push_back(n);\\n        int currhi = 0;\\n        for (auto& b : buckets) {\\n            if (b.empty()) continue;\\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\\n            for (auto& n : b)\\n                currhi = max(currhi, n), currlo = min(currlo, n);\\n            ans = max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2: return 0\\n        hi, lo, ans = max(nums), min(nums), 0\\n        bsize = (hi - lo) // (len(nums) - 1) or 1\\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\\n        for n in nums:\\n            buckets[(n - lo) // bsize].append(n)\\n        currhi = 0\\n        for b in buckets:\\n            if not len(b): continue\\n            prevhi, currlo = currhi or b[0], b[0]\\n            for n in b: \\n                currhi, currlo = max(currhi, n), min(currlo, n)\\n            ans = max(ans, currlo - prevhi)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\\n        for (int n : nums) {\\n            hi = Math.max(hi, n);\\n            lo = Math.min(lo, n);\\n        }\\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\\n            buckets.add(new ArrayList<>());\\n        for (int n : nums)\\n            buckets.get((n - lo) / bsize).add(n);\\n        int currhi = 0;\\n        for (List<Integer> b : buckets) {\\n            if (b.isEmpty()) continue;\\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\\n            for (int n : b) {\\n                currhi = Math.max(currhi, n);\\n                currlo = Math.min(currlo, n);\\n            }\\n            ans = Math.max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size() < 2) return 0;\\n        int hi = 0, lo = INT_MAX, ans = 0;\\n        for (auto& n : nums)\\n            hi = max(hi, n), lo = min(lo, n);\\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\\n        for (auto& n : nums)\\n            buckets[(n - lo) / bsize].push_back(n);\\n        int currhi = 0;\\n        for (auto& b : buckets) {\\n            if (b.empty()) continue;\\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\\n            for (auto& n : b)\\n                currhi = max(currhi, n), currlo = min(currlo, n);\\n            ans = max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50650,
                "title": "python-bucket-sort-from-official-solution",
                "content": "    class Solution:\\n    # @param num, a list of integer\\n    # @return an integer\\n    def maximumGap(self, num):\\n        if len(num) < 2 or min(num) == max(num):\\n            return 0\\n        a, b = min(num), max(num)\\n        size = math.ceil((b-a)/(len(num)-1))\\n        bucket = [[None, None] for _ in range((b-a)//size+1)]\\n        for n in num:\\n            b = bucket[(n-a)//size]\\n            b[0] = n if b[0] is None else min(b[0], n)\\n            b[1] = n if b[1] is None else max(b[1], n)\\n        bucket = [b for b in bucket if b[0] is not None]\\n        return max(bucket[i][0]-bucket[i-1][1] for i in range(1, len(bucket)))\\n\\nThe python version is 3.4, for 2.7 version rewrite the size",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param num, a list of integer\\n    # @return an integer\\n    def maximumGap(self, num):\\n        if len(num) < 2 or min(num) == max(num):\\n            return 0\\n        a, b = min(num), max(num)\\n        size = math.ceil((b-a)/(len(num)-1))\\n        bucket = [[None, None] for _ in range((b-a)//size+1)]\\n        for n in num:\\n            b = bucket[(n-a)//size]\\n            b[0] = n if b[0] is None else min(b[0], n)\\n            b[1] = n if b[1] is None else max(b[1], n)\\n        bucket = [b for b in bucket if b[0] is not None]\\n        return max(bucket[i][0]-bucket[i-1][1] for i in range(1, len(bucket)))\\n\\nThe python version is 3.4, for 2.7 version rewrite the size",
                "codeTag": "Java"
            },
            {
                "id": 1240841,
                "title": "maximum-gap-js-python-java-c-simple-bucket-sort-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we don\\'t need to actually sort every element, which would take longer than **O(N) time**. What we need to do is to find a way to group together numbers in such a way as to allow us to check the larger gaps between consecutive numbers. For this, we can turn to a **bucket sort**.\\n\\nA bucket sort involves creating an array (**buckets**) in which the elements represent buckets that cover the spread of the numbers to be sorted. Imagine trying to sort a deck of cards; it would only take once through the deck to sort it entirely into **13** \"buckets\", one for each value. Then we could go through the individual buckets and perform another, smaller sort before joining the entire deck together.\\n\\nIn this situation, however, we only need to perform the first part of the bucket sort. The idea is to define the size of our buckets such that the maximum gap will necessarily be larger than a single bucket. That would mean that our answer could then be found by comparing the highest value in each bucket with the lowest value in the next occupied bucket.\\n\\nTo achieve the right bucket size (**bsize**) for this to work, we\\'ll need to iterate through **nums** once to find the total range (**hi - lo**), then use that to figure out the absolute smallest possible maximum gap value (**(hi - lo) / (nums.length - 1)**). If we make sure to define the bucket size _smaller_ than this value, then as stated earlier, the two numbers that form the maximum gap will have to be found in separate buckets.\\n\\nSince there are exactly **N** numbers spread throughout the buckets, and since it only requires a single iteration of each number in a bucket to observe the local high and lo values (**currhi, currlo**), then it will take a total of **O(N) time** to perform this process for the entire **buckets** array. And since we only need to make one comparison per pair of buckets with consecutive numbers, and as there are only a maximum of **2 * N** buckets, the comparisons will only take **O(N) time**, as well.\\n\\nWe\\'ll just need to make sure that we remember the previous occupied bucket\\'s high value (**prevhi**) for the next comparison, as well as keeping track of the best result found so far (**ans**). Then, once we reach the end of our **buckets** array, we can simply **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **nums**_\\n    - _finding **hi** and **lo** in **nums**: **O(N)**_\\n    - _fill **buckets**: **O(N)**_\\n    - _finding all bucket **hi**\\'s and **lo**\\'s: **O(N)**_\\n    - _comparing all bucket gaps: **O(N)** for up to **2 * N** buckets_\\n - _**Space Complexity: O(N)** for **N** numbers spread among at most **2 * N** buckets_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2: return 0\\n        hi, lo, ans = max(nums), min(nums), 0\\n        bsize = (hi - lo) // (len(nums) - 1) or 1\\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\\n        for n in nums:\\n            buckets[(n - lo) // bsize].append(n)\\n        currhi = 0\\n        for b in buckets:\\n            if not len(b): continue\\n            prevhi, currlo = currhi or b[0], b[0]\\n            for n in b: \\n                currhi, currlo = max(currhi, n), min(currlo, n)\\n            ans = max(ans, currlo - prevhi)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\\n        for (int n : nums) {\\n            hi = Math.max(hi, n);\\n            lo = Math.min(lo, n);\\n        }\\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\\n            buckets.add(new ArrayList<>());\\n        for (int n : nums)\\n            buckets.get((n - lo) / bsize).add(n);\\n        int currhi = 0;\\n        for (List<Integer> b : buckets) {\\n            if (b.isEmpty()) continue;\\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\\n            for (int n : b) {\\n                currhi = Math.max(currhi, n);\\n                currlo = Math.min(currlo, n);\\n            }\\n            ans = Math.max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size() < 2) return 0;\\n        int hi = 0, lo = INT_MAX, ans = 0;\\n        for (auto& n : nums)\\n            hi = max(hi, n), lo = min(lo, n);\\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\\n        for (auto& n : nums)\\n            buckets[(n - lo) / bsize].push_back(n);\\n        int currhi = 0;\\n        for (auto& b : buckets) {\\n            if (b.empty()) continue;\\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\\n            for (auto& n : b)\\n                currhi = max(currhi, n), currlo = min(currlo, n);\\n            ans = max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2: return 0\\n        hi, lo, ans = max(nums), min(nums), 0\\n        bsize = (hi - lo) // (len(nums) - 1) or 1\\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\\n        for n in nums:\\n            buckets[(n - lo) // bsize].append(n)\\n        currhi = 0\\n        for b in buckets:\\n            if not len(b): continue\\n            prevhi, currlo = currhi or b[0], b[0]\\n            for n in b: \\n                currhi, currlo = max(currhi, n), min(currlo, n)\\n            ans = max(ans, currlo - prevhi)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\\n        for (int n : nums) {\\n            hi = Math.max(hi, n);\\n            lo = Math.min(lo, n);\\n        }\\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\\n            buckets.add(new ArrayList<>());\\n        for (int n : nums)\\n            buckets.get((n - lo) / bsize).add(n);\\n        int currhi = 0;\\n        for (List<Integer> b : buckets) {\\n            if (b.isEmpty()) continue;\\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\\n            for (int n : b) {\\n                currhi = Math.max(currhi, n);\\n                currlo = Math.min(currlo, n);\\n            }\\n            ans = Math.max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size() < 2) return 0;\\n        int hi = 0, lo = INT_MAX, ans = 0;\\n        for (auto& n : nums)\\n            hi = max(hi, n), lo = min(lo, n);\\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\\n        for (auto& n : nums)\\n            buckets[(n - lo) / bsize].push_back(n);\\n        int currhi = 0;\\n        for (auto& b : buckets) {\\n            if (b.empty()) continue;\\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\\n            for (auto& n : b)\\n                currhi = max(currhi, n), currlo = min(currlo, n);\\n            ans = max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50647,
                "title": "i-solved-it-using-radix-sort",
                "content": "Since linear time and space is required and all nums are non-negative, radix sort seems to be fit.\\nHere is the implementation.\\n\\nAny better ideas?\\n\\n    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def maximumGap(self, num):\\n            if len(num) < 2:\\n                return 0\\n            num = self.radixSort(num)\\n            res = 0\\n            for i in range(1, len(num)):\\n                res = max(num[i] - num[i - 1], res)\\n            return res\\n        \\n        def radixSort(self, num):\\n            for i in range(31):\\n                onebucket = []\\n                zerobucket = []\\n                needle = 1 << i\\n                for j in range(len(num)):\\n                    if num[j] & needle != 0:\\n                        onebucket.append(num[j])\\n                    else:\\n                        zerobucket.append(num[j])\\n                num = []\\n                num += zerobucket\\n                num += onebucket\\n            return num",
                "solutionTags": [],
                "code": "Since linear time and space is required and all nums are non-negative, radix sort seems to be fit.\\nHere is the implementation.\\n\\nAny better ideas?\\n\\n    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def maximumGap(self, num):\\n            if len(num) < 2:\\n                return 0\\n            num = self.radixSort(num)\\n            res = 0\\n            for i in range(1, len(num)):\\n                res = max(num[i] - num[i - 1], res)\\n            return res\\n        \\n        def radixSort(self, num):\\n            for i in range(31):\\n                onebucket = []\\n                zerobucket = []\\n                needle = 1 << i\\n                for j in range(len(num)):\\n                    if num[j] & needle != 0:\\n                        onebucket.append(num[j])\\n                    else:\\n                        zerobucket.append(num[j])\\n                num = []\\n                num += zerobucket\\n                num += onebucket\\n            return num",
                "codeTag": "Java"
            },
            {
                "id": 50725,
                "title": "my-c-code-12-ms-bucket-sort-o-n-time-and-space",
                "content": "The key is to use the fact that the lower bound of the gap is (maxV - minV )/ (sSize - 1). With such in mind, we can put all the num elements into different bucket with size (maxV - minV )/ (sSize - 1) (please note when such size is less than 1, then use 1 instead) and in such way, we only need to consider the min and max of each bucket and don't need to worry the numbers in between of each bucket since the gaps among those elements are smaller than the bucket size, and then the lower bound of the gap, so they can not achieve the max gap.\\n\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int> &num) {\\n        int sSize = num.size();\\n        int i, res =0;\\n        int minV, maxV;\\n        int bucket_size, bucket_num, bucket_id;\\n        int maxGap = INT_MIN;\\n        int last_max;\\n        \\n        if(sSize>1)\\n        {\\n            minV =  maxV = num[0];\\n            for(i=1; i<sSize; i++)\\n            {\\n                if(minV > num[i]) minV = num[i];\\n                else if(maxV < num[i]) maxV = num[i];\\n            }\\n            \\n            bucket_size = max(1, (maxV - minV )/ (sSize - 1)));\\n            bucket_num  = (maxV - minV)/bucket_size + 1;\\n\\n            if(bucket_num <=1) return (maxV - minV); \\n            vector<int> bucket_max(bucket_num, INT_MIN);\\n            vector<int> bucket_min(bucket_num, INT_MAX);\\n            vector<int> bucket_count(bucket_num, 0);\\n            \\n            for(i=0; i<sSize; i++)\\n            {\\n                bucket_id = (num[i] - minV)/bucket_size;\\n                bucket_count[bucket_id]++;\\n                bucket_min[bucket_id] = bucket_min[bucket_id] > num[i]? num[i]:bucket_min[bucket_id];\\n                bucket_max[bucket_id] = bucket_max[bucket_id] < num[i]? num[i]:bucket_max[bucket_id];\\n            }\\n            \\n            last_max = minV;\\n            for(i=0; i<bucket_num; i++)\\n            {\\n                if(bucket_count[i]>0)\\n                {\\n                    maxGap = max(maxGap, bucket_min[i]- last_max);\\n                    last_max = bucket_max[i];\\n                }\\n            }\\n            return maxGap;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int> &num) {\\n        int sSize = num.size();\\n        int i, res =0;\\n        int minV, maxV;\\n        int bucket_size, bucket_num, bucket_id;\\n        int maxGap = INT_MIN;\\n        int last_max;\\n        \\n        if(sSize>1)\\n        {\\n            minV =  maxV = num[0];\\n            for(i=1; i<sSize; i++)\\n            {\\n                if(minV > num[i]) minV = num[i];\\n                else if(maxV < num[i]) maxV = num[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50669,
                "title": "beat-99-81-java-coder",
                "content": "    public class Solution {\\n    public int maximumGap(int[] nums) {\\n        int n = nums.length;\\n        if(n < 2) return 0;\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int i = 1;i < n;i++){\\n            if(min > nums[i]) min = nums[i];\\n            if(max < nums[i]) max = nums[i];\\n        }\\n        \\n        int gap = (max-min)/(n-1);\\n        if(gap == 0) gap++;\\n        int len = (max-min)/gap+1;\\n        int [] tmax = new int [len];\\n        int [] tmin = new int [len];\\n        \\n        for(int i = 0;i < n;i++){\\n            int index = (nums[i]-min)/gap;\\n            if(nums[i] > tmax[index]) tmax[index] = nums[i];\\n            if(tmin[index] == 0 || nums[i] < tmin[index]) tmin[index] = nums[i];\\n        }\\n        int myMax = 0;\\n        for(int i = 0;i < len;i++){\\n            if(myMax < tmin[i]-min) myMax = tmin[i]-min;\\n            if(tmax[i] != 0) min = tmax[i];\\n        }\\n        return myMax;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        int n = nums.length;\\n        if(n < 2) return 0;\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int i = 1;i < n;i++){\\n            if(min > nums[i]) min = nums[i];\\n            if(max < nums[i]) max = nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 50667,
                "title": "solutions-in-c-with-explanation-read-it-and-then-you-get-it",
                "content": "### Solutions\\nWhen first coming into this problem, the first direct idea is to sort it and then search for the maximal difference along the array. And as a result we will have a sort solution as follows.\\n\\n#### Sort\\nVery straightforward solution via sorting using O(1) space while efficient enough time cost O(nlogn).\\n\\n```\\nint maximumGap(vector<int>& nums) \\n{\\n\\tint size = nums.size();\\n\\tif(size < 2) return 0;\\n\\tif(size == 2) return abs(nums[1]-nums[0]);\\n\\tint maxDiff = 0;\\n\\tsort(nums.begin(), nums.end());\\n\\tfor(int i = 0; i < size-1; ++i)\\n\\t\\tmaxDiff = max(maxDiff, nums[i+1]-nums[i]);\\n\\treturn maxDiff;\\n}\\n```\\n\\n#### Bucket\\nBut sorting the whole array is really costly since it's quite unnecessary to sort them all when just trying to find out the maximal difference between successive two numbers in its sorted state. So quite intuitively we would like to use bucket sort to accelerate the process, another typical case using space to accelerate. Why using bucket? If we can set a proper size for each bucket to ensure the maximal difference definitely comes from two different buckets then we do not need to sort the whole array, just checking the minimal and maximal number of each bucket from small to big buckets - ascending order. But how to select the right size for each bucket?\\n\\nBefore reading the analysis below, please do remember the following rule.\\n\\n- **ensure the maximal difference comes from different buckets**\\n\\nHere are some analysis about it:\\n\\n1. since we are to adopt bucket here, we have to first retrieve the max and min number of the array;\\n2. the array with `size` numbers will split the [min, max] space into `size-1` different blocks so the numbers of the array will lie in [min, min+gap), [min+gap, min+2\\\\*gap), ..., [min+(size-2)\\\\*gap, min+(size-1)\\\\*gap) by the way the gap here is the size of the block which we will discuss further later; the blocks here are the buckets we mentioned \\n3. via the ranges of buckets, we can easily locate the bucket-index of any number in the array by `(num-min)/gap` and also simply let's get the answer of the size of the bucket `(max-min)/(size-1)+1` but how to get the size exactly? We still have no clue.\\n4. normally the average distance between two numbers should be `(max-min)/(size-1)` but the maximal difference here must be no less than that (why?  Just imagine if the max difference is less than the average, how come the average is so big here?) as we have discussed in 2, the maximal difference within a bucket will be `gap-1` (take the first range [min, min+gap) for an example, then the min+gap-1-min = gap-1 is the difference within the bucket) so here we should set the size of bucket as `(max-min)/(size-1)+1` to split the array then the maximal difference within a bucket will be `(max-min)/(size-1)` but when we can divide (max-min) completely by (size-1), the case will be different? \\n\\n> Take an example to make it easier here:\\n[1, 2, 3, 4, 21] so max = 21, min = 1, size = 5 => (max-min)/(size-1)+1 = 20/4+1 = 6\\nso as a result the ranges of buckets are [1, 7), [7, 13), [13, 19), [19, 25) \\n> - the maximal difference within a bucket now is 5, which is the average distance and we have discussed it already\\n> - all the numbers in the array are covered including the min and max\\n> - even when the array is [1, 6, 11, 16, 21] the maximal difference still can be retrieved from different buckets here.\\n\\nWhen we can not completely divide (max-min) by (size-1) and there is remainder, the case will be still the same and even clearer.\\n\\n5. since we get the most tricky part done then let's just solve it step by step; remember we are going to retrieve the maximal difference from different buckets? So we only need to record the min and max of the bucket instead of all the numbers inside here;\\n6. after filling up the buckets, we now can retrieve the maximal from the first till the end.\\n\\nThe final solution in C++ is as follows, of course the best submission here, since it's hard to read all the things above. Enjoy now...\\n\\n```\\nint maximumGap(vector<int>& nums) \\n{\\n    int size = nums.size();\\n    if(size < 1) return 0;\\n    if(size == 2) return abs(nums[1]-nums[0]);\\n    int minNum = INT_MAX, maxNum = INT_MIN;\\n    for(int i = 0; i < size; ++i) minNum = min(minNum, nums[i]), maxNum = max(maxNum, nums[i]);\\n    if(minNum == maxNum) return 0;\\n    int gap = (maxNum-minNum)/(size-1)+1;\\n    int mins[size], maxs[size]{0};\\n    for(int i = 0; i < size; ++i) mins[i] = -1;\\n    for(int i = 0; i < size; ++i)\\n    {\\n        int k = (nums[i]-minNum)/gap;\\n        if(mins[k] == -1) mins[k] = nums[i];\\n        else mins[k] = min(mins[k], nums[i]);\\n        maxs[k] = max(maxs[k], nums[i]);\\n    }\\n    int start = maxs[0], end = mins[0];\\n    int maxGap = start-end;\\n    for(int i = 1; i < size; ++i)\\n    {\\n        if(mins[i] != -1)\\n        {\\n            maxGap = max(maxGap, mins[i]-start);\\n            start = maxs[i];\\n        }\\n    }\\n    return maxGap;\\n}\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nint maximumGap(vector<int>& nums) \\n{\\n\\tint size = nums.size();\\n\\tif(size < 2) return 0;\\n\\tif(size == 2) return abs(nums[1]-nums[0]);\\n\\tint maxDiff = 0;\\n\\tsort(nums.begin(), nums.end());\\n\\tfor(int i = 0; i < size-1; ++i)\\n\\t\\tmaxDiff = max(maxDiff, nums[i+1]-nums[i]);\\n\\treturn maxDiff;\\n}\\n```\n```\\nint maximumGap(vector<int>& nums) \\n{\\n    int size = nums.size();\\n    if(size < 1) return 0;\\n    if(size == 2) return abs(nums[1]-nums[0]);\\n    int minNum = INT_MAX, maxNum = INT_MIN;\\n    for(int i = 0; i < size; ++i) minNum = min(minNum, nums[i]), maxNum = max(maxNum, nums[i]);\\n    if(minNum == maxNum) return 0;\\n    int gap = (maxNum-minNum)/(size-1)+1;\\n    int mins[size], maxs[size]{0};\\n    for(int i = 0; i < size; ++i) mins[i] = -1;\\n    for(int i = 0; i < size; ++i)\\n    {\\n        int k = (nums[i]-minNum)/gap;\\n        if(mins[k] == -1) mins[k] = nums[i];\\n        else mins[k] = min(mins[k], nums[i]);\\n        maxs[k] = max(maxs[k], nums[i]);\\n    }\\n    int start = maxs[0], end = mins[0];\\n    int maxGap = start-end;\\n    for(int i = 1; i < size; ++i)\\n    {\\n        if(mins[i] != -1)\\n        {\\n            maxGap = max(maxGap, mins[i]-start);\\n            start = maxs[i];\\n        }\\n    }\\n    return maxGap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616338,
                "title": "python3-code-runtime-beats-92-32-memory-beats-65-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50690,
                "title": "clean-c-implementation-of-3-linear-time-sort-alg-with-detailed-explaination",
                "content": "As we can see, we should grasp all the 3 typical linear-time-sorting algorithm implementation. \\nAll the following 3 implementations have been modified from the GeeksForGeeks.\\nI have change the counting sort implementation to support negative numbers.\\nAnd the bucket support any float array input.\\n\\n> counting sort    [ stable ]       [ support:+/- intergers ]\\n> \\n> radix sort        [ use counting sort as sub-routine]   [ support only\\n> positive intergers]\\n> \\n> bucket sort     [support float : we need to change the array to in the\\n> range [0, 1)  ]\\n\\n\\n    #include <iostream>\\n    #include <vector>\\n    #include <algorithm>\\n    using namespace std;\\n    \\n\\n>     /* counting sort  Time O(N)  Space O(N+range) */\\n>     /* \\n>        support : positive / negative arrays\\n>        the last travese the array X : \\n>              FORWARD->not stable  \\n>     \\t\\t BACKWARD->stable\\n>     */\\n\\n    void countingSort(vector<int>& X){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, X[i]);\\n    \\t\\tend = max(end, X[i]);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[X[i]-start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i]=count[i-1]+count[i];\\n    \\t}\\n    \\t//for-ward traverse is not stable sorting\\n    \\t//for (int i = 0; i < len; i++)\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len-1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[X[i] - start]-1] = X[i];\\n    \\t\\tcount[X[i] - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    \\n    \\n\\n>     /* Radix sort  Time O(log(base,MAX)*(N+base))  Space O(constant)  default:base=10 */\\n>     /* \\n>        support : only positive interger \\n>        can only deal with positive integers or change the float number \\n>        of the specified precision to intergers by multiplying 10^n \\n>     */\\n\\n    \\n    void countingSort(vector<int>& X, int exp, int base){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, (X[i] / exp)%base);\\n    \\t\\tend = max(end, (X[i] / exp) % base);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[(X[i] / exp) % base -start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i] = count[i - 1] + count[i];\\n    \\t}\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len - 1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[(X[i] / exp) % base -start] - 1] = X[i];\\n    \\t\\tcount[(X[i] / exp) % base - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    void radixSort(vector<int> &X){\\n    \\tint len = X.size();\\n    \\tint max_val = INT_MIN;\\n    \\tint base = 10;\\n    \\tfor (int i = 0; i < len; i++) max_val = max(X[i], max_val);\\n    \\tfor (int exp = 1; max_val / exp>0; exp *= base){\\n    \\t\\tcountingSort(X, exp, base);\\n    \\t}\\n    }\\n    \\n    \\n\\n>     /* bubble sort  Time   Space */\\n>     /*\\n>       support : any float & int numbers\\n>       sort a large set of floating nubmers in range from 0.0 to 1.0\\n>       uniformly distributed across the range \\n>       the key idea is : \\n>             the insertion sort for all individual bucket is O(N)\\n>     */\\n\\n    void bucketSort(vector<float>& X){\\n    \\tint len = X.size();\\n    \\tfloat max_val = X[0], min_val = X[0];;\\n    \\tfor (int i = 1; i < len; i++) {\\n    \\t\\tmax_val = max(max_val, X[i]);\\n    \\t\\tmin_val = min(min_val, X[i]);\\n    \\t}\\n    \\tmax_val++;\\n    \\n    \\tvector<vector<float>> bucket(len, vector<float>());\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tint index = len*(X[i]-min_val)/(max_val-min_val);\\n    \\t\\tbucket[index].push_back(X[i]);\\n    \\t}\\n    \\n    \\tfor (int i = 0; i < len; i++)\\tsort(bucket[i].begin(), bucket[i].end());\\n    \\n    \\tint index = 0;\\n    \\tfor (int i = 0; i < len; i++)\\n    \\t\\tfor (int j = 0; j < bucket[i].size(); j++)\\n    \\t\\t\\tX[index++] = bucket[i][j];\\n    }\\n    \\n\\n>  /*   test all the 3-linear-sorting-implementation  */\\n\\n    int main(){\\n    \\tvector<int> test1 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tcountingSort(test1);\\n    \\tcout << endl<<\"counting Sort result: \";\\n    \\tfor (int i = 0; i < test1.size(); i++)\\t cout << test1[i] <<\" - \";\\n    \\tvector<int> test2 = { 11, 200, 14, 2000, 30, 400, 10, 22, 456 };\\n    \\tradixSort(test2);\\n    \\tcout << endl << \"radix Sort result: \";\\n    \\tfor (int i = 0; i < test2.size(); i++)\\t cout << test2[i] << \" - \";\\n    \\tvector<float> test3 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tbucketSort(test3);\\t\\n    \\tcout << endl << \"bucket Sort result: \";\\n    \\tfor (int i = 0; i < test3.size(); i++)\\t cout << test3[i] << \" - \";\\n    \\treturn 0;\\n    }",
                "solutionTags": [],
                "code": "As we can see, we should grasp all the 3 typical linear-time-sorting algorithm implementation. \\nAll the following 3 implementations have been modified from the GeeksForGeeks.\\nI have change the counting sort implementation to support negative numbers.\\nAnd the bucket support any float array input.\\n\\n> counting sort    [ stable ]       [ support:+/- intergers ]\\n> \\n> radix sort        [ use counting sort as sub-routine]   [ support only\\n> positive intergers]\\n> \\n> bucket sort     [support float : we need to change the array to in the\\n> range [0, 1)  ]\\n\\n\\n    #include <iostream>\\n    #include <vector>\\n    #include <algorithm>\\n    using namespace std;\\n    \\n\\n>     /* counting sort  Time O(N)  Space O(N+range) */\\n>     /* \\n>        support : positive / negative arrays\\n>        the last travese the array X : \\n>              FORWARD->not stable  \\n>     \\t\\t BACKWARD->stable\\n>     */\\n\\n    void countingSort(vector<int>& X){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, X[i]);\\n    \\t\\tend = max(end, X[i]);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[X[i]-start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i]=count[i-1]+count[i];\\n    \\t}\\n    \\t//for-ward traverse is not stable sorting\\n    \\t//for (int i = 0; i < len; i++)\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len-1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[X[i] - start]-1] = X[i];\\n    \\t\\tcount[X[i] - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    \\n    \\n\\n>     /* Radix sort  Time O(log(base,MAX)*(N+base))  Space O(constant)  default:base=10 */\\n>     /* \\n>        support : only positive interger \\n>        can only deal with positive integers or change the float number \\n>        of the specified precision to intergers by multiplying 10^n \\n>     */\\n\\n    \\n    void countingSort(vector<int>& X, int exp, int base){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, (X[i] / exp)%base);\\n    \\t\\tend = max(end, (X[i] / exp) % base);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[(X[i] / exp) % base -start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i] = count[i - 1] + count[i];\\n    \\t}\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len - 1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[(X[i] / exp) % base -start] - 1] = X[i];\\n    \\t\\tcount[(X[i] / exp) % base - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    void radixSort(vector<int> &X){\\n    \\tint len = X.size();\\n    \\tint max_val = INT_MIN;\\n    \\tint base = 10;\\n    \\tfor (int i = 0; i < len; i++) max_val = max(X[i], max_val);\\n    \\tfor (int exp = 1; max_val / exp>0; exp *= base){\\n    \\t\\tcountingSort(X, exp, base);\\n    \\t}\\n    }\\n    \\n    \\n\\n>     /* bubble sort  Time   Space */\\n>     /*\\n>       support : any float & int numbers\\n>       sort a large set of floating nubmers in range from 0.0 to 1.0\\n>       uniformly distributed across the range \\n>       the key idea is : \\n>             the insertion sort for all individual bucket is O(N)\\n>     */\\n\\n    void bucketSort(vector<float>& X){\\n    \\tint len = X.size();\\n    \\tfloat max_val = X[0], min_val = X[0];;\\n    \\tfor (int i = 1; i < len; i++) {\\n    \\t\\tmax_val = max(max_val, X[i]);\\n    \\t\\tmin_val = min(min_val, X[i]);\\n    \\t}\\n    \\tmax_val++;\\n    \\n    \\tvector<vector<float>> bucket(len, vector<float>());\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tint index = len*(X[i]-min_val)/(max_val-min_val);\\n    \\t\\tbucket[index].push_back(X[i]);\\n    \\t}\\n    \\n    \\tfor (int i = 0; i < len; i++)\\tsort(bucket[i].begin(), bucket[i].end());\\n    \\n    \\tint index = 0;\\n    \\tfor (int i = 0; i < len; i++)\\n    \\t\\tfor (int j = 0; j < bucket[i].size(); j++)\\n    \\t\\t\\tX[index++] = bucket[i][j];\\n    }\\n    \\n\\n>  /*   test all the 3-linear-sorting-implementation  */\\n\\n    int main(){\\n    \\tvector<int> test1 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tcountingSort(test1);\\n    \\tcout << endl<<\"counting Sort result: \";\\n    \\tfor (int i = 0; i < test1.size(); i++)\\t cout << test1[i] <<\" - \";\\n    \\tvector<int> test2 = { 11, 200, 14, 2000, 30, 400, 10, 22, 456 };\\n    \\tradixSort(test2);\\n    \\tcout << endl << \"radix Sort result: \";\\n    \\tfor (int i = 0; i < test2.size(); i++)\\t cout << test2[i] << \" - \";\\n    \\tvector<float> test3 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tbucketSort(test3);\\t\\n    \\tcout << endl << \"bucket Sort result: \";\\n    \\tfor (int i = 0; i < test3.size(); i++)\\t cout << test3[i] << \" - \";\\n    \\treturn 0;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 50724,
                "title": "my-concise-and-short-c-code-with-comment-explanation",
                "content": "    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 2 ) return 0;\\n        int maxE = *max_element(nums.begin(),nums.end());\\n        int minE = *min_element(nums.begin(),nums.end());\\n        \\n        int len = maxE - minE;\\n        if( len <= 1 ) return len;\\n        vector<int> buck_max(n, INT_MIN);\\n        vector<int> buck_min(n, INT_MAX);\\n        \\n        for(int i = 0; i < n; i++) {\\n            // note the divide and multiply order and the double cast\\n            // it's used to avoid the overflow and underflow during calculation\\n            int index = (double)( nums[i] - minE )  / len * ( n - 1 );\\n            buck_max[index] = max(buck_max[index], nums[i]);\\n            buck_min[index] = min(buck_min[index], nums[i]);\\n        }\\n        \\n        int gap = 0, pre = buck_max[0];\\n        for(int i = 1; i < n; i++) {\\n            if( buck_max[i] == INT_MIN ) continue;\\n            gap = max(gap, buck_min[i] - pre);\\n            pre = buck_max[i];\\n        }\\n        return gap;\\n    }",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 2 ) return 0;\\n        int maxE = *max_element(nums.begin(),nums.end());\\n        int minE = *min_element(nums.begin(),nums.end());\\n        \\n        int len = maxE - minE;\\n        if( len <= 1 ) return len;\\n        vector<int> buck_max(n, INT_MIN);\\n        vector<int> buck_min(n, INT_MAX);\\n        \\n        for(int i = 0; i < n; i++) {\\n            // note the divide and multiply order and the double cast\\n            // it's used to avoid the overflow and underflow during calculation\\n            int index = (double)( nums[i] - minE )  / len * ( n - 1 );\\n            buck_max[index] = max(buck_max[index], nums[i]);\\n            buck_min[index] = min(buck_min[index], nums[i]);\\n        }\\n        \\n        int gap = 0, pre = buck_max[0];\\n        for(int i = 1; i < n; i++) {\\n            if( buck_max[i] == INT_MIN ) continue;\\n            gap = max(gap, buck_min[i] - pre);\\n            pre = buck_max[i];\\n        }\\n        return gap;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1663928,
                "title": "c-linear-time-space-using-buckets-w-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2) return 0;\\n        \\n        int maxi = -1, mini = INT_MAX, n = nums.size();\\n        for(auto u : nums) maxi = max(maxi,u), mini = min(mini,u);\\n        // Since there will be n-1 gaps in between the numbers, this will be the average gap between\\n        // any two numbers in the array.\\n        // NOTE : Its very important to take the upper value of average gap, or else we will have a runtime error\\n        // in the index of bucket that we will find in the next step.\\n        int avg_gap = (int)ceil((double)(maxi-mini)/(n-1));\\n        // To handle cases where all the elements are same!!!\\n        if(avg_gap == 0) return 0;      \\n        /*\\n        Now, we can allot all the numbers a bucket, by dividing them with this average gap. Now it \\n        can be easily observed that by dividing any numbers with this average gap, it is sure to fall \\n        in one of the (n-1) buckets that will be formed. \\n        Taking the example 1, \\n                \\n                [3, 6, 9, 1]      =>    avg gap = ceil[(9-1)/3] ~= 3\\n        Now we have to find the maximum gap, therefore, it will be >= average gap.\\n        Alloting the buckets : [[arr[i]-min]/average_gap], for all numbers of the array, this formula will result\\n                               in numbers that lie in a range, and thus the result for each can be considered as \\n                               the bucket index.\\n                               \\n                [3-1]/3 = 0\\n                [6-1]/3 = 1\\n                [9-1]/3 = 2\\n                [1-1]/3 = 0\\n            \\n              0        1      2\\n            1___3    ____6  ____9\\n            \\n            Now as we said, the maximum gap will be greater than or equal to the average gap, therefore, the answer\\n            will not lie within a bucket because its gap between the maximum and minimum element will always be\\n            less than the average gap, for reference, consider in bucket 2nd, we had the bucket fully filled, then\\n            in that case, we would have 4 as the minimum and 6 as maximum and there difference be 2. So, even in \\n            worst case, we have a difference 1 less than the average. So, for the question, we only need to check\\n            in between the buckets. Thus we only compare the difference between the maximum of one bucket and \\n            minimum of next.\\n        */\\n        \\n        // Allocating the buckets and storing the maximum and minimum of each bucket \\n        vector <int> bucket_max(n,-1), bucket_min(n,INT_MAX);\\n        for(int i = 0; i<n; i++){\\n            int index = (nums[i]-mini)/avg_gap;\\n            bucket_min[index] = min(bucket_min[index],nums[i]);\\n            bucket_max[index] = max(bucket_max[index],nums[i]);\\n        }\\n        \\n        // After filling the min and max arrays, we just need to compare...\\n        int prev = mini, ans = 0;\\n        for(int i = 0; i<bucket_min.size(); i++){\\n            if(bucket_max[i] == -1) continue;\\n            ans = max(ans,bucket_min[i]-prev);\\n            prev = bucket_max[i];\\n        }\\n        // We need to compare with the last element which is maximum...\\n        ans = max(ans,maxi-prev);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2) return 0;\\n        \\n        int maxi = -1, mini = INT_MAX, n = nums.size();\\n        for(auto u : nums) maxi = max(maxi,u), mini = min(mini,u);\\n        // Since there will be n-1 gaps in between the numbers, this will be the average gap between\\n        // any two numbers in the array.\\n        // NOTE : Its very important to take the upper value of average gap, or else we will have a runtime error\\n        // in the index of bucket that we will find in the next step.\\n        int avg_gap = (int)ceil((double)(maxi-mini)/(n-1));\\n        // To handle cases where all the elements are same!!!\\n        if(avg_gap == 0) return 0;      \\n        /*\\n        Now, we can allot all the numbers a bucket, by dividing them with this average gap. Now it \\n        can be easily observed that by dividing any numbers with this average gap, it is sure to fall \\n        in one of the (n-1) buckets that will be formed. \\n        Taking the example 1, \\n                \\n                [3, 6, 9, 1]      =>    avg gap = ceil[(9-1)/3] ~= 3\\n        Now we have to find the maximum gap, therefore, it will be >= average gap.\\n        Alloting the buckets : [[arr[i]-min]/average_gap], for all numbers of the array, this formula will result\\n                               in numbers that lie in a range, and thus the result for each can be considered as \\n                               the bucket index.\\n                               \\n                [3-1]/3 = 0\\n                [6-1]/3 = 1\\n                [9-1]/3 = 2\\n                [1-1]/3 = 0\\n            \\n              0        1      2\\n            1___3    ____6  ____9\\n            \\n            Now as we said, the maximum gap will be greater than or equal to the average gap, therefore, the answer\\n            will not lie within a bucket because its gap between the maximum and minimum element will always be\\n            less than the average gap, for reference, consider in bucket 2nd, we had the bucket fully filled, then\\n            in that case, we would have 4 as the minimum and 6 as maximum and there difference be 2. So, even in \\n            worst case, we have a difference 1 less than the average. So, for the question, we only need to check\\n            in between the buckets. Thus we only compare the difference between the maximum of one bucket and \\n            minimum of next.\\n        */\\n        \\n        // Allocating the buckets and storing the maximum and minimum of each bucket \\n        vector <int> bucket_max(n,-1), bucket_min(n,INT_MAX);\\n        for(int i = 0; i<n; i++){\\n            int index = (nums[i]-mini)/avg_gap;\\n            bucket_min[index] = min(bucket_min[index],nums[i]);\\n            bucket_max[index] = max(bucket_max[index],nums[i]);\\n        }\\n        \\n        // After filling the min and max arrays, we just need to compare...\\n        int prev = mini, ans = 0;\\n        for(int i = 0; i<bucket_min.size(); i++){\\n            if(bucket_max[i] == -1) continue;\\n            ans = max(ans,bucket_min[i]-prev);\\n            prev = bucket_max[i];\\n        }\\n        // We need to compare with the last element which is maximum...\\n        ans = max(ans,maxi-prev);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038791,
                "title": "bucket-sort-solution-in-golang-with-explanation",
                "content": "Sort the whole array is unnecessary, we just need for loop the whole array and group  a set of elements in a way that elements in the same group are more similar (close value) to each other than to those in other groups, yeah, a bit like clustering, bucket sort can solve kind of this problem. \\n\\nAfter clustering, we will have many groups(called buckets), we store two elements in each bucket(the max one and the min one) because all elements in same bucket have close value, so the max gap is ```minValue(current bucket) - maxValue(previous bucket)```\\n\\nLet me explain more with some examples\\n\\n**NOTICE**: *In order to explain more clearly(IMHO), I made some fake data and screenshots to demonstrate how I think about this problem, that means data and screenshot may not compatible and appeared in real.*\\n\\nFor example, we have a array like this ```array = [1,2,9,3,10]```,  assume we have two bucket: ```bucketA``` and ```bucketB```, we retrieve each elements of array and put them into bucktes, because ```1,2,3``` are close value, so put they three into ```bucketA```, put ```9,10``` into ```bucketB```:\\n\\n![image](https://assets.leetcode.com/users/images/fde4e091-d920-4dc7-a542-9172028ca74c_1611821091.3885255.png)\\n\\n\\n\\t\\nIt is obviously: ```maxGap =  bucketB.min - bucketA.max```, and also,  you may see that ```2``` in ```bucketA``` is unnecessary, so we dont store it in code, each bucket has only ```2``` elements: the min one and the max one\\n\\nWell, now, the question is how to clustering these elements ?\\n\\nThe ```average gap``` between two element should be ```(array.Max - array.Min) / (array.Size - 1)``` , the max gap here must bigger than that.\\n\\nLet\\'s calculate the ```average gap``` in ```array ([1,2,9,3,10])``` above:\\n ```gap = ((2-1) + (9-2) + (3-9) + (10-3)) / (array.Size - 1)```\\n  ```gap = (1+7-6+7) / 4```\\n  ```gap = 9 / 4 = 2.25```\\n well, it is equal to```(10 - 1) / 4 = 2.25``` , so if the gap between two element is bigger than ```2.25```,  it makes itself possible to be the final, maxGap.\\n\\n\\nHere are buckets we initialized, by default they have default values respecitively:\\n![image](https://assets.leetcode.com/users/images/e1eb8e14-2c60-46cd-b93a-26dd4b674b16_1611826566.7701204.png)\\n\\n\\n\\n\\n\\n  \\n```idx``` is the index of buckets we should put elements into. ```idx := (array.element - min) / gap```\\n\\nHow many buckets I used ?  \\n```numOfBuckets = array.Size - 1```\\n\\nAssume, our buckets are looks like this:\\n![image](https://assets.leetcode.com/users/images/be4db3a6-c46b-4151-98fc-1378f5ae8c0a_1611825060.9715645.png)\\n\\n\\n\\n```Max``` is the result.\\n\\nOk, my english is not good, let see the final solution in Golang is as follows\\n```\\n\\nfunc maximumGap(nums []int) int {\\n\\n\\tsize := len(nums)\\n\\n\\tif 2 == size {\\n\\t\\treturn int(math.Abs(float64(nums[0] - nums[1])))\\n\\t}\\n\\n\\tif size < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// retrieve min and max of array\\n\\tmin, max := nums[0], nums[0]\\n\\n\\tfor i := 1; i < size; i++ {\\n\\t\\tif nums[i] > max {\\n\\t\\t\\tmax = nums[i]\\n\\t\\t} else if nums[i] < min {\\n\\t\\t\\tmin = nums[i]\\n\\t\\t}\\n\\t}\\n\\n\\t// equal elements\\n\\tif min == max {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tgap := int(float64((max - min) / (size - 1))) + 1\\n\\tcapacity := size - 1\\n\\n\\tbucketMIN := make([]int, capacity)\\n\\tbucketMAX := make([]int, capacity)\\n\\n\\tfor i := 0; i < capacity; i++ {\\n\\t\\tbucketMIN[i] = math.MaxInt64\\n\\t\\tbucketMAX[i] = math.MinInt64\\n\\t}\\n\\n\\t// buckets become\\n\\t// bucketMIN = { MaxInt64, MaxInt64, MaxInt64, ...}\\n\\t// bucketMAX = { MinInt64, MinInt64, MinInt64, ...}\\n\\n\\t// put nums into buckets respectively\\n\\tfor i := 0; i < size; i++ {\\n\\n\\t\\tnum := nums[i]\\n\\n\\t\\tif num == max || num == min {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// index of buckets\\n\\t\\tidx := (num - min) / gap\\n\\n\\t\\tbucketMIN[idx] = int(math.Min(float64(num), float64(bucketMIN[idx])))\\n\\t\\tbucketMAX[idx] = int(math.Max(float64(num), float64(bucketMAX[idx])))\\n\\t}\\n\\n\\tmaxGap := math.MinInt64\\n\\tprev := min\\n\\n\\tfor i := 0; i < capacity; i++ {\\n\\n\\t\\tif bucketMIN[i] == math.MaxInt64 &&\\n\\t\\t\\tbucketMAX[i] == math.MinInt64 {\\n\\n\\t\\t\\t// empty bucket\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tmaxGap = int(math.Max(float64(maxGap), float64(bucketMIN[i] - prev)))\\n\\t\\tprev = bucketMAX[i]\\n\\t}\\n\\n\\tmaxGap = int(math.Max(float64(maxGap), float64(max - prev)))\\n\\treturn maxGap\\n}\\n\\n```\\n\\nLeetcode says:\\n```\\nRuntime: 4 ms, faster than 95.83% of Go online submissions for Maximum Gap.\\nMemory Usage: 3.7 MB, less than 25.00% of Go online submissions for Maximum Gap.\\n```\\n\\nThanks for reading.\\n\\n\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```minValue(current bucket) - maxValue(previous bucket)```\n```array = [1,2,9,3,10]```\n```bucketA```\n```bucketB```\n```1,2,3```\n```bucketA```\n```9,10```\n```bucketB```\n```maxGap =  bucketB.min - bucketA.max```\n```2```\n```bucketA```\n```2```\n```average gap```\n```(array.Max - array.Min) / (array.Size - 1)```\n```average gap```\n```array ([1,2,9,3,10])```\n```gap = ((2-1) + (9-2) + (3-9) + (10-3)) / (array.Size - 1)```\n```gap = (1+7-6+7) / 4```\n```gap = 9 / 4 = 2.25```\n```(10 - 1) / 4 = 2.25```\n```2.25```\n```idx```\n```idx := (array.element - min) / gap```\n```numOfBuckets = array.Size - 1```\n```Max```\n```\\n\\nfunc maximumGap(nums []int) int {\\n\\n\\tsize := len(nums)\\n\\n\\tif 2 == size {\\n\\t\\treturn int(math.Abs(float64(nums[0] - nums[1])))\\n\\t}\\n\\n\\tif size < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// retrieve min and max of array\\n\\tmin, max := nums[0], nums[0]\\n\\n\\tfor i := 1; i < size; i++ {\\n\\t\\tif nums[i] > max {\\n\\t\\t\\tmax = nums[i]\\n\\t\\t} else if nums[i] < min {\\n\\t\\t\\tmin = nums[i]\\n\\t\\t}\\n\\t}\\n\\n\\t// equal elements\\n\\tif min == max {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tgap := int(float64((max - min) / (size - 1))) + 1\\n\\tcapacity := size - 1\\n\\n\\tbucketMIN := make([]int, capacity)\\n\\tbucketMAX := make([]int, capacity)\\n\\n\\tfor i := 0; i < capacity; i++ {\\n\\t\\tbucketMIN[i] = math.MaxInt64\\n\\t\\tbucketMAX[i] = math.MinInt64\\n\\t}\\n\\n\\t// buckets become\\n\\t// bucketMIN = { MaxInt64, MaxInt64, MaxInt64, ...}\\n\\t// bucketMAX = { MinInt64, MinInt64, MinInt64, ...}\\n\\n\\t// put nums into buckets respectively\\n\\tfor i := 0; i < size; i++ {\\n\\n\\t\\tnum := nums[i]\\n\\n\\t\\tif num == max || num == min {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// index of buckets\\n\\t\\tidx := (num - min) / gap\\n\\n\\t\\tbucketMIN[idx] = int(math.Min(float64(num), float64(bucketMIN[idx])))\\n\\t\\tbucketMAX[idx] = int(math.Max(float64(num), float64(bucketMAX[idx])))\\n\\t}\\n\\n\\tmaxGap := math.MinInt64\\n\\tprev := min\\n\\n\\tfor i := 0; i < capacity; i++ {\\n\\n\\t\\tif bucketMIN[i] == math.MaxInt64 &&\\n\\t\\t\\tbucketMAX[i] == math.MinInt64 {\\n\\n\\t\\t\\t// empty bucket\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tmaxGap = int(math.Max(float64(maxGap), float64(bucketMIN[i] - prev)))\\n\\t\\tprev = bucketMAX[i]\\n\\t}\\n\\n\\tmaxGap = int(math.Max(float64(maxGap), float64(max - prev)))\\n\\treturn maxGap\\n}\\n\\n```\n```\\nRuntime: 4 ms, faster than 95.83% of Go online submissions for Maximum Gap.\\nMemory Usage: 3.7 MB, less than 25.00% of Go online submissions for Maximum Gap.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 50649,
                "title": "simple-radix-sort-solution-in-python",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def radixSort(self, A): \\n            for k in xrange(10):     \\n                s=[[] for i in xrange(10)]\\n                for i in A:\\n                    s[i/(10**k)%10].append(i)\\n                A=[a for b in s for a in b] \\n            return A\\n        \\n        def maximumGap(self, nums): \\n            A = self.radixSort(nums)\\n            ans = 0\\n            if len(A) == 0: return 0\\n            prev = A[0]\\n            for i in A:\\n                if i - prev > ans: ans = i - prev\\n                prev = i\\n            return ans",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3908856,
                "title": "java-python3-explanation-code-brute-force-optimized-approach-bukcet-sort",
                "content": "# Brute Force\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust sort the array and check the pair of two adjacent elements having the maximum gap in the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Sort the array\\nStep 2: Traverse the loop in the reverse order and compare the difference between the last and its previous element.\\nStep 3: Replace the value max if value exceeds.\\nStep 4: Return the max difference.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n```Java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)return 0;\\n        Arrays.sort(nums);\\n        int maxDiff = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            maxDiff = Math.max(maxDiff, nums[i+1] - nums[i]);\\n        }\\n        return maxDiff;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def maximumGap(self, nums):\\n        if len(nums) < 2:\\n            return 0\\n    \\n        nums.sort()\\n        maxDiff = 0\\n\\n        for i in range(1, len(nums)):\\n            maxDiff = max(maxDiff, nums[i] - nums[i - 1])\\n    \\n        return maxDiff\\n```\\n\\n---\\n# Optimized Approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor finding maximum gap we are making bucket for putting middle n-2 elements and bucket size will be n-1 means (smallest and largest elements are to be avoided) means there will be one bucket that will be empty so that previous max and next mix elements of bucket will give the max difference. For doing so we make the bucket of `size n-1` for both storing max and min element in the bucket and bucket will contain and bucket will store `(max-min)/n-1` range of elements . Now we start putting elements in bucket so for checking in which index we have to put that element we find `(x-min)/avg` and avg is `(max-min)/n-1` so we get the index and we fill max and min buckets with this elements . Now we simply take difference between max of one bucket and min of next bucket. \\n# Complexity\\n- Time complexity:` O(n)`, where n is the length of the input array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`, because we are using an array to store the buckets. However, we can reduce the space complexity to `O(1) `by using a linked list instead of an array to store the buckets.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n```Java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)\\n            return 0;\\n        int n = nums.length;\\n        int max = nums[0], min= nums[0];\\n        for(int i  : nums) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int bucketSize = (max - min)/(n - 1);\\n        if(bucketSize == 0)\\n            bucketSize++;\\n        int totalBuckets = ((max - min)/bucketSize) + 1;\\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ; i++) {\\n            int index = (nums[i] - min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i < totalBuckets; i++) {\\n            if(minBucket[i] == Integer.MAX_VALUE)\\n                continue;\\n            result = Math.max(result, minBucket[i] - prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        \\n        # compute the maximum and minimum values\\n        max_value, min_value = max(nums), min(nums)\\n        \\n        # compute the size of each bucket\\n        bucket_size = max(1, (max_value - min_value) // (n - 1))\\n        \\n        # compute the number of buckets\\n        num_buckets = (max_value - min_value) // bucket_size + 1\\n        \\n        # initialize the buckets with maximum and minimum values\\n        buckets = [[float(\\'inf\\'), float(\\'-inf\\')] for _ in range(num_buckets)]\\n        for num in nums:\\n            bucket_index = (num - min_value) // bucket_size\\n            buckets[bucket_index][0] = min(buckets[bucket_index][0], num)\\n            buckets[bucket_index][1] = max(buckets[bucket_index][1], num)\\n        \\n        # compute the maximum difference\\n        max_diff = 0\\n        prev_max = buckets[0][1]\\n        for i in range(1, num_buckets):\\n            if buckets[i][0] == float(\\'inf\\'):\\n                continue\\n            max_diff = max(max_diff, buckets[i][0] - prev_max)\\n            prev_max = buckets[i][1]\\n        \\n        return max_diff\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)return 0;\\n        Arrays.sort(nums);\\n        int maxDiff = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            maxDiff = Math.max(maxDiff, nums[i+1] - nums[i]);\\n        }\\n        return maxDiff;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def maximumGap(self, nums):\\n        if len(nums) < 2:\\n            return 0\\n    \\n        nums.sort()\\n        maxDiff = 0\\n\\n        for i in range(1, len(nums)):\\n            maxDiff = max(maxDiff, nums[i] - nums[i - 1])\\n    \\n        return maxDiff\\n```\n```Java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)\\n            return 0;\\n        int n = nums.length;\\n        int max = nums[0], min= nums[0];\\n        for(int i  : nums) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int bucketSize = (max - min)/(n - 1);\\n        if(bucketSize == 0)\\n            bucketSize++;\\n        int totalBuckets = ((max - min)/bucketSize) + 1;\\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ; i++) {\\n            int index = (nums[i] - min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i < totalBuckets; i++) {\\n            if(minBucket[i] == Integer.MAX_VALUE)\\n                continue;\\n            result = Math.max(result, minBucket[i] - prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        \\n        # compute the maximum and minimum values\\n        max_value, min_value = max(nums), min(nums)\\n        \\n        # compute the size of each bucket\\n        bucket_size = max(1, (max_value - min_value) // (n - 1))\\n        \\n        # compute the number of buckets\\n        num_buckets = (max_value - min_value) // bucket_size + 1\\n        \\n        # initialize the buckets with maximum and minimum values\\n        buckets = [[float(\\'inf\\'), float(\\'-inf\\')] for _ in range(num_buckets)]\\n        for num in nums:\\n            bucket_index = (num - min_value) // bucket_size\\n            buckets[bucket_index][0] = min(buckets[bucket_index][0], num)\\n            buckets[bucket_index][1] = max(buckets[bucket_index][1], num)\\n        \\n        # compute the maximum difference\\n        max_diff = 0\\n        prev_max = buckets[0][1]\\n        for i in range(1, num_buckets):\\n            if buckets[i][0] == float(\\'inf\\'):\\n                continue\\n            max_diff = max(max_diff, buckets[i][0] - prev_max)\\n            prev_max = buckets[i][1]\\n        \\n        return max_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482255,
                "title": "faster-than-95-c-bucket-sort-o-n-space-o-n-time",
                "content": "bucket sort\\n\\n~~~C++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int mn = INT_MAX, mx = INT_MIN;\\n        int n = nums.size();\\n        if (n < 2)\\n        \\treturn 0;\\n        for (int i=0;i<n;++i) {\\n        \\tmn = min(nums[i], mn);\\n        \\tmx = max(nums[i], mx);\\n\\t\\t}\\n\\t\\tif (mx == mn)\\n\\t\\t\\treturn 0;\\n\\t\\tdouble bucket = (mx - mn + 0.0) / n; \\n\\t\\tvector<int> big(n, -1); \\n\\t\\tvector<int> small(n, -1);  \\n\\t\\tfor (int i=0;i<n;++i) {\\n\\t\\t\\tint index = (nums[i] - mn) / bucket;\\n\\t\\t\\tif (index >= n) \\n\\t\\t\\t\\tindex = n - 1; \\n\\t\\t\\t\\n\\t\\t\\tif (big[index] == -1) {\\n\\t\\t\\t\\tbig[index] = small[index] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbig[index] = max(big[index], nums[i]);\\n\\t\\t\\t\\tsmall[index] = min(small[index], nums[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint result = 0;\\n\\t\\tint s = mn, b = mn;\\n\\t\\tfor (int i=0;i<n;++i) { \\n\\t\\t\\tif (big[i] == -1)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tresult = max(small[i] - b, result); \\n\\t\\t\\ts = small[i];\\n\\t\\t\\tb = big[i];\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bucket Sort"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int mn = INT_MAX, mx = INT_MIN;\\n        int n = nums.size();\\n        if (n < 2)\\n        \\treturn 0;\\n        for (int i=0;i<n;++i) {\\n        \\tmn = min(nums[i], mn);\\n        \\tmx = max(nums[i], mx);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1251483,
                "title": "c-o-n-bucket-sort-and-pigeon-hole-with-detail-explanation-one-of-the-very-nice-approach",
                "content": "in O(nlogn) its very simple to solve lets solve in O(n)  using bucket sort pigeon hole principle. If  already done bucket sort then its not so tricky  if not then lets see\\n   \\n   lets take example [3,6,9,1] \\n     \\n\\t find the min and max in the array min=1 and max=9. so numbers in the array will range from 1 to 9. and there are total n-1 gaps.\\n\\t  3____6____9____1\\n       g1   g2   g3\\nn-1=3 total 3 gaps.now we will calculate avg dist of gap\\n     avg=(max-min)/(n-1)\\nnow we will take few buckets(we will calculate it\\'s size) and in each bucket we will put elmt like -\\nbucket 1---->[min....min+avg-1] \\nbucket 2---->[min+avg......min+2*avg-1]\\n\\'\\n\\'\\n[\\n in bucket1---->[1,2] (any of them which is present in the array can come to this \\n    bucket2----->[3,4]       bucket)\\n\\tbucket3----->[5,6]\\n\\tbucket4----->[7,8]\\n\\tbucket5----->[9]\\n\\t]\\n\\t now will calculate the number of buckets---\\n\\t numbuckets=(max-min)/avg+1;\\n\\t      here (9-1)/2+1=5;\\n   and we will put each elmt its correspondence bucket\\n     bucketIndex=(nums[i]-min)/avg;\\n\\t\\n\\tfor 3--->index=(3-1)/2=1;\\n\\t     6--->index=(6-1)/2=2;\\n\\t\\t 9--->index=(9-1)/2=4;\\n\\t\\t 1--->index=(1-1)/2=0;\\n\\t 0    bucket1----->[1]\\n     1    bucket2----->[3]\\n\\t 2    bucket3----->[6]\\n\\t 3   bucket4----->  []\\n\\t 4  bucket5----->[9]\\n\\t \\n* In each bucket the maximum diff between any two number will always be less than     avg.\\n* And our actual ans will be  always ( >=avg ) so both no\\'s (which diff is                 maximum)  cannot be in same bucket .\\n* So they will be in different buckets.Since we have to find adjacent elements different so it will be then min of next bucket and max of present bucket\\'s different.\\n* We will check for each bucket and choose the maximum .\\n* here we can optimize our space little bit instead of storing all elements in             buckets we will only store max and min in bucket .and calculate out ans.\\n\\t\\t   minBucket--->[1,3,6,INT_MAX,9]\\n\\t\\t   maxBucket--->[1,3,6,INT_MIN,9]\\n since there is <=1 element in each bucket so it will be the same if there will multiple element then min and max are stored.\\n Now  ans=0;\\n  ans=max(ans,3-1)=2;\\n  ans=max(ans,6-3)=3;\\n  ans=max(ans,9-6)=3;\\n  \\n  (if there is INT_MAX or INT_MIN ignore this)\\n  \\n  \\n ```\\n   class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n       int n=nums.size();\\n        if(n<2) return 0;\\n      \\n          int mx=nums[0],mn=nums[0];\\n        for(int i=0;i<n;i++) { mn=min(mn,nums[i]);       mx=max(mx,nums[i]); }\\n\\t\\t\\n            int avg=max((mx-mn)/(n-1),1);  //\\n            int size=(mx-mn)/avg+1;   //number of buckets \\n        \\n          int mnA[size],  mxA[size];\\n        \\n        for(int i=0;i<size;i++) mnA[i]=INT_MAX,  mxA[i]=INT_MIN;\\n        \\n      for(int i=0;i<n;i++){\\n          int pos=(nums[i]-mn)/avg;    //index of bucket\\n          \\n          mnA[pos]=min(mnA[pos],nums[i]);  //puting elements in their buckets\\n          mxA[pos]=max(mxA[pos],nums[i]);   //\\n      }\\n     int ans=0;\\n        int i=0, j=1;\\n        while(i<size-1&&j<size) {\\n            if(mnA[j]==INT_MAX)  {  j++;   continue; }  //  Ignoring this bucket since \\n            if(mxA[i]==INT_MIN) {  i++;      continue;}   //there is no element present\\n            ans=max(ans,mnA[j]-mxA[i]);\\n            i++, j++;\\n        }\\n        return ans;\\n       \\n    }\\n}; \\n     ```\\n",
                "solutionTags": [],
                "code": "```\\n   class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n       int n=nums.size();\\n        if(n<2) return 0;\\n      \\n          int mx=nums[0],mn=nums[0];\\n        for(int i=0;i<n;i++) { mn=min(mn,nums[i]);       mx=max(mx,nums[i]); }\\n\\t\\t\\n            int avg=max((mx-mn)/(n-1),1);  //\\n            int size=(mx-mn)/avg+1;   //number of buckets \\n        \\n          int mnA[size],  mxA[size];\\n        \\n        for(int i=0;i<size;i++) mnA[i]=INT_MAX,  mxA[i]=INT_MIN;\\n        \\n      for(int i=0;i<n;i++){\\n          int pos=(nums[i]-mn)/avg;    //index of bucket\\n          \\n          mnA[pos]=min(mnA[pos],nums[i]);  //puting elements in their buckets\\n          mxA[pos]=max(mxA[pos],nums[i]);   //\\n      }\\n     int ans=0;\\n        int i=0, j=1;\\n        while(i<size-1&&j<size) {\\n            if(mnA[j]==INT_MAX)  {  j++;   continue; }  //  Ignoring this bucket since \\n            if(mxA[i]==INT_MIN) {  i++;      continue;}   //there is no element present\\n            ans=max(ans,mnA[j]-mxA[i]);\\n            i++, j++;\\n        }\\n        return ans;\\n       \\n    }\\n}; \\n     ```",
                "codeTag": "Java"
            },
            {
                "id": 727709,
                "title": "python3-group-data-into-buckets",
                "content": "Algo\\nIn several posts, the algo is termed \"pigeon hole principle\". To explain it in less fancier terms, let\\'s set `n - 1` buckets equally spaced between `min` and `max` to contain `n - 2` inner points. Then, there will be at least one empty bucket. In the spirit of this, one could safely ignore the distance within the buckets as it cannot be the largest. Instead, focusing on the distance between buckets is enough to give the correct answer. \\n\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) == 0: return 0 #edge case \\n        mn, mx = min(nums), max(nums)\\n        step = max(1, (mx - mn)//(len(nums)-1)) #n-1 holes \\n        size = (mx - mn)//step + 1\\n        buckets = [[inf, -inf] for _ in range(size)]\\n        \\n        for num in nums: \\n            i = (num - mn)//step\\n            x, xx = buckets[i]\\n            buckets[i] = min(x, num), max(xx, num)\\n        \\n        ans = 0\\n        prev = mn\\n        for i in range(size):\\n            x, xx = buckets[i]\\n            if x < inf:\\n                ans = max(ans, x - prev)\\n                prev = xx \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) == 0: return 0 #edge case \\n        mn, mx = min(nums), max(nums)\\n        step = max(1, (mx - mn)//(len(nums)-1)) #n-1 holes \\n        size = (mx - mn)//step + 1\\n        buckets = [[inf, -inf] for _ in range(size)]\\n        \\n        for num in nums: \\n            i = (num - mn)//step\\n            x, xx = buckets[i]\\n            buckets[i] = min(x, num), max(xx, num)\\n        \\n        ans = 0\\n        prev = mn\\n        for i in range(size):\\n            x, xx = buckets[i]\\n            if x < inf:\\n                ans = max(ans, x - prev)\\n                prev = xx \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 50698,
                "title": "c-solution-using-bucket-to-record",
                "content": "    int maximumGap(vector<int>& nums) {\\n        const int size_num = nums.size();\\n        if (size_num < 2) return 0;\\n        int maxV = *max_element(nums.begin(), nums.end());\\n        int minV = *min_element(nums.begin(), nums.end());\\n        if (maxV == minV) return 0;\\n        double range = (maxV - minV) / double(size_num - 1);\\n        vector<int> max_b(size_num, INT_MIN), min_b(size_num, INT_MAX);\\n        for (int i = 0; i < size_num; i++) {\\n            int index = (nums[i] - minV) / range;\\n            max_b[index] = max(max_b[index], nums[i]);\\n            min_b[index] = min(min_b[index], nums[i]);\\n        }\\n        int max_g = (int)range,  start = max_b[0];\\n        for (int i = 1; i < size_num; i++) {\\n            if (min_b[i] == INT_MAX) continue;\\n            max_g = max(max_g, min_b[i] - start);\\n            start = max_b[i];\\n        }\\n        return max_g;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int maximumGap(vector<int>& nums) {\\n        const int size_num = nums.size();\\n        if (size_num < 2) return 0;\\n        int maxV = *max_element(nums.begin(), nums.end());\\n        int minV = *min_element(nums.begin(), nums.end());\\n        if (maxV == minV) return 0;\\n        double range = (maxV - minV) / double(size_num - 1);\\n        vector<int> max_b(size_num, INT_MIN), min_b(size_num, INT_MAX);\\n        for (int i = 0; i < size_num; i++) {\\n            int index = (nums[i] - minV) / range;\\n            max_b[index] = max(max_b[index], nums[i]);\\n            min_b[index] = min(min_b[index], nums[i]);\\n        }\\n        int max_g = (int)range,  start = max_b[0];\\n        for (int i = 1; i < size_num; i++) {\\n            if (min_b[i] == INT_MAX) continue;\\n            max_g = max(max_g, min_b[i] - start);\\n            start = max_b[i];\\n        }\\n        return max_g;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3338914,
                "title": "trippy-s-coding-approach-simple-to-the-point",
                "content": "# Intuition\\nSHORT AND CRISPY SOLUTION.\\nHERE I AM PRESENTING ONLY JAVA SOLUTION, FOR C++ JUST USE VECTOR INSTEAD OF ARRAY \\n\\n# Approach\\nUSING SS APPRAOCH \\n**JUST SMILE AND SOLVE** \\n\\n# Complexity\\nNOTHING COMPLEX HERE \\n\\n# PLEASE UPVOTE\\nPLEASE UPVOTE IF I HELPED YOU\\nTHANK YOU.\\nKEEP IT UP.\\nLOVE FOR YOU BY TRIPPY \\u2764\\uFE0F\\u2764\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumGap(int[] arr) {\\n        Arrays.sort(arr);\\n        int l=arr.length;\\n        if(l<2)\\n        return 0;\\n        int max=0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            int c=arr[i+1]-arr[i];\\n            if(c>max)\\n            max=c;\\n          \\n        }\\n        return max;\\n        //PLEASE UPVOTE\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] arr) {\\n        Arrays.sort(arr);\\n        int l=arr.length;\\n        if(l<2)\\n        return 0;\\n        int max=0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            int c=arr[i+1]-arr[i];\\n            if(c>max)\\n            max=c;\\n          \\n        }\\n        return max;\\n        //PLEASE UPVOTE\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208798,
                "title": "164-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We define a Solution class with a maximumGap method that takes a list of integers nums as input and returns an integer, the maximum gap between two successive elements in the sorted form of nums.\\n\\n2. We check if the length of nums is less than 2, and return 0 if so, because we cannot find a gap between two elements if there is only one or none.\\n\\n3. We get the minimum and maximum values in nums using the built-in min and max functions.\\n\\n4. We calculate the bucket size as the maximum of 1 and the integer division of the range of nums (i.e., max_val - min_val) by the number of elements in nums minus 1 (i.e., len(nums) - 1). This ensures that we have at least one element in each bucket. We also calculate the number of buckets as the integer division of the range of nums by the bucket size plus 1, to ensure that we have a bucket for the maximum value.\\n\\n5. We initialize an empty list buckets of length num_buckets to hold the buckets.\\n\\n6. We loop through each element num in nums and calculate the index of the bucket it belongs to as the integer division of its distance from min_val by the bucket size. We then check if the corresponding bucket is empty or not, and if it is, we initialize it with the min and max values of num. Otherwise, we update the min and max values of the bucket with the minimum and maximum of num and the current min and max values, respectively.\\n\\n7. We initialize a variable max_gap to hold the maximum gap between adjacent buckets, and a variable prev_max to hold the maximum value in the previous bucket, initially set to min_val.\\n\\n8. We loop through each bucket in buckets, and if it is not empty, we update max_gap with the difference between its `min\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        \\n        # Check if the list is empty or contains only one element\\n        if len(nums) < 2:\\n            return 0\\n        \\n        # Get the minimum and maximum values in the list\\n        min_val = min(nums)\\n        max_val = max(nums)\\n        \\n        # Calculate the bucket size and number of buckets\\n        bucket_size = max(1, (max_val - min_val) // (len(nums) - 1))\\n        num_buckets = (max_val - min_val) // bucket_size + 1\\n        \\n        # Initialize the buckets\\n        buckets = [None] * num_buckets\\n        \\n        # Put each element in its corresponding bucket\\n        for num in nums:\\n            bucket_index = (num - min_val) // bucket_size\\n            if not buckets[bucket_index]:\\n                buckets[bucket_index] = {\\'min\\': num, \\'max\\': num}\\n            else:\\n                buckets[bucket_index][\\'min\\'] = min(buckets[bucket_index][\\'min\\'], num)\\n                buckets[bucket_index][\\'max\\'] = max(buckets[bucket_index][\\'max\\'], num)\\n        \\n        # Calculate the maximum gap between adjacent buckets\\n        max_gap = 0\\n        prev_max = min_val\\n        for bucket in buckets:\\n            if bucket:\\n                max_gap = max(max_gap, bucket[\\'min\\'] - prev_max)\\n                prev_max = bucket[\\'max\\']\\n        \\n        return max_gap\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        \\n        # Check if the list is empty or contains only one element\\n        if len(nums) < 2:\\n            return 0\\n        \\n        # Get the minimum and maximum values in the list\\n        min_val = min(nums)\\n        max_val = max(nums)\\n        \\n        # Calculate the bucket size and number of buckets\\n        bucket_size = max(1, (max_val - min_val) // (len(nums) - 1))\\n        num_buckets = (max_val - min_val) // bucket_size + 1\\n        \\n        # Initialize the buckets\\n        buckets = [None] * num_buckets\\n        \\n        # Put each element in its corresponding bucket\\n        for num in nums:\\n            bucket_index = (num - min_val) // bucket_size\\n            if not buckets[bucket_index]:\\n                buckets[bucket_index] = {\\'min\\': num, \\'max\\': num}\\n            else:\\n                buckets[bucket_index][\\'min\\'] = min(buckets[bucket_index][\\'min\\'], num)\\n                buckets[bucket_index][\\'max\\'] = max(buckets[bucket_index][\\'max\\'], num)\\n        \\n        # Calculate the maximum gap between adjacent buckets\\n        max_gap = 0\\n        prev_max = min_val\\n        for bucket in buckets:\\n            if bucket:\\n                max_gap = max(max_gap, bucket[\\'min\\'] - prev_max)\\n                prev_max = bucket[\\'max\\']\\n        \\n        return max_gap\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451782,
                "title": "c-bucketing-explanation-code",
                "content": "**Problem:** Sorting takes O(NlogN) but we have to solve it in O(N) time. Here we use the bucketing or bucket sort method.\\n\\n**Pigeonhole Principle:** If you have n pigeons and n-1 nests, atleast one hole will have two pigeons! Trivial but very useful. \\n\\n**Why bucketing:** Let\\'s combine bucketing with the Pigeohole Principle. Now if we sort the elements and divide them into n-1 buckets of constant size, we will have 2 elements in atleast 1 bucket (as per Pigeonhole). Additionally, if 1 bucket has >2 elements, then there is atleast 1 empty bucket, which would mean Maximum Gap>bucket size.\\n\\n**Case 1:** If there are more than 1 elements within buckets, to find \"maximum\" gap withing a bucket you have to take minimum of that bucket and maximum of that bucket and subtract them. \\n**Case 2:** We take max from previous bucket and min from current bucket and subtract these two.\\n\\n*Now, the case one becomes not necessary because if there is an empty bucket, the max gap will be anyways greater than bucket size and in case 1 since we are within the bucket max gap will always be less than bucket size!!.*\\n\\n**NOTE:** Look at it this way. We made \\'n-1\\' buckets and there are \\'n\\' elements. Now, if there is atleast 1 bucket with >2 elements we distribute n-3 elements in n-2 buckets, meaning atleast 1 bucket is empty. Now the maximum gap has to be greater than bucket size! Therefore we ignore case 1 here. (The remaining case we deal with is when exactly 1 bucket has 2 elements and the others have 1 element each.)\\n\\nI understand this is difficult to click, but now that you know this thing exists, the next application would become easier!!\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) \\n    {\\n        int n = nums.size(), mx=INT_MIN, mn=INT_MAX;\\n        if(n<2) return 0; //Given in question.\\n        if(n==2) return abs(nums[0]-nums[1]); //Optional, just reduces time.\\n        for(int i=0; i<n; i++)\\n        {\\n            mx = max(mx, nums[i]);\\n            mn = min(mn, nums[i]);\\n        }\\n        if(mx==mn) return 0; //This means all elements may be equal, hence answer is 0.\\n\\t\\t\\n\\t\\t//We make n-1 buckets, I made 2 different arrays, but you could use a vector of pairs\\n        vector<int> min_buck(n-1,INT_MAX); \\n        vector<int> max_buck(n-1, -1);\\n\\t\\t\\n\\t\\t\\n\\t\\t//Size of each bucket  = Range/No. of buckets  -> sz = (max - mn) / (n-1) \\n\\t\\t\\n        int sz = (int)ceil((mx - mn + 0.0)/(n-1)); \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==mn || nums[i]==mx) continue;  //This we will account for later\\n            int index = (nums[i]-mn)/sz;  //Finding which bucket number belongs to\\n            min_buck[index]=min(min_buck[index],nums[i]);  \\n            max_buck[index]=max(max_buck[index],nums[i]);\\n        }\\n        int prev = mn, ans = 0;  //Prev variable accounts for the minimum (mn) value\\n        for(int i=0; i<min_buck.size(); i++)\\n        {\\n            if(min_buck[i]==INT_MAX || max_buck[i]==-1) continue;\\n            ans = max(ans, min_buck[i]-prev);  //We only subtract prev from minimum of curr bucket\\n            prev = max_buck[i]; //Update prev\\n        }\\n        ans = max(ans, mx-prev); //Accounting for mx (maximum)\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) \\n    {\\n        int n = nums.size(), mx=INT_MIN, mn=INT_MAX;\\n        if(n<2) return 0; //Given in question.\\n        if(n==2) return abs(nums[0]-nums[1]); //Optional, just reduces time.\\n        for(int i=0; i<n; i++)\\n        {\\n            mx = max(mx, nums[i]);\\n            mn = min(mn, nums[i]);\\n        }\\n        if(mx==mn) return 0; //This means all elements may be equal, hence answer is 0.\\n\\t\\t\\n\\t\\t//We make n-1 buckets, I made 2 different arrays, but you could use a vector of pairs\\n        vector<int> min_buck(n-1,INT_MAX); \\n        vector<int> max_buck(n-1, -1);\\n\\t\\t\\n\\t\\t\\n\\t\\t//Size of each bucket  = Range/No. of buckets  -> sz = (max - mn) / (n-1) \\n\\t\\t\\n        int sz = (int)ceil((mx - mn + 0.0)/(n-1)); \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==mn || nums[i]==mx) continue;  //This we will account for later\\n            int index = (nums[i]-mn)/sz;  //Finding which bucket number belongs to\\n            min_buck[index]=min(min_buck[index],nums[i]);  \\n            max_buck[index]=max(max_buck[index],nums[i]);\\n        }\\n        int prev = mn, ans = 0;  //Prev variable accounts for the minimum (mn) value\\n        for(int i=0; i<min_buck.size(); i++)\\n        {\\n            if(min_buck[i]==INT_MAX || max_buck[i]==-1) continue;\\n            ans = max(ans, min_buck[i]-prev);  //We only subtract prev from minimum of curr bucket\\n            prev = max_buck[i]; //Update prev\\n        }\\n        ans = max(ans, mx-prev); //Accounting for mx (maximum)\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50663,
                "title": "very-simple-solution-accepted-as-best-in-c-well-explained",
                "content": "Actually I just want to use QuickSort and then search for the value which will actually takes quite good performance accepted with 8ms in C -> even size of the list is 2^32 the sorting time will be controlled in O(32n) -> O(nlogn); but of course we should try some other funny solutions also.\\n\\n- space cost O(1);\\n- time cost O(nlogn) using QuickSort;\\n\\n\\n----------\\n\\n    void sort(int* nums, int begin, int end)\\n    {\\n        int l=begin, r=end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                int t = nums[l];\\n                nums[l] = nums[r];\\n                nums[r] = t;\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n        sort(nums, begin, r);\\n        if(l < end)\\n        sort(nums, l, end);\\n    }\\n    \\n    //AC - 8ms;\\n    int maximumGap(int* nums, int size) \\n    {\\n        sort(nums, 0, size-1);\\n        int max = 0;\\n        for(int i = 1; i < size; i++)\\n            if(nums[i]-nums[i-1] > max)\\n                max = nums[i]-nums[i-1];\\n        return max;\\n    \\n    }\\n\\n----------\\n\\nSince we are required to solve it in linear time, we have to abandon our lovely QuickSort which really make the whole code quite clean and concise. Using BucketSort is the way or actually another way as other posts mentioned RadixSort which actually I think is just a derivative of BucketSort. Three steps to solve this problem linearly:\\n\\n- get the range of the number -> O(n) find the min and max of the numbers; then get the gap within a bucket by gap=(max-min)/(size-1)+1; the bucket will cover [min+k*gap, min+(k+1)*gap) while the left inclusive and the right exclusive; as a result the maximal numbers located in a single bucket will be (max-min)/(size-1) and so there must be a gap between two consecutive numbers are bigger than this average gap -> maximal gap and then located in two different buckets -> that's why we need bucket sorting; if you don't know why, please check  [Pigeonhole Principle](https://en.wikipedia.org/wiki/Pigeonhole_principle) first.\\n\\n- map the number into buckets; but we actually only need to store the minimal and maximal value of the bucket since the maximal gap will definitely bigger than the average gap;\\n- traverse the buckets to get the maximal gap.\\n\\nEnd of Story!\\n\\n- space cost O(n) using space to save time;\\n- time cost O(n) actually when the numbers are not that much, this solution can be slower compared with the previous one.\\n\\n----------\\n\\n    int maximumGap(int* nums, int size)\\n    {\\n        if(size < 2) return 0;\\n        int min=INT_MAX, max=0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(nums[i] < min) min = nums[i];\\n            if(nums[i] > max) max = nums[i];\\n        }\\n        if(min == max) return 0; //some corner cases;\\n        if(min+1 == max) return 1;\\n        if(size == 2) return max-min;\\n        int gap = (max-min)/(size-1)+1; //make later index searching process easier but actually there will be also (max-min)/(size-1) numbers in each bucket;\\n        int** buckets = (int**)malloc(sizeof(int*)*size); //only store the min and max in the bucket;\\n        for(int i = 0; i < size; i++)\\n        {\\n            buckets[i] = (int*)malloc(sizeof(int)*2);\\n            buckets[i][0] = -1;\\n            buckets[i][1] = 0;\\n        }\\n        for(int i = 0; i < size; i++) //[min+k*gap, min+(k+1)*gap);\\n        {\\n            int k = (nums[i]-min)/gap; //get the index of the bucket;\\n            if(nums[i] > buckets[k][1]) //the greatest in the bucket;\\n                buckets[k][1] = nums[i];\\n            if(buckets[k][0]==-1 || nums[i]<buckets[k][0]) //store the minimal in the kth gap;\\n                buckets[k][0] = nums[i];\\n        }\\n        int start = buckets[0][1];\\n        int end = buckets[0][0];\\n        int maxGap = 1;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(buckets[i][0] > end) //move to the next bucket that has numbers since we initialize bucket with -1 and 0;\\n            {\\n                end = buckets[i][0]; //the end of the gap;\\n                if(end-start > maxGap)\\n                    maxGap = end-start;\\n                start = buckets[i][1]; //move to the next start;\\n            }\\n        }\\n        return maxGap;\\n    }",
                "solutionTags": [],
                "code": "Actually I just want to use QuickSort and then search for the value which will actually takes quite good performance accepted with 8ms in C -> even size of the list is 2^32 the sorting time will be controlled in O(32n) -> O(nlogn); but of course we should try some other funny solutions also.\\n\\n- space cost O(1);\\n- time cost O(nlogn) using QuickSort;\\n\\n\\n----------\\n\\n    void sort(int* nums, int begin, int end)\\n    {\\n        int l=begin, r=end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                int t = nums[l];\\n                nums[l] = nums[r];\\n                nums[r] = t;\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n        sort(nums, begin, r);\\n        if(l < end)\\n        sort(nums, l, end);\\n    }\\n    \\n    //AC - 8ms;\\n    int maximumGap(int* nums, int size) \\n    {\\n        sort(nums, 0, size-1);\\n        int max = 0;\\n        for(int i = 1; i < size; i++)\\n            if(nums[i]-nums[i-1] > max)\\n                max = nums[i]-nums[i-1];\\n        return max;\\n    \\n    }\\n\\n----------\\n\\nSince we are required to solve it in linear time, we have to abandon our lovely QuickSort which really make the whole code quite clean and concise. Using BucketSort is the way or actually another way as other posts mentioned RadixSort which actually I think is just a derivative of BucketSort. Three steps to solve this problem linearly:\\n\\n- get the range of the number -> O(n) find the min and max of the numbers; then get the gap within a bucket by gap=(max-min)/(size-1)+1; the bucket will cover [min+k*gap, min+(k+1)*gap) while the left inclusive and the right exclusive; as a result the maximal numbers located in a single bucket will be (max-min)/(size-1) and so there must be a gap between two consecutive numbers are bigger than this average gap -> maximal gap and then located in two different buckets -> that's why we need bucket sorting; if you don't know why, please check  [Pigeonhole Principle](https://en.wikipedia.org/wiki/Pigeonhole_principle) first.\\n\\n- map the number into buckets; but we actually only need to store the minimal and maximal value of the bucket since the maximal gap will definitely bigger than the average gap;\\n- traverse the buckets to get the maximal gap.\\n\\nEnd of Story!\\n\\n- space cost O(n) using space to save time;\\n- time cost O(n) actually when the numbers are not that much, this solution can be slower compared with the previous one.\\n\\n----------\\n\\n    int maximumGap(int* nums, int size)\\n    {\\n        if(size < 2) return 0;\\n        int min=INT_MAX, max=0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(nums[i] < min) min = nums[i];\\n            if(nums[i] > max) max = nums[i];\\n        }\\n        if(min == max) return 0; //some corner cases;\\n        if(min+1 == max) return 1;\\n        if(size == 2) return max-min;\\n        int gap = (max-min)/(size-1)+1; //make later index searching process easier but actually there will be also (max-min)/(size-1) numbers in each bucket;\\n        int** buckets = (int**)malloc(sizeof(int*)*size); //only store the min and max in the bucket;\\n        for(int i = 0; i < size; i++)\\n        {\\n            buckets[i] = (int*)malloc(sizeof(int)*2);\\n            buckets[i][0] = -1;\\n            buckets[i][1] = 0;\\n        }\\n        for(int i = 0; i < size; i++) //[min+k*gap, min+(k+1)*gap);\\n        {\\n            int k = (nums[i]-min)/gap; //get the index of the bucket;\\n            if(nums[i] > buckets[k][1]) //the greatest in the bucket;\\n                buckets[k][1] = nums[i];\\n            if(buckets[k][0]==-1 || nums[i]<buckets[k][0]) //store the minimal in the kth gap;\\n                buckets[k][0] = nums[i];\\n        }\\n        int start = buckets[0][1];\\n        int end = buckets[0][0];\\n        int maxGap = 1;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(buckets[i][0] > end) //move to the next bucket that has numbers since we initialize bucket with -1 and 0;\\n            {\\n                end = buckets[i][0]; //the end of the gap;\\n                if(end-start > maxGap)\\n                    maxGap = end-start;\\n                start = buckets[i][1]; //move to the next start;\\n            }\\n        }\\n        return maxGap;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3433120,
                "title": "step-by-step-c-solution-using-buckets-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // if number of elements are 1 or 2 only\\n        if(n == 1)\\n            return 0;\\n        if(n == 2)\\n            return abs(nums[0]-nums[1]);\\n\\n        // storing maximum value and minimum value\\n        int maxEle = nums[0];\\n        int minEle = nums[0];\\n        for(int i=1; i<n; i++){\\n            maxEle = max(maxEle, nums[i]);\\n            minEle = min(minEle, nums[i]);\\n        }\\n\\n        // generating bucket size with formula\\n        int bucketSize = ceil(float(maxEle-minEle)/(n-1));\\n        // bucket size will be zero if all elements are same, then max gap is 0\\n        if(bucketSize == 0)\\n            return 0;\\n        \\n        int numOfBuckets = n;\\n\\n        //made vectors to store the max and min value of each bucket\\n        vector<int> maxOfBucket(numOfBuckets, INT_MIN);\\n        vector<int> minOfBucket(numOfBuckets, INT_MAX);\\n\\n        // checking in which bucket element will fall, updating the max and min value of bucket if possible\\n        for(int i=0; i<n; i++){\\n            int ele = nums[i];\\n            int whichBucket = ((ele - minEle)/bucketSize);\\n\\n            maxOfBucket[whichBucket] = max(maxOfBucket[whichBucket], ele); \\n            minOfBucket[whichBucket] = min(minOfBucket[whichBucket], ele);\\n        }\\n\\n        // finally answer will be atleast the bucketSize or greater\\n        int ans = bucketSize;\\n\\n        // stored previous max, to find the max gap with the curr buckets minimum\\n        int prevMax = maxOfBucket[0];\\n        for(int i=1; i<numOfBuckets; i++){\\n            //because there can be buckets in between with no elements\\n            if(minOfBucket[i] == INT_MAX)\\n                continue;\\n\\n            ans = max(ans, (minOfBucket[i]-prevMax));\\n            prevMax = maxOfBucket[i];\\n        }\\n\\n        // final answer, max gap\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // if number of elements are 1 or 2 only\\n        if(n == 1)\\n            return 0;\\n        if(n == 2)\\n            return abs(nums[0]-nums[1]);\\n\\n        // storing maximum value and minimum value\\n        int maxEle = nums[0];\\n        int minEle = nums[0];\\n        for(int i=1; i<n; i++){\\n            maxEle = max(maxEle, nums[i]);\\n            minEle = min(minEle, nums[i]);\\n        }\\n\\n        // generating bucket size with formula\\n        int bucketSize = ceil(float(maxEle-minEle)/(n-1));\\n        // bucket size will be zero if all elements are same, then max gap is 0\\n        if(bucketSize == 0)\\n            return 0;\\n        \\n        int numOfBuckets = n;\\n\\n        //made vectors to store the max and min value of each bucket\\n        vector<int> maxOfBucket(numOfBuckets, INT_MIN);\\n        vector<int> minOfBucket(numOfBuckets, INT_MAX);\\n\\n        // checking in which bucket element will fall, updating the max and min value of bucket if possible\\n        for(int i=0; i<n; i++){\\n            int ele = nums[i];\\n            int whichBucket = ((ele - minEle)/bucketSize);\\n\\n            maxOfBucket[whichBucket] = max(maxOfBucket[whichBucket], ele); \\n            minOfBucket[whichBucket] = min(minOfBucket[whichBucket], ele);\\n        }\\n\\n        // finally answer will be atleast the bucketSize or greater\\n        int ans = bucketSize;\\n\\n        // stored previous max, to find the max gap with the curr buckets minimum\\n        int prevMax = maxOfBucket[0];\\n        for(int i=1; i<numOfBuckets; i++){\\n            //because there can be buckets in between with no elements\\n            if(minOfBucket[i] == INT_MAX)\\n                continue;\\n\\n            ans = max(ans, (minOfBucket[i]-prevMax));\\n            prevMax = maxOfBucket[i];\\n        }\\n\\n        // final answer, max gap\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701945,
                "title": "c-100-faster-bucket-sort-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int min_ = INT_MAX , max_ = INT_MIN ;\\n        int l = nums.size() ;\\n        if ( l < 2 ) return 0 ;\\n        for ( int i = 0 ; i < nums.size() ; ++i) {\\n            min_ = min(min_ , nums[i]) ;\\n            max_ = max(max_ , nums[i]) ;\\n            \\n        }\\n        \\n        int gap = ceil((max_ - min_)/((l-1)*1.0)) ;\\n        vector<int> m(nums.size() , INT_MAX);\\n        vector<int> n(nums.size() , INT_MIN) ;\\n        \\n        for(int i = 0 ; i < l ; ++i) {\\n            if (nums[i] == min_ || nums[i] == max_ ) continue ;\\n            \\n            int ind = ( nums[i] - min_ ) / (gap);\\n            m[ind] = min(m[ind] , nums[i]) ;\\n            n[ind] = max(n[ind] , nums[i]) ;\\n            \\n            \\n            \\n            \\n        }\\n        int ans = 0 ;\\n        for(int i = 0 ; i< m.size() ; ++i) {\\n            if (m[i] == INT_MAX) continue ;\\n            ans = max(ans , m[i] - min_ ) ;\\n            min_ = n[i] ;\\n        }\\n        \\n        ans = max(ans , max_ - min_ ) ;\\n        return ans ;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int min_ = INT_MAX , max_ = INT_MIN ;\\n        int l = nums.size() ;\\n        if ( l < 2 ) return 0 ;\\n        for ( int i = 0 ; i < nums.size() ; ++i) {\\n            min_ = min(min_ , nums[i]) ;\\n            max_ = max(max_ , nums[i]) ;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240781,
                "title": "rust-o-n-base-10-radix-sort",
                "content": "Unlike comparison-based sorts, a radix sort achieves `O(n)` time complexity.\\nThis solution uses a base-10 radix sort starting from the least-significant digits of each element in `nums` _(similiar to a bucket sort)_:\\n\\n```rust\\nimpl Solution {\\n    pub fn maximum_gap(mut nums: Vec<i32>) -> i32 {\\n        Self::radix_sort_base10(&mut nums);\\n        nums.windows(2).map(|w| w[1] - w[0]).max().unwrap_or(0)\\n    }\\n\\n    fn radix_sort_base10(nums: &mut [i32]) {\\n        let mut buckets = vec![vec![]; 10];\\n        for i in 0..10 {\\n            nums.iter()\\n                .for_each(|&x| buckets[((x / 10_i32.pow(i)) % 10) as usize].push(x));\\n            buckets\\n                .iter()\\n                .flat_map(|b| b.iter())\\n                .zip(nums.iter_mut())\\n                .for_each(|(&x, y)| *y = x);\\n            buckets.iter_mut().for_each(|b| b.clear());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn maximum_gap(mut nums: Vec<i32>) -> i32 {\\n        Self::radix_sort_base10(&mut nums);\\n        nums.windows(2).map(|w| w[1] - w[0]).max().unwrap_or(0)\\n    }\\n\\n    fn radix_sort_base10(nums: &mut [i32]) {\\n        let mut buckets = vec![vec![]; 10];\\n        for i in 0..10 {\\n            nums.iter()\\n                .for_each(|&x| buckets[((x / 10_i32.pow(i)) % 10) as usize].push(x));\\n            buckets\\n                .iter()\\n                .flat_map(|b| b.iter())\\n                .zip(nums.iter_mut())\\n                .for_each(|(&x, y)| *y = x);\\n            buckets.iter_mut().for_each(|b| b.clear());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 50755,
                "title": "my-accepted-java-code-time-o-n-space-o-n",
                "content": "    public int maximumGap(int[] num) {\\n            int n;\\n            if(num == null || (n = num.length) < 2) {\\n                return 0;\\n            }\\n            int min = num[0];\\n            int max = num[0];\\n            for(int i : num) {\\n               if(i > max) {\\n                   max = i;\\n               } else if(i < min) {\\n                   min = i;\\n               }\\n            }\\n            double dist = (double)(max-min)/(double)(n-1);\\n            int[] mins = new int[n-1];\\n            int[] maxs = new int[n-1];\\n            Arrays.fill(mins, -1);\\n            Arrays.fill(maxs, -1);\\n            for(int i : num) {\\n                int idx = (i == max ? n-2 : (int) ((i-min)/dist));\\n                if(mins[idx] == -1 || i < mins[idx]) {\\n                    mins[idx] = i;\\n                }\\n                if(maxs[idx] == -1 || i > maxs[idx]) {\\n                    maxs[idx] = i;\\n                }\\n            }\\n            int prevMax = maxs[0];\\n            int maxGap = maxs[0]-mins[0];\\n            for(int i = 1; i < n-1; i++) {\\n                if(mins[i] == -1) {\\n                    continue;\\n                }\\n                int gap = mins[i] - prevMax;\\n                if(gap > maxGap) {\\n                    maxGap = gap;\\n                }\\n                prevMax = maxs[i];\\n            }\\n            return maxGap;\\n        }",
                "solutionTags": [],
                "code": "    public int maximumGap(int[] num) {\\n            int n;\\n            if(num == null || (n = num.length) < 2) {\\n                return 0;\\n            }\\n            int min = num[0];\\n            int max = num[0];\\n            for(int i : num) {\\n               if(i > max) {\\n                   max = i;\\n               } else if(i < min) {\\n                   min = i;\\n               }\\n            }\\n            double dist = (double)(max-min)/(double)(n-1);\\n            int[] mins = new int[n-1];\\n            int[] maxs = new int[n-1];\\n            Arrays.fill(mins, -1);\\n            Arrays.fill(maxs, -1);\\n            for(int i : num) {\\n                int idx = (i == max ? n-2 : (int) ((i-min)/dist));\\n                if(mins[idx] == -1 || i < mins[idx]) {\\n                    mins[idx] = i;\\n                }\\n                if(maxs[idx] == -1 || i > maxs[idx]) {\\n                    maxs[idx] = i;\\n                }\\n            }\\n            int prevMax = maxs[0];\\n            int maxGap = maxs[0]-mins[0];\\n            for(int i = 1; i < n-1; i++) {\\n                if(mins[i] == -1) {\\n                    continue;\\n                }\\n                int gap = mins[i] - prevMax;\\n                if(gap > maxGap) {\\n                    maxGap = gap;\\n                }\\n                prevMax = maxs[i];\\n            }\\n            return maxGap;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3910212,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++) {\\n            ans= Math.max((nums[i]-nums[i-1]),ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# PLZ UPVOTE THE SOLUTION IF YOU UNDERSTAND",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++) {\\n            ans= Math.max((nums[i]-nums[i-1]),ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696652,
                "title": "bucket-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return 0;\\n\\n        int minn = nums[0], maxx = nums[0];\\n        for (auto i: nums) {\\n            minn = min(minn, i);\\n            maxx = max(maxx, i);\\n        }\\n\\n        int gap = ceil((1.0*maxx - 1.0*minn)/(n-1));\\n        if (gap < 1) gap = 1;\\n\\n        vector<pair<int, int>> arr(n, {INT_MAX, INT_MIN});\\n        for (auto i: nums) {\\n            int pos = (i-minn)/gap;\\n            arr[pos].first = min(arr[pos].first, i);\\n            arr[pos].second = max(arr[pos].second, i);\\n        }\\n\\n        int prev = minn;\\n        int res = 0;\\n        for (auto i: arr) {\\n            if (i.first == INT_MAX) continue;\\n            res = max(res, i.first-prev);\\n            prev = i.second;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return 0;\\n\\n        int minn = nums[0], maxx = nums[0];\\n        for (auto i: nums) {\\n            minn = min(minn, i);\\n            maxx = max(maxx, i);\\n        }\\n\\n        int gap = ceil((1.0*maxx - 1.0*minn)/(n-1));\\n        if (gap < 1) gap = 1;\\n\\n        vector<pair<int, int>> arr(n, {INT_MAX, INT_MIN});\\n        for (auto i: nums) {\\n            int pos = (i-minn)/gap;\\n            arr[pos].first = min(arr[pos].first, i);\\n            arr[pos].second = max(arr[pos].second, i);\\n        }\\n\\n        int prev = minn;\\n        int res = 0;\\n        for (auto i: arr) {\\n            if (i.first == INT_MAX) continue;\\n            res = max(res, i.first-prev);\\n            prev = i.second;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911176,
                "title": "c-using-bucket-sort",
                "content": "**Please Upvote if you like the solution!**\\n\\n    class Solution {\\n    public:\\n    void maxGap(vector<int> &nums)\\n    {\\n        int mx=*max_element(nums.begin(),nums.end());//finding maximum element\\n        int mn=*min_element(nums.begin(),nums.end());//finding minimum element\\n        \\n        int n=nums.size();\\n        int range=(mx-mn)/n+1;//range or number of buckets \\n        \\n        vector<int> bucket[range];//creating a bucket array for storing different range values\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int bi=(range*nums[i])/mx;//finding index actually on which range current index value is coming\\n            bucket[bi].push_back(nums[i]);//insert curr arr val to the correct range in bucket\\n        }\\n        for(int i=0;i<range;i++)\\n        {\\n            sort(bucket[i].begin(),bucket[i].end());//sort all values in bucket\\n        }\\n        int index=0;\\n        for(int i=0;i<range;i++)//modifying original arr according to sorted order of buckets\\n        {\\n            for(int j=0;j<bucket[i].size();j++)\\n            {\\n                nums[index++]=bucket[i][j];\\n            }\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) \\n    {\\n        int res=0;\\n        maxGap(nums);\\n        \\n        for(int i=0;i<nums.size()-1;i++)//finding out maximum gap\\n        {\\n            res=max(res,abs(nums[i]-nums[i+1]));\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public:\\n    void maxGap(vector<int> &nums)\\n    {\\n        int mx=*max_element(nums.begin(),nums.end());//finding maximum element\\n        int mn=*min_element(nums.begin(),nums.end());//finding minimum element\\n        \\n        int n=nums.size();\\n        int range=(mx-mn)/n+1;//range or number of buckets \\n        \\n        vector<int> bucket[range];//creating a bucket array for storing different range values\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int bi=(range*nums[i])/mx;//finding index actually on which range current index value is coming\\n            bucket[bi].push_back(nums[i]);//insert curr arr val to the correct range in bucket\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1241861,
                "title": "c-bucket-sorting-to-invent-o-n-sorting-must-use-partial-sorting",
                "content": "Approach 1: bucket sorting[1][2]\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n < 2) return 0;\\n        int ans = 0;\\n        const auto& [minV, maxV] = minmax_element(nums.begin(), nums.end());\\n        const int range = *maxV - *minV;\\n        const int bucket_size = max(1, range/(n-1)); // minimum possible maximum gap, to prove it, refer to [1]\\n        const int bucket_num = range/bucket_size + 1; // minimum bucket number to hold ALL the array items \\n        vector<int> bucket_mins(bucket_num, INT_MAX);\\n        vector<int> bucket_maxs(bucket_num, INT_MIN);\\n        for(auto& num: nums){\\n            int bucket_idx = (num - *minV)/bucket_size;\\n            bucket_mins[bucket_idx] = min(bucket_mins[bucket_idx], num);\\n            bucket_maxs[bucket_idx] = max(bucket_maxs[bucket_idx], num);\\n        }\\n        \\n        int pre_maxV = bucket_maxs[0];        \\n        for(int i = 1; i < bucket_num; i++){\\n            if(bucket_mins[i]!=INT_MAX){ // ensure current bucket is non-empty\\n                ans = max(ans, bucket_mins[i] - pre_maxV);\\n                pre_maxV = bucket_maxs[i];\\n            }\\n        }\\n        return ans;                \\n    }\\n};\\n```\\n[1] https://leetcode.com/problems/maximum-gap/solution/\\n[2] https://zxi.mytechroad.com/blog/difficulty/hard/leetcode-164-maximum-gap/",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n < 2) return 0;\\n        int ans = 0;\\n        const auto& [minV, maxV] = minmax_element(nums.begin(), nums.end());\\n        const int range = *maxV - *minV;\\n        const int bucket_size = max(1, range/(n-1)); // minimum possible maximum gap, to prove it, refer to [1]\\n        const int bucket_num = range/bucket_size + 1; // minimum bucket number to hold ALL the array items \\n        vector<int> bucket_mins(bucket_num, INT_MAX);\\n        vector<int> bucket_maxs(bucket_num, INT_MIN);\\n        for(auto& num: nums){\\n            int bucket_idx = (num - *minV)/bucket_size;\\n            bucket_mins[bucket_idx] = min(bucket_mins[bucket_idx], num);\\n            bucket_maxs[bucket_idx] = max(bucket_maxs[bucket_idx], num);\\n        }\\n        \\n        int pre_maxV = bucket_maxs[0];        \\n        for(int i = 1; i < bucket_num; i++){\\n            if(bucket_mins[i]!=INT_MAX){ // ensure current bucket is non-empty\\n                ans = max(ans, bucket_mins[i] - pre_maxV);\\n                pre_maxV = bucket_maxs[i];\\n            }\\n        }\\n        return ans;                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113111,
                "title": "c-99-o-n-time-o-n-space-pigeonhole-principle",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        ll maxnum=*max_element(nums.begin(),nums.end());\\n        ll minnum=*min_element(nums.begin(),nums.end());\\n        int bsize=nums.size()-1;\\n        if(bsize==0 or minnum==maxnum)return 0;\\n        double width=(maxnum-minnum + 0.0)/bsize;\\n        int maxin[bsize];\\n        int minin[bsize];\\n        for(int i=0;i<bsize;i++)\\n        {\\n            maxin[i]=INT_MIN;\\n            minin[i]=INT_MAX;\\n        }\\n        for(int i=0;i<bsize+1;i++)\\n        {\\n            if(nums[i]==minnum or nums[i]==maxnum)\\n                continue;\\n            int bnum=(nums[i]-minnum+0.0)/width;\\n            maxin[bnum]=max(nums[i],maxin[bnum]);\\n            minin[bnum]=min(nums[i],minin[bnum]);\\n        }\\n        ll res=0;\\n        ll prev=minnum;\\n        for(int i=0;i<bsize;i++)\\n        {\\n            if(maxin[i]==INT_MIN)\\n                continue;\\n            res=max(res,minin[i]-prev);\\n            prev=maxin[i];\\n        }\\n        return max(res,maxnum-prev);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        ll maxnum=*max_element(nums.begin(),nums.end());\\n        ll minnum=*min_element(nums.begin(),nums.end());\\n        int bsize=nums.size()-1;\\n        if(bsize==0 or minnum==maxnum)return 0;\\n        double width=(maxnum-minnum + 0.0)/bsize;\\n        int maxin[bsize];\\n        int minin[bsize];\\n        for(int i=0;i<bsize;i++)\\n        {\\n            maxin[i]=INT_MIN;\\n            minin[i]=INT_MAX;\\n        }\\n        for(int i=0;i<bsize+1;i++)\\n        {\\n            if(nums[i]==minnum or nums[i]==maxnum)\\n                continue;\\n            int bnum=(nums[i]-minnum+0.0)/width;\\n            maxin[bnum]=max(nums[i],maxin[bnum]);\\n            minin[bnum]=min(nums[i],minin[bnum]);\\n        }\\n        ll res=0;\\n        ll prev=minnum;\\n        for(int i=0;i<bsize;i++)\\n        {\\n            if(maxin[i]==INT_MIN)\\n                continue;\\n            res=max(res,minin[i]-prev);\\n            prev=maxin[i];\\n        }\\n        return max(res,maxnum-prev);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824271,
                "title": "java-o-n-heavily-commented-solution",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        /* Idea : We will use Bucked sort to solve this question. \\n            \\n            We have to first define the intervals, We will use the min and max to find the total number of intervals needed.\\n            \\n            Now, we need the min and max value of each interval, so we  can compare it with the previous bucket.\\n            \\n            In the end we will traverse from the min to the max and then check the elements in each buckets.\\n            \\n            To assign a bucket to each element, we will use : nums[i] - min / no_of_intervals.\\n            \\n            no_of_intervals = Math.ceil((max-min)/ nums.length-1).\\n            \\n            And finally we will use the max element to check if  difference between the final element and the final bucket is the answer.\\n        */\\n        int ans =0;\\n        int size = nums.length;\\n        // Base Case :\\n        if(size < 2)\\n            return 0;\\n        \\n        int min = nums[0],max=nums[0];\\n        \\n        for(int i : nums){\\n            min = Math.min(min,i);\\n            max = Math.max(max,i);\\n        }\\n        \\n        int interval = (int)Math.ceil((max-min+0.0f)/(size-1));\\n        \\n        int[] minOfBucket = new int[size-1];\\n        int[] maxOfBucket = new int[size-1];\\n        \\n        Arrays.fill(minOfBucket, Integer.MAX_VALUE);\\n        Arrays.fill(maxOfBucket, -1);\\n        \\n        //Set the min and max of bucket.\\n        for(int i =0;i<size; i++){\\n            if(nums[i]== min || nums[i]==max)\\n                continue;\\n            \\n            int idx = (nums[i] - min)/interval;\\n            minOfBucket[idx] = Math.min(minOfBucket[idx], nums[i]);\\n            maxOfBucket[idx] = Math.max(maxOfBucket[idx], nums[i]);\\n        }\\n        \\n        \\n        // Now we will use min to see the maximum of previous bucket.\\n        for(int i =0;i<size-1;i++){\\n            if(maxOfBucket[i]==-1)\\n                continue;\\n            ans = Math.max(minOfBucket[i] - min, ans);\\n            min = maxOfBucket[i];\\n        }\\n        \\n        ans = Math.max(ans, max-min);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        /* Idea : We will use Bucked sort to solve this question. \\n            \\n            We have to first define the intervals, We will use the min and max to find the total number of intervals needed.\\n            \\n            Now, we need the min and max value of each interval, so we  can compare it with the previous bucket.\\n            \\n            In the end we will traverse from the min to the max and then check the elements in each buckets.\\n            \\n            To assign a bucket to each element, we will use : nums[i] - min / no_of_intervals.\\n            \\n            no_of_intervals = Math.ceil((max-min)/ nums.length-1).\\n            \\n            And finally we will use the max element to check if  difference between the final element and the final bucket is the answer.\\n        */\\n        int ans =0;\\n        int size = nums.length;\\n        // Base Case :\\n        if(size < 2)\\n            return 0;\\n        \\n        int min = nums[0],max=nums[0];\\n        \\n        for(int i : nums){\\n            min = Math.min(min,i);\\n            max = Math.max(max,i);\\n        }\\n        \\n        int interval = (int)Math.ceil((max-min+0.0f)/(size-1));\\n        \\n        int[] minOfBucket = new int[size-1];\\n        int[] maxOfBucket = new int[size-1];\\n        \\n        Arrays.fill(minOfBucket, Integer.MAX_VALUE);\\n        Arrays.fill(maxOfBucket, -1);\\n        \\n        //Set the min and max of bucket.\\n        for(int i =0;i<size; i++){\\n            if(nums[i]== min || nums[i]==max)\\n                continue;\\n            \\n            int idx = (nums[i] - min)/interval;\\n            minOfBucket[idx] = Math.min(minOfBucket[idx], nums[i]);\\n            maxOfBucket[idx] = Math.max(maxOfBucket[idx], nums[i]);\\n        }\\n        \\n        \\n        // Now we will use min to see the maximum of previous bucket.\\n        for(int i =0;i<size-1;i++){\\n            if(maxOfBucket[i]==-1)\\n                continue;\\n            ans = Math.max(minOfBucket[i] - min, ans);\\n            min = maxOfBucket[i];\\n        }\\n        \\n        ans = Math.max(ans, max-min);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622139,
                "title": "javascript-solution-using-pigeonhole-principle-and-bucket-size",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumGap = function(nums) {\\n    let max = Math.max(...nums);\\n    let min = Math.min(...nums);\\n    \\n    let bucketSize = Math.max(1, Math.floor((max - min)/ nums.length - 1));\\n    \\n    let buckets = {};\\n    \\n    for(let i=0;i<nums.length;i++) {\\n        let bucketId = Math.floor((nums[i] - min) / bucketSize);\\n        buckets[bucketId] = {\\n            min: Math.min(nums[i], buckets[bucketId] ? buckets[bucketId].min : Infinity),\\n            max: Math.max(nums[i], buckets[bucketId] ? buckets[bucketId].max : -Infinity)\\n        };\\n    }\\n\\n\\tlet prevBucketMax = min, maxGap = 0;\\n    Object.values(buckets).forEach((b) => {\\n\\t\\t\\tmaxGap = Math.max(maxGap, b.min - prevBucketMax);\\n            prevBucketMax = b.max;\\n    });\\n    \\n    return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumGap = function(nums) {\\n    let max = Math.max(...nums);\\n    let min = Math.min(...nums);\\n    \\n    let bucketSize = Math.max(1, Math.floor((max - min)/ nums.length - 1));\\n    \\n    let buckets = {};\\n    \\n    for(let i=0;i<nums.length;i++) {\\n        let bucketId = Math.floor((nums[i] - min) / bucketSize);\\n        buckets[bucketId] = {\\n            min: Math.min(nums[i], buckets[bucketId] ? buckets[bucketId].min : Infinity),\\n            max: Math.max(nums[i], buckets[bucketId] ? buckets[bucketId].max : -Infinity)\\n        };\\n    }\\n\\n\\tlet prevBucketMax = min, maxGap = 0;\\n    Object.values(buckets).forEach((b) => {\\n\\t\\t\\tmaxGap = Math.max(maxGap, b.min - prevBucketMax);\\n            prevBucketMax = b.max;\\n    });\\n    \\n    return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 554936,
                "title": "c-pigeonhole-principle-impl",
                "content": "```\\n    public class Solution\\n    {\\n        public int MaximumGap(int[] nums)\\n        {\\n            if (nums.Length < 2)\\n            {\\n                return 0;\\n            }\\n\\n            if (nums.Length == 2)\\n            {\\n                return Math.Abs(nums[0] - nums[1]);\\n            }\\n\\n            int min = nums.Min();\\n            int max = nums.Max();\\n\\n            int bucketSize = Math.Max(1, (max - min) / (nums.Length - 1));\\n            int bucketCount = (max - min) / bucketSize + 1;\\n\\n            (int? min, int? max)[] buckets = new (int? min, int? max)[bucketCount];\\n\\n            foreach (var num in nums)\\n            {\\n                var idx = (num - min) / bucketSize;\\n                var current = buckets[idx];\\n\\n                current.min = Math.Min(current.min.GetValueOrDefault(int.MaxValue), num);\\n                current.max = Math.Max(current.max.GetValueOrDefault(int.MinValue), num);\\n                buckets[idx] = current;\\n            }\\n\\n            int res = 0;\\n\\n            int prevGapIdx = -1;\\n            for (int i = 0; i < bucketCount; i++)\\n            {\\n                if (!buckets[i].min.HasValue)\\n                {\\n                    continue;\\n                }\\n\\n                var prev = prevGapIdx >= 0 ? buckets[prevGapIdx].max.Value : min;\\n                res = Math.Max(res, buckets[i].min.Value - prev);\\n                prevGapIdx = i;\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int MaximumGap(int[] nums)\\n        {\\n            if (nums.Length < 2)\\n            {\\n                return 0;\\n            }\\n\\n            if (nums.Length == 2)\\n            {\\n                return Math.Abs(nums[0] - nums[1]);\\n            }\\n\\n            int min = nums.Min();\\n            int max = nums.Max();\\n\\n            int bucketSize = Math.Max(1, (max - min) / (nums.Length - 1));\\n            int bucketCount = (max - min) / bucketSize + 1;\\n\\n            (int? min, int? max)[] buckets = new (int? min, int? max)[bucketCount];\\n\\n            foreach (var num in nums)\\n            {\\n                var idx = (num - min) / bucketSize;\\n                var current = buckets[idx];\\n\\n                current.min = Math.Min(current.min.GetValueOrDefault(int.MaxValue), num);\\n                current.max = Math.Max(current.max.GetValueOrDefault(int.MinValue), num);\\n                buckets[idx] = current;\\n            }\\n\\n            int res = 0;\\n\\n            int prevGapIdx = -1;\\n            for (int i = 0; i < bucketCount; i++)\\n            {\\n                if (!buckets[i].min.HasValue)\\n                {\\n                    continue;\\n                }\\n\\n                var prev = prevGapIdx >= 0 ? buckets[prevGapIdx].max.Value : min;\\n                res = Math.Max(res, buckets[i].min.Value - prev);\\n                prevGapIdx = i;\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346881,
                "title": "python-8-lines-radix-sort-with-comments-o-n",
                "content": "Code can be more concised, but will affect readability imo. \\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) <= 1: return 0\\n\\t\\t # Convert nums list to reversed bit array list\\n        nums = [bin(num)[2:][::-1] for num in nums]                                 \\n        \\n        for i in range(max(map(len, nums))):\\n            nums0 = [x for x in nums if i >= len(x) or x[i] == \\'0\\']\\n            nums1 = [x for x in nums if i < len(x) and x[i] == \\'1\\']\\n\\t\\t\\t# it will only have two buckets (0, 1) in radix sort.\\n            nums = nums0 + nums1                                                                     \\n            \\n\\t    # convert the number back to base 10 integer. \\n        nums = [int(num[::-1], 2) for num in nums]     \\n\\t\\t# 1 pass to get the largest gap\\n        return max(nums[i] - nums[i - 1] for i in range(1, len(nums)))    \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) <= 1: return 0\\n\\t\\t # Convert nums list to reversed bit array list\\n        nums = [bin(num)[2:][::-1] for num in nums]                                 \\n        \\n        for i in range(max(map(len, nums))):\\n            nums0 = [x for x in nums if i >= len(x) or x[i] == \\'0\\']\\n            nums1 = [x for x in nums if i < len(x) and x[i] == \\'1\\']\\n\\t\\t\\t# it will only have two buckets (0, 1) in radix sort.\\n            nums = nums0 + nums1                                                                     \\n            \\n\\t    # convert the number back to base 10 integer. \\n        nums = [int(num[::-1], 2) for num in nums]     \\n\\t\\t# 1 pass to get the largest gap\\n        return max(nums[i] - nums[i - 1] for i in range(1, len(nums)))    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 330028,
                "title": "explaining-the-bucket-method-in-layman-terms-python-code",
                "content": "Take length of nums = N\\n\\n- first of all we get max_num and min_num from the array, the maximum and minimum number from array\\n- Now not considering max_num and min_num, we have remaining N-2 numbers, we create N-1 buckets of equal size and we put numbers in them.\\n- **We are now sure that numbers falling inside the same bucket can have maximum gap of bucket_size-1**\\n\\n- **But we have created N-1 buckets for N-2 numbers, so there is at least 1 empty bucket, thus the maximum gap will come from numbers lying in the buckets to the left and right of the empty bucket**\\n- **since there is at least an empty bucket in between, so the maximum gap will be at least bucket_size**\\n- Kth bucket will have numbers lying in the range [min_num + k* bucket_size, min_num + (k+1)* bucket_size) where 0 <= k <= N-2 --> N-1 buckets\\n- we calculate bucket size = math.ceil( (max_num - min_num)/(N-1) )\\n- when we are given a number p, we can find in which bucket does it lie, which is (p-min_num)/bucket_size\\n- We store bucketMin and bucketMax, the minimum and maximum number present inside bucket, useful for calculating maxGap.\\n\\n**Take this Example, here N=8 so buckets = N-1 = 7:**\\n![image](https://assets.leetcode.com/users/gulshan98125/image_1562573422.png)\\n\\n\\n\\n**Python code:**\\n```\\nimport math\\nclass Solution(object):\\n    def maximumGap(self, nums):\\n        if not nums or len(nums)<2:\\n            return 0\\n        N = len(nums)\\n        min_num = float(\\'inf\\')\\n        max_num = -float(\\'inf\\')\\n        \\n        for p in nums:\\n            min_num = min(p,min_num)\\n            max_num = max(p,max_num)\\n        \\n        bucketMin = [float(\\'inf\\') for i in xrange(N-1)]\\n        bucketMax = [-float(\\'inf\\') for i in xrange(N-1)]\\n        \\n        #math.ceil so that it can accomodate all the between numbers\\n        bucket_size = int(math.ceil( (max_num-min_num)/float((N-1)) ))\\n        \\n        for p in nums:\\n            if p==min_num or p==max_num:\\n                continue\\n            index = (p-min_num)/bucket_size\\n            bucketMin[index] = min(p,bucketMin[index])\\n            bucketMax[index] = max(p,bucketMax[index])\\n        \\n        maxGap = -float(\\'inf\\')\\n        previous = min_num\\n        \\n        for bucket_num in xrange(N-1):\\n            #if empty bucket then skip\\n            if bucketMin[bucket_num]== float(\\'inf\\') or \\\\\\n            bucketMax[bucket_num]== -float(\\'inf\\'):\\n                continue\\n                \\n            maxGap = max(maxGap,bucketMin[bucket_num]-previous)\\n            previous = bucketMax[bucket_num]\\n        \\n        maxGap = max(maxGap, max_num - previous);\\n        return maxGap\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def maximumGap(self, nums):\\n        if not nums or len(nums)<2:\\n            return 0\\n        N = len(nums)\\n        min_num = float(\\'inf\\')\\n        max_num = -float(\\'inf\\')\\n        \\n        for p in nums:\\n            min_num = min(p,min_num)\\n            max_num = max(p,max_num)\\n        \\n        bucketMin = [float(\\'inf\\') for i in xrange(N-1)]\\n        bucketMax = [-float(\\'inf\\') for i in xrange(N-1)]\\n        \\n        #math.ceil so that it can accomodate all the between numbers\\n        bucket_size = int(math.ceil( (max_num-min_num)/float((N-1)) ))\\n        \\n        for p in nums:\\n            if p==min_num or p==max_num:\\n                continue\\n            index = (p-min_num)/bucket_size\\n            bucketMin[index] = min(p,bucketMin[index])\\n            bucketMax[index] = max(p,bucketMax[index])\\n        \\n        maxGap = -float(\\'inf\\')\\n        previous = min_num\\n        \\n        for bucket_num in xrange(N-1):\\n            #if empty bucket then skip\\n            if bucketMin[bucket_num]== float(\\'inf\\') or \\\\\\n            bucketMax[bucket_num]== -float(\\'inf\\'):\\n                continue\\n                \\n            maxGap = max(maxGap,bucketMin[bucket_num]-previous)\\n            previous = bucketMax[bucket_num]\\n        \\n        maxGap = max(maxGap, max_num - previous);\\n        return maxGap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408256,
                "title": "easy-way-to-solve-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust the brute force way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nSimply we create a **max variable** and intilize it with zero and **check the difference** of the elements and **update max if greater** than the earlier value stored in it.\\n\\n![image.png](https://assets.leetcode.com/users/images/1f3ad12b-6c3e-4f51-b127-a2c50cfacf57_1681293191.8231432.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(nlogn)-> **As we are using only one loop and sort inbuilt function.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)-> **No extra space created**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        //if size of the given array is less than 2 there is no use of finding difference\\n        if(nums.size()<2){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int max=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n                if(nums[i+1] -nums[i]>max){\\n                    max=nums[i+1] -nums[i];\\n                }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        //if size of the given array is less than 2 there is no use of finding difference\\n        if(nums.size()<2){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int max=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n                if(nums[i+1] -nums[i]>max){\\n                    max=nums[i+1] -nums[i];\\n                }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001449,
                "title": "short-clean-priorityqueue-java",
                "content": "```java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num: nums)    pq.add(num);\\n        int max_diff = 0;\\n        while(pq.size() > 1){\\n            max_diff = Math.max(max_diff, Math.abs(pq.poll()-pq.peek()));\\n        }\\n        return max_diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num: nums)    pq.add(num);\\n        int max_diff = 0;\\n        while(pq.size() > 1){\\n            max_diff = Math.max(max_diff, Math.abs(pq.poll()-pq.peek()));\\n        }\\n        return max_diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481421,
                "title": "real-o-n-solution-using-rounding",
                "content": "\\n\\t\\tclass Solution:\\n\\t\\tdef maximumGap(self, nums: List[int]) -> int:\\n\\t\\t\\tn=len(nums)\\n\\t\\t\\tif n==1:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tmin_val = min(nums)\\n\\t\\t\\tmax_val = max(nums)\\n\\n\\t\\t\\tif max_val==min_val:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tRange = max_val-min_val\\n\\n\\n\\t\\t\\twidth = Range/n\\n\\n\\t\\t\\tpartition = [ [] for _ in range( int(min_val/width),int(max_val/width)+1)]\\n\\n\\t\\t\\tshift = min_val/width\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\ttemp = num/width\\n\\t\\t\\t\\tpartition[int(temp-shift)].append(num)\\n\\n\\t\\t\\tj=0\\n\\t\\t\\tdif = 0\\n\\t\\t\\tfor i in range(1,len(partition)):\\n\\t\\t\\t\\tif partition[i]:\\n\\t\\t\\t\\t\\tdif = max(dif,min(partition[i])-max(partition[j]))\\n\\t\\t\\t\\t\\tj=i\\n\\n\\t\\t\\treturn dif\\n",
                "solutionTags": [],
                "code": "\\n\\t\\tclass Solution:\\n\\t\\tdef maximumGap(self, nums: List[int]) -> int:\\n\\t\\t\\tn=len(nums)\\n\\t\\t\\tif n==1:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tmin_val = min(nums)\\n\\t\\t\\tmax_val = max(nums)\\n\\n\\t\\t\\tif max_val==min_val:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tRange = max_val-min_val\\n\\n\\n\\t\\t\\twidth = Range/n\\n\\n\\t\\t\\tpartition = [ [] for _ in range( int(min_val/width),int(max_val/width)+1)]\\n\\n\\t\\t\\tshift = min_val/width\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\ttemp = num/width\\n\\t\\t\\t\\tpartition[int(temp-shift)].append(num)\\n\\n\\t\\t\\tj=0\\n\\t\\t\\tdif = 0\\n\\t\\t\\tfor i in range(1,len(partition)):\\n\\t\\t\\t\\tif partition[i]:\\n\\t\\t\\t\\t\\tdif = max(dif,min(partition[i])-max(partition[j]))\\n\\t\\t\\t\\t\\tj=i\\n\\n\\t\\t\\treturn dif\\n",
                "codeTag": "Java"
            },
            {
                "id": 1861119,
                "title": "c-conceptual-radixsort-based-algorithm-without-stl-linear-time-as-asked-in-question",
                "content": "Pls Upvote if you Like the solution\\nIf you don\\'t have idea of how radix sort works, [click here](https://www.javatpoint.com/radix-sort).\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        if(n==2){\\n            return abs(nums[0]-nums[1]);\\n        }\\n        int power=1;\\n        int maxDigits=log10(*max_element(nums.begin(),nums.end()))+1;\\n        bool check=true;\\n        while(maxDigits--){\\n            vector<int> temp(n);\\n            vector<int>count(10,0);\\n            for(int i=0;i<n;i++){\\n                int digit=(int)(nums[i]/power)%10;\\n                count[digit]++;\\n            }\\n            for(int i=1;i<10;i++)\\n                count[i]+=count[i-1];\\n            for(int i=n-1;i>=0;i--){\\n                int digit=(int)(nums[i]/power)%10;\\n                temp[--count[digit]]=nums[i];\\n            }\\n            nums=temp;\\n            power*=10;\\n            \\n        }\\n        int ans=abs(nums[0]-nums[1]);\\n        for(int i:nums){\\n            cout<<i<<\" \";\\n        }\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,abs(nums[i]-nums[i-1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        if(n==2){\\n            return abs(nums[0]-nums[1]);\\n        }\\n        int power=1;\\n        int maxDigits=log10(*max_element(nums.begin(),nums.end()))+1;\\n        bool check=true;\\n        while(maxDigits--){\\n            vector<int> temp(n);\\n            vector<int>count(10,0);\\n            for(int i=0;i<n;i++){\\n                int digit=(int)(nums[i]/power)%10;\\n                count[digit]++;\\n            }\\n            for(int i=1;i<10;i++)\\n                count[i]+=count[i-1];\\n            for(int i=n-1;i>=0;i--){\\n                int digit=(int)(nums[i]/power)%10;\\n                temp[--count[digit]]=nums[i];\\n            }\\n            nums=temp;\\n            power*=10;\\n            \\n        }\\n        int ans=abs(nums[0]-nums[1]);\\n        for(int i:nums){\\n            cout<<i<<\" \";\\n        }\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,abs(nums[i]-nums[i-1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1330979,
                "title": "radix-sort-o-31-n-time-o-1-space-solution",
                "content": "```\\nvoid radix( vector<int>&A , int st , int en , int p )\\n{\\n    if( p < 0 )return ;\\n    if( st >= en )return ;\\n    int l = st ;\\n    int h = en ;\\n    while( l <= h )\\n    {\\n        if( A[l]&(1<<p) )\\n            swap( A[l] , A[h--] );\\n        else\\n            l++;\\n    }\\n    radix( A , st , l-1 , p-1 );\\n    radix( A , l , en , p-1 );\\n}\\n\\nclass Solution {\\npublic:\\nint maximumGap(vector<int>& A ) {\\n    int N = A.size();\\n    radix( A , 0 , N-1 , 31 );\\n    int mx = 0 ; \\n    for( int i = 0 ; i < N-1 ; i++ )\\n        mx = max( mx , A[i+1] - A[i] );\\n    return mx ;\\n  }\\n};\\n\\n// time complexity - O(32*N) \\n// space complexity - O(1) \\n```",
                "solutionTags": [],
                "code": "```\\nvoid radix( vector<int>&A , int st , int en , int p )\\n{\\n    if( p < 0 )return ;\\n    if( st >= en )return ;\\n    int l = st ;\\n    int h = en ;\\n    while( l <= h )\\n    {\\n        if( A[l]&(1<<p) )\\n            swap( A[l] , A[h--] );\\n        else\\n            l++;\\n    }\\n    radix( A , st , l-1 , p-1 );\\n    radix( A , l , en , p-1 );\\n}\\n\\nclass Solution {\\npublic:\\nint maximumGap(vector<int>& A ) {\\n    int N = A.size();\\n    radix( A , 0 , N-1 , 31 );\\n    int mx = 0 ; \\n    for( int i = 0 ; i < N-1 ; i++ )\\n        mx = max( mx , A[i+1] - A[i] );\\n    return mx ;\\n  }\\n};\\n\\n// time complexity - O(32*N) \\n// space complexity - O(1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316807,
                "title": "simplest-c-solution-using-bucket-sort-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int maxe=*max_element(nums.begin(),nums.end());\\n        int mine=*min_element(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        \\n        int range=(maxe-mine)/n +1;\\n        vector<vector<int>> bucket(n+1);\\n        if(range==0)\\n            return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int index=(nums[i]-mine)/range;\\n            bucket[index].push_back(nums[i]);\\n        }\\n        int prev=mine;\\n        int ans=INT_MIN;\\n        for(auto b:bucket)\\n        {\\n            sort(b.begin(),b.end());\\n            for(int i:b)\\n            {\\n                ans=max(ans,i-prev);\\n                prev=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int maxe=*max_element(nums.begin(),nums.end());\\n        int mine=*min_element(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        \\n        int range=(maxe-mine)/n +1;\\n        vector<vector<int>> bucket(n+1);\\n        if(range==0)\\n            return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int index=(nums[i]-mine)/range;\\n            bucket[index].push_back(nums[i]);\\n        }\\n        int prev=mine;\\n        int ans=INT_MIN;\\n        for(auto b:bucket)\\n        {\\n            sort(b.begin(),b.end());\\n            for(int i:b)\\n            {\\n                ans=max(ans,i-prev);\\n                prev=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241833,
                "title": "approach-using-radix-sort-easy-understandable-code-o-10-n-log10-maxe",
                "content": "Please give a upvote if you like this solutions. Comment if you didn\\'t get it.\\n```\\nclass Solution {\\n    \\n    void radixSort(vector<int> &nums, int value, int N) {\\n        \\n        int countDigit[10] = {0};\\n        \\n        for(int i = 0; i < N; i++) {\\n            int element = nums[i]/value;\\n            countDigit[element%10] += 1;\\n        }\\n        \\n        for(int i = 1; i < 10; i++) {\\n            countDigit[i] += countDigit[i - 1];\\n        }\\n        \\n        int sorteByPlace[N];\\n        \\n        int ans[N];\\n        \\n        for(int i = N - 1; i >= 0; i--) {\\n            \\n            int element = nums[i]/value;\\n\\t        int correctIndex = countDigit[element % 10] - 1;            \\n            sorteByPlace[correctIndex] = nums[i];\\t        \\n\\t        countDigit[element % 10] -= 1;\\n\\t    }\\n        \\n        for(int i = 0; i < N; i++) {\\n            nums[i] = sorteByPlace[i];\\n        }\\n    }\\n    \\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        if(N < 2) return 0;\\n        \\n        int maxElement = *max_element(nums.begin(), nums.end());\\n        int value = 1;\\n\\t\\t\\n\\t\\t// Iterate till each digit from one\\'s place to the\\n\\t\\t// ten\\'s to the hundred\\'s  and so on\\n        while(value <= maxElement) {\\n            radixSort(nums, value, N);\\n            value *= 10;\\n        }\\n        \\n        int maxDifference = -1;\\n        for(int i = 0; i < N - 1; i++) {\\n            maxDifference = max(maxDifference, nums[i + 1] - nums[i]);\\n        }\\n        \\n        return maxDifference;\\n        \\n    }\\n};\\n```\\nTime Complexity: O((10 + N)\\\\*log10(maxE))\\nAuxiliary Space: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void radixSort(vector<int> &nums, int value, int N) {\\n        \\n        int countDigit[10] = {0};\\n        \\n        for(int i = 0; i < N; i++) {\\n            int element = nums[i]/value;\\n            countDigit[element%10] += 1;\\n        }\\n        \\n        for(int i = 1; i < 10; i++) {\\n            countDigit[i] += countDigit[i - 1];\\n        }\\n        \\n        int sorteByPlace[N];\\n        \\n        int ans[N];\\n        \\n        for(int i = N - 1; i >= 0; i--) {\\n            \\n            int element = nums[i]/value;\\n\\t        int correctIndex = countDigit[element % 10] - 1;            \\n            sorteByPlace[correctIndex] = nums[i];\\t        \\n\\t        countDigit[element % 10] -= 1;\\n\\t    }\\n        \\n        for(int i = 0; i < N; i++) {\\n            nums[i] = sorteByPlace[i];\\n        }\\n    }\\n    \\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        if(N < 2) return 0;\\n        \\n        int maxElement = *max_element(nums.begin(), nums.end());\\n        int value = 1;\\n\\t\\t\\n\\t\\t// Iterate till each digit from one\\'s place to the\\n\\t\\t// ten\\'s to the hundred\\'s  and so on\\n        while(value <= maxElement) {\\n            radixSort(nums, value, N);\\n            value *= 10;\\n        }\\n        \\n        int maxDifference = -1;\\n        for(int i = 0; i < N - 1; i++) {\\n            maxDifference = max(maxDifference, nums[i + 1] - nums[i]);\\n        }\\n        \\n        return maxDifference;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296892,
                "title": "java-radix-sort-solution-with-explanation",
                "content": "```\\npublic int maximumGap(int[] nums) {\\n    int max = 0; // the number of sort passes depends on the base of max element\\n    for(int i = 0; i < nums.length; i++)\\n        max = Math.max(nums[i], max);\\n\\n    int divisor = 1;\\n    int temp[][] = new int[10][nums.length]; // save the elements in ten buckets\\n    int count[] = new int[10]; // count the size of each bucket\\n    \\n    while( divisor <= max ) { // sort the array\\n        for(int i = 0; i < nums.length; i++) { // put elements into corresponding bucket\\n            int index = (nums[i] / divisor) % 10;\\n            temp[index][count[index]] = nums[i];\\n            count[index]++;\\n        }\\n\\n        int current = 0;\\n        for(int i = 0; i < 10; i++) { // update nums after each turn\\n            for(int j = 0; j < count[i]; j++) {\\n                nums[current++] = temp[i][j];\\n            }\\n            count[i] = 0;\\n        }\\n\\n        divisor *= 10;\\n    }\\n\\n    int result = 0;\\n    for(int i = 1; i < nums.length; i++)\\n        result = Math.max(nums[i] - nums[i - 1], result);\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumGap(int[] nums) {\\n    int max = 0; // the number of sort passes depends on the base of max element\\n    for(int i = 0; i < nums.length; i++)\\n        max = Math.max(nums[i], max);\\n\\n    int divisor = 1;\\n    int temp[][] = new int[10][nums.length]; // save the elements in ten buckets\\n    int count[] = new int[10]; // count the size of each bucket\\n    \\n    while( divisor <= max ) { // sort the array\\n        for(int i = 0; i < nums.length; i++) { // put elements into corresponding bucket\\n            int index = (nums[i] / divisor) % 10;\\n            temp[index][count[index]] = nums[i];\\n            count[index]++;\\n        }\\n\\n        int current = 0;\\n        for(int i = 0; i < 10; i++) { // update nums after each turn\\n            for(int j = 0; j < count[i]; j++) {\\n                nums[current++] = temp[i][j];\\n            }\\n            count[i] = 0;\\n        }\\n\\n        divisor *= 10;\\n    }\\n\\n    int result = 0;\\n    for(int i = 1; i < nums.length; i++)\\n        result = Math.max(nums[i] - nums[i - 1], result);\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 50680,
                "title": "java-radix-sort",
                "content": "Because the question has tell us that every number has 32 bits. This can remind us to use radix sort whose run time and extra space are both linear.\\n~~~\\npublic class Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums == null || nums.length == 0 || nums.length == 1) {\\n            return 0;\\n        }\\n        int res = 0;\\n        radixsort(nums);\\n        for(int i = 1 ; i < nums.length ; i++) {\\n            res = Math.max(res , nums[i] - nums[i-1]);\\n        }\\n        return res;\\n    }\\n    \\n    protected void radixsort(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for(int i = 0 ; i < 32 ; i++) {\\n            int[] c = new int[2];\\n            for(int num : nums) {\\n                int digit = num >> i;\\n                if((digit & 1) == 0) c[0]++;\\n                else c[1]++;\\n            }\\n            c[1] = c[0] + c[1];\\n            for(int j = nums.length-1 ; j >= 0 ; j--) {\\n                int digit = (nums[j] >> i) & 1;\\n                temp[c[digit]-1] = nums[j];\\n                c[digit]--;\\n            }\\n            for(int j = 0 ; j < nums.length ; j++) {\\n                nums[j] = temp[j];\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums == null || nums.length == 0 || nums.length == 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 50684,
                "title": "c-12ms-bucket-sort",
                "content": "    class Solution {\\n    public:\\n        //bucket sort\\n        int maximumGap(vector<int>& nums) {\\n            int len = nums.size();\\n            if(len < 2){\\n                return 0;\\n            }\\n            int minValue = INT_MAX;\\n            int maxValue = INT_MIN;\\n            for(int i : nums){\\n                minValue = min(minValue, i);\\n                maxValue = max(maxValue, i);\\n            }\\n            int gap = ceil(double((maxValue - minValue))/ (len - 1));\\n            vector<int> minGaps(len - 1, INT_MAX);// the minmum value of each bucket\\n            vector<int> maxGaps(len - 1, INT_MIN);\\n            for(int i : nums){ // fill in the bucket\\n                if(i == minValue || i == maxValue){\\n                    continue;\\n                }\\n                int gapidx = (i - minValue) / gap;\\n                minGaps[gapidx] = min(minGaps[gapidx], i);\\n                maxGaps[gapidx] = max(maxGaps[gapidx], i);\\n            }\\n            int pre = minValue;\\n            int ans = INT_MIN;\\n            for(int i = 0; i < len - 1; ++i){\\n                if(minGaps[i] == INT_MAX && maxGaps[i] == INT_MIN){\\n                    continue;\\n                }\\n                ans = max(ans, minGaps[i] - pre);\\n                pre = maxGaps[i];\\n            }\\n            ans = max(ans, maxValue - pre);\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        //bucket sort\\n        int maximumGap(vector<int>& nums) {\\n            int len = nums.size();\\n            if(len < 2){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50699,
                "title": "clean-c-implementation-based-on-radix-sort",
                "content": " Please refer to  \\n[https://leetcode.com/discuss/80529/recommend-beginners-implementation-detailed-explaination][1]\\n\\nfor implementation details and explainations.\\n\\n      class Solution {\\n        public:\\n            /* radix-based-sorting-implementation */\\n            int maximumGap(vector<int>& nums){\\n                radixSort(nums);\\n            \\tint result = 0;\\n            \\tfor (int i = 1; i < nums.size(); i++){\\n            \\t\\tresult = max(result, nums[i] - nums[i - 1]);\\n            \\t}\\n            \\treturn result;\\n            }\\n            \\n            void countingSort(vector<int>& X, int exp, int base){\\n            \\tint len = X.size();\\n            \\tint start = INT_MAX, end = INT_MIN;\\n            \\tfor (int i = 0; i < len; i++){\\n            \\t\\tstart = min(start, (X[i] / exp)%base);\\n            \\t\\tend = max(end, (X[i] / exp) % base);\\n            \\t}\\n            \\tint range = end - start + 1;\\n            \\tvector<int> count(range, 0);\\n            \\tvector<int> result(len, 0);\\n            \\tfor (int i = 0; i < len; i++){\\n            \\t\\tcount[(X[i] / exp) % base -start]++;\\n            \\t}\\n            \\tfor (int i = 1; i < range; i++){\\n            \\t\\tcount[i] = count[i - 1] + count[i];\\n            \\t}\\n            \\t//back-ward traverse is stable sorting\\n            \\tfor (int i = len - 1; i >= 0; i--){\\n            \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n            \\t\\tresult[count[(X[i] / exp) % base -start] - 1] = X[i];\\n            \\t\\tcount[(X[i] / exp) % base - start]--;\\n            \\t}\\n            \\tfor (int i = 0; i < len; i++){\\n            \\t\\tX[i] = result[i];\\n            \\t}\\n            }\\n        \\n            void radixSort(vector<int> &X){\\n            \\tint len = X.size();\\n            \\tint max_val = INT_MIN;\\n            \\tint base = 10;\\n            \\tfor (int i = 0; i < len; i++) max_val = max(X[i], max_val);\\n            \\tfor (int exp = 1; max_val / exp>0; exp *= base){\\n            \\t\\tcountingSort(X, exp, base);\\n            \\t}\\n            }\\n        };\\n\\n  [1]: https://leetcode.com/discuss/80529/recommend-beginners-implementation-detailed-explaination",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            /* radix-based-sorting-implementation */\\n            int maximumGap(vector<int>& nums){\\n                radixSort(nums);\\n            \\tint result = 0;\\n            \\tfor (int i = 1; i < nums.size(); i++){\\n            \\t\\tresult = max(result, nums[i] - nums[i - 1]);\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 50709,
                "title": "radix-sort-in-python",
                "content": "    \\n    class Solution(object):\\n    \"\"\"\\n    Radix sort, you can see the explanation follow the links.\\n    https://www.cs.usfca.edu/~galles/visualization/RadixSort.html\\n    \"\"\"\\n    def maximumGap(self, nums):\\n        if not nums:\\n            return 0\\n\\n        max_num = max(nums)\\n        bucket = [[] for i in range(10)]\\n        exp = 1\\n        while max_num / exp > 0:\\n            for num in nums:\\n                bucket[(num/exp) % 10].append(num)\\n            nums = []\\n            for each in bucket:\\n                nums.extend(each)\\n            bucket = [[] for i in range(10)]\\n            exp *= 10\\n\\n        max_gap = 0\\n        for i in range(1, len(nums)):\\n            max_gap = max(max_gap, nums[i]-nums[i-1])\\n        return max_gap",
                "solutionTags": [
                    "Python"
                ],
                "code": "    \\n    class Solution(object):\\n    \"\"\"\\n    Radix sort, you can see the explanation follow the links.\\n    https://www.cs.usfca.edu/~galles/visualization/RadixSort.html\\n    \"\"\"\\n    def maximumGap(self, nums):\\n        if not nums:\\n            return 0\\n\\n        max_num = max(nums)\\n        bucket = [[] for i in range(10)]\\n        exp = 1\\n        while max_num / exp > 0:\\n            for num in nums:\\n                bucket[(num/exp) % 10].append(num)\\n            nums = []\\n            for each in bucket:\\n                nums.extend(each)\\n            bucket = [[] for i in range(10)]\\n            exp *= 10\\n\\n        max_gap = 0\\n        for i in range(1, len(nums)):\\n            max_gap = max(max_gap, nums[i]-nums[i-1])\\n        return max_gap",
                "codeTag": "Java"
            },
            {
                "id": 50735,
                "title": "concise-ac-java-standard-buckets",
                "content": "   I believe it's the simplest approach to distributed also min/max. It simplifies also last loop. Regards.\\n\\n    public class Solution {\\n      private class Pair {\\n        int min, max;\\n        public Pair(int min, int max) {\\n            this.min = min; this.max = max;\\n        }\\n      }\\n      public int maximumGap(int[] num) {\\n        if (num == null || num.length < 2) {\\n            return 0;\\n        }\\n        int min=num[0], max=num[0], N=num.length;\\n        for (int n: num) {\\n            min = Math.min(min, n);\\n            max = Math.max(max, n);\\n        }\\n        if (max == min) return 0;\\n        int dist=(((max-min)-1)/(N-1))+1;\\n        Pair[] buckets = new Pair[N];\\n        for(int n: num) {\\n            int bucket = (n-min)/dist;\\n            Pair p = buckets[bucket];\\n            if (p == null) {\\n                buckets[bucket] = new Pair(n, n);\\n            } else {\\n                p.min = Math.min(p.min, n);\\n                p.max = Math.max(p.max, n);\\n            }\\n        }\\n        max = dist;\\n        int prevBucketMax=buckets[0].max;\\n        for (int i=1; i<buckets.length; i++) {\\n            if (buckets[i] == null) continue;\\n            max = Math.max(max, buckets[i].min-prevBucketMax);\\n            prevBucketMax = buckets[i].max;\\n        }\\n        return max;\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      private class Pair {\\n        int min, max;\\n        public Pair(int min, int max) {\\n            this.min = min; this.max = max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3867555,
                "title": "using-radix-sort-c-in-linear-time-and-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2){\\n            return 0;\\n        }\\n        int ans=0;\\n        int n=nums.size();\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]);\\n        }\\n        string num=to_string(maxi);\\n        int len=num.size();\\n        long int a=10;\\n        long int b=1;\\n        vector<int>count(10,0);\\n        vector<int>dup(n);\\n        for(int i=0;i<len;i++){\\n            for(auto j:nums){   \\n                int val=((j%a)/b);\\n                count[val]++;\\n            }\\n            for(int j=1;j<10;j++){\\n                count[j]+=count[j-1];\\n            }\\n            for(int k=n-1;k>=0;k--){\\n                int j=nums[k];\\n                int val=((j%a)/b);\\n                count[val]--;\\n                int ind=count[val];\\n                dup[ind]=j;\\n            }\\n            for(int j=0;j<n;j++){\\n                nums[j]=dup[j];\\n            }\\n            for(int j=0;j<10;j++){\\n                count[j]=0;\\n            }\\n            a*=10;\\n            b*=10;\\n        }\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2){\\n            return 0;\\n        }\\n        int ans=0;\\n        int n=nums.size();\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]);\\n        }\\n        string num=to_string(maxi);\\n        int len=num.size();\\n        long int a=10;\\n        long int b=1;\\n        vector<int>count(10,0);\\n        vector<int>dup(n);\\n        for(int i=0;i<len;i++){\\n            for(auto j:nums){   \\n                int val=((j%a)/b);\\n                count[val]++;\\n            }\\n            for(int j=1;j<10;j++){\\n                count[j]+=count[j-1];\\n            }\\n            for(int k=n-1;k>=0;k--){\\n                int j=nums[k];\\n                int val=((j%a)/b);\\n                count[val]--;\\n                int ind=count[val];\\n                dup[ind]=j;\\n            }\\n            for(int j=0;j<n;j++){\\n                nums[j]=dup[j];\\n            }\\n            for(int j=0;j<10;j++){\\n                count[j]=0;\\n            }\\n            a*=10;\\n            b*=10;\\n        }\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841213,
                "title": "python-easy-solution-100-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs descripted is problem if array have 1 element then return 0\\nNext will sort the arrey and get the diffrence of each element and compare the value of max variable to this.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        mx = 0\\n        if len(nums)<2:\\n            return 0\\n        else:\\n            nums.sort()\\n            for i in range(len(nums)-1):\\n                mx = max(mx, (nums[i+1])-nums[i])\\n            return mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        mx = 0\\n        if len(nums)<2:\\n            return 0\\n        else:\\n            nums.sort()\\n            for i in range(len(nums)-1):\\n                mx = max(mx, (nums[i+1])-nums[i])\\n            return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838809,
                "title": "simple-kotlin-solution",
                "content": "# Code\\n```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun maximumGap(nums: IntArray) =\\n        nums.takeIf { it.size > 1 }?.sorted()?.run {\\n            List(size - 1) { abs(get(it) - get(it + 1)) }.max()\\n        } ?: 0\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun maximumGap(nums: IntArray) =\\n        nums.takeIf { it.size > 1 }?.sorted()?.run {\\n            List(size - 1) { abs(get(it) - get(it + 1)) }.max()\\n        } ?: 0\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673520,
                "title": "without-solution-life-is-nothing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)<2:\\n            return 0\\n        ls = sorted(nums)\\n        a = []\\n        for i in range(1,len(ls)):\\n            a.append(ls[i]-ls[i-1])\\n        return max(a)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)<2:\\n            return 0\\n        ls = sorted(nums)\\n        a = []\\n        for i in range(1,len(ls)):\\n            a.append(ls[i]-ls[i-1])\\n        return max(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615306,
                "title": "easy-c-solution-t-c-o-nlogn-and-s-c-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        int ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size()-1;i++){\\n            int maxi = 0;\\n            maxi = nums[i+1]-nums[i];\\n\\n            if(maxi>ans){\\n                ans = maxi;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        int ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size()-1;i++){\\n            int maxi = 0;\\n            maxi = nums[i+1]-nums[i];\\n\\n            if(maxi>ans){\\n                ans = maxi;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588866,
                "title": "maximum-gap-in-an-unsorted-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach is based on the concept of the **Pigeonhole Principle**. By dividing the range of values into buckets and tracking the maximum and minimum values within each bucket, we can find the maximum gap between elements. The maximum gap will always be equal to or greater than the bucket size because if it\\'s smaller, then at least one bucket will be empty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the maximum and minimum elements in the array.\\n2. Calculate the bucket size using the formula **ceil((maxele - minele) / (n - 1))**, where **\\'maxele\\'** is the maximum element and **\\'minele\\'** is the minimum element.\\n3. If the bucket size is zero, it means all elements are the same, so return 0 as the maximum gap.\\n4. Create two arrays, **\\'maxofb\\'** and **\\'minofb\\'**, of size **\\'n\\'** to store the maximum and minimum values of each bucket.\\n5. Iterate through the array and determine the bucket index for each element using the formula **\\'(arr[i] - minele) / bucketsz\\'**.\\n6. Update the **\\'maxofb[whichb]\\'** and **\\'minofb[whichb]\\'** values by comparing them with the current element.\\n7. Initialize ans as the bucket size and pre as the maximum value in the first non-empty bucket **\\'(maxofb[0])\\'**.\\n8. Iterate through the buckets starting from the second bucket.\\n   * If **\\' minofb[i]\\'** is **\\'INT_MAX\\'**, it means the current bucket is empty, so skip it.\\n   * Update ans by comparing it with the difference between **\\'minofb[i]\\'** and **\\'pre\\'**.\\n   * Update pre with the maximum value in the current bucket **\\'(maxofb[i])\\'**.\\n9. Return **\\'ans\\'** as the maximum gap.\\n\\n# Time Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Finding the maximum and minimum values in the array requires a linear scan, taking $$O(n)$$ time.\\n- Building the buckets and tracking the maximum and minimum values within each bucket also requires iterating through the array, resulting in $$O(n)$$ time complexity.\\n- Overall, the time complexity is $$O(n)$$.\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is$$O(n)$$ because we need to store the maximum and minimum values for each bucket in separate arrays, **\\'maxofb\\'** and **\\'minofb\\'**, each of size **\\'n\\'**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        if(n == 1)\\n        {\\n            return 0;\\n        }        \\n        if(n == 2)\\n        {\\n            return abs(arr[0] - arr[1]);\\n        }\\n\\n        int maxele = arr[0];\\n        int minele = arr[0];\\n\\n        // Find the maximum and minimum elements in the array\\n        for(auto i:arr)\\n        {\\n            maxele = max(maxele,i);\\n            minele = min(minele,i);\\n        }\\n\\n        // Calculate the bucket size\\n        int bucketsz = ceil(float(maxele-minele)/(n-1));\\n\\n        // If the bucket size is zero, return 0 as the maximum gap\\n        if(bucketsz == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // Create arrays to store the maximum and minimum values of each bucket\\n        vector<int>maxofb(n,INT_MIN);\\n        vector<int>minofb(n,INT_MAX);\\n\\n        // Assign each element to its corresponding bucket and update the maximum and minimum values of each bucket\\n        for(int i=0;i<n;i++)\\n        {\\n            int whichb = ((arr[i] - minele)/bucketsz);\\n\\n            maxofb[whichb] = max(maxofb[whichb],arr[i]);\\n            minofb[whichb] = min(minofb[whichb],arr[i]);\\n        }\\n\\n        // Initialize the answer as the bucket size and the previous maximum value as the maximum value in the first non-empty bucket\\n        int ans = bucketsz, pre = maxofb[0];\\n\\n        // Iterate through the buckets and find the maximum gap\\n        for(int i=1;i<n;i++)\\n        {\\n            // Skip empty buckets\\n            if(minofb[i] == INT_MAX)\\n            {\\n                continue;\\n            }\\n\\n            // Update the answer by comparing it with the difference between the minimum value of the current bucket and the previous maximum value\\n            ans = max(ans,minofb[i]-pre);\\n            pre = maxofb[i];\\n        }\\n\\n        // Return the maximum gap\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        if(n == 1)\\n        {\\n            return 0;\\n        }        \\n        if(n == 2)\\n        {\\n            return abs(arr[0] - arr[1]);\\n        }\\n\\n        int maxele = arr[0];\\n        int minele = arr[0];\\n\\n        // Find the maximum and minimum elements in the array\\n        for(auto i:arr)\\n        {\\n            maxele = max(maxele,i);\\n            minele = min(minele,i);\\n        }\\n\\n        // Calculate the bucket size\\n        int bucketsz = ceil(float(maxele-minele)/(n-1));\\n\\n        // If the bucket size is zero, return 0 as the maximum gap\\n        if(bucketsz == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // Create arrays to store the maximum and minimum values of each bucket\\n        vector<int>maxofb(n,INT_MIN);\\n        vector<int>minofb(n,INT_MAX);\\n\\n        // Assign each element to its corresponding bucket and update the maximum and minimum values of each bucket\\n        for(int i=0;i<n;i++)\\n        {\\n            int whichb = ((arr[i] - minele)/bucketsz);\\n\\n            maxofb[whichb] = max(maxofb[whichb],arr[i]);\\n            minofb[whichb] = min(minofb[whichb],arr[i]);\\n        }\\n\\n        // Initialize the answer as the bucket size and the previous maximum value as the maximum value in the first non-empty bucket\\n        int ans = bucketsz, pre = maxofb[0];\\n\\n        // Iterate through the buckets and find the maximum gap\\n        for(int i=1;i<n;i++)\\n        {\\n            // Skip empty buckets\\n            if(minofb[i] == INT_MAX)\\n            {\\n                continue;\\n            }\\n\\n            // Update the answer by comparing it with the difference between the minimum value of the current bucket and the previous maximum value\\n            ans = max(ans,minofb[i]-pre);\\n            pre = maxofb[i];\\n        }\\n\\n        // Return the maximum gap\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580473,
                "title": "easy-solution-simple-code-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n1. <!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n- <!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size()==1) return 0;\\n        sort(nums.begin(), nums.end());\\n        int maxdiff=0;\\n        for(int i=1; i<nums.size(); i++){\\n          maxdiff=abs(max(maxdiff,nums[i]-nums[i-1]));\\n          \\n        } \\n        return maxdiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size()==1) return 0;\\n        sort(nums.begin(), nums.end());\\n        int maxdiff=0;\\n        for(int i=1; i<nums.size(); i++){\\n          maxdiff=abs(max(maxdiff,nums[i]-nums[i-1]));\\n          \\n        } \\n        return maxdiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005534,
                "title": "maximum-gap-easy-to-understand-100-faster-and-0-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        int max = 0;\\n        int result = 0;\\n        if(n == 1) {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<n-1; i++) {\\n            max = nums[i+1]-nums[i];\\n            if(result < max) {\\n                result = max;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        int max = 0;\\n        int result = 0;\\n        if(n == 1) {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<n-1; i++) {\\n            max = nums[i+1]-nums[i];\\n            if(result < max) {\\n                result = max;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903035,
                "title": "using-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) \\n    {\\n       long long int n = nums.size() ;\\n       if(n<2)\\n       {\\n           return 0 ;\\n       }   \\n       sort(nums.begin(),nums.end()) ;\\n       long int diff = abs(nums[0]-nums[1]) ;\\n       for(int i=1;i<n-1;i++)\\n       {\\n           long int d = abs(nums[i]-nums[i+1]);\\n           if(d>diff)\\n           {\\n               diff=d;\\n           }\\n       }\\n       return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) \\n    {\\n       long long int n = nums.size() ;\\n       if(n<2)\\n       {\\n           return 0 ;\\n       }   \\n       sort(nums.begin(),nums.end()) ;\\n       long int diff = abs(nums[0]-nums[1]) ;\\n       for(int i=1;i<n-1;i++)\\n       {\\n           long int d = abs(nums[i]-nums[i+1]);\\n           if(d>diff)\\n           {\\n               diff=d;\\n           }\\n       }\\n       return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305748,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            ans=max(ans,abs(nums[i]-nums[i-1]));\\n        }\\n                    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            ans=max(ans,abs(nums[i]-nums[i-1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2305713,
                "title": "c-radix-sort",
                "content": "```\\nclass Solution {\\npublic:\\n//Count the digits in the largest digit\\n    int digitCount(int n)\\n    {\\n        int count=0;\\n        while(n)\\n        {\\n            n=n/10;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\t//Radix sort for m values of 0 to maxDig\\n    void radixSort(vector<int>&nums,int m)\\n    {\\n        queue<int>bin[10];\\n        int p=pow(10,m);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            bin[(nums[i]/p)%10].push(nums[i]);\\n        }\\n        int i=0;\\n        int j=0;\\n        while(j<10)\\n        {\\n            while(!bin[j].empty())\\n            {\\n                nums[i++]=bin[j].front();\\n                bin[j].pop();\\n            }\\n            j++;\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2)\\n            return 0;\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int maxDig=digitCount(maxi);\\n        for(int i=0;i<maxDig;i++)\\n            radixSort(nums,i);\\n        \\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=max(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n//Count the digits in the largest digit\\n    int digitCount(int n)\\n    {\\n        int count=0;\\n        while(n)\\n        {\\n            n=n/10;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\t//Radix sort for m values of 0 to maxDig\\n    void radixSort(vector<int>&nums,int m)\\n    {\\n        queue<int>bin[10];\\n        int p=pow(10,m);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            bin[(nums[i]/p)%10].push(nums[i]);\\n        }\\n        int i=0;\\n        int j=0;\\n        while(j<10)\\n        {\\n            while(!bin[j].empty())\\n            {\\n                nums[i++]=bin[j].front();\\n                bin[j].pop();\\n            }\\n            j++;\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2)\\n            return 0;\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int maxDig=digitCount(maxi);\\n        for(int i=0;i<maxDig;i++)\\n            radixSort(nums,i);\\n        \\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=max(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129190,
                "title": "radix-sort-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void countSort(vector<int>& nums,int n,int exp){\\n        vector<int> count(10,0);\\n        vector<int> temp(n,0);\\n        for(int i=0;i<n;i++){\\n            count[(nums[i]/exp)%10]++;\\n        }\\n        for(int i=1;i<10;i++){\\n            count[i] += count[i-1];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            temp[count[(nums[i]/exp)%10]-1] = nums[i];\\n            count[(nums[i]/exp)%10]--;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums[i] = temp[i];\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<2) return 0;\\n        int maxi = nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>maxi) maxi = nums[i];\\n        }\\n        for(int exp=1;maxi/exp > 0;exp*=10){\\n            countSort(nums,n,exp);\\n        }\\n        int maxDiff = 0;\\n        for(int i=1;i<n;i++){\\n            int temp = nums[i]-nums[i-1];\\n            if(temp > maxDiff){\\n                maxDiff = temp;\\n            }\\n        }\\n        return maxDiff;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void countSort(vector<int>& nums,int n,int exp){\\n        vector<int> count(10,0);\\n        vector<int> temp(n,0);\\n        for(int i=0;i<n;i++){\\n            count[(nums[i]/exp)%10]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2057566,
                "title": "java-time-0-n-radix-sort-count-sort",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) \\n    {\\n        int n= nums.length;\\n    \\n        int max=Integer.MIN_VALUE;\\n        for(int x:nums)\\n        {\\n            max=Math.max(max,x);\\n        }\\n        \\n        int i=1;\\n        while(i<=max)\\n        {\\n            countSort(nums,i);\\n            i=i*10;\\n        }\\n        \\n        int ans=0;\\n        for(int j=1;j<n;j++)\\n        {\\n            ans=Math.max(nums[j]-nums[j-1],ans);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void countSort(int[] nums,int exp)\\n    {\\n        int frq[]=new int[10]; \\n        int sorted[]=new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            frq[(nums[i]/exp)%10]+=1;\\n        }\\n        \\n        frq[0]-=1;\\n        for(int i=1;i<10;i++)\\n        {\\n            frq[i]+=frq[i-1];\\n        }\\n        \\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            sorted[frq[(nums[i]/exp)%10]]=nums[i];\\n            frq[(nums[i]/exp)%10]-=1;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            nums[i]=sorted[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) \\n    {\\n        int n= nums.length;\\n    \\n        int max=Integer.MIN_VALUE;\\n        for(int x:nums)\\n        {\\n            max=Math.max(max,x);\\n        }\\n        \\n        int i=1;\\n        while(i<=max)\\n        {\\n            countSort(nums,i);\\n            i=i*10;\\n        }\\n        \\n        int ans=0;\\n        for(int j=1;j<n;j++)\\n        {\\n            ans=Math.max(nums[j]-nums[j-1],ans);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void countSort(int[] nums,int exp)\\n    {\\n        int frq[]=new int[10]; \\n        int sorted[]=new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            frq[(nums[i]/exp)%10]+=1;\\n        }\\n        \\n        frq[0]-=1;\\n        for(int i=1;i<10;i++)\\n        {\\n            frq[i]+=frq[i-1];\\n        }\\n        \\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            sorted[frq[(nums[i]/exp)%10]]=nums[i];\\n            frq[(nums[i]/exp)%10]-=1;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            nums[i]=sorted[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056120,
                "title": "must-be-tagged-as-easy-problem-not-hard-one",
                "content": "class Solution {\\npublic:\\n\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n                if((nums[i]-nums[i-1])>ans)\\n                    ans=(nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n                if((nums[i]-nums[i-1])>ans)\\n                    ans=(nums[i]-nums[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2048437,
                "title": "python-radix-sort-simple-solution",
                "content": "```\\nclass Solution:\\n    def countingSort(self, arr, digitPlace):\\n        lookup = [0] * 10\\n        for i in arr:\\n            index = i / digitPlace\\n            lookup[int(index % 10)] += 1\\n        for i in range(1, 10):\\n            lookup[i] += lookup[i - 1]\\n        sortedArr = [None] * len(arr)\\n        for i in range(len(arr) - 1, -1, -1):\\n            index = arr[i] / digitPlace\\n            sortedArr[lookup[int(index % 10)] - 1] = arr[i]\\n            lookup[int(index % 10)] -= 1\\n        return sortedArr\\n\\n    def radixSort(self, arr):\\n        maxArr = max(arr)\\n        digitPlace = 1\\n        while int(maxArr) > 0:\\n            arr = self.countingSort(arr, digitPlace)\\n            digitPlace *= 10\\n            maxArr /= 10\\n        return arr\\n\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums = self.radixSort(nums)\\n        maxGap = 0\\n        for i in range(1, len(nums)):\\n            maxGap = max(maxGap, (nums[i] - nums[i - 1]))\\n        return maxGap\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countingSort(self, arr, digitPlace):\\n        lookup = [0] * 10\\n        for i in arr:\\n            index = i / digitPlace\\n            lookup[int(index % 10)] += 1\\n        for i in range(1, 10):\\n            lookup[i] += lookup[i - 1]\\n        sortedArr = [None] * len(arr)\\n        for i in range(len(arr) - 1, -1, -1):\\n            index = arr[i] / digitPlace\\n            sortedArr[lookup[int(index % 10)] - 1] = arr[i]\\n            lookup[int(index % 10)] -= 1\\n        return sortedArr\\n\\n    def radixSort(self, arr):\\n        maxArr = max(arr)\\n        digitPlace = 1\\n        while int(maxArr) > 0:\\n            arr = self.countingSort(arr, digitPlace)\\n            digitPlace *= 10\\n            maxArr /= 10\\n        return arr\\n\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums = self.radixSort(nums)\\n        maxGap = 0\\n        for i in range(1, len(nums)):\\n            maxGap = max(maxGap, (nums[i] - nums[i - 1]))\\n        return maxGap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989052,
                "title": "buckets-solution-t-o-n-s-o-n-javascript",
                "content": "\\t/**\\n\\t * The buckets solution.\\n\\t * \\n\\t * Time Complexity:  O(n)\\n\\t * Space Complexity: O(n)\\n\\t * \\n\\t * @param {number[]} nums\\n\\t * @return {number}\\n\\t */\\n\\tvar maximumGap = function(nums) {\\n\\t\\tconst n = nums.length\\n\\n\\t\\tif (n < 2) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tif (n < 3) {\\n\\t\\t\\treturn Math.abs(nums[0] - nums[1])\\n\\t\\t}\\n\\n\\t\\tlet maxNum = -Infinity\\n\\t\\tlet minNum = +Infinity\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tmaxNum = Math.max(maxNum, nums[i])\\n\\t\\t\\tminNum = Math.min(minNum, nums[i])\\n\\t\\t}\\n\\n\\t\\tif (maxNum === minNum) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tconst k = n - 1\\n\\t\\tconst averageGap = (maxNum - minNum) / k\\n\\n\\t\\tconst minBuckets = new Array(k)\\n\\t\\tconst maxBuckets = new Array(k)\\n\\n\\t\\tminBuckets[0] = minNum\\n\\t\\tmaxBuckets[0] = minNum\\n\\n\\t\\tminBuckets[k - 1] = maxNum\\n\\t\\tmaxBuckets[k - 1] = maxNum\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (minNum === nums[i] || nums[i] === maxNum) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst j = Math.floor((nums[i] - minNum) / averageGap)\\n\\n\\t\\t\\tminBuckets[j] = minBuckets[j] ? Math.min(minBuckets[j], nums[i]) : nums[i]\\n\\t\\t\\tmaxBuckets[j] = maxBuckets[j] ? Math.max(maxBuckets[j], nums[i]) : nums[i]\\n\\t\\t}\\n\\n\\t\\tlet largestGap = 0\\n\\t\\tlet prevMaxIndex = 0\\n\\n\\t\\tfor (let i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (minBuckets[i]) {\\n\\t\\t\\t\\tlargestGap = Math.max(largestGap, minBuckets[i] - maxBuckets[prevMaxIndex])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (maxBuckets[i]) {\\n\\t\\t\\t\\tprevMaxIndex = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn largestGap\\n\\t}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\t/**\\n\\t * The buckets solution.\\n\\t * \\n\\t * Time Complexity:  O(n)\\n\\t * Space Complexity: O(n)\\n\\t * \\n\\t * @param {number[]} nums\\n\\t * @return {number}\\n\\t */\\n\\tvar maximumGap = function(nums) {\\n\\t\\tconst n = nums.length\\n\\n\\t\\tif (n < 2) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tif (n < 3) {\\n\\t\\t\\treturn Math.abs(nums[0] - nums[1])\\n\\t\\t}\\n\\n\\t\\tlet maxNum = -Infinity\\n\\t\\tlet minNum = +Infinity\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tmaxNum = Math.max(maxNum, nums[i])\\n\\t\\t\\tminNum = Math.min(minNum, nums[i])\\n\\t\\t}\\n\\n\\t\\tif (maxNum === minNum) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tconst k = n - 1\\n\\t\\tconst averageGap = (maxNum - minNum) / k\\n\\n\\t\\tconst minBuckets = new Array(k)\\n\\t\\tconst maxBuckets = new Array(k)\\n\\n\\t\\tminBuckets[0] = minNum\\n\\t\\tmaxBuckets[0] = minNum\\n\\n\\t\\tminBuckets[k - 1] = maxNum\\n\\t\\tmaxBuckets[k - 1] = maxNum\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (minNum === nums[i] || nums[i] === maxNum) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst j = Math.floor((nums[i] - minNum) / averageGap)\\n\\n\\t\\t\\tminBuckets[j] = minBuckets[j] ? Math.min(minBuckets[j], nums[i]) : nums[i]\\n\\t\\t\\tmaxBuckets[j] = maxBuckets[j] ? Math.max(maxBuckets[j], nums[i]) : nums[i]\\n\\t\\t}\\n\\n\\t\\tlet largestGap = 0\\n\\t\\tlet prevMaxIndex = 0\\n\\n\\t\\tfor (let i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (minBuckets[i]) {\\n\\t\\t\\t\\tlargestGap = Math.max(largestGap, minBuckets[i] - maxBuckets[prevMaxIndex])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (maxBuckets[i]) {\\n\\t\\t\\t\\tprevMaxIndex = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn largestGap\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1630027,
                "title": "clean-and-concise-java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return 0;\\n        \\n        if(nums.length == 2)\\n            return Math.abs(nums[0] - nums[1]);\\n        \\n        Arrays.sort(nums);\\n        \\n        int maxDiff = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length - 1; i++)\\n            maxDiff = Math.max((nums[i+1] - nums[i]), maxDiff);\\n        \\n        return maxDiff;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return 0;\\n        \\n        if(nums.length == 2)\\n            return Math.abs(nums[0] - nums[1]);\\n        \\n        Arrays.sort(nums);\\n        \\n        int maxDiff = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length - 1; i++)\\n            maxDiff = Math.max((nums[i+1] - nums[i]), maxDiff);\\n        \\n        return maxDiff;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1462178,
                "title": "python-radix-sort-solution-o-n-time",
                "content": "1. Use radix sort to sort nums in O(dn) time with d <= 9, so it\\'s approximately equal to O(n).\\n2. Loop over the list to get the maximum gap across the list.\\n```\\nfrom functools import reduce\\nclass Solution(object):\\n        def maximumGap(self, nums):\\n            if len(nums) == 1:\\n                return 0\\n            \\n            sorted_array = self.radix_sort(nums)\\n            max_gap = self.maximum_Gap(sorted_array)\\n            return max_gap\\n            \\n                \\n        def radix_sort(self, nums):\\n            num_digits = len(str(max(nums)))\\n            A = nums \\n            for i in range(num_digits):\\n                B = [[] for _ in range(10)]\\n                for num in A:\\n                    bucket = (num // (10 ** i)) % 10\\n                    B[bucket].append(num)\\n                A = reduce(lambda x, y: x+y, B)\\n                \\n            return A\\n            \\n                \\n        def maximum_Gap(self, sorted_array):\\n            max_gap = -float(\\'inf\\')\\n            for i in range(1, len(sorted_array)):\\n                if sorted_array[i] - sorted_array[i-1] >= max_gap:\\n                    max_gap = sorted_array[i] - sorted_array[i-1]\\n            \\n            return max_gap\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import reduce\\nclass Solution(object):\\n        def maximumGap(self, nums):\\n            if len(nums) == 1:\\n                return 0\\n            \\n            sorted_array = self.radix_sort(nums)\\n            max_gap = self.maximum_Gap(sorted_array)\\n            return max_gap\\n            \\n                \\n        def radix_sort(self, nums):\\n            num_digits = len(str(max(nums)))\\n            A = nums \\n            for i in range(num_digits):\\n                B = [[] for _ in range(10)]\\n                for num in A:\\n                    bucket = (num // (10 ** i)) % 10\\n                    B[bucket].append(num)\\n                A = reduce(lambda x, y: x+y, B)\\n                \\n            return A\\n            \\n                \\n        def maximum_Gap(self, sorted_array):\\n            max_gap = -float(\\'inf\\')\\n            for i in range(1, len(sorted_array)):\\n                if sorted_array[i] - sorted_array[i-1] >= max_gap:\\n                    max_gap = sorted_array[i] - sorted_array[i-1]\\n            \\n            return max_gap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415450,
                "title": "c-radix-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int getDigit(int num, int factor) \\n    {\\n        return (abs(num) / abs(factor)) % 10;\\n    }\\n    \\n    void radixCountingSort(vector<int> &nums, int factor) \\n    {\\n        int freqSize = 10, size = nums.size();\\n        vector<int> freq(freqSize, 0), sorted(size, 0);\\n        \\n        for (int ind = 0; ind < size; ind++)\\n            freq[getDigit(nums[ind], factor)]++;\\n        \\n        for (int ind = 1; ind < freqSize; ind++)\\n            freq[ind] += freq[ind - 1];\\n        \\n        // for stable sorting start ind from end and decrement till 0\\n        \\n        for (int ind = size - 1; ind >= 0; ind--) \\n            sorted[freq[getDigit(nums[ind], factor)]-- - 1] = nums[ind];\\n        \\n        nums = sorted;\\n    }\\n    \\n    void radixSort(vector<int> &nums)\\n    {\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        for(auto &num : nums) \\n            num -= minVal;\\n        \\n        int factor = 1, maxVal = *max_element(nums.begin(), nums.end());\\n        \\n        while (maxVal / factor) \\n        {\\n            radixCountingSort(nums, factor);\\n            factor *= 10;\\n        }\\n        \\n        for (auto &num : nums) \\n            num += minVal;\\n    }\\n    \\n    int maximumGap(vector<int>& nums) \\n    {    \\n        if(nums.size() < 2)\\n            return 0;\\n        \\n        radixSort(nums);\\n        //sort(nums.begin(), nums.end());\\n        \\n        int result = INT_MIN;\\n        for(int i = 0; i < nums.size() - 1; i++)\\n            result = max(result, nums[i + 1] - nums[i]);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getDigit(int num, int factor) \\n    {\\n        return (abs(num) / abs(factor)) % 10;\\n    }\\n    \\n    void radixCountingSort(vector<int> &nums, int factor) \\n    {\\n        int freqSize = 10, size = nums.size();\\n        vector<int> freq(freqSize, 0), sorted(size, 0);\\n        \\n        for (int ind = 0; ind < size; ind++)\\n            freq[getDigit(nums[ind], factor)]++;\\n        \\n        for (int ind = 1; ind < freqSize; ind++)\\n            freq[ind] += freq[ind - 1];\\n        \\n        // for stable sorting start ind from end and decrement till 0\\n        \\n        for (int ind = size - 1; ind >= 0; ind--) \\n            sorted[freq[getDigit(nums[ind], factor)]-- - 1] = nums[ind];\\n        \\n        nums = sorted;\\n    }\\n    \\n    void radixSort(vector<int> &nums)\\n    {\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        for(auto &num : nums) \\n            num -= minVal;\\n        \\n        int factor = 1, maxVal = *max_element(nums.begin(), nums.end());\\n        \\n        while (maxVal / factor) \\n        {\\n            radixCountingSort(nums, factor);\\n            factor *= 10;\\n        }\\n        \\n        for (auto &num : nums) \\n            num += minVal;\\n    }\\n    \\n    int maximumGap(vector<int>& nums) \\n    {    \\n        if(nums.size() < 2)\\n            return 0;\\n        \\n        radixSort(nums);\\n        //sort(nums.begin(), nums.end());\\n        \\n        int result = INT_MIN;\\n        for(int i = 0; i < nums.size() - 1; i++)\\n            result = max(result, nums[i + 1] - nums[i]);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386071,
                "title": "bucket-sort-o-n-time-and-space-complexity-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        int bucketNo = n+1;\\n        int maxVal = *max_element(nums.begin(), nums.end());\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        if(maxVal == minVal) return 0;\\n        int bucketSize = (maxVal - minVal)/n+1;\\n        \\n        vector<vector<int>> buckets(bucketNo);\\n        \\n        for(int i=0;i<n;i++){\\n            int index = (nums[i] - minVal)/bucketSize;\\n            buckets[index].push_back(nums[i]);\\n        }\\n        int prevVal  = minVal;\\n        int maxDiff = 0;\\n        \\n        for(auto b: buckets){\\n            sort(b.begin(), b.end());\\n            for(auto i: b){\\n                 maxDiff = max(maxDiff, i-prevVal);\\n                 prevVal = i;\\n            }\\n            \\n        }\\n        \\n      return maxDiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        int bucketNo = n+1;\\n        int maxVal = *max_element(nums.begin(), nums.end());\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        if(maxVal == minVal) return 0;\\n        int bucketSize = (maxVal - minVal)/n+1;\\n        \\n        vector<vector<int>> buckets(bucketNo);\\n        \\n        for(int i=0;i<n;i++){\\n            int index = (nums[i] - minVal)/bucketSize;\\n            buckets[index].push_back(nums[i]);\\n        }\\n        int prevVal  = minVal;\\n        int maxDiff = 0;\\n        \\n        for(auto b: buckets){\\n            sort(b.begin(), b.end());\\n            for(auto i: b){\\n                 maxDiff = max(maxDiff, i-prevVal);\\n                 prevVal = i;\\n            }\\n            \\n        }\\n        \\n      return maxDiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360504,
                "title": "radix-sort-o-n",
                "content": "```\\n// Radix sort\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        for (int i = 0; i < 10; i++) { // O(N)\\n            int[] sorted = countSort(nums, i);\\n            nums = sorted;\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < n; i++) { // O(N)\\n            res = Math.max(res, nums[i] - nums[i - 1]);\\n        }\\n        if (res == Integer.MIN_VALUE) return 0;\\n        return res;\\n    }\\n    \\n    private int[] countSort(int[] nums, int d) {\\n        int n = nums.length;\\n        int[] sorted = new int[n];\\n        int[] count = new int[10];\\n        for (int i = 0; i < n; i++) { // o(n)\\n            int curr = nums[i] / (int) Math.pow(10, d) % 10;\\n            count[curr]++;\\n        }\\n        for (int j = 1; j < 10; j++) { // o(1)\\n            count[j] += count[j - 1];\\n        }\\n        for (int i = n - 1; i >= 0; i--) { // (n)\\n            int curr = nums[i] / (int) Math.pow(10, d) % 10;\\n            int index = count[curr] - 1;\\n            count[curr]--;\\n            sorted[index] = nums[i];\\n        }\\n        return sorted;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Radix sort\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        for (int i = 0; i < 10; i++) { // O(N)\\n            int[] sorted = countSort(nums, i);\\n            nums = sorted;\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < n; i++) { // O(N)\\n            res = Math.max(res, nums[i] - nums[i - 1]);\\n        }\\n        if (res == Integer.MIN_VALUE) return 0;\\n        return res;\\n    }\\n    \\n    private int[] countSort(int[] nums, int d) {\\n        int n = nums.length;\\n        int[] sorted = new int[n];\\n        int[] count = new int[10];\\n        for (int i = 0; i < n; i++) { // o(n)\\n            int curr = nums[i] / (int) Math.pow(10, d) % 10;\\n            count[curr]++;\\n        }\\n        for (int j = 1; j < 10; j++) { // o(1)\\n            count[j] += count[j - 1];\\n        }\\n        for (int i = n - 1; i >= 0; i--) { // (n)\\n            int curr = nums[i] / (int) Math.pow(10, d) % 10;\\n            int index = count[curr] - 1;\\n            count[curr]--;\\n            sorted[index] = nums[i];\\n        }\\n        return sorted;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326627,
                "title": "radix-sort-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& a) {\\n        if(a.size()<2)return 0;\\n        int mx = *max_element(a.begin(),a.end()),v=1,ans=0,n=a.size();\\n        while(v<=mx and v){\\n            vector<int>A[10];\\n            for(int V:a){\\n                A[(V/v)%10].push_back(V);\\n            }\\n            int idx =0;\\n            for(int i = 0;i<10;i++){\\n                for(int V:A[i])a[idx++]=V;\\n            }\\n            v*=10;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            ans=max(ans,a[i+1]-a[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& a) {\\n        if(a.size()<2)return 0;\\n        int mx = *max_element(a.begin(),a.end()),v=1,ans=0,n=a.size();\\n        while(v<=mx and v){\\n            vector<int>A[10];\\n            for(int V:a){\\n                A[(V/v)%10].push_back(V);\\n            }\\n            int idx =0;\\n            for(int i = 0;i<10;i++){\\n                for(int V:A[i])a[idx++]=V;\\n            }\\n            v*=10;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            ans=max(ans,a[i+1]-a[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293328,
                "title": "c-bucket-sort-easy-to-understand-proper-comments-clean-and-concise",
                "content": "Please upvote if it helps!\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& a) {\\n        int n=a.size(), maxi = INT_MIN, mini = INT_MAX, ans = INT_MIN;\\n        vector<vector<int>> bucket(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi = max(a[i], maxi);\\n            mini = min(a[i], mini);\\n        }\\n        if(maxi == mini)\\n            return 0;\\n        \\n        //create bucket\\n        int range = (maxi - mini)/n + 1; // range must be greater than equal to 1\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int b_index = (a[i] - mini)/range;\\n            if((a[i]-mini)%range==0 && a[i]!=mini)\\n            {\\n                bucket[((a[i] - mini)/range) - 1].push_back(a[i]);\\n                continue;\\n            }\\n            bucket[b_index].push_back(a[i]);\\n        }\\n        \\n        // traverse bucket\\n        int temp = -1;\\n        for(auto p:bucket)\\n        {\\n            if(p.size()==0)\\n                continue;\\n            sort(p.begin(), p.end());\\n            for(int i=0;i<p.size();i++)\\n            {\\n                if(temp == -1)\\n                {\\n                    temp = p[i];\\n                    continue;\\n                }\\n                ans = max(ans, p[i]-temp);\\n                temp = p[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& a) {\\n        int n=a.size(), maxi = INT_MIN, mini = INT_MAX, ans = INT_MIN;\\n        vector<vector<int>> bucket(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi = max(a[i], maxi);\\n            mini = min(a[i], mini);\\n        }\\n        if(maxi == mini)\\n            return 0;\\n        \\n        //create bucket\\n        int range = (maxi - mini)/n + 1; // range must be greater than equal to 1\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int b_index = (a[i] - mini)/range;\\n            if((a[i]-mini)%range==0 && a[i]!=mini)\\n            {\\n                bucket[((a[i] - mini)/range) - 1].push_back(a[i]);\\n                continue;\\n            }\\n            bucket[b_index].push_back(a[i]);\\n        }\\n        \\n        // traverse bucket\\n        int temp = -1;\\n        for(auto p:bucket)\\n        {\\n            if(p.size()==0)\\n                continue;\\n            sort(p.begin(), p.end());\\n            for(int i=0;i<p.size();i++)\\n            {\\n                if(temp == -1)\\n                {\\n                    temp = p[i];\\n                    continue;\\n                }\\n                ans = max(ans, p[i]-temp);\\n                temp = p[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241098,
                "title": "maximum-gap-c-using-pigeonhole-sort",
                "content": "If you like the solution, please ***upvote*** this post!!!!!\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2)\\n            return 0;\\n        int n =nums.size();\\n        int max_value = nums[0], min_value = nums[0];\\n    for (int i = 1; i < n; i++) {\\n        max_value = max(max_value, nums[i]);\\n        min_value = min(min_value, nums[i]);\\n    }\\n \\n    int max_Bucket[n - 1];\\n    int min_Bucket[n - 1];\\n    fill_n(max_Bucket, n - 1, INT_MIN);\\n    fill_n(min_Bucket, n - 1, INT_MAX);\\n \\n    float delta = (float)(max_value - min_value) / (float)(n - 1);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] == max_value || nums[i] == min_value)\\n            continue;\\n        int index = (float)(floor(nums[i] - min_value) / delta);\\n        max_Bucket[index] = max(max_Bucket[index], nums[i]);\\n        min_Bucket[index] = min(min_Bucket[index], nums[i]);\\n    }\\n \\n    int prev_val = min_value;\\n    int max_gap = 0;\\n    for (int i = 0; i < n - 1; i++) {\\n        if (min_Bucket[i] == INT_MAX)\\n            continue;\\n        max_gap = max(max_gap, min_Bucket[i] - prev_val);\\n        prev_val = max_Bucket[i];\\n    }\\n    max_gap = max(max_gap, max_value - prev_val);\\n    return max_gap;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2)\\n            return 0;\\n        int n =nums.size();\\n        int max_value = nums[0], min_value = nums[0];\\n    for (int i = 1; i < n; i++) {\\n        max_value = max(max_value, nums[i]);\\n        min_value = min(min_value, nums[i]);\\n    }\\n \\n    int max_Bucket[n - 1];\\n    int min_Bucket[n - 1];\\n    fill_n(max_Bucket, n - 1, INT_MIN);\\n    fill_n(min_Bucket, n - 1, INT_MAX);\\n \\n    float delta = (float)(max_value - min_value) / (float)(n - 1);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] == max_value || nums[i] == min_value)\\n            continue;\\n        int index = (float)(floor(nums[i] - min_value) / delta);\\n        max_Bucket[index] = max(max_Bucket[index], nums[i]);\\n        min_Bucket[index] = min(min_Bucket[index], nums[i]);\\n    }\\n \\n    int prev_val = min_value;\\n    int max_gap = 0;\\n    for (int i = 0; i < n - 1; i++) {\\n        if (min_Bucket[i] == INT_MAX)\\n            continue;\\n        max_gap = max(max_gap, min_Bucket[i] - prev_val);\\n        prev_val = max_Bucket[i];\\n    }\\n    max_gap = max(max_gap, max_value - prev_val);\\n    return max_gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240880,
                "title": "c-solution-bucket-sort",
                "content": "```\\n    /*\\n     * Approach followed is bucket sorting technique because the\\n     * algorithm should take only linear time\\n    */\\n    int maximumGap(vector<int>& nums) {\\n        // check if the array hase less than two elements\\n        if (nums.size() < 2) {\\n            // Input has less than 2 elements return 0;\\n            return 0;\\n        }\\n        \\n        // For Performing bucket sort, first thing to do is to\\n        // find the range of the elements in input array ie...,\\n        // min and max elements in the input array\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        int maxVal = *max_element(nums.begin(), nums.end());\\n        \\n        // variable to hold the size of input vector\\n        int n = nums.size();\\n        \\n        // Calculate the gap between each bucket and no of buckets\\n        // Eg: 3, 6, 9, 1 -> min = 1, max = 9\\n        // gap = 9 - 1 / n - 1 = 8 / 3 = 2.66\\n        // =>   -------------------------------------------------\\n        //     1     2.66          5.32          7.98           9\\n        // From above, it is clear that we have 4 buckets\\n        float gap = (float)(maxVal - minVal) / (float)(n - 1);\\n        \\n        // Cornor case where if the gap is zero\\n        if (gap == 0.0) {\\n            // Gap between buckets is zero ie.., we have same elements\\n            // in input array for eg: [1,1,1,1]\\n            // Max difference will be always zero\\n            return 0;\\n        }\\n        \\n        // Vectors to store min and max elements in each bucket\\n        vector<int> minBucket(n, INT_MAX);\\n        vector<int> maxBucket(n, INT_MIN);\\n        \\n        int idx;\\n        // Traverse the input vector and put the elements in correct bucket\\n        for (int& num : nums) {\\n            // Identify in which bucket this number should go\\n            idx = (num - minVal) / gap;\\n            \\n            // place the current number in min and max buckets\\n            minBucket[idx] = min(num, minBucket[idx]);\\n            maxBucket[idx] = max(num, maxBucket[idx]);\\n        }\\n        \\n        // Traverse the loop to find the max differnece between successive elements\\n        int prev = minBucket[0];\\n        // variable to store maxDifference\\n        int maxDiff = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Check if the bucket is empty\\n            if (minBucket[i] != INT_MAX) {\\n                maxDiff = max(maxDiff, minBucket[i] - prev);\\n                prev = maxBucket[i];\\n            }\\n        }\\n        \\n        return maxDiff;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Approach followed is bucket sorting technique because the\\n     * algorithm should take only linear time\\n    */\\n    int maximumGap(vector<int>& nums) {\\n        // check if the array hase less than two elements\\n        if (nums.size() < 2) {\\n            // Input has less than 2 elements return 0;\\n            return 0;\\n        }\\n        \\n        // For Performing bucket sort, first thing to do is to\\n        // find the range of the elements in input array ie...,\\n        // min and max elements in the input array\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        int maxVal = *max_element(nums.begin(), nums.end());\\n        \\n        // variable to hold the size of input vector\\n        int n = nums.size();\\n        \\n        // Calculate the gap between each bucket and no of buckets\\n        // Eg: 3, 6, 9, 1 -> min = 1, max = 9\\n        // gap = 9 - 1 / n - 1 = 8 / 3 = 2.66\\n        // =>   -------------------------------------------------\\n        //     1     2.66          5.32          7.98           9\\n        // From above, it is clear that we have 4 buckets\\n        float gap = (float)(maxVal - minVal) / (float)(n - 1);\\n        \\n        // Cornor case where if the gap is zero\\n        if (gap == 0.0) {\\n            // Gap between buckets is zero ie.., we have same elements\\n            // in input array for eg: [1,1,1,1]\\n            // Max difference will be always zero\\n            return 0;\\n        }\\n        \\n        // Vectors to store min and max elements in each bucket\\n        vector<int> minBucket(n, INT_MAX);\\n        vector<int> maxBucket(n, INT_MIN);\\n        \\n        int idx;\\n        // Traverse the input vector and put the elements in correct bucket\\n        for (int& num : nums) {\\n            // Identify in which bucket this number should go\\n            idx = (num - minVal) / gap;\\n            \\n            // place the current number in min and max buckets\\n            minBucket[idx] = min(num, minBucket[idx]);\\n            maxBucket[idx] = max(num, maxBucket[idx]);\\n        }\\n        \\n        // Traverse the loop to find the max differnece between successive elements\\n        int prev = minBucket[0];\\n        // variable to store maxDifference\\n        int maxDiff = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Check if the bucket is empty\\n            if (minBucket[i] != INT_MAX) {\\n                maxDiff = max(maxDiff, minBucket[i] - prev);\\n                prev = maxBucket[i];\\n            }\\n        }\\n        \\n        return maxDiff;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240475,
                "title": "c-bucket-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n<2) return 0;\\n        int maxE = *max_element(nums.begin(),nums.end());\\n        int minE = *min_element(nums.begin(),nums.end());\\n        int avgIntervals = (int)ceil(double(maxE-minE)/double(n-1));\\n        vector<int> maxA(n-1,INT_MIN); // n-1 buckets enough as per pegion hole principle\\n        vector<int> minA(n-1,INT_MAX);\\n        // We shouldn\\'t worry about other elements. In each bucket, minimum and maximum is enough.\\n        for(int i=0; i<n-1; i++) {\\n            if(nums[i]==minE || nums[i]==maxE) continue;  //[1,1,1,1]. AvgIntervals=0 and divByZero next line\\n            int bucketIndx = (nums[i]-minE)/avgIntervals; // Magic formula to find bucket index.\\n            maxA[bucketIndx] = max(maxA[bucketIndx],nums[i]);\\n            minA[bucketIndx] = min(minA[bucketIndx],nums[i]);\\n        }\\n        \\n        //We didn\\'t place min element and max element in the buckets before. We would start prev with min ele\\n        int gap = INT_MIN, prev = minE;\\n        for(int i=0; i<n-1; i++) {\\n            if(maxA[i]==INT_MIN || minA[i]==INT_MAX) continue; // Empty bucket\\n            gap = max(gap,minA[i]-prev); // Find diff b/w minimum of current and maximum of prev bucket\\n            prev = maxA[i];\\n        }\\n        //Finally compare with Maximum element\\n        gap=max(gap, maxE-prev);\\n        return gap;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n<2) return 0;\\n        int maxE = *max_element(nums.begin(),nums.end());\\n        int minE = *min_element(nums.begin(),nums.end());\\n        int avgIntervals = (int)ceil(double(maxE-minE)/double(n-1));\\n        vector<int> maxA(n-1,INT_MIN); // n-1 buckets enough as per pegion hole principle\\n        vector<int> minA(n-1,INT_MAX);\\n        // We shouldn\\'t worry about other elements. In each bucket, minimum and maximum is enough.\\n        for(int i=0; i<n-1; i++) {\\n            if(nums[i]==minE || nums[i]==maxE) continue;  //[1,1,1,1]. AvgIntervals=0 and divByZero next line\\n            int bucketIndx = (nums[i]-minE)/avgIntervals; // Magic formula to find bucket index.\\n            maxA[bucketIndx] = max(maxA[bucketIndx],nums[i]);\\n            minA[bucketIndx] = min(minA[bucketIndx],nums[i]);\\n        }\\n        \\n        //We didn\\'t place min element and max element in the buckets before. We would start prev with min ele\\n        int gap = INT_MIN, prev = minE;\\n        for(int i=0; i<n-1; i++) {\\n            if(maxA[i]==INT_MIN || minA[i]==INT_MAX) continue; // Empty bucket\\n            gap = max(gap,minA[i]-prev); // Find diff b/w minimum of current and maximum of prev bucket\\n            prev = maxA[i];\\n        }\\n        //Finally compare with Maximum element\\n        gap=max(gap, maxE-prev);\\n        return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240248,
                "title": "c-bucket-sort-solution-o-n-time-and-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return 0;\\n        vector<pair<int, int>> min_max(n, {INT_MAX, INT_MIN});\\n        int mn = *min_element(nums.begin(), nums.end()), mx = *max_element(nums.begin(), nums.end());\\n        int diff = (mx - mn) / (n - 1);\\n        if ((mx - mn) % (n - 1)) diff++;\\n        if (diff == 0) return 0;\\n\\n        for (int num : nums) {\\n            int ind = (num - mn) / diff;\\n            min_max[ind].first = min(min_max[ind].first, num);\\n            min_max[ind].second = max(min_max[ind].second, num);\\n        }\\n\\n        int ans = 0;\\n        int curr_mn = INT_MIN, curr_mx = INT_MAX;\\n\\n        int i = 0;\\n        while (i < n) {\\n            if (min_max[i].first == INT_MAX) {\\n                i++; continue;\\n            }\\n            if (curr_mx == INT_MAX) {\\n                curr_mx = min_max[i++].second; continue;\\n            }\\n            ans = max(ans, min_max[i].first - curr_mx);\\n            curr_mx = min_max[i++].second;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return 0;\\n        vector<pair<int, int>> min_max(n, {INT_MAX, INT_MIN});\\n        int mn = *min_element(nums.begin(), nums.end()), mx = *max_element(nums.begin(), nums.end());\\n        int diff = (mx - mn) / (n - 1);\\n        if ((mx - mn) % (n - 1)) diff++;\\n        if (diff == 0) return 0;\\n\\n        for (int num : nums) {\\n            int ind = (num - mn) / diff;\\n            min_max[ind].first = min(min_max[ind].first, num);\\n            min_max[ind].second = max(min_max[ind].second, num);\\n        }\\n\\n        int ans = 0;\\n        int curr_mn = INT_MIN, curr_mx = INT_MAX;\\n\\n        int i = 0;\\n        while (i < n) {\\n            if (min_max[i].first == INT_MAX) {\\n                i++; continue;\\n            }\\n            if (curr_mx == INT_MAX) {\\n                curr_mx = min_max[i++].second; continue;\\n            }\\n            ans = max(ans, min_max[i].first - curr_mx);\\n            curr_mx = min_max[i++].second;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228401,
                "title": "c-solution-using-buckets-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t//Base Case\\n        if (n < 2) return 0;\\n        if (n == 2) return max(nums[0], nums[1]) - min(nums[0], nums[1]);\\n        \\n\\t\\t//Calculate minimum and maximum values in the given array\\n        int minVal = nums[0], maxVal = 0; \\n        for (int num : nums) {\\n            minVal = min(num, minVal);\\n            maxVal = max(num, maxVal);\\n        }\\n        \\n\\t\\t//Calculate the intervals i.e size of buckets\\n        int interval = (int)ceil((maxVal - minVal + 0.0) / (n - 1));\\n\\t\\t\\n\\t\\t//interval 0 implies all the data valuesin the array are same, hence max gap is 0\\n        if (!interval) return 0;\\n        \\n\\t\\t//Initialize buckets, now we need on two because we wil be comparing only the maximum and minimum values in the interval, hence we dont need to store intermediate values\\n        vector<int> BucketMin(n-1, INT_MAX), BucketMax(n-1, -1);\\n        \\n\\t\\t//Fill the buckets using the magic formula\\n        int index;\\n        for (int num : nums) {\\n            if (num == maxVal || num == minVal) continue;\\n            index = (num - minVal) / interval;\\n            BucketMin[index] = min(BucketMin[index], num);\\n            BucketMax[index] = max(BucketMax[index], num);\\n        }\\n        \\n\\t\\t//Comaparing the buckets\\n\\t\\t//We consider the difference between the minimum value of current interval and the max value of previous interval\\n\\t\\t//For better understanding consider this,\\n\\t\\t// 1   ---A---5   47----B---68\\n\\t\\t//Let there be two buckets A and B, if you notice the minimum value of bucket B will be consecutive to maximum value of bucket A in sorted order\\n        int prev = minVal, res = 0;\\n        for (int i = 0; i < BucketMin.size(); i++) {\\n            if (BucketMax[i] == -1) continue;\\n            res = max(res, BucketMin[i] - prev);\\n            prev = BucketMax[i];\\n        }\\n        \\n        res = max(res, maxVal - prev);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity : O(N)\\nSpace Complexity: O(N)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t//Base Case\\n        if (n < 2) return 0;\\n        if (n == 2) return max(nums[0], nums[1]) - min(nums[0], nums[1]);\\n        \\n\\t\\t//Calculate minimum and maximum values in the given array\\n        int minVal = nums[0], maxVal = 0; \\n        for (int num : nums) {\\n            minVal = min(num, minVal);\\n            maxVal = max(num, maxVal);\\n        }\\n        \\n\\t\\t//Calculate the intervals i.e size of buckets\\n        int interval = (int)ceil((maxVal - minVal + 0.0) / (n - 1));\\n\\t\\t\\n\\t\\t//interval 0 implies all the data valuesin the array are same, hence max gap is 0\\n        if (!interval) return 0;\\n        \\n\\t\\t//Initialize buckets, now we need on two because we wil be comparing only the maximum and minimum values in the interval, hence we dont need to store intermediate values\\n        vector<int> BucketMin(n-1, INT_MAX), BucketMax(n-1, -1);\\n        \\n\\t\\t//Fill the buckets using the magic formula\\n        int index;\\n        for (int num : nums) {\\n            if (num == maxVal || num == minVal) continue;\\n            index = (num - minVal) / interval;\\n            BucketMin[index] = min(BucketMin[index], num);\\n            BucketMax[index] = max(BucketMax[index], num);\\n        }\\n        \\n\\t\\t//Comaparing the buckets\\n\\t\\t//We consider the difference between the minimum value of current interval and the max value of previous interval\\n\\t\\t//For better understanding consider this,\\n\\t\\t// 1   ---A---5   47----B---68\\n\\t\\t//Let there be two buckets A and B, if you notice the minimum value of bucket B will be consecutive to maximum value of bucket A in sorted order\\n        int prev = minVal, res = 0;\\n        for (int i = 0; i < BucketMin.size(); i++) {\\n            if (BucketMax[i] == -1) continue;\\n            res = max(res, BucketMin[i] - prev);\\n            prev = BucketMax[i];\\n        }\\n        \\n        res = max(res, maxVal - prev);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961598,
                "title": "buckets-sort-and-the-pigeonhole-principle-with-o-n-explained-in-comments",
                "content": "```\\n// return 0 if nums length is less than 0\\n// find the min and max of nums array\\n// then find the interval by subtracting max and min and dividing it by length\\n// make two array bucketMin and bucketMax and fill both array with max integer and minus one\\n// after that put the minimum value in particular index of bucketMin and maximum value in particular index of bucketMax\\n// at last compare the max interval gap with max of particular index\\n// after the loop compare maxgap with final interval and return the maxgap\\n\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int min = nums[0], max = 0;\\n        for(int num : nums){\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n        \\n        int interval = (int)(Math.ceil((max - min + 0.0)/(nums.length - 1)));\\n        int[] bucketMin = new int[nums.length - 1];\\n        int[] bucketMax = new int[nums.length - 1];\\n        Arrays.fill(bucketMin, Integer.MAX_VALUE);\\n        Arrays.fill(bucketMax, -1);                             \\n                        \\n        for(int i=0; i < nums.length; i++){\\n            if(nums[i] == min || nums[i] == max) continue;\\n            int index = (nums[i] - min)/interval;\\n            bucketMin[index] = Math.min(bucketMin[index], nums[i]);\\n            bucketMax[index] = Math.max(bucketMax[index], nums[i]);\\n        }\\n                             \\n        int prev = min, maxGap = 0;\\n        for(int i=0; i<bucketMin.length; i++){\\n            if(bucketMax[i] == -1) continue;\\n            maxGap = Math.max(bucketMin[i] - prev, maxGap);\\n            prev = bucketMax[i];\\n        }\\n                             \\n        maxGap = Math.max(max - prev, maxGap);\\n        return maxGap;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// return 0 if nums length is less than 0\\n// find the min and max of nums array\\n// then find the interval by subtracting max and min and dividing it by length\\n// make two array bucketMin and bucketMax and fill both array with max integer and minus one\\n// after that put the minimum value in particular index of bucketMin and maximum value in particular index of bucketMax\\n// at last compare the max interval gap with max of particular index\\n// after the loop compare maxgap with final interval and return the maxgap\\n\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int min = nums[0], max = 0;\\n        for(int num : nums){\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n        \\n        int interval = (int)(Math.ceil((max - min + 0.0)/(nums.length - 1)));\\n        int[] bucketMin = new int[nums.length - 1];\\n        int[] bucketMax = new int[nums.length - 1];\\n        Arrays.fill(bucketMin, Integer.MAX_VALUE);\\n        Arrays.fill(bucketMax, -1);                             \\n                        \\n        for(int i=0; i < nums.length; i++){\\n            if(nums[i] == min || nums[i] == max) continue;\\n            int index = (nums[i] - min)/interval;\\n            bucketMin[index] = Math.min(bucketMin[index], nums[i]);\\n            bucketMax[index] = Math.max(bucketMax[index], nums[i]);\\n        }\\n                             \\n        int prev = min, maxGap = 0;\\n        for(int i=0; i<bucketMin.length; i++){\\n            if(bucketMax[i] == -1) continue;\\n            maxGap = Math.max(bucketMin[i] - prev, maxGap);\\n            prev = bucketMax[i];\\n        }\\n                             \\n        maxGap = Math.max(max - prev, maxGap);\\n        return maxGap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861517,
                "title": "swift-radix-sort-bucket-sort",
                "content": "Radix sort\\nO(d*(n+b)) O(n+b)\\n```\\nfunc maximumGap(_ nums: [Int]) -> Int {\\n\\tif nums.isEmpty || nums.count == 1 { return 0 }\\n\\tlet count = nums.count\\n\\tlet maxNum = nums.max()!\\n\\tvar temp = nums\\n\\tvar exp = 1\\n\\n\\twhile maxNum / exp > 0 {\\n\\t\\tvar freqs = Array(repeating: 0, count: 10)\\n\\n\\t\\tfor num in temp {\\n\\t\\t\\tfreqs[(num / exp) % 10] += 1\\n\\t\\t}\\n\\n\\t\\tfor i in 1...9 {\\n\\t\\t\\tfreqs[i] += freqs[i - 1]\\n\\t\\t}\\n\\n\\t\\tfor num in temp.reversed() {\\n\\t\\t\\tlet digit = (num / exp) % 10\\n\\t\\t\\tfreqs[digit] -= 1\\n\\t\\t\\ttemp[freqs[digit]] = num\\n\\t\\t}\\n\\t\\texp *= 10\\n\\t}\\n\\n\\tvar maxGap = 0\\n\\tfor i in 1..<count {\\n\\t\\tmaxGap = max(maxGap, temp[i] - temp[i - 1])\\n\\t}\\n\\n\\treturn maxGap\\n}\\n```\\n\\nBucket sort, supa fast\\nO(n), O(n)\\n```\\nfunc maximumGap(_ nums: [Int]) -> Int {\\n\\tif nums.isEmpty || nums.count == 1 { return 0 }\\n\\tlet count = nums.count\\n\\tlet minNum = nums.min()!\\n\\tlet maxNum = nums.max()!\\n\\tif minNum == maxNum { return 0 }\\n\\tlet gap = Int((Double(maxNum - minNum)/Double(count - 1)).rounded(.up))\\n\\n\\tvar minBucket = Array(repeating: Int.max, count: count)\\n\\tvar maxBucket = Array(repeating: Int.min, count: count)\\n\\n\\tfor num in nums {\\n\\t\\tlet index = (num - minNum) / gap\\n\\n\\t\\tminBucket[index] = min(minBucket[index], num)\\n\\t\\tmaxBucket[index] = max(maxBucket[index], num)\\n\\t}\\n\\n\\tvar maxGap = 0\\n\\tvar prev = maxBucket[0]\\n\\tfor i in 1..<count {\\n\\t\\tif minBucket[i] == Int.max { continue }\\n\\t\\tmaxGap = max(maxGap, minBucket[i] - prev)\\n\\t\\tprev = maxBucket[i]\\n\\t}\\n\\n\\treturn maxGap\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maximumGap(_ nums: [Int]) -> Int {\\n\\tif nums.isEmpty || nums.count == 1 { return 0 }\\n\\tlet count = nums.count\\n\\tlet maxNum = nums.max()!\\n\\tvar temp = nums\\n\\tvar exp = 1\\n\\n\\twhile maxNum / exp > 0 {\\n\\t\\tvar freqs = Array(repeating: 0, count: 10)\\n\\n\\t\\tfor num in temp {\\n\\t\\t\\tfreqs[(num / exp) % 10] += 1\\n\\t\\t}\\n\\n\\t\\tfor i in 1...9 {\\n\\t\\t\\tfreqs[i] += freqs[i - 1]\\n\\t\\t}\\n\\n\\t\\tfor num in temp.reversed() {\\n\\t\\t\\tlet digit = (num / exp) % 10\\n\\t\\t\\tfreqs[digit] -= 1\\n\\t\\t\\ttemp[freqs[digit]] = num\\n\\t\\t}\\n\\t\\texp *= 10\\n\\t}\\n\\n\\tvar maxGap = 0\\n\\tfor i in 1..<count {\\n\\t\\tmaxGap = max(maxGap, temp[i] - temp[i - 1])\\n\\t}\\n\\n\\treturn maxGap\\n}\\n```\n```\\nfunc maximumGap(_ nums: [Int]) -> Int {\\n\\tif nums.isEmpty || nums.count == 1 { return 0 }\\n\\tlet count = nums.count\\n\\tlet minNum = nums.min()!\\n\\tlet maxNum = nums.max()!\\n\\tif minNum == maxNum { return 0 }\\n\\tlet gap = Int((Double(maxNum - minNum)/Double(count - 1)).rounded(.up))\\n\\n\\tvar minBucket = Array(repeating: Int.max, count: count)\\n\\tvar maxBucket = Array(repeating: Int.min, count: count)\\n\\n\\tfor num in nums {\\n\\t\\tlet index = (num - minNum) / gap\\n\\n\\t\\tminBucket[index] = min(minBucket[index], num)\\n\\t\\tmaxBucket[index] = max(maxBucket[index], num)\\n\\t}\\n\\n\\tvar maxGap = 0\\n\\tvar prev = maxBucket[0]\\n\\tfor i in 1..<count {\\n\\t\\tif minBucket[i] == Int.max { continue }\\n\\t\\tmaxGap = max(maxGap, minBucket[i] - prev)\\n\\t\\tprev = maxBucket[i]\\n\\t}\\n\\n\\treturn maxGap\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726951,
                "title": "java-meaningful-variable-names-radix-sort-bucket-sort",
                "content": "***Radix Sort :*** \\nOnce you understand this - https://www.cs.usfca.edu/~galles/visualization/RadixSort.html , radix sort will be easy for you.\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int largest = nums[0];\\n        int[] aux = new int[nums.length];\\n        int divisor = 1;\\n        for(int i : nums)    largest = Math.max(largest, i);\\n        while(largest / divisor > 0){\\n            int[] count = new int[10];\\n            for(int i = 0; i < nums.length; i++){\\n                count[(nums[i] / divisor) % 10]++;\\n            }\\n            for(int i = 1; i < count.length; i++){\\n                count[i] += count[i-1];\\n            }\\n            for(int i = nums.length-1; i >= 0; i--){\\n                aux[--count[(nums[i]/divisor)%10]] = nums[i];\\n            }\\n            System.arraycopy(aux, 0, nums, 0, nums.length);\\n            divisor = divisor * 10;\\n        }        \\n        int res = 0;\\n        for(int i = 1; i < nums.length; i++){\\n            res = Math.max(res, nums[i]-nums[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n***Bucket Sort :***\\n*  bucketSize is chosen wisely as \\n\\t*  ``` bucketSize = (max-min)/(n+1)```\\n\\t*  max = largest element in nums\\n\\t*  min = smallest element in nums\\n\\t*  n = size of nums\\n*  Reason for this bucketSize :\\n\\t*  Note that ```(n+1)```  gives total number of differences (gaps) in nums.\\n\\t*  the value of ```(max-min)/(n+1)``` gives minimum possible maximum gap in nums. This can only be maximum difference (gap) in nums iff sorted nums have uniform gap between each element, otherwise it will always be  < maximum gap in nums.\\n\\t* consider case of ```1,2,3,4,5,6``` .\\n\\t* If any of the changes in non-corner elements in made, maxGap will get greater than ```(max-min)/(n+1)```.\\n*  We are storing elements in buckets such that for each bucket, (difference between any 2 elements in the bucket < bucketSize). Hence, we don\\'t need to calculate differences between elements of a bucket, as they won\\'t give us maximum gap of nums.\\n* Let\\'s see how we have found total number of buckets.\\n\\t*  we know that ```max = min + (bucketSize * totalBuckets)```\\n\\t*  Using above formulae, ```totalBuckets = (max-min)/bucketSize```\\n* Now, we have to store elements in buckets\\n\\t*  Formula for this : ``` index = (nums[i]-min)/bucketSize;```\\n* Since differences between elements of a bucket won\\'t give us ans, we have to find inter-bucket difference. Hence, we need to find difference between maximum of a bucket with the manimum of next bucket ( for all buckets).\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int min = nums[0], max = nums[0];\\n        for(int i : nums){\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }\\n        int n = nums.length;\\n        int bucketSize = (max-min)/(n-1);\\n        if(bucketSize == 0) bucketSize++;\\n        int totalBuckets = (max-min)/bucketSize + 1;\\n        \\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < n; i++){\\n            int index = (nums[i]-min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i< totalBuckets; i++){\\n            if(minBucket[i] == Integer.MAX_VALUE)   continue;\\n            result = Math.max(result, minBucket[i]-prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int largest = nums[0];\\n        int[] aux = new int[nums.length];\\n        int divisor = 1;\\n        for(int i : nums)    largest = Math.max(largest, i);\\n        while(largest / divisor > 0){\\n            int[] count = new int[10];\\n            for(int i = 0; i < nums.length; i++){\\n                count[(nums[i] / divisor) % 10]++;\\n            }\\n            for(int i = 1; i < count.length; i++){\\n                count[i] += count[i-1];\\n            }\\n            for(int i = nums.length-1; i >= 0; i--){\\n                aux[--count[(nums[i]/divisor)%10]] = nums[i];\\n            }\\n            System.arraycopy(aux, 0, nums, 0, nums.length);\\n            divisor = divisor * 10;\\n        }        \\n        int res = 0;\\n        for(int i = 1; i < nums.length; i++){\\n            res = Math.max(res, nums[i]-nums[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```\n``` bucketSize = (max-min)/(n+1)```\n```(n+1)```\n```(max-min)/(n+1)```\n```1,2,3,4,5,6```\n```(max-min)/(n+1)```\n```max = min + (bucketSize * totalBuckets)```\n```totalBuckets = (max-min)/bucketSize```\n``` index = (nums[i]-min)/bucketSize;```\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int min = nums[0], max = nums[0];\\n        for(int i : nums){\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }\\n        int n = nums.length;\\n        int bucketSize = (max-min)/(n-1);\\n        if(bucketSize == 0) bucketSize++;\\n        int totalBuckets = (max-min)/bucketSize + 1;\\n        \\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < n; i++){\\n            int index = (nums[i]-min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i< totalBuckets; i++){\\n            if(minBucket[i] == Integer.MAX_VALUE)   continue;\\n            result = Math.max(result, minBucket[i]-prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611353,
                "title": "python-implementation-of-the-bucket-sort-solution",
                "content": "This is just a python implemenation of the bucket sort solution introduced by this [top voted post](https://leetcode.com/problems/maximum-gap/discuss/50643/bucket-sort-JAVA-solution-with-explanation-O(N)-time-and-space). In case anyone could not find a python bucketsort idea by searching in the post list like I did.\\nThe idea is discussed in the top voted post so there is no need for redundant explaination. Just make sure in the second for loop you take care of the empty buckets.\\n\\n```\\nimport math\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        n = len(nums)\\n        minv, maxv = min(nums), max(nums)\\n        gap = math.ceil((maxv - minv)/(n-1))\\n        \\n        # in case of zero division error\\n        if not gap:\\n            return 0\\n        \\n        num_buckets = math.ceil((maxv - minv)/gap) + 1\\n        buckets = [[float(\\'inf\\'), float(\\'-inf\\')] for _ in range(num_buckets)]\\n        \\n        for num in nums:\\n            idx = (num-minv)//gap\\n            if idx >= 0:\\n                buckets[idx][0] = min(buckets[idx][0], num)\\n                buckets[idx][1] = max(buckets[idx][1], num)\\n         \\n\\t\\t# iterate over buckets to find maxgap, make sure the empty buckets is taken care of\\n        res = -1\\n        for i in range(1, num_buckets):\\n            if buckets[i][0] == float(\\'inf\\'): continue\\n            prev = i - 1\\n            while prev >= 0 and buckets[prev][0] == float(\\'inf\\'):\\n                prev -= 1\\n            if prev >= 0:\\n                res = max(res, buckets[i][0] - buckets[prev][1])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        n = len(nums)\\n        minv, maxv = min(nums), max(nums)\\n        gap = math.ceil((maxv - minv)/(n-1))\\n        \\n        # in case of zero division error\\n        if not gap:\\n            return 0\\n        \\n        num_buckets = math.ceil((maxv - minv)/gap) + 1\\n        buckets = [[float(\\'inf\\'), float(\\'-inf\\')] for _ in range(num_buckets)]\\n        \\n        for num in nums:\\n            idx = (num-minv)//gap\\n            if idx >= 0:\\n                buckets[idx][0] = min(buckets[idx][0], num)\\n                buckets[idx][1] = max(buckets[idx][1], num)\\n         \\n\\t\\t# iterate over buckets to find maxgap, make sure the empty buckets is taken care of\\n        res = -1\\n        for i in range(1, num_buckets):\\n            if buckets[i][0] == float(\\'inf\\'): continue\\n            prev = i - 1\\n            while prev >= 0 and buckets[prev][0] == float(\\'inf\\'):\\n                prev -= 1\\n            if prev >= 0:\\n                res = max(res, buckets[i][0] - buckets[prev][1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521415,
                "title": "rust-bucket-sort",
                "content": "```rust\\nimpl Solution {\\n    // O(nlog(n))\\n    //  sort and one pass\\n    \\n    // O(n) bucket sort\\n    pub fn maximum_gap(nums: Vec<i32>) -> i32 {\\n        if nums.len() < 2 {\\n            return 0 as i32;\\n        }\\n        \\n        let max = *nums.iter().max().unwrap();\\n        let min = *nums.iter().min().unwrap();\\n        \\n        let bucket_size = std::cmp::max(1 as i32, (max - min) / nums.len() as i32);\\n        let bucket_count = (max - min) / bucket_size + 1;\\n        let mut buckets = vec![(None, None); bucket_count as usize]; // bucket(min_val, max_val)\\n        \\n        for n in &nums {\\n            let bucket_num = ((n - min) / bucket_size) as usize;\\n            let bucket = buckets[bucket_num];\\n            \\n            match bucket {\\n                (Some(a), Some(b)) => {\\n                    if n < a {\\n                        buckets[bucket_num] = (Some(n), Some(b))\\n                    } else if n > b {\\n                        buckets[bucket_num] = (Some(a), Some(n))\\n                    }\\n                }\\n                \\n                (None, None) => {\\n                    buckets[bucket_num] = (Some(n), Some(n));                  \\n                }\\n                \\n                _ => ()\\n            }\\n        }\\n        \\n        let mut res = 0;\\n        let mut prev_max = min;\\n        \\n        for bucket in buckets {\\n            if let (Some(a), Some(b)) = bucket {\\n                res = std::cmp::max(res, a - prev_max);\\n                prev_max = *b;\\n            }\\n        }\\n        \\n        res as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    // O(nlog(n))\\n    //  sort and one pass\\n    \\n    // O(n) bucket sort\\n    pub fn maximum_gap(nums: Vec<i32>) -> i32 {\\n        if nums.len() < 2 {\\n            return 0 as i32;\\n        }\\n        \\n        let max = *nums.iter().max().unwrap();\\n        let min = *nums.iter().min().unwrap();\\n        \\n        let bucket_size = std::cmp::max(1 as i32, (max - min) / nums.len() as i32);\\n        let bucket_count = (max - min) / bucket_size + 1;\\n        let mut buckets = vec![(None, None); bucket_count as usize]; // bucket(min_val, max_val)\\n        \\n        for n in &nums {\\n            let bucket_num = ((n - min) / bucket_size) as usize;\\n            let bucket = buckets[bucket_num];\\n            \\n            match bucket {\\n                (Some(a), Some(b)) => {\\n                    if n < a {\\n                        buckets[bucket_num] = (Some(n), Some(b))\\n                    } else if n > b {\\n                        buckets[bucket_num] = (Some(a), Some(n))\\n                    }\\n                }\\n                \\n                (None, None) => {\\n                    buckets[bucket_num] = (Some(n), Some(n));                  \\n                }\\n                \\n                _ => ()\\n            }\\n        }\\n        \\n        let mut res = 0;\\n        let mut prev_max = min;\\n        \\n        for bucket in buckets {\\n            if let (Some(a), Some(b)) = bucket {\\n                res = std::cmp::max(res, a - prev_max);\\n                prev_max = *b;\\n            }\\n        }\\n        \\n        res as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499481,
                "title": "python3-super-simple-nlog-n-solution",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        nums.sort()\\n        max_diff=0\\n        for i in range(len(nums)-1):\\n            max_diff=max(max_diff,nums[i+1]-nums[i])\\n        return max_diff\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        nums.sort()\\n        max_diff=0\\n        for i in range(len(nums)-1):\\n            max_diff=max(max_diff,nums[i+1]-nums[i])\\n        return max_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370218,
                "title": "c-radix-sort",
                "content": "```\\npublic class Solution {\\n    public int MaximumGap(int[] nums) {\\n        if(nums.Length < 2) return 0;\\n        int digit = 1;\\n        foreach(int n in nums) digit = Math.Max(digit, (int) Math.Floor(Math.Log10(n) + 1));  \\n        \\n        for(int i = 1 ; i <= digit ; i++) nums = CountingSort(nums, i);\\n        \\n        int maxD = int.MinValue;\\n        for(int i = 1 ; i < nums.Length ; i++) maxD = Math.Max(maxD, nums[i] - nums[i - 1]);\\n\\n        return maxD;\\n    }\\n    \\n    private int[] CountingSort(int[] nums, int digit) {\\n        List<int>[] idx = new List<int>[10];\\n        for(int i = 0 ; i < idx.Length ; i++) {\\n            idx[i] = new List<int>();\\n        }\\n        \\n        foreach(int n in nums) {\\n            int d1 = (int) Math.Pow(10, digit);\\n            int d2 = (int) Math.Pow(10, digit - 1);\\n            int tmp = n % d1 / d2;\\n            idx[tmp].Add(n);\\n        }\\n        \\n        List<int> ret = new List<int>();\\n        for(int i = 0 ; i < idx.Length ; i++) ret.AddRange(idx[i]);\\n        \\n        return ret.ToArray();\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaximumGap(int[] nums) {\\n        if(nums.Length < 2) return 0;\\n        int digit = 1;\\n        foreach(int n in nums) digit = Math.Max(digit, (int) Math.Floor(Math.Log10(n) + 1));  \\n        \\n        for(int i = 1 ; i <= digit ; i++) nums = CountingSort(nums, i);\\n        \\n        int maxD = int.MinValue;\\n        for(int i = 1 ; i < nums.Length ; i++) maxD = Math.Max(maxD, nums[i] - nums[i - 1]);\\n\\n        return maxD;\\n    }\\n    \\n    private int[] CountingSort(int[] nums, int digit) {\\n        List<int>[] idx = new List<int>[10];\\n        for(int i = 0 ; i < idx.Length ; i++) {\\n            idx[i] = new List<int>();\\n        }\\n        \\n        foreach(int n in nums) {\\n            int d1 = (int) Math.Pow(10, digit);\\n            int d2 = (int) Math.Pow(10, digit - 1);\\n            int tmp = n % d1 / d2;\\n            idx[tmp].Add(n);\\n        }\\n        \\n        List<int> ret = new List<int>();\\n        for(int i = 0 ; i < idx.Length ; i++) ret.AddRange(idx[i]);\\n        \\n        return ret.ToArray();\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50672,
                "title": "c-bucket-sort-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    /**\\n     * @param nums: a vector of integers\\n     * @return: the maximum difference\\n     */\\n    void sort(vector<int> &nums, int s, int e, int d) {\\n        if (d < 0 || s == e)\\n            return;\\n        int i = s;\\n        for (int j = s; j < e; j++)\\n            if (nums[j] & (1 << d))\\n                swap(nums[i++], nums[j]);\\n        sort(nums, s, i, d-1);\\n        sort(nums, i, e, d-1);\\n    }\\n    int maximumGap(vector<int> nums) {\\n        sort(nums, 0, nums.size(), 31);\\n        int max_diff = 0;\\n        for (int i = 1; i < nums.size(); i++)\\n            max_diff = max(max_diff, nums[i-1] - nums[i]);\\n        return max_diff;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /**\\n     * @param nums: a vector of integers\\n     * @return: the maximum difference\\n     */\\n    void sort(vector<int> &nums, int s, int e, int d) {\\n        if (d < 0 || s == e)\\n            return;\\n        int i = s;\\n        for (int j = s; j < e; j++)\\n            if (nums[j] & (1 << d))\\n                swap(nums[i++], nums[j]);\\n        sort(nums, s, i, d-1);\\n        sort(nums, i, e, d-1);\\n    }\\n    int maximumGap(vector<int> nums) {\\n        sort(nums, 0, nums.size(), 31);\\n        int max_diff = 0;\\n        for (int i = 1; i < nums.size(); i++)\\n            max_diff = max(max_diff, nums[i-1] - nums[i]);\\n        return max_diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50677,
                "title": "c-solution-with-explanation-bucket-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)  //corner check\\n              return 0;         \\n        int numsMin = nums[0];\\n        int numsMax = nums[0];\\n\\n      //get the max value and the min value of the  array\\n        for(int i=1; i<nums.size(); i++)            \\n        {\\n            numsMin = min(numsMin, nums[i]);\\n            numsMax = max(numsMax, nums[i]);\\n        }\\n        \\n     // if all numbers of the array are equal, return 0 \\n        if(numsMin == numsMax)                  \\n             return 0;\\n        int len = nums.size();\\n        int gap = ceil((numsMax-numsMin)*1.0/(len-1));\\n\\n       // store the min value in that bucket\\n       // store the max value in that bucket\\n        vector<int> bucketMin(len, INT_MAX);         \\n        vector<int> bucketMax(len, INT_MIN);            \\n        \\n        for(int i=0; i<len; i++)         //scan the array\\n        {\\n            int idx = (nums[i]-numsMin)/gap;\\n            bucketMin[idx] = min(nums[i], bucketMin[idx]);\\n            bucketMax[idx] = max(nums[i], bucketMax[idx]);\\n        }\\n        \\n        for(int i=0; i<len; i++)\\n        {\\n             //judge if the bucket is empty\\n            if(bucketMin[i] != INT_MAX)                 \\n            {\\n                //update the max gap\\n                gap = max(bucketMin[i]-numsMin, gap);      \\n                numsMin = bucketMax[i];\\n            }\\n        }\\n        \\n        return gap;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)  //corner check\\n              return 0;         \\n        int numsMin = nums[0];\\n        int numsMax = nums[0];\\n\\n      //get the max value and the min value of the  array\\n        for(int i=1; i<nums.size(); i++)            \\n        {\\n            numsMin = min(numsMin, nums[i]);\\n            numsMax = max(numsMax, nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 50688,
                "title": "concise-c-solution-use-buckets",
                "content": "    class Solution {\\n    public:\\n        int maximumGap(vector<int>& nums) {\\n            if (nums.size() < 2) {\\n                return 0;\\n            }\\n            int max_num = *max_element(nums.begin(), nums.end());\\n            int min_num = *min_element(nums.begin(), nums.end());\\n            if (max_num == min_num) {\\n                return 0;\\n            }\\n            float bucket_size = (float)(max_num - min_num) / nums.size();\\n            vector<pair<int, int>> buckets(nums.size() + 1, make_pair(INT_MAX, INT_MIN));\\n            for (auto i : nums) {\\n                int index = (int)((i - min_num) / bucket_size);\\n                buckets[index].first = min(buckets[index].first, i);\\n                buckets[index].second = max(buckets[index].second, i);\\n            }\\n            int max_gap = buckets[0].second - buckets[0].first;\\n            for (int i = 1, pre = buckets[0].second; i < buckets.size(); ++i) {\\n                if (buckets[i].first == INT_MAX) continue;\\n                max_gap = max(max_gap, max(buckets[i].second - buckets[i].first, buckets[i].first - pre));\\n                pre = buckets[i].second;\\n            }\\n            return max_gap;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximumGap(vector<int>& nums) {\\n            if (nums.size() < 2) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50693,
                "title": "recommend-for-beginners-2-different-clean-c-implementations-with-detailed-explaination",
                "content": "As far as I am concerned, I think you should grasp the 3 linear-time-sorting-algorithm-implementation introduced at  \\n[https://leetcode.com/discuss/80529/recommend-beginners-implementation-detailed-explaination][1]\\n\\nThen you can quickly understand the following 2 implementation. They are just the small changed version of the original implementation.\\n\\n    class Solution {\\n    public:\\n        /* bucket-sort-inspired-ideas-implementation */\\n        int maximumGap(vector<int>& nums) {\\n            const int size_num=nums.size();\\n            if(size_num < 2)    return 0;\\n            int maxV=*max_element(nums.begin(), nums.end());\\n            int minV=*min_element(nums.begin(), nums.end());\\n            if(maxV==minV)  return 0;\\n            double range=(maxV-minV)/double(size_num-1);\\n            cout<<\"range:\"<<maxV<<\"-\"<<minV<<\"=\"<<(int)(maxV-minV/double(1))<<endl;\\n            vector<int> max_bucket(size_num, INT_MIN);\\n            vector<int> min_bucket(size_num, INT_MAX);\\n            for(int i=0; i<size_num; i++){\\n                int index=(nums[i]-minV)/range;\\n                max_bucket[index]=max(max_bucket[index], nums[i]);\\n                min_bucket[index]=min(min_bucket[index], nums[i]);\\n            }\\n            \\n            int max_gap=(int)range, start=max_bucket[0];\\n            cout<<max_gap<<endl;\\n            for(int i=1; i<size_num; i++){\\n                if(min_bucket[i]==INT_MAX) continue;\\n                max_gap = max(max_gap, min_bucket[i]-start);\\n                start=max_bucket[i];\\n            }\\n            return max_gap;\\n        }\\n        \\n        /* radix-based-sorting-implementation */\\n        int maximumGap(vector<int>& nums){\\n        \\tif (nums.size() < 2)\\treturn 0;\\n        \\tint max_val = *max_element(nums.begin(), nums.end());\\n        \\tint exp = 1;\\n        \\tint R = 10;\\n        \\tvector<int> aux(nums.size(), 0);\\n        \\n        \\twhile (max_val / exp > 0){\\n        \\t\\tvector<int> count(R, 0);\\n        \\t\\tfor (int i = 0; i < nums.size(); i++){\\n        \\t\\t\\tcount[(nums[i] / exp) % 10]++;\\n        \\t\\t}\\n        \\t\\tfor (int i = 1; i < count.size(); i++){\\n        \\t\\t\\tcount[i] += count[i - 1];\\n        \\t\\t}\\n        \\t\\tfor (int i = nums.size() - 1; i >= 0; i--){\\n        \\t\\t\\taux[--count[(nums[i] / exp) % 10]] = nums[i];\\n        \\t\\t}\\n        \\n        \\t\\tfor (int i = 0; i < nums.size(); i++){\\n        \\t\\t\\tnums[i] = aux[i];\\n        \\t\\t}\\n        \\t\\texp *= 10;\\n        \\t}\\n        \\n        \\tint result = 0;\\n        \\tfor (int i = 1; i < aux.size(); i++){\\n        \\t\\tresult = max(result, aux[i] - aux[i - 1]);\\n        \\t}\\n        \\n        \\treturn result;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/80529/recommend-beginners-implementation-detailed-explaination",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        /* bucket-sort-inspired-ideas-implementation */\\n        int maximumGap(vector<int>& nums) {\\n            const int size_num=nums.size();\\n            if(size_num < 2)    return 0;\\n            int maxV=*max_element(nums.begin(), nums.end());\\n            int minV=*min_element(nums.begin(), nums.end());\\n            if(maxV==minV)  return 0;\\n            double range=(maxV-minV)/double(size_num-1);\\n            cout<<\"range:\"<<maxV<<\"-\"<<minV<<\"=\"<<(int)(maxV-minV/double(1))<<endl;\\n            vector<int> max_bucket(size_num, INT_MIN);\\n            vector<int> min_bucket(size_num, INT_MAX);\\n            for(int i=0; i<size_num; i++){\\n                int index=(nums[i]-minV)/range;\\n                max_bucket[index]=max(max_bucket[index], nums[i]);\\n                min_bucket[index]=min(min_bucket[index], nums[i]);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 50736,
                "title": "c-solution-with-12ms",
                "content": "     class Solution {\\n    public:\\n        int maximumGap(vector<int> &num) {\\n            if (num.size() < 2) return 0;\\n            int min = num[0];\\n            int max = num[0];\\n            for (int i = 0; i < num.size(); ++i) {\\n                min = num[i] < min ? num[i] : min;\\n                max = num[i] > max ? num[i] : max;\\n            }\\n            if (max == min) return 0;\\n            int blocksize = (max - min + num.size() - 1) / num.size();\\n            vector<int> blockmin(num.size());\\n            vector<int> blockmax(num.size());\\n            vector<int> blockvalid(num.size(), 0);\\n            for (int i = 0; i < num.size(); ++i) {\\n                int blockidx = (num[i] - min) / blocksize;\\n                if (blockvalid[blockidx] == 0) {\\n                    blockvalid[blockidx] = 1;\\n                    blockmin[blockidx] = num[i];\\n                    blockmax[blockidx] = num[i];\\n                } else {\\n                    blockmin[blockidx] = num[i] < blockmin[blockidx] ? num[i] : blockmin[blockidx];\\n                    blockmax[blockidx] = num[i] > blockmax[blockidx] ? num[i] : blockmax[blockidx];\\n                }\\n            }\\n            int maxgap = 0;\\n            bool firstflag = false;\\n            int lastvalue = 0;\\n            for (int blockidx = 0; blockidx < num.size(); ++blockidx) {\\n                if (blockvalid[blockidx]) {\\n                    if (firstflag && blockmin[blockidx] - lastvalue > maxgap)\\n                        maxgap = blockmin[blockidx] - lastvalue;\\n                    firstflag = true;\\n                    if (blockmax[blockidx] - blockmin[blockidx] > maxgap)\\n                        maxgap = blockmax[blockidx] - blockmin[blockidx];\\n                    lastvalue = blockmax[blockidx];\\n                }\\n            }\\n            return maxgap;\\n        }\\n    };\\n\\nUse n (n = num.size()) buckets. Track max and min and empty of each bucket. Loop from the beginning and check the maximum gap.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximumGap(vector<int> &num) {\\n            if (num.size() < 2) return 0;\\n            int min = num[0];\\n            int max = num[0];\\n            for (int i = 0; i < num.size(); ++i) {\\n                min = num[i] < min ? num[i] : min;\\n                max = num[i] > max ? num[i] : max;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50692,
                "title": "bucket-and-radix",
                "content": "    public class Solution {\\n        public int maximumGap(int[] num) {\\n           int len = num.length;\\n           int mask = 1;\\n           int[] num2 = new int[len];\\n           for(int i = 0; i<31; i++){\\n               int[] tmp = num;\\n               num = num2;\\n               num2 = tmp;\\n               int s = 0;\\n               int e = len-1;\\n               for(int j = 0; j<len; j++){\\n                   if((num2[j]&mask)==0) num[s++] = num2[j];\\n                   if((num2[len-1-j]&mask)>0) num[e--] = num2[len-1-j];\\n               }\\n               mask <<= 1;\\n           }\\n           int max = 0;\\n           for(int i = 1; i<len; i++){\\n               max = Math.max(max, num[i]-num[i-1]);\\n           }\\n           return max;\\n        }\\n    }\\n    \\n    \\n    public class Solution {\\n        public int maximumGap(int[] num) {\\n            if(num==null||num.length<2) return 0;\\n            int len = num.length;\\n            int min = 0;\\n            int max = 0;\\n            for(int i = 0; i < len; i++){\\n                min = Math.min(min, num[i]);\\n                max = Math.max(max, num[i]);\\n            }\\n            int bucketLen = (max-min)/(len-1) + ((max-min)%(len-1)>0?1:0);\\n            int bucketCount = (max-min)/bucketLen + 1;\\n            int[] minBuckets = new int[bucketCount];\\n            int[] maxBuckets = new int[bucketCount];\\n            \\n            Arrays.fill(minBuckets, Integer.MAX_VALUE);\\n            Arrays.fill(maxBuckets, Integer.MIN_VALUE);\\n            \\n            for(int i = 0; i < len; i++){\\n                int b = (num[i] - min)/bucketLen;\\n                minBuckets[b] = Math.min(minBuckets[b], num[i]);\\n                maxBuckets[b] = Math.max(maxBuckets[b], num[i]);\\n            }\\n            int maxGap = 0;\\n            int prev = maxBuckets[0];\\n            for(int i = 1; i < bucketCount; i++){\\n                if(minBuckets[i]==Integer.MAX_VALUE&&maxBuckets[i]==Integer.MIN_VALUE) continue;\\n                maxGap = Math.max(maxGap, minBuckets[i] - prev);\\n                prev = maxBuckets[i];\\n            }\\n            \\n            return maxGap;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maximumGap(int[] num) {\\n           int len = num.length;\\n           int mask = 1;\\n           int[] num2 = new int[len];\\n           for(int i = 0; i<31; i++){\\n               int[] tmp = num;\\n               num = num2;\\n               num2 = tmp;\\n               int s = 0;\\n               int e = len-1;\\n               for(int j = 0; j<len; j++){\\n                   if((num2[j]&mask)==0) num[s++] = num2[j];\\n                   if((num2[len-1-j]&mask)>0) num[e--] = num2[len-1-j];\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 50751,
                "title": "use-average-gap-to-achieve-o-n-run-time-java-solution",
                "content": "My idea comes from this: Since the question only allow O(n) run time, I cannot do sorting, (sorting takes at least O(n log n). I can only make use of the O(n) space. Considering the worst case, where the integers are spread by equal distance, like {1,3,5,7,9}. Then the maximum gap is the 2, change any integer in between will leads to larger gap.\\n\\n So I keep a gaps array which has equal gap distance and non-overlapping range. Like the example {1,3,5,7,9} become {[1,3),[3,5),[5,7),[7,9]}. Let me add some number into it without changing the minimum and maximum bound. {1,3,2,4,5,7,9}. Then, go through the num array, assign lower bound and upper bound for each gap. \\n\\nThe example {1,3,2,4,5,7,9} has gaps\\n\\n[1,3) with lower bound = 1 and upper bound = 2;\\n\\n[3,5) with lower bound = 3 and upper bound = 4;\\n\\n[5,7) with lower bound = 5 and upper bound = 5;\\n\\n[7,9] with lower bound = 7 and upper bound = 9;\\n\\nThen go through the gaps array once, you'll be able to find out the maximum gap.\\n\\n    public class Solution {\\n        public int maximumGap(int[] num) {\\n            int maxGap = 0;\\n            \\n            // edge case\\n            if(num.length < 2){return maxGap;}\\n            \\n            // get maximum and minimum\\n            int min = num[0];\\n            int max = num[0];\\n            for(int i = 0;i < num.length;i++){\\n                if(num[i] < min)\\n                    min = num[i];\\n                if(num[i] > max)\\n                    max = num[i];\\n            }\\n            \\n            // divide into identical gaps\\n            Gap[] gaps = new Gap[num.length-1];\\n            boolean[] Engaged = new boolean[num.length-1];\\n            double gap = (double)(max-min)/(double)(num.length-1);\\n            for(int i = 0;i < gaps.length;i++)\\n                Engaged[Math.min((int)Math.floor((double)(num[i]-min)/gap),gaps.length-1)] = true;\\n                \\n            // assign maximum and minimum for each gap\\n            for(int i = 0;i < gaps.length;i++)\\n                gaps[i] = new Gap();\\n            for(int i = 0;i < num.length;i++){\\n                int index = (int)Math.floor((double)(num[i]-min)/gap);\\n                index = Math.min(index,gaps.length-1);\\n                \\n                // lower bound\\n                if(gaps[index].low == -1)\\n                    gaps[index].low = num[i];\\n                else\\n                    gaps[index].low = Math.min(gaps[index].low, num[i]);\\n                        \\n                // upper bound\\n                if(gaps[index].high == -1)\\n                    gaps[index].high = num[i];\\n                else\\n                    gaps[index].high = Math.max(gaps[index].high, num[i]);\\n            }\\n            \\n            // find maximum gap\\n            for(int i = 0;i < gaps.length;i++){\\n                if(Engaged[i]){\\n                    // check its inner gap\\n                    maxGap = Math.max(gaps[i].high-gaps[i].low, maxGap);\\n                    \\n                    // lower all the way\\n                    int j = i;\\n                    while(--j >= 0){\\n                        if(Engaged[j])\\n                            break;\\n                    }\\n                    if(j >= 0)\\n                        maxGap = Math.max(gaps[i].low - gaps[j].high,maxGap);\\n                        \\n                    // upper all the way\\n                    j = i;\\n                    while(++j < num.length-2){\\n                        if(Engaged[j])\\n                            break;\\n                    }\\n                    if(j < gaps.length)\\n                        maxGap = Math.max(gaps[j].low - gaps[i].high, maxGap);\\n                }\\n            }\\n            \\n            return maxGap;\\n        }\\n        \\n        class Gap{\\n            int low;\\n            int high;\\n            Gap(){\\n                low = -1;\\n                high = -1;\\n            }\\n            Gap(int x,int y){\\n                low = x;\\n                high = y;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maximumGap(int[] num) {\\n            int maxGap = 0;\\n            \\n            // edge case\\n            if(num.length < 2){return maxGap;}",
                "codeTag": "Java"
            },
            {
                "id": 50720,
                "title": "i-directly-sort-the-vector-and-then-get-the-max-gap-it-cost-52ms-std-is-powerful",
                "content": "At Beginning, I using the std::sort to make the vector in order, and then get the max gap, after submit it, it cost 52ms. Then I follow the solution provided by leetcode, and it cost 44ms, but it cost me almost 2 hours to finish it. It seems that sometimes I cost large time to get a solution which seems to be a good solution, and it may not reduce too much cost when comparing with some easy way.\\n\\n\\n    #include <iostream>\\n    #include <functional>\\n    \\n    // Solution 1 cost 52ms\\n    int solution_1(std::vector<int> &num)\\n    {\\n        if (num.size() < 2)\\n        {\\n            return 0;\\n        }\\n        \\n        std::sort(num.begin(), num.end());\\n        int gap = 0;\\n        \\n        for(int n = 0, m = 1; m < num.size(); ++n, ++m)\\n        {\\n            int tmp_gap = num[m] - num[n];\\n            if (tmp_gap > gap)\\n            {\\n                gap = tmp_gap;\\n            }\\n        }\\n        \\n        //std::cout << gap << \"\\\\n\";\\n        \\n        return gap;\\n    }\\n    \\n    \\n    // Solution2 according to suggestion by leetcode\\n    // This solution cost 44ms\\n    \\n    typedef struct Bucket_S\\n    {\\n        int gap;\\n        int max;\\n        int min;\\n    } Bucket_T;\\n    \\n    void add2bluck(Bucket_T& bucket, int value)\\n    {\\n        if (bucket.max == -1)\\n        {\\n            bucket.max = value;\\n            bucket.min = value;\\n        }\\n        else\\n        {\\n            if (bucket.max < value)\\n            {\\n                bucket.max = value;\\n            }\\n            else if (bucket.min > value)\\n            {\\n                bucket.min = value;\\n            }\\n        }\\n    }\\n    \\n    int getIndexInBucket(int min, int value, int min_gap)\\n    {\\n        return (value - min)/min_gap;\\n    }\\n    \\n    void caculateGapSelf(Bucket_T& bucket)\\n    {\\n        if (bucket.max != -1)\\n        {\\n            bucket.gap = bucket.max - bucket.min;\\n        }\\n    }\\n    \\n    int solution_2(std::vector<int> &num)\\n    {\\n        if (num.size() < 2)\\n        {\\n            return 0;\\n        }\\n        \\n        int max = num[0];\\n        int min = num[0];\\n        \\n        for (unsigned int i = 1; i < num.size(); ++i)\\n        {\\n            if (num[i] > max)\\n            {\\n                max = num[i];\\n            }\\n            else if (num[i] < min)\\n            {\\n                min = num[i];\\n            }\\n        }\\n        \\n    //    std::cout << \"Max: \" << max <<\" Min: \"<< min << \"\\\\n\";\\n        \\n        int min_gap = (max - min)/(num.size() - 1);\\n        if (min_gap == 0)\\n        {\\n            min_gap = 1;\\n        }\\n    //    std::cout << \"Min Gap:\"<<min_gap<<\"\\\\n\";\\n        std::vector<Bucket_T> buckets;\\n        int total_buckets = (max - min)/min_gap + 1;\\n        for(unsigned int i = 0; i < total_buckets; ++i)\\n        {\\n            //std::cout<< i << \"<<<\";\\n            Bucket_T b;\\n            b.max = -1;\\n            b.min = -1;\\n            b.gap = -1;\\n            buckets.push_back(b);\\n    \\n        }\\n    \\n        int max_gap = 0;\\n        for (unsigned int i = 0; i < num.size(); ++i)\\n        {\\n            int index = getIndexInBucket(min, num[i], min_gap);\\n            //std::cout<< index << \" \" << num[i] << \"\\\\n\";\\n            add2bluck(buckets[index], num[i]);\\n            caculateGapSelf(buckets[index]);\\n            if (buckets[index].gap > max_gap)\\n            {\\n                max_gap = buckets[index].gap;\\n            }\\n        }\\n    \\n        \\n        \\n        for(unsigned int n = 0, m = 0; ;)\\n        {\\n            while (buckets[n].max == -1)\\n            {\\n                ++n;\\n                if (n >= buckets.size()-1)\\n                {\\n                    return -1; // error condition\\n                }\\n            }\\n            m = n + 1;\\n            while (buckets[m].max == -1)\\n            {\\n                ++m;\\n                if (m > buckets.size()-1)\\n                {\\n                    return -1;\\n                }\\n            }\\n            int tmp_gap = buckets[m].min - buckets[n].max;\\n            if (tmp_gap > max_gap)\\n            {\\n                max_gap = tmp_gap;\\n            }\\n            ++n;\\n            if ( n >= buckets.size()-1 || m >= buckets.size() - 1)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return max_gap;\\n    }",
                "solutionTags": [],
                "code": "At Beginning, I using the std::sort to make the vector in order, and then get the max gap, after submit it, it cost 52ms. Then I follow the solution provided by leetcode, and it cost 44ms, but it cost me almost 2 hours to finish it. It seems that sometimes I cost large time to get a solution which seems to be a good solution, and it may not reduce too much cost when comparing with some easy way.\\n\\n\\n    #include <iostream>\\n    #include <functional>\\n    \\n    // Solution 1 cost 52ms\\n    int solution_1(std::vector<int> &num)\\n    {\\n        if (num.size() < 2)\\n        {\\n            return 0;\\n        }\\n        \\n        std::sort(num.begin(), num.end());\\n        int gap = 0;\\n        \\n        for(int n = 0, m = 1; m < num.size(); ++n, ++m)\\n        {\\n            int tmp_gap = num[m] - num[n];\\n            if (tmp_gap > gap)\\n            {\\n                gap = tmp_gap;\\n            }\\n        }\\n        \\n        //std::cout << gap << \"\\\\n\";\\n        \\n        return gap;\\n    }\\n    \\n    \\n    // Solution2 according to suggestion by leetcode\\n    // This solution cost 44ms\\n    \\n    typedef struct Bucket_S\\n    {\\n        int gap;\\n        int max;\\n        int min;\\n    } Bucket_T;\\n    \\n    void add2bluck(Bucket_T& bucket, int value)\\n    {\\n        if (bucket.max == -1)\\n        {\\n            bucket.max = value;\\n            bucket.min = value;\\n        }\\n        else\\n        {\\n            if (bucket.max < value)\\n            {\\n                bucket.max = value;\\n            }\\n            else if (bucket.min > value)\\n            {\\n                bucket.min = value;\\n            }\\n        }\\n    }\\n    \\n    int getIndexInBucket(int min, int value, int min_gap)\\n    {\\n        return (value - min)/min_gap;\\n    }\\n    \\n    void caculateGapSelf(Bucket_T& bucket)\\n    {\\n        if (bucket.max != -1)\\n        {\\n            bucket.gap = bucket.max - bucket.min;\\n        }\\n    }\\n    \\n    int solution_2(std::vector<int> &num)\\n    {\\n        if (num.size() < 2)\\n        {\\n            return 0;\\n        }\\n        \\n        int max = num[0];\\n        int min = num[0];\\n        \\n        for (unsigned int i = 1; i < num.size(); ++i)\\n        {\\n            if (num[i] > max)\\n            {\\n                max = num[i];\\n            }\\n            else if (num[i] < min)\\n            {\\n                min = num[i];\\n            }\\n        }\\n        \\n    //    std::cout << \"Max: \" << max <<\" Min: \"<< min << \"\\\\n\";\\n        \\n        int min_gap = (max - min)/(num.size() - 1);\\n        if (min_gap == 0)\\n        {\\n            min_gap = 1;\\n        }\\n    //    std::cout << \"Min Gap:\"<<min_gap<<\"\\\\n\";\\n        std::vector<Bucket_T> buckets;\\n        int total_buckets = (max - min)/min_gap + 1;\\n        for(unsigned int i = 0; i < total_buckets; ++i)\\n        {\\n            //std::cout<< i << \"<<<\";\\n            Bucket_T b;\\n            b.max = -1;\\n            b.min = -1;\\n            b.gap = -1;\\n            buckets.push_back(b);\\n    \\n        }\\n    \\n        int max_gap = 0;\\n        for (unsigned int i = 0; i < num.size(); ++i)\\n        {\\n            int index = getIndexInBucket(min, num[i], min_gap);\\n            //std::cout<< index << \" \" << num[i] << \"\\\\n\";\\n            add2bluck(buckets[index], num[i]);\\n            caculateGapSelf(buckets[index]);\\n            if (buckets[index].gap > max_gap)\\n            {\\n                max_gap = buckets[index].gap;\\n            }\\n        }\\n    \\n        \\n        \\n        for(unsigned int n = 0, m = 0; ;)\\n        {\\n            while (buckets[n].max == -1)\\n            {\\n                ++n;\\n                if (n >= buckets.size()-1)\\n                {\\n                    return -1; // error condition\\n                }\\n            }\\n            m = n + 1;\\n            while (buckets[m].max == -1)\\n            {\\n                ++m;\\n                if (m > buckets.size()-1)\\n                {\\n                    return -1;\\n                }\\n            }\\n            int tmp_gap = buckets[m].min - buckets[n].max;\\n            if (tmp_gap > max_gap)\\n            {\\n                max_gap = tmp_gap;\\n            }\\n            ++n;\\n            if ( n >= buckets.size()-1 || m >= buckets.size() - 1)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return max_gap;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 4046277,
                "title": "o-nlogn-time-complexity",
                "content": "# Intuition\\n- The problem asks us to find the maximum gap between any two elements in an array nums when the array is sorted. To do this, we can follow the following intuition:\\n\\n- Sort the array nums in ascending order. Sorting is necessary because we want to find the maximum gap, and the maximum gap will likely occur between adjacent elements after sorting.\\n\\n- Iterate through the sorted array and calculate the difference between each pair of adjacent elements. Keep track of the maximum difference found during this process.\\n\\n- Return the maximum difference as the answer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Import the necessary library java.util for using Arrays.sort().\\n\\n2. Define a function maximumGap that takes an array of integers nums as input and returns an integer representing the maximum gap.\\n\\n3. Check if the length of nums is 1. If it is, return 0 because there is only one element, and there can be no gap.\\n\\n4. Sort the nums array in ascending order using Arrays.sort(nums).\\n\\n5. Initialize a variable max_diff to store the maximum gap and set it to 0.\\n\\n6. Iterate through the sorted array from index 0 to nums.length - 2 (inclusive). For each pair of adjacent elements, calculate the difference curr_diff between them (i.e., nums[i+1] - nums[i]).\\n\\n7. If curr_diff is greater than the current max_diff, update max_diff to be equal to curr_diff.\\n\\n8. After the loop finishes, max_diff will contain the maximum gap between elements in the sorted array. Return max_diff as the result.\\n\\n# Complexity\\n- Time complexity: `O(nlog(n))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n    Arrays.sort(nums);\\n    int max_diff = 0;\\n    if(nums.length == 1) {\\n        return 0;\\n    } \\n    for(int i=0;i<nums.length-1;i++) {\\n        int curr_diff = nums[i+1]-nums[i];\\n        if(curr_diff > max_diff) {\\n            max_diff = curr_diff;\\n        }\\n    }\\n    return max_diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n    Arrays.sort(nums);\\n    int max_diff = 0;\\n    if(nums.length == 1) {\\n        return 0;\\n    } \\n    for(int i=0;i<nums.length-1;i++) {\\n        int curr_diff = nums[i+1]-nums[i];\\n        if(curr_diff > max_diff) {\\n            max_diff = curr_diff;\\n        }\\n    }\\n    return max_diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025797,
                "title": "very-easy-approach-python-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the Input List\\nCalculate the Differences Between Adjacent Elements:\\nFind the Maximum Gap:\\nAnd return \\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n- The dominant factor here is the sorting step, so the overall time complexity of your code is O(n log n) due to the sorting operation.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Therefore, the overall space complexity of your code is O(n) due to the space used by the k list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        nums.sort()\\n        k = []\\n        for i in range(len(nums) - 1):\\n            k.append(nums[i + 1] - nums[i])\\n        return max(k)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        nums.sort()\\n        k = []\\n        for i in range(len(nums) - 1):\\n            k.append(nums[i + 1] - nums[i])\\n        return max(k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833911,
                "title": "o-n-time-o-b-space-bucket-sort-hint",
                "content": "**radix sort**\\n\\n    def maximumGap(self, nums: List[int]) -> int:\\n\\n        def counting_sort(arr, key):\\n            d = {i: [] for i in range(10)}\\n            for n in arr:\\n                d[key(n)] += n,\\n            return sum(d.values(), [])\\n\\n        l = len(str(max(nums)))\\n\\n        for i in range(1, l + 1):\\n            fn = lambda x: int(str(x).zfill(l)[-i])\\n            nums = counting_sort(nums, key=fn)\\n\\n        return max((b - a for a, b in itertools.pairwise(nums)), default=0)\\n\\n**classic bucket sort**\\n\\n        def maximumGap(self, nums):\\n            a, b, l = min(nums), max(nums), len(nums)\\n            o = max(1, (b - a)//(l - 1)) if l != 1 else 1  # for zero division\\n            bs = collections.defaultdict(list)\\n\\n            for n in nums:\\n                bs[(n - a)//o] += n,\\n\\n            [b.sort() for b in bs.values()]\\n            arr = itertools.chain.from_iterable(bs[i] for i in range(l))\\n            return max((b - a for a, b in itertools.pairwise(arr)), default=0)\\n\\n\\n**bucket sort +hint**\\n![image](https://assets.leetcode.com/users/images/557d62ab-4e8a-454d-bc76-0ce7f46f7032_1690638380.4297183.png)\\n\\n\\n    def maximumGap(self, nums):\\n        a, b, l = min(nums), max(nums), len(nums)\\n        o = max(1, (b - a)//(l - 1)) if l != 1 else 1  # for zero division\\n        bs = collections.defaultdict(list)\\n\\n        for n in nums:\\n            bs[(n - a)//o] += n,\\n\\n        bb = (bs[i] for i in range(l) if i in bs)\\n        return max((min(j) - max(i) for i, j in itertools.pairwise(bb)), default=0)",
                "solutionTags": [],
                "code": "**radix sort**\\n\\n    def maximumGap(self, nums: List[int]) -> int:\\n\\n        def counting_sort(arr, key):\\n            d = {i: [] for i in range(10)}\\n            for n in arr:\\n                d[key(n)] += n,\\n            return sum(d.values(), [])\\n\\n        l = len(str(max(nums)))\\n\\n        for i in range(1, l + 1):\\n            fn = lambda x: int(str(x).zfill(l)[-i])\\n            nums = counting_sort(nums, key=fn)\\n\\n        return max((b - a for a, b in itertools.pairwise(nums)), default=0)\\n\\n**classic bucket sort**\\n\\n        def maximumGap(self, nums):\\n            a, b, l = min(nums), max(nums), len(nums)\\n            o = max(1, (b - a)//(l - 1)) if l != 1 else 1  # for zero division\\n            bs = collections.defaultdict(list)\\n\\n            for n in nums:\\n                bs[(n - a)//o] += n,\\n\\n            [b.sort() for b in bs.values()]\\n            arr = itertools.chain.from_iterable(bs[i] for i in range(l))\\n            return max((b - a for a, b in itertools.pairwise(arr)), default=0)\\n\\n\\n**bucket sort +hint**\\n![image](https://assets.leetcode.com/users/images/557d62ab-4e8a-454d-bc76-0ce7f46f7032_1690638380.4297183.png)\\n\\n\\n    def maximumGap(self, nums):\\n        a, b, l = min(nums), max(nums), len(nums)\\n        o = max(1, (b - a)//(l - 1)) if l != 1 else 1  # for zero division\\n        bs = collections.defaultdict(list)\\n\\n        for n in nums:\\n            bs[(n - a)//o] += n,\\n\\n        bb = (bs[i] for i in range(l) if i in bs)\\n        return max((min(j) - max(i) for i, j in itertools.pairwise(bb)), default=0)",
                "codeTag": "Java"
            },
            {
                "id": 3772929,
                "title": "solution-using-counting-sort-linear-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730723,
                "title": "easy-python3-solution-beats-atleat-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        ls = nums\\n        b = sorted(ls) \\n        l1 =  []\\n        if(len(b) > 1):\\n            for x in range(1,len(ls)):\\n                difference = b[x] - b[x-1]\\n                l1.append(difference)\\n            return(max(l1))\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        ls = nums\\n        b = sorted(ls) \\n        l1 =  []\\n        if(len(b) > 1):\\n            for x in range(1,len(ls)):\\n                difference = b[x] - b[x-1]\\n                l1.append(difference)\\n            return(max(l1))\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655849,
                "title": "beginner-friendly-solution-radix-sort-count-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void CountSort(vector<int>& nums, int m){\\n        int n = nums.size();\\n        vector<int> v(n), count(10, 0);\\n        for(int i=0; i<n; ++i){\\n            count[(nums[i]/m)%10]++;\\n        }\\n        for(int i=1; i<10; ++i){\\n            count[i] += count[i-1];\\n        }\\n        for(int i=n-1; i>=0; --i){\\n            v[count[(nums[i]/m)%10]-1] = nums[i];\\n            count[(nums[i]/m)%10]--;\\n        }\\n        for(int i=0; i<n; ++i){\\n            nums[i] = v[i];\\n        }\\n        return;\\n    }\\n    void Radix_Sort(vector<int>& nums){\\n        int n = nums.size();\\n        int m = -1;\\n        for(int i=0; i<n; ++i){\\n            m = max(m, nums[i]);\\n        }\\n        for(int i=1; m/i>0; i *= 10){\\n            CountSort(nums, i);\\n        }\\n        return;\\n    }\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        Radix_Sort(nums);\\n        int mx = 0;\\n        for(int i=1; i<n; ++i){\\n            mx = max(mx, nums[i]-nums[i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Radix Sort"
                ],
                "code": "```\\nclass Solution {\\n    void CountSort(vector<int>& nums, int m){\\n        int n = nums.size();\\n        vector<int> v(n), count(10, 0);\\n        for(int i=0; i<n; ++i){\\n            count[(nums[i]/m)%10]++;\\n        }\\n        for(int i=1; i<10; ++i){\\n            count[i] += count[i-1];\\n        }\\n        for(int i=n-1; i>=0; --i){\\n            v[count[(nums[i]/m)%10]-1] = nums[i];\\n            count[(nums[i]/m)%10]--;\\n        }\\n        for(int i=0; i<n; ++i){\\n            nums[i] = v[i];\\n        }\\n        return;\\n    }\\n    void Radix_Sort(vector<int>& nums){\\n        int n = nums.size();\\n        int m = -1;\\n        for(int i=0; i<n; ++i){\\n            m = max(m, nums[i]);\\n        }\\n        for(int i=1; m/i>0; i *= 10){\\n            CountSort(nums, i);\\n        }\\n        return;\\n    }\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        Radix_Sort(nums);\\n        int mx = 0;\\n        for(int i=1; i<n; ++i){\\n            mx = max(mx, nums[i]-nums[i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631436,
                "title": "easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        l=[]\\n        a=nums\\n        b=sorted(a)\\n        if len(b)!=1:\\n            for i in range(1,len(a)):\\n                c=b[i]-b[i-1]\\n                l.append(c)\\n            return(max(l))\\n        else:\\n            return(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        l=[]\\n        a=nums\\n        b=sorted(a)\\n        if len(b)!=1:\\n            for i in range(1,len(a)):\\n                c=b[i]-b[i-1]\\n                l.append(c)\\n            return(max(l))\\n        else:\\n            return(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476565,
                "title": "easily-understandable-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2)\\n          return 0;\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n           {\\n                ans=max(ans,nums[i]-nums[i-1]);\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2)\\n          return 0;\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n           {\\n                ans=max(ans,nums[i]-nums[i-1]);\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464087,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        if(nums.length<2) return 0;\\n        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n            if(nums[i]-nums[i-1]>max) max=nums[i]-nums[i-1];\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        if(nums.length<2) return 0;\\n        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n            if(nums[i]-nums[i-1]>max) max=nums[i]-nums[i-1];\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314886,
                "title": "o-n-solution-beginner-friendly-solution-c",
                "content": "- Approach\\n          Firstly, I check if my size of vector is less than 2 then simply return 0\\n          Otherwise I sort the whole vector and initiallize one max variable assign to INT_MIN and simply traversing whole sorted vector and simply check if my max is less than or equal to difference of two adjacent number then assign max to that difference.\\n          After loop will over simply return that max variable.\\n\\n# Complexity\\n- **Time complexity: O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int max = INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(max<=(nums[i+1]-nums[i]))\\n            {\\n                max = (nums[i+1]-nums[i]);\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/bfd06e9e-5d8c-4e9f-85f4-a9a8ca3448a8_1679207552.3106096.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int max = INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(max<=(nums[i+1]-nums[i]))\\n            {\\n                max = (nums[i+1]-nums[i]);\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202734,
                "title": "simple-six-line-code-c-easy-approach-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing sort function and take max variable ,store differences in ans and compare with max if ans is greator than max=ans this will continue ..at the end return the max value..\\n\\n# Complexity\\n- Time complexity:\\nO(NLogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n<=1){\\n        return 0;\\n        }\\n        int max=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int ans=nums[i+1]-nums[i];\\n             if(ans>max)\\n             {\\n                 max=ans;\\n             }\\n        }\\n       \\n  return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n<=1){\\n        return 0;\\n        }\\n        int max=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int ans=nums[i+1]-nums[i];\\n             if(ans>max)\\n             {\\n                 max=ans;\\n             }\\n        }\\n       \\n  return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186883,
                "title": "optimized-solution-swift-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maximumGap(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        let mi = nums.min()!\\n        let ma = nums.max()!\\n        if ma == mi {return ma - mi}\\n        let bucketSize = Int(ceil(Double(ma-mi) / Double(n-1)))\\n        var minMaxBucket = Array(repeating: (min: Int.max, max: Int.min), count: n )\\n\\n        for num in nums {\\n            let idx = (num - mi) / bucketSize\\n            minMaxBucket[idx].min = min(minMaxBucket[idx].min, num)\\n            minMaxBucket[idx].max = max(minMaxBucket[idx].max, num)\\n        }\\n\\n        var maxGap: Int = bucketSize  \\n        var prev = minMaxBucket[0].max  \\n        for i in 1..<n where minMaxBucket[i].min != Int.max { \\n            maxGap = max(maxGap, minMaxBucket[i].min - prev)\\n            prev = minMaxBucket[i].max\\n        }\\n        return maxGap\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    func maximumGap(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        let mi = nums.min()!\\n        let ma = nums.max()!\\n        if ma == mi {return ma - mi}\\n        let bucketSize = Int(ceil(Double(ma-mi) / Double(n-1)))\\n        var minMaxBucket = Array(repeating: (min: Int.max, max: Int.min), count: n )\\n\\n        for num in nums {\\n            let idx = (num - mi) / bucketSize\\n            minMaxBucket[idx].min = min(minMaxBucket[idx].min, num)\\n            minMaxBucket[idx].max = max(minMaxBucket[idx].max, num)\\n        }\\n\\n        var maxGap: Int = bucketSize  \\n        var prev = minMaxBucket[0].max  \\n        for i in 1..<n where minMaxBucket[i].min != Int.max { \\n            maxGap = max(maxGap, minMaxBucket[i].min - prev)\\n            prev = minMaxBucket[i].max\\n        }\\n        return maxGap\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052339,
                "title": "java-priorityqueue",
                "content": "# Intuition\\nUse a PriorityQueue to sort elements into correct order on addition, then compare consecutive elements to get the maximum difference.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        int len = nums.length;\\n        if (len < 2) {\\n            return 0;\\n        }\\n\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>();\\n        for (Integer num : nums) {\\n            queue.add(num);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        int last = queue.poll();\\n        while(!queue.isEmpty()) {\\n            int curr = queue.peek();\\n            res = Math.max(res, curr - last);\\n            last = queue.poll();\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        int len = nums.length;\\n        if (len < 2) {\\n            return 0;\\n        }\\n\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>();\\n        for (Integer num : nums) {\\n            queue.add(num);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        int last = queue.poll();\\n        while(!queue.isEmpty()) {\\n            int curr = queue.peek();\\n            res = Math.max(res, curr - last);\\n            last = queue.poll();\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034767,
                "title": "simple-approach-using-python",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\nAlmost beats 97.44%\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n999ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n28.1mb\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        count=0\\n        x=len(nums)\\n        nums.sort()\\n        if x<2:\\n            return 0\\n        if x==2:\\n            return (nums[1]-nums[0])\\n        \\n        for i in range(1,len(nums)-1):\\n            \\n            max1=nums[i+1]-nums[i]\\n            if(max1>count):\\n                count=max1\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        count=0\\n        x=len(nums)\\n        nums.sort()\\n        if x<2:\\n            return 0\\n        if x==2:\\n            return (nums[1]-nums[0])\\n        \\n        for i in range(1,len(nums)-1):\\n            \\n            max1=nums[i+1]-nums[i]\\n            if(max1>count):\\n                count=max1\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735237,
                "title": "python-o-nlogn-runtime-1123-ms-beats-91-69-memory-28-2-mb-beats-42-79",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- best: O(N)\\n- wrost: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        m=0\\n        for i in range(n-1):\\n            m=max(m,abs(nums[i]-nums[i+1]))\\n        return m\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        m=0\\n        for i in range(n-1):\\n            m=max(m,abs(nums[i]-nums[i+1]))\\n        return m\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723115,
                "title": "js-solution-radix-sort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar maximumGap = function (nums) {\\n  if (nums.length < 2) {\\n    return 0;\\n  }\\n\\n  let max = -Infinity;\\n  for (let num of nums) {\\n    max = Math.max(max, num);\\n  }\\n\\n  let place = 1;\\n  const sorted = Array(nums.length);\\n\\n  while (max / place > 0) {\\n    const count = Array(10).fill(0);\\n\\n    for (let num of nums) {\\n      count[Math.floor(num / place) % 10]++;\\n    }\\n\\n    for (let i = 1; i < count.length; i++) {\\n      count[i] += count[i - 1];\\n    }\\n\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n      sorted[--count[Math.floor(nums[i] / place) % 10]] = nums[i];\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n      nums[i] = sorted[i];\\n    }\\n\\n    place *= 10;\\n  }\\n\\n  max = -Infinity;\\n  for (let i = 1; i < sorted.length; i++) {\\n    max = Math.max(max, sorted[i] - sorted[i - 1]);\\n  }\\n  return max;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar maximumGap = function (nums) {\\n  if (nums.length < 2) {\\n    return 0;\\n  }\\n\\n  let max = -Infinity;\\n  for (let num of nums) {\\n    max = Math.max(max, num);\\n  }\\n\\n  let place = 1;\\n  const sorted = Array(nums.length);\\n\\n  while (max / place > 0) {\\n    const count = Array(10).fill(0);\\n\\n    for (let num of nums) {\\n      count[Math.floor(num / place) % 10]++;\\n    }\\n\\n    for (let i = 1; i < count.length; i++) {\\n      count[i] += count[i - 1];\\n    }\\n\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n      sorted[--count[Math.floor(nums[i] / place) % 10]] = nums[i];\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n      nums[i] = sorted[i];\\n    }\\n\\n    place *= 10;\\n  }\\n\\n  max = -Infinity;\\n  for (let i = 1; i < sorted.length; i++) {\\n    max = Math.max(max, sorted[i] - sorted[i - 1]);\\n  }\\n  return max;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2691520,
                "title": "c-solution-maximum-gap-radix-sort-easy-to-understand",
                "content": "**Using Radix Sort**\\n* First Sort and then find Maximum Gap\\n```\\nclass Solution {\\npublic:\\n    // Radix Sort Code\\n    void countSort(vector<int>& nums, long long expo){\\n        int n = nums.size();\\n        int range = 10; // 0 to 9\\n        vector<int> freqArr(range, 0);\\n        \\n        for(int i = 0; i < n; i++){\\n            freqArr[nums[i]/expo % 10]++;\\n        }\\n        \\n        //pair sum array\\n        for(int i = 1; i < range; i++){\\n            freqArr[i] += freqArr[i-1];\\n        }\\n        vector<int> ans(n);\\n        for(int i = n - 1; i >= 0; i--){\\n            int pos = freqArr[nums[i]/expo % 10] - 1;\\n            ans[pos] = nums[i];\\n            freqArr[nums[i]/expo % 10]--;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            nums[i] = ans[i];\\n        }\\n    }\\n    \\n    void radixSort(vector<int>& nums){\\n        int max = *max_element(nums.begin(), nums.end());\\n        \\n        long long expo = 1;\\n        while(expo <= max){\\n            countSort(nums, expo);\\n            expo = expo * 10; \\n        }\\n    }\\n    \\n    // Finding Maximum Gap\\n    int maximumGap(vector<int>& nums) {\\n        radixSort(nums);\\n        int n = nums.size();\\n        int maxi = INT_MIN;\\n        \\n        if( n < 2){\\n            return 0;\\n        }\\n        \\n        for(int i = 1; i <= n - 1; i++){\\n            \\n            maxi = max(maxi, nums[i] - nums[i-1]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\\n\\n**Please Upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Radix Sort Code\\n    void countSort(vector<int>& nums, long long expo){\\n        int n = nums.size();\\n        int range = 10; // 0 to 9\\n        vector<int> freqArr(range, 0);\\n        \\n        for(int i = 0; i < n; i++){\\n            freqArr[nums[i]/expo % 10]++;\\n        }\\n        \\n        //pair sum array\\n        for(int i = 1; i < range; i++){\\n            freqArr[i] += freqArr[i-1];\\n        }\\n        vector<int> ans(n);\\n        for(int i = n - 1; i >= 0; i--){\\n            int pos = freqArr[nums[i]/expo % 10] - 1;\\n            ans[pos] = nums[i];\\n            freqArr[nums[i]/expo % 10]--;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            nums[i] = ans[i];\\n        }\\n    }\\n    \\n    void radixSort(vector<int>& nums){\\n        int max = *max_element(nums.begin(), nums.end());\\n        \\n        long long expo = 1;\\n        while(expo <= max){\\n            countSort(nums, expo);\\n            expo = expo * 10; \\n        }\\n    }\\n    \\n    // Finding Maximum Gap\\n    int maximumGap(vector<int>& nums) {\\n        radixSort(nums);\\n        int n = nums.size();\\n        int maxi = INT_MIN;\\n        \\n        if( n < 2){\\n            return 0;\\n        }\\n        \\n        for(int i = 1; i <= n - 1; i++){\\n            \\n            maxi = max(maxi, nums[i] - nums[i-1]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556773,
                "title": "python-bucket-sort-solution-with-explanation",
                "content": "we can use bucket sort to solve it.\\nfirst, calculate minimum and maximum of ```nums```, and determine the buckect size. and number of buckect.\\n```python\\n# eg. [2,4,6,8] -> three interval [2, 4), [4, 6), [6, 8), interval size is 2 \\nbuckectSize = max(1, (maxVal-minVal) // (leng-1))\\n```\\n```python\\n# eg. [2,4,6,8] -> three interval [2, 4), [4, 6), [6, 8), add a interval to put maximum 8 -> [8, 10)\\nnumBucket = (maxVal-minVal) // buckectSize + 1\\n\\n# because (8 - 2) // 2 = 3, so buckect index is 0 to 3, there have 4 buckects -> (8-2) // 2 + 1\\nindex = (n-minVal) // buckectSize\\n```\\nwe use bucket to track min and max in each interval, then calculate the gap between buckect ```min[i] - max[i-1]```\\ntc is ```O(N)```, sc is the same as tc\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        minVal, maxVal, leng = min(nums), max(nums), len(nums)\\n        if maxVal-minVal==0: return 0\\n        buckectSize = max(1, (maxVal-minVal) // (leng-1))\\n        numBucket = (maxVal-minVal) // buckectSize + 1\\n        bucketMin,  bucketMax = [float(\\'inf\\')] * numBucket, [-1] * numBucket\\n        for n in nums:\\n            index = (n-minVal) // buckectSize\\n            bucketMin[index] = min(bucketMin[index], n)\\n            bucketMax[index] = max(bucketMax[index], n)\\n        maxGap = buckectSize\\n        previousMax = -1\\n        for i in range(numBucket):\\n            if bucketMax[i] == -1: \\n                continue\\n            if previousMax != -1:\\n                maxGap = max(bucketMin[i] - previousMax, maxGap)\\n            previousMax = bucketMax[i]\\n        return maxGap\\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```nums```\n```python\\n# eg. [2,4,6,8] -> three interval [2, 4), [4, 6), [6, 8), interval size is 2 \\nbuckectSize = max(1, (maxVal-minVal) // (leng-1))\\n```\n```python\\n# eg. [2,4,6,8] -> three interval [2, 4), [4, 6), [6, 8), add a interval to put maximum 8 -> [8, 10)\\nnumBucket = (maxVal-minVal) // buckectSize + 1\\n\\n# because (8 - 2) // 2 = 3, so buckect index is 0 to 3, there have 4 buckects -> (8-2) // 2 + 1\\nindex = (n-minVal) // buckectSize\\n```\n```min[i] - max[i-1]```\n```O(N)```\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        minVal, maxVal, leng = min(nums), max(nums), len(nums)\\n        if maxVal-minVal==0: return 0\\n        buckectSize = max(1, (maxVal-minVal) // (leng-1))\\n        numBucket = (maxVal-minVal) // buckectSize + 1\\n        bucketMin,  bucketMax = [float(\\'inf\\')] * numBucket, [-1] * numBucket\\n        for n in nums:\\n            index = (n-minVal) // buckectSize\\n            bucketMin[index] = min(bucketMin[index], n)\\n            bucketMax[index] = max(bucketMax[index], n)\\n        maxGap = buckectSize\\n        previousMax = -1\\n        for i in range(numBucket):\\n            if bucketMax[i] == -1: \\n                continue\\n            if previousMax != -1:\\n                maxGap = max(bucketMin[i] - previousMax, maxGap)\\n            previousMax = bucketMax[i]\\n        return maxGap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470094,
                "title": "java-bucket-sort-99-93-faster",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length==1){\\n            return 0;\\n        }\\n        int max=Integer.MIN_VALUE;\\n        int min=Integer.MAX_VALUE;\\n        int n=nums.length;\\n        \\n        for(int num: nums){\\n            max=Math.max(max,num);\\n            min=Math.min(min,num);\\n        }\\n        if(max==min){\\n            return 0;\\n        }\\n        int avgGap=(int)Math.ceil((double)(max-min)/(n-1));\\n        int bucketCount=(max-min+1)/avgGap+1;\\n        int[] minBucket=new int[bucketCount];\\n        int[] maxBucket=new int[bucketCount];\\n        \\n        Arrays.fill(maxBucket, -1);\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        \\n        for(int num: nums){\\n            int bucketIdx=(num-min)/avgGap;\\n            \\n            minBucket[bucketIdx]=Math.min(minBucket[bucketIdx],num);\\n            maxBucket[bucketIdx]=Math.max(maxBucket[bucketIdx],num);\\n        }\\n        \\n        int maxGap=avgGap;\\n        int prev=-1;\\n        for(int i=0;i<bucketCount;i++){\\n            if(maxBucket[i]==-1){\\n                continue;\\n            }else if(prev!=-1){\\n                maxGap=Math.max(maxGap,minBucket[i]-prev);\\n            }\\n            prev=maxBucket[i];\\n        }\\n        return maxGap;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length==1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2426405,
                "title": "java-solution-o-n-logn",
                "content": "if(nums.length <2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        int maxDifference = Integer.MIN_VALUE;\\n        for(int i=0; i<nums.length-1; i++) {\\n            int diff = nums[i+1]-nums[i];\\n            if(diff > maxDifference) {\\n                maxDifference = diff;\\n            }\\n        }\\n        return maxDifference;",
                "solutionTags": [],
                "code": "if(nums.length <2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        int maxDifference = Integer.MIN_VALUE;\\n        for(int i=0; i<nums.length-1; i++) {\\n            int diff = nums[i+1]-nums[i];\\n            if(diff > maxDifference) {\\n                maxDifference = diff;\\n            }\\n        }\\n        return maxDifference;",
                "codeTag": "Unknown"
            },
            {
                "id": 2421242,
                "title": "java-linear-solution-using-bucket-sort-beats-71",
                "content": "```\\nclass Solution {\\n    class pair{\\n        int f;\\n        int s;\\n        pair(int f , int s){\\n            this.f = f;\\n            this.s = s;\\n        }\\n    }\\n    int inf = Integer.MAX_VALUE;\\n    int nrk = Integer.MIN_VALUE;\\n    public int maximumGap(int a[]) {\\n        int n = a.length;\\n        if(n < 2) return 0;\\n        pair v[] = new pair[n - 1];\\n        for(int i = 0; i < n - 1; i++){\\n            v[i] = new pair(inf , nrk);\\n        }\\n        int mx = nrk;\\n        int mn = inf;\\n        for(int e : a){\\n            mx = Math.max(mx , e);\\n            mn = Math.min(mn , e);\\n        }\\n        double gap = (double)(mx - mn) / (double)(n - 1);\\n        for(int e : a){\\n            if(e == mn || e == mx) continue;\\n            int idx = (int)((double)(e - mn) / (double)gap);\\n            v[idx].f = Math.min(v[idx].f , e);\\n            v[idx].s = Math.max(v[idx].s , e);\\n        }\\n        int prev = mn;\\n        int max = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            if(v[i].f == inf) continue;\\n            max = Math.max(max , v[i].f - prev);\\n            prev = v[i].s;\\n        }\\n        return Math.max(max , mx - prev);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "class Solution {\\n    class pair{\\n        int f;\\n        int s;\\n        pair(int f , int s){\\n            this.f = f;\\n            this.s = s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2390211,
                "title": "python-o-n-bucket-sort-commented-with-explanation",
                "content": "**tl;dr**\\n\\nBLAH.... that is all\\n\\np.s. radix sorting is probably easier and more intuitive than this.\\n\\n**Solution**\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        \"\"\"\\n        We use bucket sort to achieve O(n) runtime. However,\\n        instead of using values as bucket index, we use a \"gap\" index\\n        to fit a value into a range where its gaps **within the bucket** is\\n\\t\\tless than **gaps between buckets**.\\n        \\n        For example:\\n        \\n        [4, 3, 9, 1]\\n        \\n        min = 1\\n        max = 9\\n        total_gap = (9-1) = 8 (this is the gap across the entire array)\\n       \\n        If we do a normal bucket sort, our buckets would look like:\\n        \\n                    0  1  2  3  4  5  6  7\\n          buckets  [1][ ][3][4][ ][ ][ ][9]\\n       \\n        However, this is no longer linear space and the num can go up\\n        to 10**9. Instead, we will need to limit our buckets. Keep in mind\\n        we ONLY need to find the maximum GAP. So we only need to keep\\n        enough numbers sorted to help us determine that answer.\\n        \\n        Let\\'s summarize what we know:\\n        \\n        1. Our total gap is 8\\n        2. We have 4 elements, which means we have (4-1) gaps\\n        3. We can think of the above as:\\n        \\n           gap_0 + gap_1 + gap_2 = 8 (total_gap)\\n\\n        What if we make our gap index the bucket index instead?\\n           \\n        4. We know for sure that there will be at least two buckets\\n           populated with >= 1 element. Why? If everything is in one\\n           bucket, we would never get total_gap of 8. \\n        \\n        This leads us to an important realization:\\n        \\n        5. Our answer will always be the gap between two buckets,\\n           instead a gap inside elements of the same bucket. Gap between two\\n           buckets will always be >= gap within a single bucket.\\n\\n        6. So we just need to figure out which bucket a number would go into.\\n           Then within each bucket, we keep track of the min/max.\\n           Then lastly, we will iterate through all the buckets to identify\\n           the maximum gap (which we know will be between two buckets).\\n        \"\"\"\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        \\n        # find the min and max in the array\\n        # this gives us the range that gaps will fall into\\n        min_num = min(nums)\\n        max_num = max(nums)\\n        total_gap = max_num - min_num\\n        if total_gap == 0:\\n            # no gap, all are equal\\n            return 0\\n        \\n        # if we have n elements, we have n - 1 gaps\\n        gap_count = n - 1\\n        \\n        # find the minimum bucket size needed.\\n        bucket_size = math.ceil(total_gap / gap_count)\\n        \\n        # keep track of min/max at each bucket\\n        bucket_min = [float(\"inf\")] * n\\n        bucket_max = [float(\"-inf\")] * n\\n        \\n        # assign our numbers to a bucket\\n        for num in nums:\\n            bucket_idx = (num - min_num) // bucket_size\\n            bucket_min[bucket_idx] = min(bucket_min[bucket_idx], num)\\n            bucket_max[bucket_idx] = max(bucket_max[bucket_idx], num)\\n        \\n        # iterate through each bucket\\n        # while keeping track of the max gap between buckets\\n        res = 0\\n        \\n        prev_bucket_max = bucket_max[0]\\n        for i in range(1, n):\\n            if bucket_min[i] == float(\"inf\"):\\n                # we didn\\'t put anything in this bucket, skip\\n                continue\\n            \\n            # see if gap between this bucket and previous bucket\\n            # is larger than result\\n            res = max(res, bucket_min[i] - prev_bucket_max)\\n            prev_bucket_max = bucket_max[i]\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        \"\"\"\\n        We use bucket sort to achieve O(n) runtime. However,\\n        instead of using values as bucket index, we use a \"gap\" index\\n        to fit a value into a range where its gaps **within the bucket** is\\n\\t\\tless than **gaps between buckets**.\\n        \\n        For example:\\n        \\n        [4, 3, 9, 1]\\n        \\n        min = 1\\n        max = 9\\n        total_gap = (9-1) = 8 (this is the gap across the entire array)\\n       \\n        If we do a normal bucket sort, our buckets would look like:\\n        \\n                    0  1  2  3  4  5  6  7\\n          buckets  [1][ ][3][4][ ][ ][ ][9]\\n       \\n        However, this is no longer linear space and the num can go up\\n        to 10**9. Instead, we will need to limit our buckets. Keep in mind\\n        we ONLY need to find the maximum GAP. So we only need to keep\\n        enough numbers sorted to help us determine that answer.\\n        \\n        Let\\'s summarize what we know:\\n        \\n        1. Our total gap is 8\\n        2. We have 4 elements, which means we have (4-1) gaps\\n        3. We can think of the above as:\\n        \\n           gap_0 + gap_1 + gap_2 = 8 (total_gap)\\n\\n        What if we make our gap index the bucket index instead?\\n           \\n        4. We know for sure that there will be at least two buckets\\n           populated with >= 1 element. Why? If everything is in one\\n           bucket, we would never get total_gap of 8. \\n        \\n        This leads us to an important realization:\\n        \\n        5. Our answer will always be the gap between two buckets,\\n           instead a gap inside elements of the same bucket. Gap between two\\n           buckets will always be >= gap within a single bucket.\\n\\n        6. So we just need to figure out which bucket a number would go into.\\n           Then within each bucket, we keep track of the min/max.\\n           Then lastly, we will iterate through all the buckets to identify\\n           the maximum gap (which we know will be between two buckets).\\n        \"\"\"\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        \\n        # find the min and max in the array\\n        # this gives us the range that gaps will fall into\\n        min_num = min(nums)\\n        max_num = max(nums)\\n        total_gap = max_num - min_num\\n        if total_gap == 0:\\n            # no gap, all are equal\\n            return 0\\n        \\n        # if we have n elements, we have n - 1 gaps\\n        gap_count = n - 1\\n        \\n        # find the minimum bucket size needed.\\n        bucket_size = math.ceil(total_gap / gap_count)\\n        \\n        # keep track of min/max at each bucket\\n        bucket_min = [float(\"inf\")] * n\\n        bucket_max = [float(\"-inf\")] * n\\n        \\n        # assign our numbers to a bucket\\n        for num in nums:\\n            bucket_idx = (num - min_num) // bucket_size\\n            bucket_min[bucket_idx] = min(bucket_min[bucket_idx], num)\\n            bucket_max[bucket_idx] = max(bucket_max[bucket_idx], num)\\n        \\n        # iterate through each bucket\\n        # while keeping track of the max gap between buckets\\n        res = 0\\n        \\n        prev_bucket_max = bucket_max[0]\\n        for i in range(1, n):\\n            if bucket_min[i] == float(\"inf\"):\\n                # we didn\\'t put anything in this bucket, skip\\n                continue\\n            \\n            # see if gap between this bucket and previous bucket\\n            # is larger than result\\n            res = max(res, bucket_min[i] - prev_bucket_max)\\n            prev_bucket_max = bucket_max[i]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374852,
                "title": "c-easiest-and-simplest-solution-no-concepts-required",
                "content": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n       \\n\\t    int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        if(n==1)\\n            return 0;\\n\\t\\t\\t\\n        int diff = nums[1]- nums[0];\\n        for(int i=1; i<n; i++){\\n            if(nums[i]-nums[i-1] > diff)\\n                diff = nums[i]-nums[i-1];\\n        }\\n        return diff;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n       \\n\\t    int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        if(n==1)\\n            return 0;\\n\\t\\t\\t\\n        int diff = nums[1]- nums[0];\\n        for(int i=1; i<n; i++){\\n            if(nums[i]-nums[i-1] > diff)\\n                diff = nums[i]-nums[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2360155,
                "title": "treeset-solution-in-java",
                "content": "```\\npublic int maximumGap(int[] nums) {\\n\\n\\tTreeSet<Integer> st = Arrays.stream(nums)\\n\\t\\t\\t\\t\\t\\t\\t\\t.boxed()\\n\\t\\t\\t\\t\\t\\t\\t\\t.collect(Collectors.toCollection(TreeSet::new));\\n\\n\\tint maxGap = 0;\\n\\tint prev = -1;\\n\\n\\tfor (int num : st)  {                         \\n\\t\\tif (prev == -1) {\\n\\t\\t\\tprev = num;\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tmaxGap = Math.max(maxGap, num - prev);\\n\\t\\t\\tprev = num;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxGap;\\n}\\n```\\n\\nTC : O(N)\\nSC : O(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumGap(int[] nums) {\\n\\n\\tTreeSet<Integer> st = Arrays.stream(nums)\\n\\t\\t\\t\\t\\t\\t\\t\\t.boxed()\\n\\t\\t\\t\\t\\t\\t\\t\\t.collect(Collectors.toCollection(TreeSet::new));\\n\\n\\tint maxGap = 0;\\n\\tint prev = -1;\\n\\n\\tfor (int num : st)  {                         \\n\\t\\tif (prev == -1) {\\n\\t\\t\\tprev = num;\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tmaxGap = Math.max(maxGap, num - prev);\\n\\t\\t\\tprev = num;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxGap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2296354,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)<2:\\n            return 0\\n        if len(nums)==2:\\n            return abs(nums[0]-nums[1])\\n        nums.sort()\\n        md=abs(nums[0]-nums[1])\\n        for i in range(1,len(nums)):\\n            if md<(abs(nums[i]-nums[i-1])):\\n                md=abs(nums[i]-nums[i-1])\\n        return md\\n```\\nI\\'ve tried solving it by taking a \"md\" max difference variable and initialising it to the first two elements difference and then checking all the other consecutive element\\'s difference \\nI think this is not the optimal way to do this but this worked \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)<2:\\n            return 0\\n        if len(nums)==2:\\n            return abs(nums[0]-nums[1])\\n        nums.sort()\\n        md=abs(nums[0]-nums[1])\\n        for i in range(1,len(nums)):\\n            if md<(abs(nums[i]-nums[i-1])):\\n                md=abs(nums[i]-nums[i-1])\\n        return md\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284722,
                "title": "easy-o-n-95-faster-java-bucket-sort",
                "content": "Hope It will help you.\\n...\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumGap(int[] nums) {\\n\\t\\t   int n = nums.length;\\n\\n\\t\\t   if(n < 2)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = -1;\\n\\n\\t\\t\\tfor(int num : nums){\\n\\t\\t\\t\\tmin = Math.min(min, num);\\n\\t\\t\\t\\tmax = Math.max(max, num);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//average interval/gap -> total gap / no of gaps\\n\\t\\t\\t//no of gaps = n - 1\\n\\t\\t\\tint interval = (int)(Math.ceil((max - min + 0.0) / (n - 1)));\\n\\t\\t\\tif(interval == 0)//all are equal\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t//there is atleast one gap of >= interval to make total gap\\n\\t\\t\\t//eg. if total = 7, no of gap = 3, then at least one gap is >= 3\\n\\t\\t\\t//bcz if we take 3 gaps of 2 -> then it can not make 7\\n\\n\\t\\t\\t//maxGap >= interval\\n\\t\\t\\t//try to sort the array by bucket sort\\n\\t\\t\\t//bucket contains elemnts whose gap is less than interval -> the gap b/w elemnts in a single bucket not gives max Gap\\n\\n\\t\\t\\tint[] bucketMin = new int[n];\\n\\t\\t\\tint[] bucketMax = new int[n];\\n\\t\\t\\t//is no of gaps of size interval\\n\\t\\t\\t//[i] - bcket can have min + i * interval to min + (i + 1) * interval - 1\\n\\n\\t\\t\\tArrays.fill(bucketMin, Integer.MAX_VALUE);\\n\\t\\t\\tArrays.fill(bucketMax, Integer.MIN_VALUE);\\n\\t\\t\\t//we only neeed to store min and max of bucket -> bcz distance between successive elemnts between 2 buckets can give gap >= interval\\n\\n\\t\\t\\t//fill bucket\\n\\t\\t\\tfor(int num : nums){\\n\\t\\t\\t\\tint index = (num - min) / interval;\\n\\n\\t\\t\\t\\tbucketMin[index] = Math.min(bucketMin[index], num);\\n\\t\\t\\t\\tbucketMax[index] = Math.max(bucketMax[index], num);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//check b/w successive points\\n\\t\\t\\tint prev = min;\\n\\t\\t\\tint maxGap = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tif(bucketMin[i] == Integer.MAX_VALUE)//no element in this bucket\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tint gap = bucketMin[i] - prev;\\n\\t\\t\\t\\tmaxGap = Math.max(maxGap, gap);\\n\\n\\t\\t\\t\\tprev = bucketMax[i];//prev for next min\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxGap;\\n\\t\\t}\\n\\t}\\n\\n...",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bucket Sort"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maximumGap(int[] nums) {\\n\\t\\t   int n = nums.length;\\n\\n\\t\\t   if(n < 2)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = -1;\\n\\n\\t\\t\\tfor(int num : nums){\\n\\t\\t\\t\\tmin = Math.min(min, num);\\n\\t\\t\\t\\tmax = Math.max(max, num);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2281883,
                "title": "using-set-unique-solution",
                "content": "```\\n   int maximumGap(vector<int>& v) {\\n        if(v.size() < 2) return 0;\\n        set<int> s; int ans = INT_MIN; int dif = 0;\\n        int t = 0;\\n        copy(v.begin(),v.end(),inserter(s, s.end()));\\n        set<int>::iterator it = s.begin();\\n        int prev = (*it);\\n        while(it != s.end()){\\n            t = (*it);\\n            dif = t - prev;\\n            ans = max(ans,dif);\\n            prev = t;\\n            it++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int maximumGap(vector<int>& v) {\\n        if(v.size() < 2) return 0;\\n        set<int> s; int ans = INT_MIN; int dif = 0;\\n        int t = 0;\\n        copy(v.begin(),v.end(),inserter(s, s.end()));\\n        set<int>::iterator it = s.begin();\\n        int prev = (*it);\\n        while(it != s.end()){\\n            t = (*it);\\n            dif = t - prev;\\n            ans = max(ans,dif);\\n            prev = t;\\n            it++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2253358,
                "title": "python-bucket-sort-solution",
                "content": "```\\ndef maximumGap(self, nums: List[int]) -> int:\\n\\tmn, mx, n = min(nums), max(nums), len(nums)\\n\\tif len(nums)<2 or mx==mn:\\n\\t\\treturn 0\\n\\tstep = math.ceil((mx-mn)/(n-1))\\n\\tbuckets = [[] for _ in range((mx-mn)//step+1)]\\n\\tfor n in nums:\\n\\t\\tidx = (n-mn)//step\\n\\t\\tif not buckets[idx]:\\n\\t\\t\\tbuckets[idx] = [n, n]\\n\\t\\telse:\\n\\t\\t\\ta, b = buckets[idx]\\n\\t\\t\\tbuckets[idx] = [min(a, n), max(b, n)]\\n\\tbuckets = [b for b in buckets if b]\\n\\treturn max(buckets[i+1][0]-buckets[i][1] for i in range(len(buckets)-1))\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumGap(self, nums: List[int]) -> int:\\n\\tmn, mx, n = min(nums), max(nums), len(nums)\\n\\tif len(nums)<2 or mx==mn:\\n\\t\\treturn 0\\n\\tstep = math.ceil((mx-mn)/(n-1))\\n\\tbuckets = [[] for _ in range((mx-mn)//step+1)]\\n\\tfor n in nums:\\n\\t\\tidx = (n-mn)//step\\n\\t\\tif not buckets[idx]:\\n\\t\\t\\tbuckets[idx] = [n, n]\\n\\t\\telse:\\n\\t\\t\\ta, b = buckets[idx]\\n\\t\\t\\tbuckets[idx] = [min(a, n), max(b, n)]\\n\\tbuckets = [b for b in buckets if b]\\n\\treturn max(buckets[i+1][0]-buckets[i][1] for i in range(len(buckets)-1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2246694,
                "title": "code-working-in-local-but-not-in-leetcode-ide",
                "content": "Here is my code which seems to work fine in my local for the same test cases for which leetcode IDE is giving Wrong Answer. \\nAlso the same input is giving correct output when executed manually in Testcase window (problem link : https://leetcode.com/problems/maximum-gap/) FYI\\nAny suggestions will be appreciated,\\n```\\nclass Solution {\\n    \\n    static int prev = -1;\\n    static int MAX_BITS = 32;\\n    static int powersOf2 [] = new int[MAX_BITS];\\n    static int maxDiff = 0;\\n    \\n    public int maximumGap(int[] nums) {\\n        powersOf2[0] = 1;\\n        for(int i = 1; i < MAX_BITS; i++) {\\n            powersOf2[i] = 2*powersOf2[i - 1];\\n        }\\n\\n\\n        Node ROOT = new Node();\\n        for(int i = 0; i < nums.length ; i++) {\\n            addToTrieTree(ROOT, nums[i]);\\n        }\\n\\n        preOrder(ROOT, MAX_BITS - 1, 0);\\n        return maxDiff;\\n    }\\n    \\n      public void preOrder(Node node, int index, int num) {\\n\\n        if (index == -1) {\\n            if (prev != -1) {\\n                maxDiff = Math.max(maxDiff, num - prev);\\n            }\\n            prev = num;\\n        }\\n\\n        if(node.left != null) {\\n            preOrder(node.left, index - 1, num);\\n        }\\n\\n        if(node.right != null) {\\n            preOrder(node.right, index - 1, num + powersOf2[index]);\\n        }\\n\\n    }\\n\\n    public void addToTrieTree(Node root, int num) {\\n\\n        int binary[] = getBinary(num);\\n\\n        for(int i = 0; i < binary.length ; i++) {\\n\\n            if(binary[i] == 0) {\\n                if (root.left == null) {\\n                    root.left = new Node();\\n                }\\n                root = root.left;\\n\\n            } else {\\n                if (root.right == null) {\\n                    root.right = new Node();\\n\\n                }\\n                root = root.right;\\n            }\\n        }\\n    }\\n\\n    public int[] getBinary(int num) {\\n\\n        int binary[] = new int[MAX_BITS];\\n        int index = MAX_BITS - 1;\\n        while (num > 0)  {\\n            binary[index--] = num % 2;\\n            num /= 2;\\n        }\\n        return binary;\\n    }\\n}\\n\\nclass Node {\\n    Node left, right;\\n}\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int prev = -1;\\n    static int MAX_BITS = 32;\\n    static int powersOf2 [] = new int[MAX_BITS];\\n    static int maxDiff = 0;\\n    \\n    public int maximumGap(int[] nums) {\\n        powersOf2[0] = 1;\\n        for(int i = 1; i < MAX_BITS; i++) {\\n            powersOf2[i] = 2*powersOf2[i - 1];\\n        }\\n\\n\\n        Node ROOT = new Node();\\n        for(int i = 0; i < nums.length ; i++) {\\n            addToTrieTree(ROOT, nums[i]);\\n        }\\n\\n        preOrder(ROOT, MAX_BITS - 1, 0);\\n        return maxDiff;\\n    }\\n    \\n      public void preOrder(Node node, int index, int num) {\\n\\n        if (index == -1) {\\n            if (prev != -1) {\\n                maxDiff = Math.max(maxDiff, num - prev);\\n            }\\n            prev = num;\\n        }\\n\\n        if(node.left != null) {\\n            preOrder(node.left, index - 1, num);\\n        }\\n\\n        if(node.right != null) {\\n            preOrder(node.right, index - 1, num + powersOf2[index]);\\n        }\\n\\n    }\\n\\n    public void addToTrieTree(Node root, int num) {\\n\\n        int binary[] = getBinary(num);\\n\\n        for(int i = 0; i < binary.length ; i++) {\\n\\n            if(binary[i] == 0) {\\n                if (root.left == null) {\\n                    root.left = new Node();\\n                }\\n                root = root.left;\\n\\n            } else {\\n                if (root.right == null) {\\n                    root.right = new Node();\\n\\n                }\\n                root = root.right;\\n            }\\n        }\\n    }\\n\\n    public int[] getBinary(int num) {\\n\\n        int binary[] = new int[MAX_BITS];\\n        int index = MAX_BITS - 1;\\n        while (num > 0)  {\\n            binary[index--] = num % 2;\\n            num /= 2;\\n        }\\n        return binary;\\n    }\\n}\\n\\nclass Node {\\n    Node left, right;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226760,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bucket***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        if(n < 2)\\n            return 0;\\n        \\n        // find maximum and minimum element of the array\\n        \\n        int maxi = *max_element(nums.begin(), nums.end());\\n        \\n        int mini = *min_element(nums.begin(), nums.end());\\n        \\n        // find the gap\\n        \\n        int gap = ((maxi - mini) / (n - 1)) + 1;\\n        \\n        // min_bucket[i] store the min of that bucket\\n        \\n        vector<int> min_bucket(n - 1, INT_MAX);\\n        \\n        // max_bucket[i] store the max of that bucket\\n        \\n        vector<int> max_bucket(n - 1, INT_MIN);\\n        \\n        // fill the min_bucket and max_bucket\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] != mini && nums[i] != maxi)\\n            {\\n                // index of bucket\\n                \\n                int buk_idx = (nums[i] - mini) / gap;\\n                \\n                min_bucket[buk_idx] = min(min_bucket[buk_idx], nums[i]);\\n                \\n                max_bucket[buk_idx] = max(max_bucket[buk_idx], nums[i]);\\n            }\\n        }\\n        \\n        // now traverse over buckets and find max_gap\\n        \\n        int max_gap = INT_MIN;\\n        \\n        // prev store max of prev bucket\\n        \\n        int prev = mini;\\n        \\n        // find max gap\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            // if bucket is not empty\\n            \\n            if(min_bucket[i] != INT_MAX && max_bucket[i] != INT_MIN)\\n            {\\n                int curr_gap = min_bucket[i] - prev;\\n                \\n                max_gap = max(max_gap, curr_gap);\\n                \\n                prev = max(prev, max_bucket[i]);\\n            }\\n        }\\n        \\n        max_gap = max(max_gap, maxi - prev);\\n        \\n        return max_gap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        if(n < 2)\\n            return 0;\\n        \\n        // find maximum and minimum element of the array\\n        \\n        int maxi = *max_element(nums.begin(), nums.end());\\n        \\n        int mini = *min_element(nums.begin(), nums.end());\\n        \\n        // find the gap\\n        \\n        int gap = ((maxi - mini) / (n - 1)) + 1;\\n        \\n        // min_bucket[i] store the min of that bucket\\n        \\n        vector<int> min_bucket(n - 1, INT_MAX);\\n        \\n        // max_bucket[i] store the max of that bucket\\n        \\n        vector<int> max_bucket(n - 1, INT_MIN);\\n        \\n        // fill the min_bucket and max_bucket\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] != mini && nums[i] != maxi)\\n            {\\n                // index of bucket\\n                \\n                int buk_idx = (nums[i] - mini) / gap;\\n                \\n                min_bucket[buk_idx] = min(min_bucket[buk_idx], nums[i]);\\n                \\n                max_bucket[buk_idx] = max(max_bucket[buk_idx], nums[i]);\\n            }\\n        }\\n        \\n        // now traverse over buckets and find max_gap\\n        \\n        int max_gap = INT_MIN;\\n        \\n        // prev store max of prev bucket\\n        \\n        int prev = mini;\\n        \\n        // find max gap\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            // if bucket is not empty\\n            \\n            if(min_bucket[i] != INT_MAX && max_bucket[i] != INT_MIN)\\n            {\\n                int curr_gap = min_bucket[i] - prev;\\n                \\n                max_gap = max(max_gap, curr_gap);\\n                \\n                prev = max(prev, max_bucket[i]);\\n            }\\n        }\\n        \\n        max_gap = max(max_gap, maxi - prev);\\n        \\n        return max_gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196625,
                "title": "radix-sort-javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\n//check \"https://visualgo.net/en/sorting\" for radix sort\\'s logic\\n\\nconst radixSort = (nums) => {\\n    var bucket = Array(10).fill().map(subArr => subArr = Array());\\n    var max = Math.max(...nums);//find max digit\\n    \\n    var digit = String(max).length;\\n    for(var i = digit; i != -1; i--) {\\n        nums.forEach(num => {\\n            var temp = \\'\\';\\n            var size = String(num).length;// check if number lenght is less than digit\\n            if(size <= digit) {\\n                temp = \\'0\\'.repeat(digit-size+1) + String(num); //if numbers digit count is less than digit to avoid out of index err adding 0 to first\\n            } else {                                          // like 00041\\n                temp = String(num); // if not just parse to string\\n            }\\n            bucket[parseInt(temp.charAt(i))].push(num); // parseInt(temp.charAt(i)) // Checking i\\'th digit of number\\n        })                                              // parsing string then checking is more easy than checking on numbers\\n        nums = [] //reseting nums\\n        for(var arr of bucket) {\\n            if(arr.length != 0) nums.push(...arr) //inserting sorted numbers to nums\\n        }\\n        bucket = Array(10).fill().map(subArr => subArr = Array(0)); //reseting bucket\\n    }\\n    return nums; //it doesnt affect nums in parameter so we are returning other one\\n}\\n\\nconst maximumGap = (nums) => {\\n    var array = radixSort(nums)\\n    //here radix sort is completed and array is sorted nums\\n    //console.log(array) //controls\\n    var maxDiff = 0\\n    for(var i = 1;i<array.length;i++) { //find maxDiff\\n        maxDiff = Math.max(maxDiff,array[i] - array[i-1]);\\n    }\\n    //console.log(maxDiff) //controls\\n    return maxDiff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\n//check \"https://visualgo.net/en/sorting\" for radix sort\\'s logic\\n\\nconst radixSort = (nums) => {\\n    var bucket = Array(10).fill().map(subArr => subArr = Array());\\n    var max = Math.max(...nums);//find max digit\\n    \\n    var digit = String(max).length;\\n    for(var i = digit; i != -1; i--) {\\n        nums.forEach(num => {\\n            var temp = \\'\\';\\n            var size = String(num).length;// check if number lenght is less than digit\\n            if(size <= digit) {\\n                temp = \\'0\\'.repeat(digit-size+1) + String(num); //if numbers digit count is less than digit to avoid out of index err adding 0 to first\\n            } else {                                          // like 00041\\n                temp = String(num); // if not just parse to string\\n            }\\n            bucket[parseInt(temp.charAt(i))].push(num); // parseInt(temp.charAt(i)) // Checking i\\'th digit of number\\n        })                                              // parsing string then checking is more easy than checking on numbers\\n        nums = [] //reseting nums\\n        for(var arr of bucket) {\\n            if(arr.length != 0) nums.push(...arr) //inserting sorted numbers to nums\\n        }\\n        bucket = Array(10).fill().map(subArr => subArr = Array(0)); //reseting bucket\\n    }\\n    return nums; //it doesnt affect nums in parameter so we are returning other one\\n}\\n\\nconst maximumGap = (nums) => {\\n    var array = radixSort(nums)\\n    //here radix sort is completed and array is sorted nums\\n    //console.log(array) //controls\\n    var maxDiff = 0\\n    for(var i = 1;i<array.length;i++) { //find maxDiff\\n        maxDiff = Math.max(maxDiff,array[i] - array[i-1]);\\n    }\\n    //console.log(maxDiff) //controls\\n    return maxDiff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2179653,
                "title": "c-radix-sort-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void countSort(vector<int> &nums, const int exp){\\n        int N = nums.size();\\n        int output[N];\\n        int count[10] = {};\\n        \\n\\t\\t//For exp = 100, num = 19403, num/exp = 194, (num/exp)%10 = 4\\n        for(const int &num : nums){\\n            int idx = (num/exp)%10;\\n            count[idx]++;\\n        }\\n        \\n\\t\\t // Change count[i] so that count[i] now contains actual\\n\\t\\t//  position of this digit in output[]\\n        for(int i = 1; i < 10; i++){\\n            count[i] += count[i-1];\\n        }\\n        \\n        for(int i = N-1; i >= 0; i--){\\n            int idx = (nums[i]/exp)%10;\\n            int outputIdx = --count[idx];\\n            output[outputIdx] = nums[i];\\n        }\\n        \\n        for(int i = 0; i < N; i++){\\n            nums[i] = output[i];\\n        }\\n        return;\\n    }\\n    void radixSort(vector<int> &nums){\\n        int maxi = *max_element(begin(nums), end(nums));\\n        //For maxi = 19403, exp = 1, 10, 100, 1000, 10000\\n\\t\\t// Do counting sort for every digit. Note that instead of passing digit number, exp is passed. exp is 10^i\\n        // where i is current digit number\\n        for(int exp = 1; maxi/exp > 0; exp *= 10){\\n            countSort(nums, exp);\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        radixSort(nums);\\n        int res = 0;\\n        int N = nums.size();\\n        for(int i = 1; i < N; i++){\\n            res = max(res, nums[i] - nums[i-1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void countSort(vector<int> &nums, const int exp){\\n        int N = nums.size();\\n        int output[N];\\n        int count[10] = {};\\n        \\n\\t\\t//For exp = 100, num = 19403, num/exp = 194, (num/exp)%10 = 4\\n        for(const int &num : nums){\\n            int idx = (num/exp)%10;\\n            count[idx]++;\\n        }\\n        \\n\\t\\t // Change count[i] so that count[i] now contains actual\\n\\t\\t//  position of this digit in output[]\\n        for(int i = 1; i < 10; i++){\\n            count[i] += count[i-1];\\n        }\\n        \\n        for(int i = N-1; i >= 0; i--){\\n            int idx = (nums[i]/exp)%10;\\n            int outputIdx = --count[idx];\\n            output[outputIdx] = nums[i];\\n        }\\n        \\n        for(int i = 0; i < N; i++){\\n            nums[i] = output[i];\\n        }\\n        return;\\n    }\\n    void radixSort(vector<int> &nums){\\n        int maxi = *max_element(begin(nums), end(nums));\\n        //For maxi = 19403, exp = 1, 10, 100, 1000, 10000\\n\\t\\t// Do counting sort for every digit. Note that instead of passing digit number, exp is passed. exp is 10^i\\n        // where i is current digit number\\n        for(int exp = 1; maxi/exp > 0; exp *= 10){\\n            countSort(nums, exp);\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        radixSort(nums);\\n        int res = 0;\\n        int N = nums.size();\\n        for(int i = 1; i < N; i++){\\n            res = max(res, nums[i] - nums[i-1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131103,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=INT_MIN;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=max(ans,nums[i+1]-nums[i]);\\n        }\\n        if(n>1)\\n            return ans;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=INT_MIN;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=max(ans,nums[i+1]-nums[i]);\\n        }\\n        if(n>1)\\n            return ans;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073308,
                "title": "c-time-space-o-n-96-fast-explanation",
                "content": "```\\n// The assamtion is that the larger gap will be >= (max-min)/n.\\n// By deviding the range for block smaller than (max-min)/n we make sure that the 2 related numbers not in the same block;\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n<2) return 0;\\n        int min_ = INT_MAX;\\n        int max_ = INT_MIN;\\n        for(auto& num : nums)\\n        {\\n            max_ = max(max_,num);\\n            min_ = min(min_,num);\\n        }\\n        \\n        if (min_ == max_) return 0;\\n        int block_size = (max_ - min_)/(n-1);\\n        if (block_size == 0) block_size = 1;\\n        int m = (max_ - min_)/block_size+1;\\n        vector<pair<int,int>> blocks(m,{INT_MAX,INT_MIN});\\n        \\n        for(auto num: nums)\\n        {\\n            int ix;\\n            if (num == min_) ix = 0;\\n            else\\n                ix = (num - min_)/block_size;\\n\\n            blocks[ix].first = min(blocks[ix].first,num);\\n            blocks[ix].second = max(blocks[ix].second,num);\\n        }\\n        \\n        int ans = 0;\\n        int p = min_;\\n        for(auto& block : blocks)        \\n        {\\n            if (block.first == INT_MAX) continue;\\n            ans = max(ans,block.first-p);\\n            p = block.second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// The assamtion is that the larger gap will be >= (max-min)/n.\\n// By deviding the range for block smaller than (max-min)/n we make sure that the 2 related numbers not in the same block;\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n<2) return 0;\\n        int min_ = INT_MAX;\\n        int max_ = INT_MIN;\\n        for(auto& num : nums)\\n        {\\n            max_ = max(max_,num);\\n            min_ = min(min_,num);\\n        }\\n        \\n        if (min_ == max_) return 0;\\n        int block_size = (max_ - min_)/(n-1);\\n        if (block_size == 0) block_size = 1;\\n        int m = (max_ - min_)/block_size+1;\\n        vector<pair<int,int>> blocks(m,{INT_MAX,INT_MIN});\\n        \\n        for(auto num: nums)\\n        {\\n            int ix;\\n            if (num == min_) ix = 0;\\n            else\\n                ix = (num - min_)/block_size;\\n\\n            blocks[ix].first = min(blocks[ix].first,num);\\n            blocks[ix].second = max(blocks[ix].second,num);\\n        }\\n        \\n        int ans = 0;\\n        int p = min_;\\n        for(auto& block : blocks)        \\n        {\\n            if (block.first == INT_MAX) continue;\\n            ans = max(ans,block.first-p);\\n            p = block.second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066629,
                "title": "here-is-the-post-to-understand-completely",
                "content": "For finding maximum gap we are making bucket for putting middle n-2 elements and bucket size will be n-1 means (smallest and largest elements are to be avoided) means there will be one bucket that will be empty so that previous max and next mix elements of bucket will give the max difference. For doing so we make the bucket of size n-1 for both storing max and min element in the bucket and bucket will contain and bucket will store (max-min)/n-1 range of elements . Now we start putting elements in bucket so for checking in which index we have to put that element we find (x-min)/avg and avg is (max-min)/n-1 so we get the index and we fill max and min buckets with this elements . Now we simply take difference between max of one bucket and min of next bucket.\\n\\n```\\nclass Solution {\\n    public int maximumGap(int[] arr) {\\n        int n=arr.length;\\n        if(n<2)return 0;\\n        int max=arr[0],min=arr[0];\\n        for(int x:arr){\\n            max=Math.max(max,x);\\n            min=Math.min(min,x);\\n        }\\n        int avg=(int)Math.ceil((max-min+0.0)/(n-1));\\n        \\n        int []maxB=new int[n-1];\\n        int []minB=new int[n-1];\\n        \\n        Arrays.fill(maxB,-1);\\n        Arrays.fill(minB,Integer.MAX_VALUE);\\n        \\n        for(int x:arr){\\n            if(x==max||x==min){\\n                continue;\\n            }\\n            \\n            int index=(x-min)/avg;\\n            maxB[index]=Math.max(maxB[index],x);\\n            minB[index]=Math.min(minB[index],x);\\n        }\\n        \\n        int prev=min;\\n        int ans=0;\\n        \\n        for(int i=0;i<maxB.length;i++){\\n            if(maxB[i]==-1)continue;\\n            ans=Math.max(ans,minB[i]-prev);\\n            prev=maxB[i];\\n        }\\n        ans=Math.max(ans,max-prev);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] arr) {\\n        int n=arr.length;\\n        if(n<2)return 0;\\n        int max=arr[0],min=arr[0];\\n        for(int x:arr){\\n            max=Math.max(max,x);\\n            min=Math.min(min,x);\\n        }\\n        int avg=(int)Math.ceil((max-min+0.0)/(n-1));\\n        \\n        int []maxB=new int[n-1];\\n        int []minB=new int[n-1];\\n        \\n        Arrays.fill(maxB,-1);\\n        Arrays.fill(minB,Integer.MAX_VALUE);\\n        \\n        for(int x:arr){\\n            if(x==max||x==min){\\n                continue;\\n            }\\n            \\n            int index=(x-min)/avg;\\n            maxB[index]=Math.max(maxB[index],x);\\n            minB[index]=Math.min(minB[index],x);\\n        }\\n        \\n        int prev=min;\\n        int ans=0;\\n        \\n        for(int i=0;i<maxB.length;i++){\\n            if(maxB[i]==-1)continue;\\n            ans=Math.max(ans,minB[i]-prev);\\n            prev=maxB[i];\\n        }\\n        ans=Math.max(ans,max-prev);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050642,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        c=[]\\n        a=sorted(nums)\\n        if len(a)<2:\\n            c.append(0)\\n        else:\\n            for i in range(len(a)-1):\\n                c.append(a[i+1]-a[i])\\n        return(max(c))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        c=[]\\n        a=sorted(nums)\\n        if len(a)<2:\\n            c.append(0)\\n        else:\\n            for i in range(len(a)-1):\\n                c.append(a[i+1]-a[i])\\n        return(max(c))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974534,
                "title": "one-simple-solution",
                "content": "Wasn\\'t that hard. Easy solution\\n\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length<2) return 0;\\n        Arrays.sort(nums);\\n        int ans = Integer.MIN_VALUE;\\n        for(int i=0;i+1<nums.length;i++) ans = Math.max(ans,nums[i+1]-nums[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length<2) return 0;\\n        Arrays.sort(nums);\\n        int ans = Integer.MIN_VALUE;\\n        for(int i=0;i+1<nums.length;i++) ans = Math.max(ans,nums[i+1]-nums[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967826,
                "title": "python-3-bucket-sort",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        \\n        maxNum = max(nums)\\n        digit = 1\\n        base = 16\\n        \\n        while maxNum >= digit:\\n            buckets = [[] for _ in range(base)]\\n            for num in nums:\\n                buckets[num // digit % base].append(num)\\n            \\n            nums = []\\n            for bucket in buckets:\\n                nums.extend(bucket)\\n            digit *= base\\n        \\n        return max(nums[i] - nums[i - 1] for i in range(1, len(nums)))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        \\n        maxNum = max(nums)\\n        digit = 1\\n        base = 16\\n        \\n        while maxNum >= digit:\\n            buckets = [[] for _ in range(base)]\\n            for num in nums:\\n                buckets[num // digit % base].append(num)\\n            \\n            nums = []\\n            for bucket in buckets:\\n                nums.extend(bucket)\\n            digit *= base\\n        \\n        return max(nums[i] - nums[i - 1] for i in range(1, len(nums)))",
                "codeTag": "Java"
            },
            {
                "id": 1945386,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func maximumGap(_ nums: [Int]) -> Int {\\n        let count = nums.count\\n        guard count >= 2 else { return 0 }\\n        \\n        var minNum = nums[0], maxNum = nums[0]\\n        for n in nums {\\n            minNum = min(minNum, n)\\n            maxNum = max(maxNum, n)\\n        }\\n        \\n        let stride = max(1, (maxNum - minNum) / (count - 1))\\n        var buckets = Array(repeating: [-1, -1], count: (maxNum - minNum) / stride + 1)\\n        \\n        for n in nums {\\n            let i = (n - minNum) / stride\\n            if buckets[i][0] == -1 {\\n                buckets[i][0] = n\\n                buckets[i][1] = n\\n            } else {\\n                buckets[i][0] = min(buckets[i][0], n)\\n                buckets[i][1] = max(buckets[i][1], n)\\n            }\\n        }\\n        \\n        var gap = 0, prev = -1\\n        for i in 0..<buckets.count {\\n            if buckets[i][0] == -1 { continue }\\n            if prev != -1 {\\n                gap = max(gap, buckets[i][0] - buckets[prev][1])\\n            }\\n            prev = i\\n        }\\n        \\n        return gap\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumGap(_ nums: [Int]) -> Int {\\n        let count = nums.count\\n        guard count >= 2 else { return 0 }\\n        \\n        var minNum = nums[0], maxNum = nums[0]\\n        for n in nums {\\n            minNum = min(minNum, n)\\n            maxNum = max(maxNum, n)\\n        }\\n        \\n        let stride = max(1, (maxNum - minNum) / (count - 1))\\n        var buckets = Array(repeating: [-1, -1], count: (maxNum - minNum) / stride + 1)\\n        \\n        for n in nums {\\n            let i = (n - minNum) / stride\\n            if buckets[i][0] == -1 {\\n                buckets[i][0] = n\\n                buckets[i][1] = n\\n            } else {\\n                buckets[i][0] = min(buckets[i][0], n)\\n                buckets[i][1] = max(buckets[i][1], n)\\n            }\\n        }\\n        \\n        var gap = 0, prev = -1\\n        for i in 0..<buckets.count {\\n            if buckets[i][0] == -1 { continue }\\n            if prev != -1 {\\n                gap = max(gap, buckets[i][0] - buckets[prev][1])\\n            }\\n            prev = i\\n        }\\n        \\n        return gap\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932265,
                "title": "python-sort-by-steps-o-n-solution",
                "content": "Though we can\\'t sort the list exactly, we can sort it with lower resolution. That is, we can sort it with a step of (max - min) / (n - 1) instead of 1. Yes, in this way multiple numbers can appear in one step, but the good thing is we don\\'t have to know the details within each step, we only need to know the max and min of each step. And the answer must appear as one of the min_of_next_step - max_of_prev_step. Why? Because the answer won\\'t be the diff of numbers in the same step, since the smallest possible Maximum Gap is the step length.\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        n = len(nums)\\n        min_all = min(nums)\\n        max_all = max(nums)\\n        if min_all == max_all:\\n            return 0\\n        #step is average distance between each number,\\n        #which is the smallest possible Maximum Gap.\\n        #though we can\\'t sort the list exactly, we can sort\\n        #it by how many steps it is above the lowest\\n        aveD = (max_all - min_all) / (n - 1)\\n        d_class = {}\\n        for num in nums:\\n            d_to_min = (num - min_all) // aveD\\n            if d_to_min not in d_class:\\n                d_class[d_to_min] = []\\n            d_class[d_to_min].append(num)\\n        #after sorting by steps, the answer must appear as one of the\\n        #distance between max of the previous step and the min of next step\\n        for d_to_min in d_class:\\n            d_class[d_to_min].append(min(d_class[d_to_min]))\\n            d_class[d_to_min].append(max(d_class[d_to_min]))\\n        ans = float(\\'-inf\\')\\n        start = 0\\n        for i in range(1, n):\\n            if i in d_class:\\n                end = i\\n                cur = d_class[end][-2] - d_class[start][-1]\\n                ans = max(ans, cur)\\n                start = i\\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        n = len(nums)\\n        min_all = min(nums)\\n        max_all = max(nums)\\n        if min_all == max_all:\\n            return 0\\n        #step is average distance between each number,\\n        #which is the smallest possible Maximum Gap.\\n        #though we can\\'t sort the list exactly, we can sort\\n        #it by how many steps it is above the lowest\\n        aveD = (max_all - min_all) / (n - 1)\\n        d_class = {}",
                "codeTag": "Java"
            },
            {
                "id": 1928701,
                "title": "java-easy-to-undersand-solution",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        if(nums.length==1) return 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max = Math.max(max,Math.abs(nums[i]-nums[i+1]));\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        if(nums.length==1) return 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max = Math.max(max,Math.abs(nums[i]-nums[i+1]));\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911857,
                "title": "c-easiest-solution",
                "content": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int ans = INT_MIN;\\n        if(nums.size() < 2)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        for (int i = 1; i < nums.size(); i++) {\\n            ans = max(ans,nums[i] - nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int ans = INT_MIN;\\n        if(nums.size() < 2)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        for (int i = 1; i < nums.size(); i++) {\\n            ans = max(ans,nums[i] - nums[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1861970,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n    int result=0;\\n    sort(nums.begin(),nums.end());\\n    for(int i=1;i<nums.size();i++)\\n    {\\n        result=max(result,nums[i]-nums[i-1]);\\n    }\\n    return result;\\n}\\n        \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n    int result=0;\\n    sort(nums.begin(),nums.end());\\n    for(int i=1;i<nums.size();i++)\\n    {\\n        result=max(result,nums[i]-nums[i-1]);\\n    }\\n    return result;\\n}\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827209,
                "title": "maximum-gap-java",
                "content": "TC :- O(n)  and SC :- O(n)\\npublic int maximumGap(int[] a) {\\n        \\n\\t\\t// If the array contains less than 2 elements return 0.\\n        if(a.length < 2){\\n            return 0;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        // Find max and min value!\\n        for(int arr : a){\\n            min = Math.min(min, arr);\\n            max = Math.max(max, arr);\\n        }\\n        \\n        int n = a.length;\\n        int num_of_bucket = n-1;\\n        \\n        // Bucket size \\n        int size_of_bucket = (int) Math.ceil( (double) (max - min)/num_of_bucket );\\n        \\n        // bucket contain 2 thing min and max value!\\n        int[] min_bucket_value = new int[n-1];\\n        int[] max_bucket_value = new int[n-1];\\n        \\n        Arrays.fill(min_bucket_value, Integer.MAX_VALUE);\\n        Arrays.fill(max_bucket_value, Integer.MIN_VALUE);\\n        \\n        // Now we fill the bucket min and max value in it\\n        // here we need to know that we do not consider max and min value into bucket!\\n        for(int i=0; i<n; i++){\\n        \\n            if(a[i] == min || a[i] == max){\\n                continue;\\n            }\\n            int bucket_index = (a[i] - min)/size_of_bucket;\\n            // here we seperate the min and max value in bucket in min bucket and max bucket.\\n            min_bucket_value[bucket_index] = Math.min( min_bucket_value[bucket_index] , a[i] );\\n            max_bucket_value[bucket_index] = Math.max( max_bucket_value[bucket_index] , a[i] );\\n        }\\n        \\n        // now for finding max gap in bucket we use max(min of B bucket - max of A bucket)!\\n        int max_gap = 0;\\n        \\n        // reason is we start for index 0 and it may be possible that its min and max value be same or equal or only one value present thats why we use min here.\\n        int max_of_prev_bucket = min;\\n        \\n        for(int i=0; i<a.length-1; i++){\\n            // bucket not contain any value skip it\\n            if(max_bucket_value[i] == Integer.MIN_VALUE){\\n                continue;\\n            }\\n            max_gap = Math.max(max_gap, min_bucket_value[i] - max_of_prev_bucket);\\n            // update max_of_prev_bucket!\\n            max_of_prev_bucket = max_bucket_value[i];\\n        }\\n        \\n        // here we take care if we have only 2 element in bucket!\\n        max_gap = Math.max(max_gap , max - max_of_prev_bucket);\\n        \\n        \\n        return max_gap;\\n\\t\\t\\n   }",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "TC :- O(n)  and SC :- O(n)\\npublic int maximumGap(int[] a) {\\n        \\n\\t\\t// If the array contains less than 2 elements return 0.\\n        if(a.length < 2){\\n            return 0;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        // Find max and min value!\\n        for(int arr : a){\\n            min = Math.min(min, arr);\\n            max = Math.max(max, arr);\\n        }\\n        \\n        int n = a.length;\\n        int num_of_bucket = n-1;\\n        \\n        // Bucket size \\n        int size_of_bucket = (int) Math.ceil( (double) (max - min)/num_of_bucket );\\n        \\n        // bucket contain 2 thing min and max value!\\n        int[] min_bucket_value = new int[n-1];\\n        int[] max_bucket_value = new int[n-1];\\n        \\n        Arrays.fill(min_bucket_value, Integer.MAX_VALUE);\\n        Arrays.fill(max_bucket_value, Integer.MIN_VALUE);\\n        \\n        // Now we fill the bucket min and max value in it\\n        // here we need to know that we do not consider max and min value into bucket!\\n        for(int i=0; i<n; i++){\\n        \\n            if(a[i] == min || a[i] == max){\\n                continue;\\n            }\\n            int bucket_index = (a[i] - min)/size_of_bucket;\\n            // here we seperate the min and max value in bucket in min bucket and max bucket.\\n            min_bucket_value[bucket_index] = Math.min( min_bucket_value[bucket_index] , a[i] );\\n            max_bucket_value[bucket_index] = Math.max( max_bucket_value[bucket_index] , a[i] );\\n        }\\n        \\n        // now for finding max gap in bucket we use max(min of B bucket - max of A bucket)!\\n        int max_gap = 0;\\n        \\n        // reason is we start for index 0 and it may be possible that its min and max value be same or equal or only one value present thats why we use min here.\\n        int max_of_prev_bucket = min;\\n        \\n        for(int i=0; i<a.length-1; i++){\\n            // bucket not contain any value skip it\\n            if(max_bucket_value[i] == Integer.MIN_VALUE){\\n                continue;\\n            }\\n            max_gap = Math.max(max_gap, min_bucket_value[i] - max_of_prev_bucket);\\n            // update max_of_prev_bucket!\\n            max_of_prev_bucket = max_bucket_value[i];\\n        }\\n        \\n        // here we take care if we have only 2 element in bucket!\\n        max_gap = Math.max(max_gap , max - max_of_prev_bucket);\\n        \\n        \\n        return max_gap;\\n\\t\\t\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 1827182,
                "title": "javascript-radix-sort",
                "content": "**Solution: Radix Sort**\\n\\nGet the max number from nums and count the number of digits it has.\\nLoop for maxDigits number of times:\\n  1. arrange each nums[i] into its bucket based on the current digit\\n  2. prefix sum/accumulate indices in count\\n  3. place each nums[i] to next based on the accumulated index in count\\n  4. reassign nums to next\\n----\\nd = digits <= 10, n = length of nums, b = base = 10\\nTime Complexity: O(d(n + b)) = O(n) 310ms\\nSpace Complexity: O(n) 67.2MB\\n```\\nvar maximumGap = function(nums) {\\n  let n = nums.length, max = Math.max(...nums), maxDigits = getDigits(max);\\n  let power = 1;\\n  \\n  for (let k = 0; k < maxDigits; k++) {\\n    let next = Array(n), count = Array(10).fill(0);\\n    for (let i = 0; i < n; i++) {\\n      let digit = Math.floor(nums[i] / power) % 10;\\n      count[digit]++; // counting sort based on current digit\\n    }\\n    for (let i = 1; i < 10; i++) count[i] += count[i - 1]; // prefix sum \\n    for (let i = n - 1; i >= 0; i--) {\\n      let digit = Math.floor(nums[i] / power) % 10;\\n      next[--count[digit]] = nums[i];\\n    }\\n    nums = next;\\n    power *= 10;\\n  }\\n  \\n  let ans = 0;\\n  for (let i = 1; i < n; i++) {\\n    ans = Math.max(ans, nums[i] - nums[i - 1]);\\n  }\\n  return ans;\\n};\\n\\nfunction getDigits(num) {\\n  let digits = 0;\\n  while (num > 0) {\\n    num = Math.floor(num / 10);\\n    digits++;\\n  }\\n  return digits;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumGap = function(nums) {\\n  let n = nums.length, max = Math.max(...nums), maxDigits = getDigits(max);\\n  let power = 1;\\n  \\n  for (let k = 0; k < maxDigits; k++) {\\n    let next = Array(n), count = Array(10).fill(0);\\n    for (let i = 0; i < n; i++) {\\n      let digit = Math.floor(nums[i] / power) % 10;\\n      count[digit]++; // counting sort based on current digit\\n    }\\n    for (let i = 1; i < 10; i++) count[i] += count[i - 1]; // prefix sum \\n    for (let i = n - 1; i >= 0; i--) {\\n      let digit = Math.floor(nums[i] / power) % 10;\\n      next[--count[digit]] = nums[i];\\n    }\\n    nums = next;\\n    power *= 10;\\n  }\\n  \\n  let ans = 0;\\n  for (let i = 1; i < n; i++) {\\n    ans = Math.max(ans, nums[i] - nums[i - 1]);\\n  }\\n  return ans;\\n};\\n\\nfunction getDigits(num) {\\n  let digits = 0;\\n  while (num > 0) {\\n    num = Math.floor(num / 10);\\n    digits++;\\n  }\\n  return digits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809870,
                "title": "java-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)\\n            return 0;\\n        int n = nums.length;\\n        int max = nums[0], min= nums[0];\\n        for(int i  : nums) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int bucketSize = (max - min)/(n - 1);\\n        if(bucketSize == 0)\\n            bucketSize++;\\n        int totalBuckets = ((max - min)/bucketSize) + 1;\\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ; i++) {\\n            int index = (nums[i] - min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i < totalBuckets; i++) {\\n            if(minBucket[i] == Integer.MAX_VALUE)\\n                continue;\\n            result = Math.max(result, minBucket[i] - prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\nGuy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)\\n            return 0;\\n        int n = nums.length;\\n        int max = nums[0], min= nums[0];\\n        for(int i  : nums) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int bucketSize = (max - min)/(n - 1);\\n        if(bucketSize == 0)\\n            bucketSize++;\\n        int totalBuckets = ((max - min)/bucketSize) + 1;\\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ; i++) {\\n            int index = (nums[i] - min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i < totalBuckets; i++) {\\n            if(minBucket[i] == Integer.MAX_VALUE)\\n                continue;\\n            result = Math.max(result, minBucket[i] - prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764793,
                "title": "easy-c-solution-radix-sort",
                "content": "```\\nclass Solution {\\npublic:\\n  void countsort(vector<int> &arr, int n, int exp)\\n  {\\n    int count[10] = {0};\\n    for (int i = 0; i < n; i++)\\n    {\\n      count[(arr[i] / exp) % 10]++;\\n    }\\n\\n    for (int i = 1; i < 10; i++)\\n    {\\n      count[i] += count[i - 1];\\n    }\\n\\n    int ans[n];\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n      ans[--count[(arr[i] / exp) % 10]] = arr[i];\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n      arr[i] = ans[i];\\n    }\\n  }\\n    int maximumGap(vector<int>& nums) {\\n       int n = nums.size();\\n       if(n < 2)\\n       return 0;\\n       int maxval = nums[0];\\n       for (int i = 1; i < n; i++)\\n       {\\n         maxval = max(maxval, nums[i]);\\n       }\\n       int exp = 1;\\n       while (exp <= maxval)\\n       {\\n         countsort(nums, n, exp);\\n         exp = exp * 10;\\n       }\\n       int diff = 0;\\n       for (int i = 1; i < n; i++)\\n       {\\n         diff = max(diff, nums[i] - nums[i-1]);\\n       }\\n       return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void countsort(vector<int> &arr, int n, int exp)\\n  {\\n    int count[10] = {0};\\n    for (int i = 0; i < n; i++)\\n    {\\n      count[(arr[i] / exp) % 10]++;\\n    }\\n\\n    for (int i = 1; i < 10; i++)\\n    {\\n      count[i] += count[i - 1];\\n    }\\n\\n    int ans[n];\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n      ans[--count[(arr[i] / exp) % 10]] = arr[i];\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n      arr[i] = ans[i];\\n    }\\n  }\\n    int maximumGap(vector<int>& nums) {\\n       int n = nums.size();\\n       if(n < 2)\\n       return 0;\\n       int maxval = nums[0];\\n       for (int i = 1; i < n; i++)\\n       {\\n         maxval = max(maxval, nums[i]);\\n       }\\n       int exp = 1;\\n       while (exp <= maxval)\\n       {\\n         countsort(nums, n, exp);\\n         exp = exp * 10;\\n       }\\n       int diff = 0;\\n       for (int i = 1; i < n; i++)\\n       {\\n         diff = max(diff, nums[i] - nums[i-1]);\\n       }\\n       return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705083,
                "title": "using-radix-sort-o-n",
                "content": "```\\n//Time will be : O(10*(10+n)) for radix sort == O(n) here\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int gap=0;\\n        int n =nums.length;\\n        int d = Integer.MIN_VALUE;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > d) d=nums[i];\\n        }\\n        while(d>0){\\n            c++;\\n            d=d/10;\\n        }\\n        d=1;\\n        while(c-->0){\\n            int count[] = new int[10];\\n            int[] arr = new int[n];\\n            for(int i=0;i<n;i++){\\n                ++count[(nums[i]/d)%10];\\n            }\\n            for(int i=1;i<10;i++) count[i]+=count[i-1];\\n            for(int i=n-1;i>=0;i--){\\n                arr[--count[(nums[i]/d)%10]] = nums[i];\\n            }\\n            nums=arr;\\n            d=d*10;\\n        }\\n        for(int i=1;i<n;i++) if(nums[i]-nums[i-1]>gap) gap=nums[i]-nums[i-1];\\n        return gap;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//Time will be : O(10*(10+n)) for radix sort == O(n) here\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int gap=0;\\n        int n =nums.length;\\n        int d = Integer.MIN_VALUE;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > d) d=nums[i];\\n        }\\n        while(d>0){\\n            c++;\\n            d=d/10;\\n        }\\n        d=1;\\n        while(c-->0){\\n            int count[] = new int[10];\\n            int[] arr = new int[n];\\n            for(int i=0;i<n;i++){\\n                ++count[(nums[i]/d)%10];\\n            }\\n            for(int i=1;i<10;i++) count[i]+=count[i-1];\\n            for(int i=n-1;i>=0;i--){\\n                arr[--count[(nums[i]/d)%10]] = nums[i];\\n            }\\n            nums=arr;\\n            d=d*10;\\n        }\\n        for(int i=1;i<n;i++) if(nums[i]-nums[i-1]>gap) gap=nums[i]-nums[i-1];\\n        return gap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617881,
                "title": "maximum-gap-using-bucket-java-o-n-with-o-n",
                "content": "public int maximumGap(int[] a) {\\n        // O(n) with O(n)\\n\\t\\t\\n\\t\\tif(a.length <2){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\t\\n        int min = a[0];\\n        int max = 0;\\n        // find max and min!\\n        for(int n : a){\\n            min = Math.min(min,n);\\n            max = Math.max(max,n);\\n        }\\n        // find interval!\\n        int interval = (int)Math.ceil((max - min + 0.0)/(a.length-1));\\n        // bucket!\\n        int[] bucketmin = new int[a.length -1];\\n        int[] bucketmax = new int[a.length -1];\\n        Arrays.fill(bucketmin,Integer.MAX_VALUE);\\n        Arrays.fill(bucketmax,-1);\\n        \\n        for(int i=0; i < a.length; i++){\\n            if(a[i] == min || a[i] == max) continue;\\n            int index = (a[i] - min)/ interval;\\n            bucketmin[index] = Math.min(bucketmin[index],a[i]);\\n            bucketmax[index] = Math.max(bucketmax[index],a[i]);\\n        }\\n        \\n        int prev = min;\\n        int maxgap = 0;\\n        for(int i=0; i<bucketmin.length; i++){\\n            if(bucketmax[i] == -1 ) continue;    \\n            maxgap = Math.max(bucketmin[i] - prev,maxgap);\\n            prev = bucketmax[i];\\n        }\\n        maxgap = Math.max(max - prev, maxgap);\\n        return maxgap;\\n        \\n        \\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "public int maximumGap(int[] a) {\\n        // O(n) with O(n)\\n\\t\\t\\n\\t\\tif(a.length <2){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\t\\n        int min = a[0];\\n        int max = 0;\\n        // find max and min!\\n        for(int n : a){\\n            min = Math.min(min,n);\\n            max = Math.max(max,n);\\n        }\\n        // find interval!\\n        int interval = (int)Math.ceil((max - min + 0.0)/(a.length-1));\\n        // bucket!\\n        int[] bucketmin = new int[a.length -1];\\n        int[] bucketmax = new int[a.length -1];\\n        Arrays.fill(bucketmin,Integer.MAX_VALUE);\\n        Arrays.fill(bucketmax,-1);\\n        \\n        for(int i=0; i < a.length; i++){\\n            if(a[i] == min || a[i] == max) continue;\\n            int index = (a[i] - min)/ interval;\\n            bucketmin[index] = Math.min(bucketmin[index],a[i]);\\n            bucketmax[index] = Math.max(bucketmax[index],a[i]);\\n        }\\n        \\n        int prev = min;\\n        int maxgap = 0;\\n        for(int i=0; i<bucketmin.length; i++){\\n            if(bucketmax[i] == -1 ) continue;    \\n            maxgap = Math.max(bucketmin[i] - prev,maxgap);\\n            prev = bucketmax[i];\\n        }\\n        maxgap = Math.max(max - prev, maxgap);\\n        return maxgap;\\n        \\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1597159,
                "title": "java-o-n-tc-using-radix-sort-o-n-sc",
                "content": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return 0;\\n        for(int i=1;i<=1000000000;i=i*10)\\n\\t{\\n\\t\\tsort(nums,i);\\n\\t}\\n        int max = Integer.MIN_VALUE;\\n    \\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            max = Math.max(max,(nums[i+1]-nums[i]));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    \\n    \\t  public static void sort(int[] a,int divide)\\n\\t    {\\n\\t        ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\\n\\t        for(int i=0;i<10;i++)\\n\\t        {\\n\\t            list.add(i,new ArrayList<Integer>());\\n\\t        }\\n\\t        for(int i=0;i<a.length;i++)\\n\\t        {\\n\\t            list.get((a[i]/divide)%10).add(a[i]);\\n\\t        \\n\\t        }\\n\\t        \\n\\t        int k = 0;\\n\\t        for(ArrayList<Integer> arr : list)\\n\\t        {\\n\\t            for(Integer ele : arr)\\n\\t            {\\n\\t                a[k]= ele;\\n\\t                k++;\\n\\t            }\\n\\t        }\\n\\t        \\n\\t    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return 0;\\n        for(int i=1;i<=1000000000;i=i*10)\\n\\t{\\n\\t\\tsort(nums,i);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1392188,
                "title": "python-o-n-bit-trie-solution",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        def addToTrie(trie, num: int):\\n            mask = 1 << 31\\n            while mask:\\n                currentBit = 1 if (num & mask > 0) else 0 \\n                mask >>= 1\\n                if currentBit not in trie:\\n                    trie[currentBit] = dict()\\n                trie = trie[currentBit]\\n            trie[\"Number\"] = num\\n            \\n        def process(trie, bitShift: int, current: int):\\n            if \"Number\" in trie:\\n                if not self.prev is None:\\n                    gap = current - self.prev\\n                    self.maxGap = max(gap, self.maxGap)\\n                self.prev = current\\n            if 0 in trie:\\n                process(trie[0], bitShift >> 1, current)\\n            if 1 in trie:\\n                process(trie[1], bitShift >> 1, current + bitShift)\\n            \\n        if len(nums) < 2:\\n            return 0\\n        \\n        trie = dict()\\n        for num in nums:\\n            addToTrie(trie, num)\\n            \\n        self.prev = None\\n        self.maxGap = 0\\n        process(trie, 1 << 31, 0)\\n        return self.maxGap\\n                   \\n```\\nActually it\\'s equivalent to the radix sort\\n\\n",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        def addToTrie(trie, num: int):\\n            mask = 1 << 31\\n            while mask:\\n                currentBit = 1 if (num & mask > 0) else 0 \\n                mask >>= 1\\n                if currentBit not in trie:\\n                    trie[currentBit] = dict()\\n                trie = trie[currentBit]\\n            trie[\"Number\"] = num\\n            \\n        def process(trie, bitShift: int, current: int):\\n            if \"Number\" in trie:\\n                if not self.prev is None:\\n                    gap = current - self.prev\\n                    self.maxGap = max(gap, self.maxGap)\\n                self.prev = current\\n            if 0 in trie:\\n                process(trie[0], bitShift >> 1, current)\\n            if 1 in trie:\\n                process(trie[1], bitShift >> 1, current + bitShift)\\n            \\n        if len(nums) < 2:\\n            return 0\\n        \\n        trie = dict()\\n        for num in nums:\\n            addToTrie(trie, num)\\n            \\n        self.prev = None\\n        self.maxGap = 0\\n        process(trie, 1 << 31, 0)\\n        return self.maxGap\\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383922,
                "title": "python3-solution-using-radix-sort",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        elif len(nums) == 2:\\n            return max(nums) - min(nums)\\n        \\n        self.max_N_digits = max([len(str(num)) for num in nums])\\n        nums = self.radixSort(nums, 0)\\n        \\n        return max([nums[i]-nums[i-1] for i in range(1, len(nums))])\\n        \\n    def radixSort(self, nums, d):\\n        if d == self.max_N_digits:\\n            return nums\\n        bucket = {i:[] for i in range(10)}\\n        key = lambda x: int((x/(10**d))%10)\\n        \\n        for num in nums:\\n            bucket[key(num)].append(num)\\n        \\n        new_nums = []\\n        for i in range(10):\\n            new_nums += bucket[i]\\n        \\n        return self.radixSort(new_nums, d+1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        elif len(nums) == 2:\\n            return max(nums) - min(nums)\\n        \\n        self.max_N_digits = max([len(str(num)) for num in nums])\\n        nums = self.radixSort(nums, 0)\\n        \\n        return max([nums[i]-nums[i-1] for i in range(1, len(nums))])\\n        \\n    def radixSort(self, nums, d):\\n        if d == self.max_N_digits:\\n            return nums\\n        bucket = {i:[] for i in range(10)}\\n        key = lambda x: int((x/(10**d))%10)\\n        \\n        for num in nums:\\n            bucket[key(num)].append(num)\\n        \\n        new_nums = []\\n        for i in range(10):\\n            new_nums += bucket[i]\\n        \\n        return self.radixSort(new_nums, d+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352305,
                "title": "python-bucket-sort-solution-not-comparison-based-soritng",
                "content": "```\\nclass Solution:\\n    def BucketSort(self,arr,n):\\n        max_ele=max(arr)\\n        size=max_ele/n\\n        bucketList=[[] for i in range(n)]\\n        for i in range(n):\\n            j=int(arr[i]/size)\\n            if j==n:bucketList[j-1].append(arr[i])\\n            else:bucketList[j].append(arr[i])\\n        for i in bucketList:\\n            if i:i.sort()\\n        k=0\\n        for lst in bucketList:\\n            if lst:\\n                for i in lst:\\n                    arr[k]=i\\n                    k+=1\\n    def maximumGap(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n<2:return 0\\n        self.BucketSort(nums,n)\\n        ans=0\\n        for i in range(n-1):\\n            x=nums[i+1]-nums[i]\\n            if x>ans:ans=x\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def BucketSort(self,arr,n):\\n        max_ele=max(arr)\\n        size=max_ele/n\\n        bucketList=[[] for i in range(n)]\\n        for i in range(n):\\n            j=int(arr[i]/size)\\n            if j==n:bucketList[j-1].append(arr[i])\\n            else:bucketList[j].append(arr[i])\\n        for i in bucketList:\\n            if i:i.sort()\\n        k=0\\n        for lst in bucketList:\\n            if lst:\\n                for i in lst:\\n                    arr[k]=i\\n                    k+=1\\n    def maximumGap(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n<2:return 0\\n        self.BucketSort(nums,n)\\n        ans=0\\n        for i in range(n-1):\\n            x=nums[i+1]-nums[i]\\n            if x>ans:ans=x\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1853589,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1567469,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1966139,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1566077,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1820461,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1566758,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 2019688,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1571359,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1575340,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1571993,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1853589,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1567469,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1966139,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1566077,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1820461,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1566758,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 2019688,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1571359,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1575340,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1571993,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            }
        ]
    }
]