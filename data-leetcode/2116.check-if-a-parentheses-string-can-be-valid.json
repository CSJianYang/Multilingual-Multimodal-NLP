[
    {
        "title": "Check if a Parentheses String Can Be Valid",
        "question_content": "A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:\n\n\tIt is ().\n\tIt can be written as AB (A concatenated with B), where A and B are valid parentheses strings.\n\tIt can be written as (A), where A is a valid parentheses string.\n\nYou are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked,\n\n\tIf locked[i] is '1', you cannot change s[i].\n\tBut if locked[i] is '0', you can change s[i] to either '(' or ')'.\n\nReturn true if you can make s a valid parentheses string. Otherwise, return false.\n&nbsp;\nExample 1:\n\nInput: s = \"))()))\", locked = \"010100\"\nOutput: true\nExplanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].\nWe change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.\nExample 2:\n\nInput: s = \"()()\", locked = \"0000\"\nOutput: true\nExplanation: We do not need to make any changes because s is already valid.\n\nExample 3:\n\nInput: s = \")\", locked = \"0\"\nOutput: false\nExplanation: locked permits us to change s[0]. \nChanging s[0] to either '(' or ')' will not make s valid.\n\n&nbsp;\nConstraints:\n\n\tn == s.length == locked.length\n\t1 <= n <= 105\n\ts[i] is either '(' or ')'.\n\tlocked[i] is either '0' or '1'.",
        "solutions": [
            {
                "id": 1646594,
                "title": "left-to-right-and-right-to-left",
                "content": "A useful trick (when doing any parentheses validation) is to greedily check balance left-to-right, and then right-to-left.\\n- Left-to-right check ensures that we do not have orphan \\')\\' parentheses.\\n- Right-to-left checks for orphan \\'(\\' parentheses.\\n\\nWe go left-to-right:\\n- Count `wild` (not locked) characters. \\n- Track the balance `bal` for locked parentheses. \\n\\t- If the balance goes negative, we check if we have enough `wild` characters to compensate.\\n- In the end, check that we have enough `wild` characters to cover positive balance (open parentheses). \\n\\nThis approach alone, however, will fail for `[\"))((\", \"0011\"]` test case. That is why we also need to do the same going right-to-left.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        def validate(s: str, locked: str, op: str) -> bool:\\n            bal, wild = 0, 0\\n            for i in range(len(s)):\\n                if locked[i] == \"1\":\\n                    bal += 1 if s[i] == op else -1\\n                else:\\n                    wild += 1\\n                if wild + bal < 0:\\n                    return False\\n            return bal <= wild\\n        return len(s) % 2 == 0 and validate(s, locked, \\'(\\') and validate(s[::-1], locked[::-1], \\')\\')\\n```\\n\\n**Java**\\n```java\\nboolean validate(String s, String locked, char op) {\\n    int bal = 0, wild = 0, sz = s.length();\\n    int start = op == \\'(\\' ? 0 : sz - 1, dir = op == \\'(\\' ? 1 : - 1;\\n    for (int i = start; i >= 0 && i < sz && wild + bal >= 0; i += dir)\\n        if (locked.charAt(i) == \\'1\\')\\n            bal += s.charAt(i) == op ? 1 : -1;\\n        else\\n            ++wild;\\n    return Math.abs(bal) <= wild;\\n}\\npublic boolean canBeValid(String s, String locked) {\\n    return s.length() % 2 == 0 && validate(s, locked, \\'(\\') && validate(s, locked, \\')\\');\\n}\\n```\\n**C++**\\n```cpp\\nbool canBeValid(string s, string locked) {\\n    auto validate = [&](char op) {\\n        int bal = 0, wild = 0, sz = s.size();\\n        int start = op == \\'(\\' ? 0 : sz - 1, dir = op == \\'(\\' ? 1 : - 1;\\n        for (int i = start; i >= 0 && i < sz && wild + bal >= 0; i += dir)\\n            if (locked[i] == \\'1\\')\\n                bal += s[i] == op ? 1 : -1;\\n            else\\n                ++wild;\\n        return abs(bal) <= wild;\\n    };\\n    return s.size() % 2 == 0 && validate(\\'(\\') && validate(\\')\\');\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        def validate(s: str, locked: str, op: str) -> bool:\\n            bal, wild = 0, 0\\n            for i in range(len(s)):\\n                if locked[i] == \"1\":\\n                    bal += 1 if s[i] == op else -1\\n                else:\\n                    wild += 1\\n                if wild + bal < 0:\\n                    return False\\n            return bal <= wild\\n        return len(s) % 2 == 0 and validate(s, locked, \\'(\\') and validate(s[::-1], locked[::-1], \\')\\')\\n```\n```java\\nboolean validate(String s, String locked, char op) {\\n    int bal = 0, wild = 0, sz = s.length();\\n    int start = op == \\'(\\' ? 0 : sz - 1, dir = op == \\'(\\' ? 1 : - 1;\\n    for (int i = start; i >= 0 && i < sz && wild + bal >= 0; i += dir)\\n        if (locked.charAt(i) == \\'1\\')\\n            bal += s.charAt(i) == op ? 1 : -1;\\n        else\\n            ++wild;\\n    return Math.abs(bal) <= wild;\\n}\\npublic boolean canBeValid(String s, String locked) {\\n    return s.length() % 2 == 0 && validate(s, locked, \\'(\\') && validate(s, locked, \\')\\');\\n}\\n```\n```cpp\\nbool canBeValid(string s, string locked) {\\n    auto validate = [&](char op) {\\n        int bal = 0, wild = 0, sz = s.size();\\n        int start = op == \\'(\\' ? 0 : sz - 1, dir = op == \\'(\\' ? 1 : - 1;\\n        for (int i = start; i >= 0 && i < sz && wild + bal >= 0; i += dir)\\n            if (locked[i] == \\'1\\')\\n                bal += s[i] == op ? 1 : -1;\\n            else\\n                ++wild;\\n        return abs(bal) <= wild;\\n    };\\n    return s.size() % 2 == 0 && validate(\\'(\\') && validate(\\')\\');\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650613,
                "title": "intuition-explained-balanced-parentheses-greedy-approach-c-clean-code",
                "content": "**Intuition :**\\n\\n* **Idea** : \\n\\t* Idea is similar to other **Balance Parentheses** related problems. i.e we check the balance of `( and )` brackets.\\n\\t\\n\\t* And whenever `number of )` exceeds `number of (` , we can say that it is unbalanced from start.\\n\\t* And whenever `number of (` exceeds `number of )` , we can say that it is unbalanced from end ( this one is trivial). \\n\\t* This can be done by incrementing when we see *opening* `(` bracket and decrementing vice versa. \\n \\n * **Observations** :\\n\\t * We can get a valid Balanced Parentheses only when length of string is even. \\n\\t \\n\\t\\t * So that every `(` bracket has it counterpart `)`.\\n\\t * String can be said invalid in terms of `(` , if \\n\\t\\t * `number of ) > number of (` , at any point.\\n\\t\\t * and vice versa in terms of `)` as well.\\n\\t * Also in this problem, we are given that we can change bracket at index i \\n\\t\\t * iff `locked[i] == \\'0\\'` , i.e index i is unlocked\\n\\t* Thus, we can say if at point we see `balance < 0`, but that index is unlocked,\\n\\t\\t * then we change character at that index, thus maintaining the balance.\\n\\t\\t \\n* So we need to check if string is balanced in terms of ***opening \\'(\\' bracket*** from **left -> right**.\\n* As well as check if string is balanced in terms of ***closing \\')\\' bracket*** from **right -> left**.\\n* If at any point we encounter negative balance i.e `balance < 0` , simple return false as it is surely invalid. \\n\\n--------------------\\n# Code :\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n    \\n        int n = s.size();\\n        if(n&1) return false;\\n         \\n        int balance = 0;\\n        \\n\\t\\t// First check balance from left to right\\n\\t\\t// For opening \\'(\\' brackets\\n\\t\\t\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\n\\t\\t\\t// If either char is ( or it is unlocked,  \\n\\t\\t\\t// We can increment balance\\n\\t\\t\\t\\n            if(locked[i] == \\'0\\' || s[i] == \\'(\\') balance++;   \\n            else balance--;     // otherwise decrement balance, since it is ) and also locked\\n            \\n\\t\\t\\t// Since balance is negative, we have more \\')\\'. \\n\\t\\t\\t// And there is no unlocked char available\\n\\t\\t\\t// SO, it is invalid string for sure\\n\\t\\t\\t\\n            if(balance < 0) return false;\\n        }\\n        \\n\\t\\t// reset balance \\n        balance = 0;\\n\\t\\t\\n\\t\\t// Then also check balance from right to left\\n\\t\\t// For closing \\')\\' brackets\\n\\n        for(int i=n-1; i>=0; i--) {\\n\\t\\t\\n\\t\\t\\t// If either char is ) or it is unlocked,  \\n\\t\\t\\t// We can increment balance\\n\\t\\t\\t\\n            if(locked[i] == \\'0\\' || s[i] == \\')\\') balance++;\\n            else balance--;\\n            \\n\\t\\t\\t// Since balance is negative, we have more \\'(\\'. \\n\\t\\t\\t// And there is no unlocked char available\\n\\t\\t\\t// SO, it is invalid string for sure\\n\\t\\t\\t\\n            if(balance < 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n--------------------\\n\\n**Complexity :**\\n\\n* Time : `O(N + N) ~ O(N)` , N is size of string `s`\\n* Space : `O(1)`\\n\\n----------------\\n\\n**More Practice Problems :**\\n\\n* [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\\n* [Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/) \\n* [Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)\\n* [Minimum Number of Swaps to Make the String Balanced](https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/)\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n    \\n        int n = s.size();\\n        if(n&1) return false;\\n         \\n        int balance = 0;\\n        \\n\\t\\t// First check balance from left to right\\n\\t\\t// For opening \\'(\\' brackets\\n\\t\\t\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\n\\t\\t\\t// If either char is ( or it is unlocked,  \\n\\t\\t\\t// We can increment balance\\n\\t\\t\\t\\n            if(locked[i] == \\'0\\' || s[i] == \\'(\\') balance++;   \\n            else balance--;     // otherwise decrement balance, since it is ) and also locked\\n            \\n\\t\\t\\t// Since balance is negative, we have more \\')\\'. \\n\\t\\t\\t// And there is no unlocked char available\\n\\t\\t\\t// SO, it is invalid string for sure\\n\\t\\t\\t\\n            if(balance < 0) return false;\\n        }\\n        \\n\\t\\t// reset balance \\n        balance = 0;\\n\\t\\t\\n\\t\\t// Then also check balance from right to left\\n\\t\\t// For closing \\')\\' brackets\\n\\n        for(int i=n-1; i>=0; i--) {\\n\\t\\t\\n\\t\\t\\t// If either char is ) or it is unlocked,  \\n\\t\\t\\t// We can increment balance\\n\\t\\t\\t\\n            if(locked[i] == \\'0\\' || s[i] == \\')\\') balance++;\\n            else balance--;\\n            \\n\\t\\t\\t// Since balance is negative, we have more \\'(\\'. \\n\\t\\t\\t// And there is no unlocked char available\\n\\t\\t\\t// SO, it is invalid string for sure\\n\\t\\t\\t\\n            if(balance < 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646582,
                "title": "python3-java-c-counting-brackets-o-n",
                "content": "* We iterate over the string s twice. \\n* Count of variable brackets is maintained using `tot`\\n* Count of fixed open brackets is maintained using `op`\\n* Count of fixed closed brackets is maintained using `cl`\\n* In forward iteration we are checking if we have too many fixed closed brackets `)`, this is achieved using: `if tot + op - cl < 0: return False `\\n* In backward iteration we are checking if we have too many fixed open brackets `(`, this is achieved using: `if tot - op + cl < 0: return False`\\n\\n**Python3**:\\n```\\n    def canBeValid(self, s: str, l: str) -> bool:\\n        if len(s) % 2 == 1: return False\\n        tot = op = cl = 0 # tot -> Total variable brackets, op -> Open, cl -> Closed\\n        for i in range(len(s) - 1, -1, -1):\\n            if l[i] == \\'0\\': tot += 1\\n            elif s[i] == \\'(\\': op += 1\\n            elif s[i] == \\')\\': cl += 1\\n            if tot - op + cl < 0: return False\\n        tot = op = cl = 0\\n        for i in range(len(s)):\\n            if l[i] == \\'0\\': tot += 1\\n            elif s[i] == \\'(\\': op += 1\\n            elif s[i] == \\')\\': cl += 1\\n            if tot + op - cl < 0: return False \\n        return True\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/HfZuXCuy/shared\" frameBorder=\"0\" width=\"700\" height=\"490\"></iframe>\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\n    def canBeValid(self, s: str, l: str) -> bool:\\n        if len(s) % 2 == 1: return False\\n        tot = op = cl = 0 # tot -> Total variable brackets, op -> Open, cl -> Closed\\n        for i in range(len(s) - 1, -1, -1):\\n            if l[i] == \\'0\\': tot += 1\\n            elif s[i] == \\'(\\': op += 1\\n            elif s[i] == \\')\\': cl += 1\\n            if tot - op + cl < 0: return False\\n        tot = op = cl = 0\\n        for i in range(len(s)):\\n            if l[i] == \\'0\\': tot += 1\\n            elif s[i] == \\'(\\': op += 1\\n            elif s[i] == \\')\\': cl += 1\\n            if tot + op - cl < 0: return False \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1646708,
                "title": "c-o-n-intuition",
                "content": "We are interested in the number of brackets which are locked and cannot be modified.\\n\\nFirst we traverse the string from left to right and check the following\\n\\n1. The chars which are **unlocked**.\\n2. The chars which are **locked and are open brackets**.\\n3. The chars which are **locked and are closed brackets**.\\n4. We need to identify the number of locked brackets which are **unpaired**, which is equal to **number of closed brackets - number of open brackets**.\\n5. Now the only way to balance these locked, unpaired brackets is by modifying the unlocked ones. So we check if the **number of unlocked > unpaired**. If it is not, then balancing is not possible and we return false.\\n6. Similarly we traverse the string from right to left and check for this condition unlocked > unpaired, which is (number of open brackets - number of closed brackets) in this case.\\n\\n```\\nclass Solution {\\npublic:\\n      bool canBeValid(string s, string locked) {\\n          \\n        if (s.length() % 2 == 1) \\n            return false;\\n          \\n        int unlocked = 0, open = 0, closed = 0, unpaired;\\n        for(int i = 0; i <s.length(); i++) {\\n            if (locked[i] == \\'0\\')\\n                unlocked++;\\n            else if (s[i] == \\'(\\')\\n                open++;\\n            else if (s[i] == \\')\\')\\n                closed++;\\n            unpaired = closed-open;\\n            if (unpaired > unlocked)\\n                return false;\\n        }\\n          \\n        unlocked = 0, open = 0, closed = 0, unpaired=0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if (locked[i] == \\'0\\')\\n                unlocked++;\\n            else if (s[i] == \\'(\\')\\n                open++;\\n            else if (s[i] == \\')\\')\\n                closed++;\\n            unpaired = open-closed;\\n            if (unpaired > unlocked)\\n                return false;\\n        }\\n          \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n      bool canBeValid(string s, string locked) {\\n          \\n        if (s.length() % 2 == 1) \\n            return false;\\n          \\n        int unlocked = 0, open = 0, closed = 0, unpaired;\\n        for(int i = 0; i <s.length(); i++) {\\n            if (locked[i] == \\'0\\')\\n                unlocked++;\\n            else if (s[i] == \\'(\\')\\n                open++;\\n            else if (s[i] == \\')\\')\\n                closed++;\\n            unpaired = closed-open;\\n            if (unpaired > unlocked)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1648142,
                "title": "python-simple-2-pass-o-n-solution-detailed-explanation-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n```\\nclass Solution(object):\\n    def canBeValid(self, s, locked):\\n        if len(s) % 2:  # Intuitively, odd-length s cannot be valid.\\n            return False\\n\\n        # traverse each parenthesis forward, treat all unlocked Parentheses as\\'(\\' and check if there is \\')\\'\\n        # that cannot be eliminated by previous \\'(\\', if it exists, then the input s can\\'t be valid.\\n        balance = 0\\n        for i in range(len(s)):\\n            balance += 1 if s[i] == \\'(\\' or locked[i] == \\'0\\' else -1\\n            if balance < 0:\\n                return False\\n\\n        # traverse each parenthesis backward, treat all unlocked Parentheses as\\')\\' and check if there is \\'(\\'\\n        # that cannot be eliminated by previous \\')\\', if it exists, then the input s can\\'t be valid.\\n        balance = 0\\n        for i in range(len(s) - 1, -1, -1):\\n            balance += 1 if s[i] == \\')\\' or locked[i] == \\'0\\' else -1\\n            if balance < 0:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canBeValid(self, s, locked):\\n        if len(s) % 2:  # Intuitively, odd-length s cannot be valid.\\n            return False\\n\\n        # traverse each parenthesis forward, treat all unlocked Parentheses as\\'(\\' and check if there is \\')\\'\\n        # that cannot be eliminated by previous \\'(\\', if it exists, then the input s can\\'t be valid.\\n        balance = 0\\n        for i in range(len(s)):\\n            balance += 1 if s[i] == \\'(\\' or locked[i] == \\'0\\' else -1\\n            if balance < 0:\\n                return False\\n\\n        # traverse each parenthesis backward, treat all unlocked Parentheses as\\')\\' and check if there is \\'(\\'\\n        # that cannot be eliminated by previous \\')\\', if it exists, then the input s can\\'t be valid.\\n        balance = 0\\n        for i in range(len(s) - 1, -1, -1):\\n            balance += 1 if s[i] == \\')\\' or locked[i] == \\'0\\' else -1\\n            if balance < 0:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646760,
                "title": "c-2116-check-if-a-parentheses-string-can-be-valid",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if (s.size() & 1) return false; \\n        for (int i = 0, bal = 0; i < s.size(); ++i) {\\n            if (locked[i] == \\'0\\' || s[i] == \\'(\\') bal += 1; \\n            else bal -= 1; \\n            if (bal < 0) return false; \\n        }\\n        for (int i = s.size()-1, bal = 0; 0 <= i; --i) {\\n            if (locked[i] == \\'0\\' || s[i] == \\')\\') bal += 1; \\n            else bal -= 1; \\n            if (bal < 0) return false; \\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if (s.size() & 1) return false; \\n        for (int i = 0, bal = 0; i < s.size(); ++i) {\\n            if (locked[i] == \\'0\\' || s[i] == \\'(\\') bal += 1; \\n            else bal -= 1; \\n            if (bal < 0) return false; \\n        }\\n        for (int i = s.size()-1, bal = 0; 0 <= i; --i) {\\n            if (locked[i] == \\'0\\' || s[i] == \\')\\') bal += 1; \\n            else bal -= 1; \\n            if (bal < 0) return false; \\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852106,
                "title": "c-solution-fully-explained",
                "content": "THIS IS A TRICKY QUESTION , IT CAN BE SOLVED IF WE OBSERVE VERY CAREFULLY\\n\\n**THINGS NEED TO BE OBSERVED**\\n\\n1) IF THE STRING IS OF **ODD** SIZE, IT MEANS THAT THERE IS AN EXTRA BRACKET PRESENT SO WE CAN\\'T ACHIEVE A BALANCED STRING.\\n\\n2) IF WE ARE GOING FROM LEFT TO RIGHT, WE NEED TO CHECK AT EVERY POINT THAT \\n\\t\\t**IF THE NO OF CLOSE BRACKETS > NO OF OPEN BRACKETS + NO OF BRACKETS THAT CAN BE CHANGED**  THEN THE STRING CAN\\'T BE BALANCED\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE TO PROVE THIS THING\\n\\nLET THE STRING BE S = \"))((\" AND ARRAY  BE [1,1,0,0]\\n\\nNOW IF SEE THE FIRST INDEX ONLY THEN WE SEE THAT IT CANT BE CHANGED + IT IS CLOSED \\n\\nSO OUR CLOSED COUNT = 1;\\n\\t\\t\\t\\tOPEN COUNT = 0;     *{{{ FOR THE FIRST INDEX  ONLY}}}*\\n\\t\\t\\t\\tNO OF BRACKETS THAT CAN BE CHANGED = 0;\\nSO THE **NO OF CLOSED BRACKETS ARE MORE THEN THE NO OF OPEN BRACKETS+ NO OF BRACKETS THAT CAN BE CHANGED**\\nHENCE THIS STRING CAN NEVER BE BALACNED\\n\\n3) IF WE ARE GOING FROM RIGHT TO LEFT, WE NEED TO CHECK AT EVERY POINT THAT \\n\\t**IF THE NO OF OPEN BRACKETS > NO OF CLOSE BRACKETS + NO OF BRACKETS THAT CAN BE CHANGED THEN THE STRING CAN\\'T BE BALANCED**\\n\\n\\nLET ME EXPLAIN WITH A SIMPLE EXAMPLE\\n\\nLET S = \"))((\" AND ARRAY = [0,0,1,1]\\nNOW STARTING FROM THE RIGHT HAND SIDE OF THE STRING,\\n\\tFOR THE FIRST INDEX \\n\\tOPEN COUNT = 1;\\n\\tCLOSE COUNT = 0;\\n\\tNO OF BRACKETS THAT CAN BE CHANGED = 0;\\n\\nSO THE** NO OF OPEN BRACKETS  ARE MORE THEN THE NO OF CLOSED BRACKETS + NO OF BRACKETS THAT CAN BE CHANGED**\\nHENCE THIS STRING CAN\\'T BE BALANCED\\n\\nTHE CODE IS REALLY SIMPLE\\n\\n```\\nif(s.size()%2!=0)\\n        {\\n            return false;\\n        }\\n        \\n        int a = 0;\\n        int b =  0;\\n        int c = 0;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n           if(locked[i]==\\'0\\')\\n           {\\n               c++;\\n           }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    a++;\\n                }\\n                else\\n                {\\n                    b++;\\n                }\\n            }\\n            \\n             if(b> (a+c) )\\n        {\\n            return false;\\n        }\\n        }\\n        a=0;\\n        b=0;\\n        c=0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(locked[i]==\\'0\\')\\n           {\\n               c++;\\n           }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    a++;\\n                }\\n                else\\n                {\\n                    b++;\\n                }\\n            }\\n            \\n             if(a>(b+c) )\\n        {\\n            return false;\\n        }     \\n            \\n        }\\n       \\n       \\n        return true;\\n        \\n    }",
                "solutionTags": [],
                "code": "THIS IS A TRICKY QUESTION , IT CAN BE SOLVED IF WE OBSERVE VERY CAREFULLY\\n\\n**THINGS NEED TO BE OBSERVED**\\n\\n1) IF THE STRING IS OF **ODD** SIZE, IT MEANS THAT THERE IS AN EXTRA BRACKET PRESENT SO WE CAN\\'T ACHIEVE A BALANCED STRING.\\n\\n2) IF WE ARE GOING FROM LEFT TO RIGHT, WE NEED TO CHECK AT EVERY POINT THAT \\n\\t\\t**IF THE NO OF CLOSE BRACKETS > NO OF OPEN BRACKETS + NO OF BRACKETS THAT CAN BE CHANGED**  THEN THE STRING CAN\\'T BE BALANCED\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE TO PROVE THIS THING\\n\\nLET THE STRING BE S = \"))((\" AND ARRAY  BE [1,1,0,0]\\n\\nNOW IF SEE THE FIRST INDEX ONLY THEN WE SEE THAT IT CANT BE CHANGED + IT IS CLOSED \\n\\nSO OUR CLOSED COUNT = 1;\\n\\t\\t\\t\\tOPEN COUNT = 0;     *{{{ FOR THE FIRST INDEX  ONLY}}}*\\n\\t\\t\\t\\tNO OF BRACKETS THAT CAN BE CHANGED = 0;\\nSO THE **NO OF CLOSED BRACKETS ARE MORE THEN THE NO OF OPEN BRACKETS+ NO OF BRACKETS THAT CAN BE CHANGED**\\nHENCE THIS STRING CAN NEVER BE BALACNED\\n\\n3) IF WE ARE GOING FROM RIGHT TO LEFT, WE NEED TO CHECK AT EVERY POINT THAT \\n\\t**IF THE NO OF OPEN BRACKETS > NO OF CLOSE BRACKETS + NO OF BRACKETS THAT CAN BE CHANGED THEN THE STRING CAN\\'T BE BALANCED**\\n\\n\\nLET ME EXPLAIN WITH A SIMPLE EXAMPLE\\n\\nLET S = \"))((\" AND ARRAY = [0,0,1,1]\\nNOW STARTING FROM THE RIGHT HAND SIDE OF THE STRING,\\n\\tFOR THE FIRST INDEX \\n\\tOPEN COUNT = 1;\\n\\tCLOSE COUNT = 0;\\n\\tNO OF BRACKETS THAT CAN BE CHANGED = 0;\\n\\nSO THE** NO OF OPEN BRACKETS  ARE MORE THEN THE NO OF CLOSED BRACKETS + NO OF BRACKETS THAT CAN BE CHANGED**\\nHENCE THIS STRING CAN\\'T BE BALANCED\\n\\nTHE CODE IS REALLY SIMPLE\\n\\n```\\nif(s.size()%2!=0)\\n        {\\n            return false;\\n        }\\n        \\n        int a = 0;\\n        int b =  0;\\n        int c = 0;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n           if(locked[i]==\\'0\\')\\n           {\\n               c++;\\n           }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    a++;\\n                }\\n                else\\n                {\\n                    b++;\\n                }\\n            }\\n            \\n             if(b> (a+c) )\\n        {\\n            return false;\\n        }\\n        }\\n        a=0;\\n        b=0;\\n        c=0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(locked[i]==\\'0\\')\\n           {\\n               c++;\\n           }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    a++;\\n                }\\n                else\\n                {\\n                    b++;\\n                }\\n            }\\n            \\n             if(a>(b+c) )\\n        {\\n            return false;\\n        }     \\n            \\n        }\\n       \\n       \\n        return true;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1646716,
                "title": "java-short-and-intuitive-solution-o-n",
                "content": "```java\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        if (n % 2 != 0) return false;\\n        \\n        int possibleOpens = 0;\\n        int fixedCloses = 0;\\n        \\n        for (int i = 0; i < n; i ++) {\\n            if (s.charAt(i) == \\'(\\' || locked.charAt(i) == \\'0\\') {\\n                possibleOpens++;\\n            } else {\\n                fixedCloses++;\\n            }\\n            \\n            if (fixedCloses > possibleOpens) return false;\\n        }\\n        \\n        int possibleCloses = 0;\\n        int fixedOpens = 0;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\' || locked.charAt(i) == \\'0\\') {\\n                possibleCloses++;\\n            } else {\\n                fixedOpens++;\\n            }\\n            \\n            if (fixedOpens > possibleCloses) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        if (n % 2 != 0) return false;\\n        \\n        int possibleOpens = 0;\\n        int fixedCloses = 0;\\n        \\n        for (int i = 0; i < n; i ++) {\\n            if (s.charAt(i) == \\'(\\' || locked.charAt(i) == \\'0\\') {\\n                possibleOpens++;\\n            } else {\\n                fixedCloses++;\\n            }\\n            \\n            if (fixedCloses > possibleOpens) return false;\\n        }\\n        \\n        int possibleCloses = 0;\\n        int fixedOpens = 0;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\' || locked.charAt(i) == \\'0\\') {\\n                possibleCloses++;\\n            } else {\\n                fixedOpens++;\\n            }\\n            \\n            if (fixedOpens > possibleCloses) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592759,
                "title": "stack-c-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple and this problem is similar to the below problem.\\nNote:- Keep in mind that here we can change the unlocked parenthesis.\\n**To make similar problem , change the unlocked parenthesis to \"*\"**\\n\\nRelated Problem:- https://leetcode.com/problems/valid-parenthesis-string/description/\\n\\n1. start traverse the string if s[i] is \\'*\\' then push back it to star stack , if s[i] is \"(\" then push back it to open stack , if s[i] is \")\" then first check open stack if it is empty then check star stack if it is also empty ,return false otherwise pop the top elment of the stack.\\n\\n2. after traversing, pop the elments of open stack with star stack if position(top elment of the open stack )is less then position(top element of the star stack)\\n\\n3. check that number of reaming stars in star stack if even no problem otherwise return false\\n\\n4. if open stack is not empty then return false otherwise return true;\\n \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n\\n        int n = s.size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(locked[i]==\\'0\\')\\n            s[i] = \\'*\\';\\n        }\\n\\n        cout<<s<<endl;\\n\\n        stack<int> open,star;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\') open.push(i);\\n            else if(s[i]==\\'*\\') star.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!open.empty()) open.pop();\\n                else if(!star.empty()) star.pop();\\n                else return false;\\n            }\\n        }\\n\\n        while(!open.empty() && !star.empty() && open.top() < star.top())\\n        {\\n            open.pop();\\n            star.pop();\\n        }\\n\\n        if(star.size()%2)\\n        return false;\\n    \\n        return (open.empty());\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/5c4e53bd-c153-4cd6-92c5-ad8f46bfd664_1685791452.2005236.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n\\n        int n = s.size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(locked[i]==\\'0\\')\\n            s[i] = \\'*\\';\\n        }\\n\\n        cout<<s<<endl;\\n\\n        stack<int> open,star;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\') open.push(i);\\n            else if(s[i]==\\'*\\') star.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!open.empty()) open.pop();\\n                else if(!star.empty()) star.pop();\\n                else return false;\\n            }\\n        }\\n\\n        while(!open.empty() && !star.empty() && open.top() < star.top())\\n        {\\n            open.pop();\\n            star.pop();\\n        }\\n\\n        if(star.size()%2)\\n        return false;\\n    \\n        return (open.empty());\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1672472,
                "title": "in-depth-step-by-step-explanation",
                "content": "# Logic\\nThe problem is a simple balancing based problem where one has to find if the string is balanced or not.\\nThis can be simply achieved by thinking of all the cased where the string won\\'t be balanced.\\nThere will be 3 cases in which string won\\'t be balanced:\\n1. when length of string is an odd number, in this case there will always be some extra element either of left side or right side\\n2. suppose we have a string like this, s = \\'((()\\' and l = \\'1110\\'\\nin this case count of open string is more than count of closed strings + count of chanegable strings\\n3. Lastly, we have a string like this, s = \\'()))\\' and l = \\'0111\\'\\nin this case count of closed string is more than count of open strings + count of chanegable strings\\n\\n# Code With Step-By-Step Explainations\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n//         n is the length of string s\\n        int n = s.length();\\n        if(n % 2 != 0){\\n//             if n is odd then the paranthesis can never be balanced, So return false\\n            return false;\\n        }\\n//         if the locked[i] == \\'1\\' then it can\\'t be changed\\n//         so, lets say a is the count of open paranthesis[\\'(\\'], b is the count of closed parathesis[\\')\\'] and c is the count of \\n//         positions which can be changed i.e. locked[i] == \\'0\\'\\n        int a = 0, b = 0, c = 0;\\n//      To find the invalid strings we need to check if there is a case possible where the string always gets invalid\\n//      so, lets define an invalid string first\\n//      the string gets invalid for 2 cases\\n//      case 1: s = \\'(())))\\' and l=\\'001110\\' => #open brackets + #changeable brackets < #closed brackets [from left to right]\\n//         Note: \\'#\\' is short hand for \\'number of\\'\\n//      case 2: s = \\'((()\\' and l = \\'0111\\' => #closed brackets + #changeable brackets < #closed brackets [from right to left]\\n        for(int i = 0; i < n; i++){ // CASE-1\\n            if(locked[i] == \\'0\\'){\\n                c++;\\n            }\\n            else{\\n                if(s[i] == \\'(\\'){\\n                    a++;\\n                }\\n                else{\\n                    b++;\\n                }\\n            }\\n            // if number of closed brackets exceed number of open brackets + number of changeable brackets \\n            // then if strings gets invalid\\n            if((c + a) < b){\\n                return false;\\n            }\\n        }\\n//         the same process needs to be repeated for the other side of the string as well\\n        a = 0, b = 0, c = 0; // reset a,b,c\\n        for(int i = n-1; i >=0; i--){ // CASE-2\\n            if(locked[i] == \\'0\\'){\\n                c++;\\n            }\\n            else{\\n                if(s[i] == \\'(\\'){\\n                    a++;\\n                }\\n                else{\\n                    b++;\\n                }\\n            }\\n            // if number of closed brackets exceed number of open brackets + number of changeable brackets \\n            // then if strings gets invalid\\n            if((c + b) < a){\\n                return false;\\n            }\\n        }\\n//         all the remaining cases are valid strings\\n        return true;\\n    }\\n};\\n```\\n\\nHope This solution helps you understand and solve the problem\\nHappy Coding!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n//         n is the length of string s\\n        int n = s.length();\\n        if(n % 2 != 0){\\n//             if n is odd then the paranthesis can never be balanced, So return false\\n            return false;\\n        }\\n//         if the locked[i] == \\'1\\' then it can\\'t be changed\\n//         so, lets say a is the count of open paranthesis[\\'(\\'], b is the count of closed parathesis[\\')\\'] and c is the count of \\n//         positions which can be changed i.e. locked[i] == \\'0\\'\\n        int a = 0, b = 0, c = 0;\\n//      To find the invalid strings we need to check if there is a case possible where the string always gets invalid\\n//      so, lets define an invalid string first\\n//      the string gets invalid for 2 cases\\n//      case 1: s = \\'(())))\\' and l=\\'001110\\' => #open brackets + #changeable brackets < #closed brackets [from left to right]\\n//         Note: \\'#\\' is short hand for \\'number of\\'\\n//      case 2: s = \\'((()\\' and l = \\'0111\\' => #closed brackets + #changeable brackets < #closed brackets [from right to left]\\n        for(int i = 0; i < n; i++){ // CASE-1\\n            if(locked[i] == \\'0\\'){\\n                c++;\\n            }\\n            else{\\n                if(s[i] == \\'(\\'){\\n                    a++;\\n                }\\n                else{\\n                    b++;\\n                }\\n            }\\n            // if number of closed brackets exceed number of open brackets + number of changeable brackets \\n            // then if strings gets invalid\\n            if((c + a) < b){\\n                return false;\\n            }\\n        }\\n//         the same process needs to be repeated for the other side of the string as well\\n        a = 0, b = 0, c = 0; // reset a,b,c\\n        for(int i = n-1; i >=0; i--){ // CASE-2\\n            if(locked[i] == \\'0\\'){\\n                c++;\\n            }\\n            else{\\n                if(s[i] == \\'(\\'){\\n                    a++;\\n                }\\n                else{\\n                    b++;\\n                }\\n            }\\n            // if number of closed brackets exceed number of open brackets + number of changeable brackets \\n            // then if strings gets invalid\\n            if((c + b) < a){\\n                return false;\\n            }\\n        }\\n//         all the remaining cases are valid strings\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646610,
                "title": "python3-greedy-2-pass",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8bba95f803d58a5e571fa13de6635c96f5d1c1ee) for solutions of biweekly 68. \\n\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)&1: return False\\n        bal = 0\\n        for ch, lock in zip(s, locked):\\n            if lock == \\'0\\' or ch == \\'(\\': bal += 1\\n            elif ch == \\')\\': bal -= 1\\n            if bal < 0: return False \\n        bal = 0\\n        for ch, lock in zip(reversed(s), reversed(locked)): \\n            if lock == \\'0\\' or ch == \\')\\': bal += 1\\n            elif ch == \\'(\\': bal -= 1\\n            if bal < 0: return False\\n        return True\\n```\\n\\nNote: zip object is not reversable but reversed object is zippable.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)&1: return False\\n        bal = 0\\n        for ch, lock in zip(s, locked):\\n            if lock == \\'0\\' or ch == \\'(\\': bal += 1\\n            elif ch == \\')\\': bal -= 1\\n            if bal < 0: return False \\n        bal = 0\\n        for ch, lock in zip(reversed(s), reversed(locked)): \\n            if lock == \\'0\\' or ch == \\')\\': bal += 1\\n            elif ch == \\'(\\': bal -= 1\\n            if bal < 0: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646589,
                "title": "java-two-loops-to-check-locked-parentheses",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake sure we have enough left parentheses to pair.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nVerify that locked parentheses forward and backward.\\n\\nFrom left to right:\\nMake sure we have enough locked \\'(\\' and unlocked to pair locked \\')\\' \\n\\nFrom right to left:\\nMake sure we have enough locked \\')\\' and unlocked to pair locked \\'(\\' \\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\npublic class Solution {\\n  public boolean canBeValid(String s, String locked) {\\n    int n = s.length();\\n    if (n % 2 == 1) {\\n      return false;\\n    }\\n    // forward check \\')\\'\\n    // number of unlocked and locked \\'(\\'\\n    int remain = 0;\\n    for (int i = 0; i < n; i++) {\\n      // check locked \\')\\'\\n      if (locked.charAt(i) == \\'1\\' && s.charAt(i) == \\')\\') {\\n        // don\\'t have nothing left to pair \\')\\'\\n        if (remain == 0) {\\n          return false;\\n        } else {\\n          remain--;\\n        }\\n      } else {\\n        remain++;\\n      }\\n    }\\n\\n    // backward check \\'(\\'\\n    // number of unlocked and locked \\')\\'\\n    remain = 0;\\n    for (int i = n - 1; i >= 0; i--) {\\n      // check locked \\'(\\'\\n      if (locked.charAt(i) == \\'1\\' && s.charAt(i) == \\'(\\') {\\n        // don\\'t have nothing left to pair \\'(\\'\\n        if (remain == 0) {\\n          return false;\\n        } else {\\n          remain--;\\n        }\\n      } else {\\n        remain++;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n  public boolean canBeValid(String s, String locked) {\\n    int n = s.length();\\n    if (n % 2 == 1) {\\n      return false;\\n    }\\n    // forward check \\')\\'\\n    // number of unlocked and locked \\'(\\'\\n    int remain = 0;\\n    for (int i = 0; i < n; i++) {\\n      // check locked \\')\\'\\n      if (locked.charAt(i) == \\'1\\' && s.charAt(i) == \\')\\') {\\n        // don\\'t have nothing left to pair \\')\\'\\n        if (remain == 0) {\\n          return false;\\n        } else {\\n          remain--;\\n        }\\n      } else {\\n        remain++;\\n      }\\n    }\\n\\n    // backward check \\'(\\'\\n    // number of unlocked and locked \\')\\'\\n    remain = 0;\\n    for (int i = n - 1; i >= 0; i--) {\\n      // check locked \\'(\\'\\n      if (locked.charAt(i) == \\'1\\' && s.charAt(i) == \\'(\\') {\\n        // don\\'t have nothing left to pair \\'(\\'\\n        if (remain == 0) {\\n          return false;\\n        } else {\\n          remain--;\\n        }\\n      } else {\\n        remain++;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524028,
                "title": "c-simple-c-code-o-n-88-time",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(n&1)\\n            return false;\\n        int lftbrak = 0, rhtbrak = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(locked[i] == \\'1\\')\\n            {\\n                if(s[i] == \\')\\')\\n                    lftbrak--;\\n                else\\n                    lftbrak++;\\n            }\\n            else\\n                lftbrak++;\\n            if(lftbrak < 0)\\n                return false;\\n        }\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(locked[i] == \\'1\\')\\n            {\\n                if(s[i] == \\'(\\')\\n                    rhtbrak--;\\n                else\\n                    rhtbrak++;\\n            }\\n            else\\n                rhtbrak++;\\n            if(rhtbrak < 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(n&1)\\n            return false;\\n        int lftbrak = 0, rhtbrak = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(locked[i] == \\'1\\')\\n            {\\n                if(s[i] == \\')\\')\\n                    lftbrak--;\\n                else\\n                    lftbrak++;\\n            }\\n            else\\n                lftbrak++;\\n            if(lftbrak < 0)\\n                return false;\\n        }\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(locked[i] == \\'1\\')\\n            {\\n                if(s[i] == \\'(\\')\\n                    rhtbrak--;\\n                else\\n                    rhtbrak++;\\n            }\\n            else\\n                rhtbrak++;\\n            if(rhtbrak < 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646849,
                "title": "python3-greedy-one-pass",
                "content": "We go through in one pass, with 3 variables: \\n\\t\\n\\t1. freeL, the number of left parentheses that may be toggled\\n\\t2. freeR, the number of rights that can be toggled\\n\\t3. degree, the number of left parentheses so far minus right parentheses so far\\n\\nFormulated this way, the problem is whether we can swap parentheses so that at no point does degree drop below 0, and, at the end, the degree = freeL.\\n\\nIterating through s, we adjust the variables in the obvious way. If we come on a right parenthesis, and degree is 0, the case is possible invalid. Now, if there are no free rights, then the case definitely is invalid and we return false. If there is a free right, then we decrement freeR by 1 and increment degree by 2, simulating swapping a prior free right into a left.\\n\\nAfter this, number of free lefts must be adjusted to be no greater than degree/2. The reason for this is, toggling a left parenthesis decrements degree by 2. If we were to toggle more than degree/2 lefts, degree would drop below 0.\\n\\nLast, we only need to check if the degree is equal to number of free lefts.\\n\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        freeL, freeR, degree = 0, 0, 0\\n        for c, lock in zip(s, locked):\\n            if c == \\'(\\': \\n                degree += 1\\n                if lock == \\'0\\': freeL += 1\\n            else: \\n                degree -= 1\\n                if lock == \\'0\\': freeR += 1\\n            if degree < 0:\\n                if not freeR: return False\\n                freeR -= 1\\n                degree += 2\\n            freeL = min(degree//2, freeL)\\n        return degree == freeL*2",
                "solutionTags": [
                    "Python"
                ],
                "code": "We go through in one pass, with 3 variables: \\n\\t\\n\\t1. freeL, the number of left parentheses that may be toggled\\n\\t2. freeR, the number of rights that can be toggled\\n\\t3. degree, the number of left parentheses so far minus right parentheses so far\\n\\nFormulated this way, the problem is whether we can swap parentheses so that at no point does degree drop below 0, and, at the end, the degree = freeL.\\n\\nIterating through s, we adjust the variables in the obvious way. If we come on a right parenthesis, and degree is 0, the case is possible invalid. Now, if there are no free rights, then the case definitely is invalid and we return false. If there is a free right, then we decrement freeR by 1 and increment degree by 2, simulating swapping a prior free right into a left.\\n\\nAfter this, number of free lefts must be adjusted to be no greater than degree/2. The reason for this is, toggling a left parenthesis decrements degree by 2. If we were to toggle more than degree/2 lefts, degree would drop below 0.\\n\\nLast, we only need to check if the degree is equal to number of free lefts.\\n\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        freeL, freeR, degree = 0, 0, 0\\n        for c, lock in zip(s, locked):\\n            if c == \\'(\\': \\n                degree += 1\\n                if lock == \\'0\\': freeL += 1\\n            else: \\n                degree -= 1\\n                if lock == \\'0\\': freeR += 1\\n            if degree < 0:\\n                if not freeR: return False\\n                freeR -= 1\\n                degree += 2\\n            freeL = min(degree//2, freeL)\\n        return degree == freeL*2",
                "codeTag": "Java"
            },
            {
                "id": 1735834,
                "title": "c-o-n-solution-easy-simple-concise-counting",
                "content": "**If the solution helps you,please do consider upvoting it.**\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) \\n    {\\n     if(s.size()&1)\\n         return false;\\n        int bal=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(locked[i]==\\'0\\' or s[i]==\\'(\\')\\n                bal+=1;\\n            else\\n                bal-=1;\\n            if(bal<0)\\n                return false;\\n            \\n        }\\n        bal=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(locked[i]==\\'0\\' or s[i]==\\')\\')\\n                bal+=1;\\n            else\\n                bal-=1;\\n            if(bal<0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) \\n    {\\n     if(s.size()&1)\\n         return false;\\n        int bal=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(locked[i]==\\'0\\' or s[i]==\\'(\\')\\n                bal+=1;\\n            else\\n                bal-=1;\\n            if(bal<0)\\n                return false;\\n            \\n        }\\n        bal=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(locked[i]==\\'0\\' or s[i]==\\')\\')\\n                bal+=1;\\n            else\\n                bal-=1;\\n            if(bal<0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653325,
                "title": "2116-check-if-a-parentheses-string-can-be-valid-left-to-right-and-right-to-left-approach",
                "content": "**Runtime: 14 ms, faster than 90.02% of Java online submissions for Check if a Parentheses String Can Be Valid.\\nMemory Usage: 39.8 MB, less than 55.53% of Java online submissions for Check if a Parentheses String Can Be Valid.**\\n\\nA useful trick (when doing any parentheses validation) is to greedily check balance left-to-right, and then right-to-left.\\n\\nLeft-to-right check ensures that we do not have orphan \\')\\' parentheses.\\nRight-to-left checks for orphan \\'(\\' parentheses.\\n\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int close=0;\\n        int open=0;\\n        int n = s.length();\\n        if(n%2!=0)\\n            return false;\\n        for(int i=0;i<n;i++){\\n            if(locked.charAt(i)==\\'0\\' || s.charAt(i)==\\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close>open)\\n                return false;\\n        }\\n        open=0;\\n        close=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(locked.charAt(i)==\\'0\\' || s.charAt(i)==\\')\\')\\n                open++;\\n            else\\n                close++;\\n            if(close>open)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\\n\\n**Upvote if you liked the approach.**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int close=0;\\n        int open=0;\\n        int n = s.length();\\n        if(n%2!=0)\\n            return false;\\n        for(int i=0;i<n;i++){\\n            if(locked.charAt(i)==\\'0\\' || s.charAt(i)==\\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close>open)\\n                return false;\\n        }\\n        open=0;\\n        close=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(locked.charAt(i)==\\'0\\' || s.charAt(i)==\\')\\')\\n                open++;\\n            else\\n                close++;\\n            if(close>open)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646601,
                "title": "java-o-n-iterative-runtime-37-ms-faster-than-80-00",
                "content": "\\nThe basic Idea to solve this question is same as \\nValid Parenthesis  ->>https://leetcode.com/problems/valid-parentheses/\\n\\nFirst of all i am checking the string by\\n* Same string\\n* by reversing the string\\n\\nfor same string\\nif any time we are unable to find the valid parenthesis mean no of \\')\\' is greater then \\'(\\' i immediately return false\\nand this case didn\\'t happens\\n\\nthen we got a value ans which indicate the the no of \\'(((((\\' then if count (no of locked character) is greater then half od ans(\\'(((\\')  then we can easily form the valid parenthesis.\\n\\nThis is working same after reversing the string\\n\\nif this explanation is enough for you to completely understand the logic. \\nI request you please Dry Run this code.\\n\\n\\uD83D\\uDE4C\\u270C hope you will Upvote this post Thanku from indian boy\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        \\n        int len=s.length();\\n        if(len%2!=0) return false;\\n        \\n        \\n        return check(s,\\')\\',locked) && check(new StringBuilder(s).reverse().toString(),\\'(\\',new StringBuilder(locked).reverse().toString());\\n    }\\n    boolean check(String s,char te,String locked){\\n        int ans=0,count=0;\\n        int len=s.length();\\n        for(int i=0;i<len;i++){\\n            char ch=s.charAt(i);\\n            \\n            if(ch==te && locked.charAt(i)==\\'1\\') ans--;\\n            else ans++;\\n            \\n            if(ans<0) return false;\\n            if(locked.charAt(i)==\\'0\\') count++;\\n        }\\n        return (count>=(ans/2));\\n    }\\n}\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nIf you find this post useful upvote it!\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        \\n        int len=s.length();\\n        if(len%2!=0) return false;\\n        \\n        \\n        return check(s,\\')\\',locked) && check(new StringBuilder(s).reverse().toString(),\\'(\\',new StringBuilder(locked).reverse().toString());\\n    }\\n    boolean check(String s,char te,String locked){\\n        int ans=0,count=0;\\n        int len=s.length();\\n        for(int i=0;i<len;i++){\\n            char ch=s.charAt(i);\\n            \\n            if(ch==te && locked.charAt(i)==\\'1\\') ans--;\\n            else ans++;\\n            \\n            if(ans<0) return false;\\n            if(locked.charAt(i)==\\'0\\') count++;\\n        }\\n        return (count>=(ans/2));\\n    }\\n}\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nIf you find this post useful upvote it!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213128,
                "title": "java-easy-to-understand-two-stacks-greedy",
                "content": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) \\n    {\\n        Stack<Integer> open=new Stack<>();\\n        Stack<Integer> free=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(locked.charAt(i)==\\'0\\')\\n            free.push(i);\\n            \\n            else if(s.charAt(i)==\\'(\\')\\n            open.push(i);\\n            \\n            else if(s.charAt(i)==\\')\\' && !open.isEmpty())\\n            open.pop();\\n            \\n            else if(s.charAt(i)==\\')\\' && !free.isEmpty())\\n            free.pop();\\n            \\n            else\\n            {\\n                System.out.println(i);\\n                return false;\\n            }\\n            \\n        }\\n        \\n        while(!open.isEmpty() && !free.isEmpty())\\n        {\\n            if(open.peek()>free.peek())\\n            return false;\\n            \\n            open.pop();\\n            free.pop();\\n        }\\n        \\n        if(!open.isEmpty())\\n        return false;\\n        \\n        if(free.size()%2!=0)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) \\n    {\\n        Stack<Integer> open=new Stack<>();\\n        Stack<Integer> free=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(locked.charAt(i)==\\'0\\')\\n            free.push(i);\\n            \\n            else if(s.charAt(i)==\\'(\\')\\n            open.push(i);\\n            \\n            else if(s.charAt(i)==\\')\\' && !open.isEmpty())\\n            open.pop();\\n            \\n            else if(s.charAt(i)==\\')\\' && !free.isEmpty())\\n            free.pop();\\n            \\n            else\\n            {\\n                System.out.println(i);\\n                return false;\\n            }\\n            \\n        }\\n        \\n        while(!open.isEmpty() && !free.isEmpty())\\n        {\\n            if(open.peek()>free.peek())\\n            return false;\\n            \\n            open.pop();\\n            free.pop();\\n        }\\n        \\n        if(!open.isEmpty())\\n        return false;\\n        \\n        if(free.size()%2!=0)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810440,
                "title": "c-sweet-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.size()&1)\\n            return false;\\n       int lopen=0,free=0,lclose=0;\\n        for(int i=0;i<s.size();i++){\\n            if(locked[i]==\\'0\\') free++;\\n            else{\\n                if(s[i]==\\'(\\') lopen++;\\n                else \\n                    lclose++;\\n            }\\n            if(lclose>free+lopen) return false;\\n        }\\n          lopen=0,free=0,lclose=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(locked[i]==\\'0\\') free++;\\n            else{\\n                if(s[i]==\\'(\\') lopen++;\\n                else \\n                    lclose++;\\n            }\\n            if(lopen>free+lclose) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.size()&1)\\n            return false;\\n       int lopen=0,free=0,lclose=0;\\n        for(int i=0;i<s.size();i++){\\n            if(locked[i]==\\'0\\') free++;\\n            else{\\n                if(s[i]==\\'(\\') lopen++;\\n                else \\n                    lclose++;\\n            }\\n            if(lclose>free+lopen) return false;\\n        }\\n          lopen=0,free=0,lclose=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(locked[i]==\\'0\\') free++;\\n            else{\\n                if(s[i]==\\'(\\') lopen++;\\n                else \\n                    lclose++;\\n            }\\n            if(lopen>free+lclose) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654660,
                "title": "c-easy-solution",
                "content": "```\\nbool canBeValid(string s, string locked) {\\n        int n=s.length();\\n        if(n%2!=0) return false;\\n        int lockedOpen=0,lockedClose=0,free=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(locked[i]==\\'0\\')\\n            {\\n                free++;\\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    lockedOpen++;\\n                }\\n                else\\n                {\\n                    lockedClose++;\\n                }\\n            }\\n            if(lockedClose > free+lockedOpen) return false;\\n        }\\n        lockedOpen=0,lockedClose=0,free=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(locked[i]==\\'0\\')\\n            {\\n                free++;\\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    lockedOpen++;\\n                }\\n                else\\n                {\\n                    lockedClose++;\\n                }\\n            }\\n            if(lockedOpen > free+lockedClose) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canBeValid(string s, string locked) {\\n        int n=s.length();\\n        if(n%2!=0) return false;\\n        int lockedOpen=0,lockedClose=0,free=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(locked[i]==\\'0\\')\\n            {\\n                free++;\\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    lockedOpen++;\\n                }\\n                else\\n                {\\n                    lockedClose++;\\n                }\\n            }\\n            if(lockedClose > free+lockedOpen) return false;\\n        }\\n        lockedOpen=0,lockedClose=0,free=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(locked[i]==\\'0\\')\\n            {\\n                free++;\\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    lockedOpen++;\\n                }\\n                else\\n                {\\n                    lockedClose++;\\n                }\\n            }\\n            if(lockedOpen > free+lockedClose) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646666,
                "title": "very-simple-easy-to-understand-c",
                "content": "if no. of characters is odd - return false;\\nelse check for this algo .\\nintuition - what if \\n```\\ns=\").....\"\\nloc=\"1....\"\\n```\\nthis should return false. as nothing can satisfies this. hence check this for all values of i . so for each value first we calculate no. of locked \")\" and \"(\" or unlocked characters (f) . let denote them as l,r,and f. so if (l>r+f ) then return false .\\nsimilarly goes for \\n```\\ns=\"......(\"\\nl=\".......1\"\\n```\\nhere again we calculate no. of l \")\" , r \"(\" and free variable - f which are not locked \\nbut here condition is reversed - if r>l+f  then return false.\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string lo) {\\n        int n=s.size();\\n        if(n%2) return false;\\n        int l=0,r=0,f=0;\\n        for(int i=0;i!=s.size();i++){ // checking from left side .\\n            if(lo[i]==\\'1\\'){\\n                if(s[i]==\\')\\'){\\n                    l++; // calculating no. of \")\"\\n                    \\n                }\\n                else{\\n                    r++; // calculating no. of \"(\"\\n                }\\n            }\\n            else{\\n                f++;   // calculating no. of unlocked variable for which locked[i]==\\'0\\'\\n            }\\n            if(l>r){\\n                if(l>r+f){\\n                    return false;\\n                }\\n            }\\n        }\\n        l=0,r=0,f=0;\\n        for(int i=n-1;i>=0;i--){        // checking from right side .\\n            if(lo[i]==\\'1\\'){\\n                if(s[i]==\\')\\'){\\n                    l++;        // calculating no. of \")\"\\n                }\\n                else{\\n                    r++;        // calculating no. of \"(\"\\n                }\\n            }\\n            else{\\n                f++;            // calculating no. of unlocked variable for which locked[i]==\\'0\\'\\n            }\\n            if(r>l){\\n                if(r>(l+f)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ns=\").....\"\\nloc=\"1....\"\\n```\n```\\ns=\"......(\"\\nl=\".......1\"\\n```\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string lo) {\\n        int n=s.size();\\n        if(n%2) return false;\\n        int l=0,r=0,f=0;\\n        for(int i=0;i!=s.size();i++){ // checking from left side .\\n            if(lo[i]==\\'1\\'){\\n                if(s[i]==\\')\\'){\\n                    l++; // calculating no. of \")\"\\n                    \\n                }\\n                else{\\n                    r++; // calculating no. of \"(\"\\n                }\\n            }\\n            else{\\n                f++;   // calculating no. of unlocked variable for which locked[i]==\\'0\\'\\n            }\\n            if(l>r){\\n                if(l>r+f){\\n                    return false;\\n                }\\n            }\\n        }\\n        l=0,r=0,f=0;\\n        for(int i=n-1;i>=0;i--){        // checking from right side .\\n            if(lo[i]==\\'1\\'){\\n                if(s[i]==\\')\\'){\\n                    l++;        // calculating no. of \")\"\\n                }\\n                else{\\n                    r++;        // calculating no. of \"(\"\\n                }\\n            }\\n            else{\\n                f++;            // calculating no. of unlocked variable for which locked[i]==\\'0\\'\\n            }\\n            if(r>l){\\n                if(r>(l+f)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646644,
                "title": "python-one-pass",
                "content": "If s has an odd length, it\\'s impossible to get a valid string.\\nPass through s and locked, and use low and high to track the range of the possible number of \"(\" remained.\\nIf s[i] is locked, add or minus low and high by 1.\\nIf s[i] is unlocked, it can be modified as \\')\\' with low -= 1, or \\'(\\' with high += 1.\\nIn each step, low should not be lower than 0, so we get low=max(0, low) and if low > high, it\\'s impossible to be valid.\\nFinally, the string can be valid only if 0 is within the range of [low, high], or low == 0.\\n\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s) % 2 == 1:\\n            return False\\n        low = high = 0\\n        for i in range(len(s)):\\n            if locked[i] == \\'1\\':\\n                if s[i] == \\'(\\':\\n                    low += 1\\n                    high += 1\\n                else:\\n                    low -= 1\\n                    high -= 1\\n            else:\\n                low -= 1\\n                high += 1\\n            low = max(low, 0)\\n            if low > high:\\n                return False\\n        return low == 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s) % 2 == 1:\\n            return False\\n        low = high = 0\\n        for i in range(len(s)):\\n            if locked[i] == \\'1\\':\\n                if s[i] == \\'(\\':\\n                    low += 1\\n                    high += 1\\n                else:\\n                    low -= 1\\n                    high -= 1\\n            else:\\n                low -= 1\\n                high += 1\\n            low = max(low, 0)\\n            if low > high:\\n                return False\\n        return low == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340582,
                "title": "easy-python-and-c-solutions-using-greedy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int csc=0,opc=0,loc=0; #csc closed count opc open count loc locked count\\n        char op=\\'(\\',cs=\\')\\',one=\\'1\\',zro=\\'0\\';\\n        if(s.size()%2!=0) \\n            return false;\\n        for(int i=0; i<s.size();i++){\\n            if(locked[i]==one && s[i]==op) \\n                opc++;\\n            else if(locked[i]==one && s[i]==cs) \\n                csc++;\\n            if(locked[i]==zro) loc++;\\n\\n            if(loc+opc<csc) return false;\\n        }\\n        int rsc=0,rpc=0,roc=0; #rsc reverse close count rpc reverse close count roc reverse closed count\\n        for(int i=s.size()-1; i>=0;i--){\\n            cout<<i<<\\' \\';\\n            if(locked[i]==one && s[i]==op) \\n                rpc++;\\n            else if(locked[i]==one && s[i]==cs) \\n                rsc++;\\n            if(locked[i]==zro) roc++;\\n            if(roc+rsc<rpc) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n# #code\\n```\\nclass Solution(object):\\n    def canBeValid(self, s, locked):\\n        \"\"\"\\n        :type s: str\\n        :type locked: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s)%2!=0:\\n            return False\\n        opc,csc,loc=0,0,0 #opc open count , loc=locked count, csc close count\\n        for i in range(len(s)):\\n            if locked[i]==\"1\" and s[i]==\"(\":\\n                opc+=1\\n            elif locked[i]==\"1\" and s[i]==\")\":\\n                csc+=1\\n            if locked[i]==\"0\":\\n                loc+=1\\n            if opc+loc<csc:\\n                return False\\n        opc,csc,loc=0,0,0\\n        for i in range(len(s),-1,-1):\\n            if locked[i-1]==\"1\" and s[i-1]==\"(\":\\n                opc+=1\\n            elif locked[i-1]==\"1\" and s[i-1]==\")\":\\n                csc+=1\\n            if locked[i-1]==\"0\":\\n                loc+=1\\n            if csc+loc<opc:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int csc=0,opc=0,loc=0; #csc closed count opc open count loc locked count\\n        char op=\\'(\\',cs=\\')\\',one=\\'1\\',zro=\\'0\\';\\n        if(s.size()%2!=0) \\n            return false;\\n        for(int i=0; i<s.size();i++){\\n            if(locked[i]==one && s[i]==op) \\n                opc++;\\n            else if(locked[i]==one && s[i]==cs) \\n                csc++;\\n            if(locked[i]==zro) loc++;\\n\\n            if(loc+opc<csc) return false;\\n        }\\n        int rsc=0,rpc=0,roc=0; #rsc reverse close count rpc reverse close count roc reverse closed count\\n        for(int i=s.size()-1; i>=0;i--){\\n            cout<<i<<\\' \\';\\n            if(locked[i]==one && s[i]==op) \\n                rpc++;\\n            else if(locked[i]==one && s[i]==cs) \\n                rsc++;\\n            if(locked[i]==zro) roc++;\\n            if(roc+rsc<rpc) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def canBeValid(self, s, locked):\\n        \"\"\"\\n        :type s: str\\n        :type locked: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s)%2!=0:\\n            return False\\n        opc,csc,loc=0,0,0 #opc open count , loc=locked count, csc close count\\n        for i in range(len(s)):\\n            if locked[i]==\"1\" and s[i]==\"(\":\\n                opc+=1\\n            elif locked[i]==\"1\" and s[i]==\")\":\\n                csc+=1\\n            if locked[i]==\"0\":\\n                loc+=1\\n            if opc+loc<csc:\\n                return False\\n        opc,csc,loc=0,0,0\\n        for i in range(len(s),-1,-1):\\n            if locked[i-1]==\"1\" and s[i-1]==\"(\":\\n                opc+=1\\n            elif locked[i-1]==\"1\" and s[i-1]==\")\":\\n                csc+=1\\n            if locked[i-1]==\"0\":\\n                loc+=1\\n            if csc+loc<opc:\\n                return False\\n        return True\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2384558,
                "title": "easy-java-solution-in-o-n-time-and-constant-space",
                "content": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if(s.length()%2!=0)\\n            return false;\\n        int open=0,close =0,flip_allowed=0;\\n        for(int i =0;i<s.length();i++){\\n            if(locked.charAt(i)==\\'0\\')\\n                flip_allowed++;\\n            else{\\n                if(s.charAt(i)==\\'(\\')\\n                    open++;\\n                else\\n                    close++;\\n            }\\n            if(open+flip_allowed<close)\\n                return false;\\n        }\\n        open =0;close=0;\\n        flip_allowed=0;\\n        for(int i =s.length()-1;i>=0;i--){\\n            if(locked.charAt(i)==\\'0\\')\\n                flip_allowed++;\\n            else{\\n                if(s.charAt(i)==\\'(\\')\\n                    open++;\\n                else\\n                    close++;\\n            }\\n            if(flip_allowed+close<open)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if(s.length()%2!=0)\\n            return false;\\n        int open=0,close =0,flip_allowed=0;\\n        for(int i =0;i<s.length();i++){\\n            if(locked.charAt(i)==\\'0\\')\\n                flip_allowed++;\\n            else{\\n                if(s.charAt(i)==\\'(\\')\\n                    open++;\\n                else\\n                    close++;\\n            }\\n            if(open+flip_allowed<close)\\n                return false;\\n        }\\n        open =0;close=0;\\n        flip_allowed=0;\\n        for(int i =s.length()-1;i>=0;i--){\\n            if(locked.charAt(i)==\\'0\\')\\n                flip_allowed++;\\n            else{\\n                if(s.charAt(i)==\\'(\\')\\n                    open++;\\n                else\\n                    close++;\\n            }\\n            if(flip_allowed+close<open)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109305,
                "title": "python-simple-logic",
                "content": "\\n    def canBeValid(self, s, locked):\\n        if len(s)%2 == 1:\\n            return False\\n        \\n        op, cl, count = 0, 0, 0\\n        \\n        for i in range(len(s)):\\n            if locked[i] == \"0\":\\n                count += 1\\n            else:\\n                if s[i] == \"(\":\\n                    op += 1\\n                else:\\n                    cl += 1\\n                    \\n                if cl - op > count:\\n                    return False\\n                \\n                \\n        op, cl, count = 0, 0, 0\\n        \\n        for i in range(len(s)-1,-1,-1):\\n            if locked[i] == \"0\":\\n                count += 1\\n            else:\\n                if s[i] == \"(\":\\n                    op += 1\\n                else:\\n                    cl += 1\\n                    \\n                if op - cl > count:\\n                    return False\\n                \\n        return True",
                "solutionTags": [],
                "code": "\\n    def canBeValid(self, s, locked):\\n        if len(s)%2 == 1:\\n            return False\\n        \\n        op, cl, count = 0, 0, 0\\n        \\n        for i in range(len(s)):\\n            if locked[i] == \"0\":\\n                count += 1\\n            else:\\n                if s[i] == \"(\":\\n                    op += 1\\n                else:\\n                    cl += 1\\n                    \\n                if cl - op > count:\\n                    return False\\n                \\n                \\n        op, cl, count = 0, 0, 0\\n        \\n        for i in range(len(s)-1,-1,-1):\\n            if locked[i] == \"0\":\\n                count += 1\\n            else:\\n                if s[i] == \"(\":\\n                    op += 1\\n                else:\\n                    cl += 1\\n                    \\n                if op - cl > count:\\n                    return False\\n                \\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 1658229,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) \\n    {\\n        int n=s.size();\\n        if(n%2)\\n            return false;\\n        stack<int>lock,unlock;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\')\\' && locked[i]==\\'1\\')\\n            {\\n                if(!lock.empty())\\n                   lock.pop();\\n                else if(!unlock.empty())\\n                    unlock.pop();\\n                else\\n                    return false;\\n            }\\n            else if(s[i]==\\'(\\' && locked[i]==\\'1\\')\\n                lock.push(i);\\n            else\\n                unlock.push(i);\\n        }\\n        while(!lock.empty())\\n        {\\n            if(unlock.empty() || unlock.top()<lock.top())\\n                return false;\\n            unlock.pop();\\n            lock.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) \\n    {\\n        int n=s.size();\\n        if(n%2)\\n            return false;\\n        stack<int>lock,unlock;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\')\\' && locked[i]==\\'1\\')\\n            {\\n                if(!lock.empty())\\n                   lock.pop();\\n                else if(!unlock.empty())\\n                    unlock.pop();\\n                else\\n                    return false;\\n            }\\n            else if(s[i]==\\'(\\' && locked[i]==\\'1\\')\\n                lock.push(i);\\n            else\\n                unlock.push(i);\\n        }\\n        while(!lock.empty())\\n        {\\n            if(unlock.empty() || unlock.top()<lock.top())\\n                return false;\\n            unlock.pop();\\n            lock.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651007,
                "title": "python-3-greedy-100-time",
                "content": "![image](https://assets.leetcode.com/users/images/b6b10303-85fd-4ea0-8334-4aaddf58e4c2_1640628378.3221455.png)\\n\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        N = len(s)\\n        if N & 1:\\n            return False\\n        \\n        # Scan from left to right and greedily match a locked \\')\\' to an earlier locked \\'(\\'.\\n        # If running out of locked \\'(\\', start consuming unlocked.\\n        # Once all \\')\\' paired, from right to left, pair locked \\'(\\' with unlocked.\\n        # After all locked processed, return True since the rest unlocked can always be manipulated to keep the string valid.\\n        locked_open = []\\n        unlocked = []\\n        \\n        for i, c in enumerate(s):\\n            if locked[i] == \\'0\\':\\n                unlocked.append(i)\\n            else:\\n                if c == \\'(\\':\\n                    locked_open.append(i)\\n                else:\\n                    if locked_open:\\n                        locked_open.pop()\\n                    elif unlocked:\\n                        unlocked.pop()\\n                    else:\\n                        return False\\n        \\n        while locked_open:\\n            if unlocked and unlocked[-1] > locked_open[-1]:\\n                unlocked.pop()\\n                locked_open.pop()\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        N = len(s)\\n        if N & 1:\\n            return False\\n        \\n        # Scan from left to right and greedily match a locked \\')\\' to an earlier locked \\'(\\'.\\n        # If running out of locked \\'(\\', start consuming unlocked.\\n        # Once all \\')\\' paired, from right to left, pair locked \\'(\\' with unlocked.\\n        # After all locked processed, return True since the rest unlocked can always be manipulated to keep the string valid.\\n        locked_open = []\\n        unlocked = []\\n        \\n        for i, c in enumerate(s):\\n            if locked[i] == \\'0\\':\\n                unlocked.append(i)\\n            else:\\n                if c == \\'(\\':\\n                    locked_open.append(i)\\n                else:\\n                    if locked_open:\\n                        locked_open.pop()\\n                    elif unlocked:\\n                        unlocked.pop()\\n                    else:\\n                        return False\\n        \\n        while locked_open:\\n            if unlocked and unlocked[-1] > locked_open[-1]:\\n                unlocked.pop()\\n                locked_open.pop()\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647925,
                "title": "this-problem-is-the-same-as-678-valid-parenthesis-string-o-n-runtime-1-pass-solution",
                "content": "In 678, we **kept track of maxNumOpen and minNumOpen**, which represent the maximum and minimum number of unpaired opening parentheses \\'(\\'. Whenever we encountered a wildcard character \\' * \\', we would **increment maxNumOpen and decrement minNumOpen** to represent that the wildcard could be used as an opening or a closing parenthesis. At every iteration we would also **check that the maximum number of opening parentheses maxNumOpen never fell below 0**, as that would indicate that we had too many closing parentheses even if we set all the seen wildcard characters to opening parentheses. Also, **if the minimum number of opening parentheses minNumOpen ever fell below 0, we could simply set minNumOpen to 0**, as doing so implied that some of the wildcard characters that we have seen so far would be used as opening parentheses to make sure that the count of \\'(\\' is always >= the count of \\')\\'. \\nFinally, we could **confirm that the string is valid by making sure that minNumOpen is == 0**, as that implies that there is a configuration where there are exactly 0 unpaired opening parentheses which would result in a balanced string.\\n\\nCode for 678:\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int maxNumOpen = 0;\\n        int minNumOpen = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            char cur = s.charAt(i);\\n            if(cur == \\'(\\') {\\n                maxNumOpen++;\\n                minNumOpen++;\\n            } else if(cur == \\')\\') {\\n                maxNumOpen--;\\n                minNumOpen--;\\n            } else {\\n                maxNumOpen++;\\n                minNumOpen--;\\n            }\\n            \\n            if(maxNumOpen < 0) {\\n                return false;\\n            }\\n            //Because if minNumOpen is < 0, then \\n            //we can\\'t use the * in (*)... as a ) because then the string\\n            //would be invalid and impossible to fix. So we are forced to set * to (.\\n            if(minNumOpen < 0) {\\n                minNumOpen = 0;\\n            }\\n        }\\n        return minNumOpen == 0;\\n    }\\n}\\n```\\n\\n\\nIn this problem, the only difference is that instead of explicit wildcard characters, we have some characters that are modifiable, so we treat all of these characters as wildcard characters. Also, we need an explicit check for the evenness of the length of the string because we cannot replace these modifiable characters with whitespace like we could in 678.\\n\\nCode for 2116:\\n\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        \\n        if(n % 2 != 0) {\\n            return false;\\n        }\\n        \\n        int maxOpen = 0;\\n        int minOpen = 0;\\n        for(int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n            char l = locked.charAt(i);\\n            \\n            if(l == \\'1\\') {\\n                if(c == \\'(\\') {\\n                    maxOpen++;\\n                    minOpen++;\\n                } else {\\n                    maxOpen--;\\n                    minOpen--;\\n                }\\n            } else {\\n                maxOpen++;\\n                minOpen--;\\n            }\\n            \\n            if(maxOpen < 0) {\\n                return false;\\n            }\\n            \\n            if(minOpen < 0) {\\n                minOpen = 0;\\n            }\\n        }\\n        return minOpen == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int maxNumOpen = 0;\\n        int minNumOpen = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            char cur = s.charAt(i);\\n            if(cur == \\'(\\') {\\n                maxNumOpen++;\\n                minNumOpen++;\\n            } else if(cur == \\')\\') {\\n                maxNumOpen--;\\n                minNumOpen--;\\n            } else {\\n                maxNumOpen++;\\n                minNumOpen--;\\n            }\\n            \\n            if(maxNumOpen < 0) {\\n                return false;\\n            }\\n            //Because if minNumOpen is < 0, then \\n            //we can\\'t use the * in (*)... as a ) because then the string\\n            //would be invalid and impossible to fix. So we are forced to set * to (.\\n            if(minNumOpen < 0) {\\n                minNumOpen = 0;\\n            }\\n        }\\n        return minNumOpen == 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        \\n        if(n % 2 != 0) {\\n            return false;\\n        }\\n        \\n        int maxOpen = 0;\\n        int minOpen = 0;\\n        for(int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n            char l = locked.charAt(i);\\n            \\n            if(l == \\'1\\') {\\n                if(c == \\'(\\') {\\n                    maxOpen++;\\n                    minOpen++;\\n                } else {\\n                    maxOpen--;\\n                    minOpen--;\\n                }\\n            } else {\\n                maxOpen++;\\n                minOpen--;\\n            }\\n            \\n            if(maxOpen < 0) {\\n                return false;\\n            }\\n            \\n            if(minOpen < 0) {\\n                minOpen = 0;\\n            }\\n        }\\n        return minOpen == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931919,
                "title": "python3-solution-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeValid(self, s, locked):\\n        cmin, cmax = 0, 0\\n        for i, j in zip(s, locked):\\n            cmin -= 1 if cmin and (j == \\'0\\' or i == \\')\\') else -1\\n            cmax += 1 if j == \\'0\\' or i == \\'(\\' else -1\\n            if cmax < 0: return False\\n        return cmin == 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s, locked):\\n        cmin, cmax = 0, 0\\n        for i, j in zip(s, locked):\\n            cmin -= 1 if cmin and (j == \\'0\\' or i == \\')\\') else -1\\n            cmax += 1 if j == \\'0\\' or i == \\'(\\' else -1\\n            if cmax < 0: return False\\n        return cmin == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876504,
                "title": "c-o-n-solution",
                "content": "Runtime: 100 ms, faster than 89.56% of C++ online submissions for Check if a Parentheses String Can Be Valid.\\nMemory Usage: 27.2 MB, less than 42.88% of C++ online submissions for Check if a Parentheses String Can Be Valid.\\n\\n`Check balance value from left to right for orphan \\')\\' and right to left for orphan \\'(\\'`\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        \\n        // return false for even length\\n        if(s.length() & 1) return false;\\n        \\n        int balance = 0;\\n        \\n        // check for orphan \\')\\' from left to right\\n        for(int i=0;i<s.length() && balance>=0;i++)\\n        {\\n            if(locked[i]==\\'1\\' && s[i]==\\')\\')balance--;\\n            else balance++;\\n            \\n            if(balance<0)return false;\\n        }\\n        \\n        balance = 0;\\n        \\n        // check for orphan \\'(\\' from right to left\\n        for(int i=s.length()-1;i>=0 && balance>=0;i--)\\n        {\\n            if(locked[i]==\\'1\\' && s[i]==\\'(\\')balance--;\\n            else balance++;\\n            \\n            if(balance<0)return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        \\n        // return false for even length\\n        if(s.length() & 1) return false;\\n        \\n        int balance = 0;\\n        \\n        // check for orphan \\')\\' from left to right\\n        for(int i=0;i<s.length() && balance>=0;i++)\\n        {\\n            if(locked[i]==\\'1\\' && s[i]==\\')\\')balance--;\\n            else balance++;\\n            \\n            if(balance<0)return false;\\n        }\\n        \\n        balance = 0;\\n        \\n        // check for orphan \\'(\\' from right to left\\n        for(int i=s.length()-1;i>=0 && balance>=0;i--)\\n        {\\n            if(locked[i]==\\'1\\' && s[i]==\\'(\\')balance--;\\n            else balance++;\\n            \\n            if(balance<0)return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669053,
                "title": "java-one-string-scan-no-dp-constant-space-explained-clean-code",
                "content": "Initially I was thinking to use stack for this problem, but after giving a second though I realized it can be done by just keeping running number of opening and closing paretheses. \\nCatch is - we will need to scan string 2 times, from left to right and from right to left. On left to right we\\'ll be checking if there is any \")\" unbalanced, and vise versa for the right to left it\\'s done for \"(\". \\nfor each next char in string we keep following:\\n   if this is unlocked char - just increment the count\\n   balance that is a number that shows total sum of opening and closing paretheses. we increment it for \"(\" and decrement for \")\" on left-to-right scan and do invert operation on right-to-left scan. \\nevery next ieration we\\'re checking if balance + unlocked is >= 0. That means either substring is balanced or we can make it balanced by using unlocked chars. \\nAt the end it\\'s possible that our balance is != 0, in such case we need enough unlocked ones to make it balanced. We check if balanced (abs) is <= of unlocked.\\n\\nSome optimization - we can pack left to right and right to left scans into one loop because we can compute the index of the other scan based on index for the first scan.\\n\\nO(n) time - scan string once\\nO(1) space - use few variables to keep state\\n\\n```\\n    public boolean canBeValid(String s, String locked) {\\n        int N = s.length();\\n        if (N % 2 == 1) {\\n            return false;\\n        }\\n        \\n        int balanceLeftToRight = 0, unlockedLeftToRight = 0;\\n        int balanceRightToLeft = 0, unlockedRightToLeft = 0;\\n        //checking left to right, \"(\" +1, \")\" -1\\n        for (int i = 0; i < N && balanceLeftToRight + unlockedLeftToRight >= 0 && balanceRightToLeft + unlockedRightToLeft >= 0; i++) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                unlockedLeftToRight++;\\n            } else {\\n                if (s.charAt(i) == \\'(\\') {\\n                    balanceLeftToRight++;\\n                } else {\\n                    balanceLeftToRight--;\\n                }\\n            }\\n            int rightToLeftIdx = N - i - 1;\\n            if (locked.charAt(rightToLeftIdx) == \\'0\\') {\\n                unlockedRightToLeft++;\\n            } else {\\n                if (s.charAt(rightToLeftIdx) == \\')\\') {\\n                    balanceRightToLeft++;\\n                } else {\\n                    balanceRightToLeft--;\\n                }\\n            }\\n        }\\n        if (Math.abs(balanceLeftToRight) > unlockedLeftToRight || Math.abs(balanceRightToLeft) > unlockedRightToLeft) {\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean canBeValid(String s, String locked) {\\n        int N = s.length();\\n        if (N % 2 == 1) {\\n            return false;\\n        }\\n        \\n        int balanceLeftToRight = 0, unlockedLeftToRight = 0;\\n        int balanceRightToLeft = 0, unlockedRightToLeft = 0;\\n        //checking left to right, \"(\" +1, \")\" -1\\n        for (int i = 0; i < N && balanceLeftToRight + unlockedLeftToRight >= 0 && balanceRightToLeft + unlockedRightToLeft >= 0; i++) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                unlockedLeftToRight++;\\n            } else {\\n                if (s.charAt(i) == \\'(\\') {\\n                    balanceLeftToRight++;\\n                } else {\\n                    balanceLeftToRight--;\\n                }\\n            }\\n            int rightToLeftIdx = N - i - 1;\\n            if (locked.charAt(rightToLeftIdx) == \\'0\\') {\\n                unlockedRightToLeft++;\\n            } else {\\n                if (s.charAt(rightToLeftIdx) == \\')\\') {\\n                    balanceRightToLeft++;\\n                } else {\\n                    balanceRightToLeft--;\\n                }\\n            }\\n        }\\n        if (Math.abs(balanceLeftToRight) > unlockedLeftToRight || Math.abs(balanceRightToLeft) > unlockedRightToLeft) {\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661656,
                "title": "java-constant-space-code",
                "content": "This problem is similar to 678 problem.\\nFor intuition please visit  this link https://leetcode.com/problems/valid-parenthesis-string/discuss/543521/Java-Count-Open-Parenthesis-O(n)-time-O(1)-space-Picture-Explain\\n\\n\\'\\'\\'\\npublic boolean canBeValid(String s, String locked) {\\n      \\n       int n =s.length();\\n        \\n        if(n%2==1)return false;\\n        \\n        int cmin=0,cmax=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(locked.charAt(i)==\\'0\\')\\n            {\\n                cmax++;\\n                cmin--;\\n            }\\n            else\\n            {\\n                if(s.charAt(i)==\\'(\\') \\n                {\\n                    cmax++;\\n                    cmin++; \\n                }\\n                else\\n                {\\n                    cmax--;\\n                    cmin--;\\n                }  \\n            }\\n            \\n            if(cmax<0) return false;\\n            \\n            cmin=Math.max(cmin,0);\\n        }\\n            \\n            \\n       return cmin==0;     \\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "This problem is similar to 678 problem.\\nFor intuition please visit  this link https://leetcode.com/problems/valid-parenthesis-string/discuss/543521/Java-Count-Open-Parenthesis-O(n)-time-O(1)-space-Picture-Explain\\n\\n\\'\\'\\'\\npublic boolean canBeValid(String s, String locked) {\\n      \\n       int n =s.length();\\n        \\n        if(n%2==1)return false;\\n        \\n        int cmin=0,cmax=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(locked.charAt(i)==\\'0\\')\\n            {\\n                cmax++;\\n                cmin--;\\n            }\\n            else\\n            {\\n                if(s.charAt(i)==\\'(\\') \\n                {\\n                    cmax++;\\n                    cmin++; \\n                }\\n                else\\n                {\\n                    cmax--;\\n                    cmin--;\\n                }  \\n            }\\n            \\n            if(cmax<0) return false;\\n            \\n            cmin=Math.max(cmin,0);\\n        }\\n            \\n            \\n       return cmin==0;     \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1659321,
                "title": "easy-c-solution-l-r-and-r-l",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.size()%2!=0) return false;\\n        int open=0,close=0,unpaired=0,unlock=0;\\n        for(int i=0;i<s.size();i++){\\n            if(locked[i]==\\'0\\') unlock++;\\n            else if(s[i]==\\'(\\') open++;\\n            else if(s[i]==\\')\\') close++;\\n            unpaired=close-open;\\n            if(unpaired>unlock) return false;\\n        }\\n        open=0,close=0,unpaired=0,unlock=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(locked[i]==\\'0\\') unlock++;\\n            else if(s[i]==\\'(\\') open++;\\n            else if(s[i]==\\')\\') close++;\\n            unpaired=open-close;\\n            if(unpaired>unlock) return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.size()%2!=0) return false;\\n        int open=0,close=0,unpaired=0,unlock=0;\\n        for(int i=0;i<s.size();i++){\\n            if(locked[i]==\\'0\\') unlock++;\\n            else if(s[i]==\\'(\\') open++;\\n            else if(s[i]==\\')\\') close++;\\n            unpaired=close-open;\\n            if(unpaired>unlock) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1646712,
                "title": "python3-dp-one-pass-o-1-space",
                "content": "Let\\'s give the opening bracket a value of 1, closing bracket a value of -1.\\nFor a valid sequence:\\n* at any point, the accumulated sum is non-negative.\\n* the sum of the whole sequence must be 0, as any opening brackets are exactly matched by closing brackets.\\n\\nBecause some values are locked and some are not, let\\'s define two values while going through the sequence.\\nalpha: the current sum of locked brackets\\nbeta: the current number of non-locked brackets\\nIf we can invalidate a sequence before it has ended, the sequence must have more \")\" than\"(\" up tilll this point. So alpha is negative and if we set all non-locked brackets to \"(\", we still have more \")\". So if alpha + beta < 0 at any point we can return false.\\nThere is another possibility for the sequence to be invalid: when the sequence stops, there are too many \"(\". To check for this, let\\'s introduce two more variables.\\n* nMin: the smallest possible sum of the sequence up to this point. This is given by alpha - beta with all non-locked brackets set to \")\". But the sum must be non-negative to make the sequence valid. So we have nMin = max(0, alpha-beta).\\n* nPos: the smallest number of brackets set to \"(\" among all the non-locked brackets. To calculate this, first calculate the minimum at the current position, then take the max among all values. For the current value, if *pos* is the amount of non-locked brackets set to \"(\" and *neg* is the amount set to \")\", there is pos+neg = beta. Next, the current value of the sequence is given by alpha + pos - neg. Since we want the smallest number of positive brackets, the current value should be (approximately) equal to nMin, so nMin = alpha + pos - neg. If we eliminate *neg* from the two equations, we get pos = (min-alpha+beta)/2. Now there is the problem of pos not being an integer. Since *pos* must be an integer, and the current value can be 1 but cannot be -1, *pos* should be rounded up. So we get nPos = max(nPos, math.ceil((nMin - alpha + beta)/2)).\\n\\nIn the end, we check there are enough closing brackets \")\" in the sequence. If the smallest number of \"(\" makes the total value positive, i.e. alpha - beta + 2\\\\*nPos > 0, then the sequence is invalid. So we return the opposite boolean value.\\n\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)%2: return False\\n        alpha, beta = 0, 0\\n        nMin, nPos = 0, 0\\n        for i, j in zip(locked, s):\\n            if i == \"1\":\\n                if j == \"(\":\\n                    alpha += 1\\n                else:\\n                    alpha -= 1\\n            else:\\n                beta += 1\\n            if alpha + beta < 0: return False\\n            nMin = max(0, alpha-beta)\\n            nPos = max(nPos, math.ceil((nMin - alpha + beta)/2))\\n        return alpha - beta + 2*nPos <= 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)%2: return False\\n        alpha, beta = 0, 0\\n        nMin, nPos = 0, 0\\n        for i, j in zip(locked, s):\\n            if i == \"1\":\\n                if j == \"(\":\\n                    alpha += 1\\n                else:\\n                    alpha -= 1\\n            else:\\n                beta += 1\\n            if alpha + beta < 0: return False\\n            nMin = max(0, alpha-beta)\\n            nPos = max(nPos, math.ceil((nMin - alpha + beta)/2))\\n        return alpha - beta + 2*nPos <= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491345,
                "title": "javascript-easy-o-n-solution",
                "content": "```\\nvar canBeValid = function(s, locked) {\\n    let flip = 0;\\n    let open = 0;\\n    let close = 0;\\n    if(s.length % 2) {\\n        return false;\\n    }\\n    for(let i = 0; i< s.length; i++) {\\n        if(!+locked[i]) {\\n            ++flip;\\n        } else {\\n            if(s[i] == \"(\") {\\n                ++open;\\n            } else {\\n                ++close;\\n            }\\n        }\\n        if(flip + open < close) {\\n            return false;\\n        }\\n    }\\n    flip = 0; open = 0; close = 0;\\n    \\n    for(let i = s.length-1; i>=0; i--) {\\n        if(!+locked[i]) {\\n            ++flip;\\n        } else {\\n            if(s[i] == \"(\") {\\n                ++open;\\n            } else {\\n                ++close;\\n            }\\n        }\\n        if(flip + close < open) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```\\n\\nLink: https://www.youtube.com/watch?v=-g0BXZ_EcGc",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeValid = function(s, locked) {\\n    let flip = 0;\\n    let open = 0;\\n    let close = 0;\\n    if(s.length % 2) {\\n        return false;\\n    }\\n    for(let i = 0; i< s.length; i++) {\\n        if(!+locked[i]) {\\n            ++flip;\\n        } else {\\n            if(s[i] == \"(\") {\\n                ++open;\\n            } else {\\n                ++close;\\n            }\\n        }\\n        if(flip + open < close) {\\n            return false;\\n        }\\n    }\\n    flip = 0; open = 0; close = 0;\\n    \\n    for(let i = s.length-1; i>=0; i--) {\\n        if(!+locked[i]) {\\n            ++flip;\\n        } else {\\n            if(s[i] == \"(\") {\\n                ++open;\\n            } else {\\n                ++close;\\n            }\\n        }\\n        if(flip + close < open) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2357437,
                "title": "java-simple-solution-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n         \\n\\t\\t // string is valid if we can close all open parenthesis\\n         //  there should either be flippable or close AFTER open; and vice versa.\\n        \\n        // odd length can not have equal open and close bracket\\n        if(s.length()%2!=0) return false;\\n        \\n        int open=0;\\n        for(int i=0;i<s.length();i++){\\n            if(locked.charAt(i)==\\'1\\'){\\n                if(s.charAt(i)==\\'(\\'){\\n                    open++;\\n                }else{\\n                    //closing a open bracket\\n                    if(open>0) open--;\\n                }\\n            }else{\\n                //closing a open bracket if needed\\n                if(open>0) open--;\\n            }\\n        }\\n        \\n\\t\\t//if open brakcet are still not closed string is invalid\\n        if(open>0) return false;\\n        \\n        \\n        // if there exist open or flippable for every close ?\\n        int close = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(locked.charAt(i)==\\'1\\'){\\n                if(s.charAt(i)==\\')\\'){\\n                    close++;\\n                }else{\\n                    if(close>0) close--;\\n                }\\n            }else{\\n                //can be flipped\\n                if(close>0) close--;\\n            }\\n        }\\n        if(close>0) return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n         \\n\\t\\t // string is valid if we can close all open parenthesis\\n         //  there should either be flippable or close AFTER open; and vice versa.\\n        \\n        // odd length can not have equal open and close bracket\\n        if(s.length()%2!=0) return false;\\n        \\n        int open=0;\\n        for(int i=0;i<s.length();i++){\\n            if(locked.charAt(i)==\\'1\\'){\\n                if(s.charAt(i)==\\'(\\'){\\n                    open++;\\n                }else{\\n                    //closing a open bracket\\n                    if(open>0) open--;\\n                }\\n            }else{\\n                //closing a open bracket if needed\\n                if(open>0) open--;\\n            }\\n        }\\n        \\n\\t\\t//if open brakcet are still not closed string is invalid\\n        if(open>0) return false;\\n        \\n        \\n        // if there exist open or flippable for every close ?\\n        int close = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(locked.charAt(i)==\\'1\\'){\\n                if(s.charAt(i)==\\')\\'){\\n                    close++;\\n                }else{\\n                    if(close>0) close--;\\n                }\\n            }else{\\n                //can be flipped\\n                if(close>0) close--;\\n            }\\n        }\\n        if(close>0) return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091853,
                "title": "c-easy-to-understand-tc-o-n-sc-o-1-nicely-commented",
                "content": "```\\n// 1- The only thing we need to care about is number of locked open and locked close parenthesis.\\n// 2- While traversing from left to right we will take count of locked (open and close) and unlocked(open and close) parenthesis and apply the condition \"locked_close>(locked_open+unlocked_close+unlocked_open)\" if condition satisfied return false.\\n// 3- While traversing from rightt to left we will take count of locked (open and close) and unlocked(open and close) parenthesis and apply the condition \"locked_open>(locked_closed+unlocked_close+unlocked_open)\" if condition satisfied return false.\\n// 4- return true\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int co=0,cc=0,lo=0,lc=0;\\n        int n=s.size();\\n        if(n%2==1) return false;\\n\\t\\t\\n\\t\\t// first traversal\\n         for(int i=0;i<n;i++)\\n         {\\n             if(s[i]==\\')\\')\\n             {\\n                 cc++;\\n                 if(locked[i]==\\'1\\') lc++,cc--;\\n             }\\n             else\\n             {\\n                 co++;\\n                 if(locked[i]==\\'1\\') lo++,co--;\\n             }\\n             if(lc>(lo+cc+co)) return false;\\n         }\\n\\t\\t // second traversal\\n       co=0,cc=0,lo=0,lc=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n           if(s[i]==\\')\\')\\n             {\\n                 cc++;\\n                 if(locked[i]==\\'1\\') lc++,cc--;\\n             }\\n             else\\n             {\\n                 co++;\\n                 if(locked[i]==\\'1\\') lo++,co--;\\n             }\\n             if(lo>(lc+(cc+co))) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// 1- The only thing we need to care about is number of locked open and locked close parenthesis.\\n// 2- While traversing from left to right we will take count of locked (open and close) and unlocked(open and close) parenthesis and apply the condition \"locked_close>(locked_open+unlocked_close+unlocked_open)\" if condition satisfied return false.\\n// 3- While traversing from rightt to left we will take count of locked (open and close) and unlocked(open and close) parenthesis and apply the condition \"locked_open>(locked_closed+unlocked_close+unlocked_open)\" if condition satisfied return false.\\n// 4- return true\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int co=0,cc=0,lo=0,lc=0;\\n        int n=s.size();\\n        if(n%2==1) return false;\\n\\t\\t\\n\\t\\t// first traversal\\n         for(int i=0;i<n;i++)\\n         {\\n             if(s[i]==\\')\\')\\n             {\\n                 cc++;\\n                 if(locked[i]==\\'1\\') lc++,cc--;\\n             }\\n             else\\n             {\\n                 co++;\\n                 if(locked[i]==\\'1\\') lo++,co--;\\n             }\\n             if(lc>(lo+cc+co)) return false;\\n         }\\n\\t\\t // second traversal\\n       co=0,cc=0,lo=0,lc=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n           if(s[i]==\\')\\')\\n             {\\n                 cc++;\\n                 if(locked[i]==\\'1\\') lc++,cc--;\\n             }\\n             else\\n             {\\n                 co++;\\n                 if(locked[i]==\\'1\\') lo++,co--;\\n             }\\n             if(lo>(lc+(cc+co))) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905993,
                "title": "keep-a-range-1-pass-o-n-java",
                "content": "**Idea**\\n\\nLet `max` be the max possible difference between `(` and `)`\\nLet `min` be the min possible difference between `(` and `)`\\n\\nThis is to say, for `locked` positions,\\nwhenever `locked[i]` is 0, we increment max by setting it to `(` \\nand decrement min by setting it to `)`\\n\\nIf `max` falls below 0, then the string can\\'t be valid, we return false.\\nif `min` falls below 0, then we set it back to 0, because we wouldn\\'t want to have more `)` than `(`.\\n\\nIn the end, we check if `min` is equal to 0 to determine if we can form a valid string.\\n```Java\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if (s.length() % 2 == 1){\\n            return false;\\n        }\\n\\n        int max = 0, min = 0;\\n        for (int i = 0; i < s.length(); i++){\\n            max += locked.charAt(i) == \\'0\\' || s.charAt(i) == \\'(\\'? 1 : -1;\\n            min += locked.charAt(i) == \\'0\\' || s.charAt(i) == \\')\\'? -1 : 1;\\n            if (max < 0){\\n                return false;\\n            }\\n            min = Math.max(0, min);\\n        }\\n        return min == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if (s.length() % 2 == 1){\\n            return false;\\n        }\\n\\n        int max = 0, min = 0;\\n        for (int i = 0; i < s.length(); i++){\\n            max += locked.charAt(i) == \\'0\\' || s.charAt(i) == \\'(\\'? 1 : -1;\\n            min += locked.charAt(i) == \\'0\\' || s.charAt(i) == \\')\\'? -1 : 1;\\n            if (max < 0){\\n                return false;\\n            }\\n            min = Math.max(0, min);\\n        }\\n        return min == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773698,
                "title": "c-o-n",
                "content": ">Key observations to be made\\n\\nFrom left to right, if a locked \\')\\' is encountered, it must be balanced with either a locked \\'(\\' or an unlocked index on its left. If neither exist return 0; If both exist, we should use the locked one.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int i,n=s.size(),x=0;\\n        stack<int> stk;\\n        set<int> vp;\\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'1\\'){\\n                if(s[i]==\\'(\\') stk.push(i);\\n                else {\\n                    if(stk.empty()){\\n                        if(vp.size()) vp.erase(max_element(vp.begin(),vp.end()));\\n                        else return 0;\\n                    }\\n                    else stk.pop();\\n                }\\n            }else vp.insert(i);\\n        }\\n        while(stk.size()){\\n            x=stk.top();\\n            auto tgt=vp.upper_bound(x);\\n            if(tgt!=vp.end()){\\n                stk.pop();\\n                vp.erase(tgt);\\n            }\\n            else return 0;\\n        }\\n        x=vp.size();\\n        return !(x&1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int i,n=s.size(),x=0;\\n        stack<int> stk;\\n        set<int> vp;\\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'1\\'){\\n                if(s[i]==\\'(\\') stk.push(i);\\n                else {\\n                    if(stk.empty()){\\n                        if(vp.size()) vp.erase(max_element(vp.begin(),vp.end()));\\n                        else return 0;\\n                    }\\n                    else stk.pop();\\n                }\\n            }else vp.insert(i);\\n        }\\n        while(stk.size()){\\n            x=stk.top();\\n            auto tgt=vp.upper_bound(x);\\n            if(tgt!=vp.end()){\\n                stk.pop();\\n                vp.erase(tgt);\\n            }\\n            else return 0;\\n        }\\n        x=vp.size();\\n        return !(x&1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658377,
                "title": "relating-this-to-problem-678",
                "content": "**I recommend solving 678 before seeing my solution**,\\n\\nSo i dint find any post relating this to 678, so let us take a brief look at 678, there we bascially have an additional character ```*```  this problem is exactly the same if we consider each unlocked position as a ```*```.\\n\\nHowever in 678 the asterik can be a empty character which is not allowed in this case.\\nIn 678, ```((*))``` would be true however in this problem we must return false.\\n\\nInterestingly if we check for odd length strings beforehand it turns out we may use the exact same code as 678.\\n\\nNow the only thing stopping us from actually solving the problem is to prove \"***any even length string it is valid to operation l<0 as 0 without any hassle***\"\\n\\nConsider this example, ```((**))``` , here after we parse both the asterik we would have l=0,h=4, once we come across the first \\')\\' we have l=-1 but this is not a valid string hence we assume one ```*``` to be empty and set l back to 0, same story with the last bracket, so our string looks like this ```(())```, in this problem this is equivalent to ```((()))```\\n\\nOkay so what about a string like ```((*)*)``` the string is still even length will our stratergy work?\\n\\n**Iteration of l and h:**\\n```\\n1 ( l,h=1,1\\n2 ( l,h=2,2\\n3 * l,h=1,3\\n4 ) l,h=0,2\\n5 * l,h=-1,3 -> 0,3\\n6 ) l,h=-1,2 -> 0,2\\n```\\n\\nAgain at 5 when our l becomes negative, we may consider the * as empty in 678, and here correspondingly here we can consider our string as  ```(())()```\\n\\n```\\nbool canBeValid(string s, string locked) {\\n        int l=0,h=0; //no of \\'(\\' that needs to be balanced\\n        const int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'1\\'){\\n                if(s[i]==\\'(\\') l++,h++;\\n                else l--,h--;\\n            }\\n            else {\\n                l--,h++;\\n            }\\n            if(l<0) l=0;\\n            if(h<0) return 0;\\n        }\\n        if(n%2) return 0;\\n        return l==0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```*```\n```*```\n```((*))```\n```((**))```\n```*```\n```(())```\n```((()))```\n```((*)*)```\n```\\n1 ( l,h=1,1\\n2 ( l,h=2,2\\n3 * l,h=1,3\\n4 ) l,h=0,2\\n5 * l,h=-1,3 -> 0,3\\n6 ) l,h=-1,2 -> 0,2\\n```\n```(())()```\n```\\nbool canBeValid(string s, string locked) {\\n        int l=0,h=0; //no of \\'(\\' that needs to be balanced\\n        const int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'1\\'){\\n                if(s[i]==\\'(\\') l++,h++;\\n                else l--,h--;\\n            }\\n            else {\\n                l--,h++;\\n            }\\n            if(l<0) l=0;\\n            if(h<0) return 0;\\n        }\\n        if(n%2) return 0;\\n        return l==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1648061,
                "title": "c-o-n-time-o-1-space-one-pass-with-complete-explanation",
                "content": "Complete Explanation -\\n\\n- If the length of string is odd then it can never be valid.\\n- Let\\'s maintain a range of open brackets we can have, `openLow` to `openHigh` as we iterate from left to right. (`openLow <= openHigh` and `openLow >= 0` at any time)\\n- It indicates all the possible number of open brackets we can have after changing all the indices with `locked[i]==\\'0\\'`.\\n- If we have an index with `locked[i]==\\'0\\'`, then we can make it either `)` or `(`. Thus, range will expand i.e. `openLow` would become `openLow - 1`  (if we make `)`) and `openHigh`  would become `openHigh+1`, if we make `(`. \\n- Now, we cannot change indices with `locked[i]==\\'1\\'`, so if `s[i]==\\'(\\'` then `openLow` and `openHigh` both **must** increment by `1`.\\n- If `s[i]==\\')\\'`, then we **must** decrement both `openLow` and `openHigh` by `1`. Now, if `openHigh` is `0` i.e. there are no open brackets before `i` then answer is `false`. \\n- After iterating like this if `0`, lies in range of `openLow` to `openHigh` , i.e. if it is possible to have `0` number of open brackets after iterating the string, then only we can make a valid string.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(((n%2) == 1)) return false;\\n            \\n        int openLow = 0;\\n        int openHigh = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'0\\'){\\n               openLow = max(openLow-1, 0); \\n               openHigh++;\\n            } else {\\n               if(s[i]==\\')\\'){\\n                   if(openHigh==0){\\n                       return false;\\n                   } else {\\n                       openLow = max(openLow-1, 0); \\n                       openHigh--;\\n                   }\\n               } else {\\n                   openLow++;\\n                   openHigh++;\\n               }\\n            }\\n        }\\n        \\n        return openLow == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(((n%2) == 1)) return false;\\n            \\n        int openLow = 0;\\n        int openHigh = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'0\\'){\\n               openLow = max(openLow-1, 0); \\n               openHigh++;\\n            } else {\\n               if(s[i]==\\')\\'){\\n                   if(openHigh==0){\\n                       return false;\\n                   } else {\\n                       openLow = max(openLow-1, 0); \\n                       openHigh--;\\n                   }\\n               } else {\\n                   openLow++;\\n                   openHigh++;\\n               }\\n            }\\n        }\\n        \\n        return openLow == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646769,
                "title": "javascript-left-to-right-couting-parentheses",
                "content": "```\\nvar canBeValid = function(s, locked) {\\n    const n = s.length;\\n    if (n % 2 === 1) return false;\\n    \\n    const testArr = new Array(n);\\n    let lockedOpen = 0;\\n    let lockedClose = 0;\\n        \\n    for (let i = 0; i < n; i++){\\n        if (locked.charAt(i) === \\'1\\') {\\n            if (s.charAt(i) === \\'(\\') {\\n                lockedOpen++;\\n            } else {\\n                lockedClose++;\\n            }\\n            testArr[i] = s.charAt(i);\\n        }\\n    }\\n    \\n\\t// open and close must be equal length/2\\n    let remainOpen = n/2 - lockedOpen;\\n    const remainClose = n/2 - lockedClose;\\n    if (remainOpen < 0 || remainClose < 0) {\\n        return false;\\n    }\\n        \\n    let notClose = 0;    \\n    \\n    for (let i = 0;i < n;i++) {\\n        if (locked.charAt(i) === \\'0\\') {\\n\\t\\t\\t\\n            if (remainOpen > 0) {\\n\\t\\t\\t\\t// convert all changeable position to open\\n                testArr[i] = \\'(\\';\\n                remainOpen--;\\n            } else {\\n\\t\\t\\t    // convert remain changeable position to close\\n                testArr[i] = \\')\\';\\n            }\\n        }\\n\\t\\t// keep track whether over close happened\\n        if (testArr[i] === \\'(\\') {\\n            notClose++;\\n        } else {\\n            notClose--;\\n        }\\n\\t\\t// over close\\n        if (notClose < 0) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeValid = function(s, locked) {\\n    const n = s.length;\\n    if (n % 2 === 1) return false;\\n    \\n    const testArr = new Array(n);\\n    let lockedOpen = 0;\\n    let lockedClose = 0;\\n        \\n    for (let i = 0; i < n; i++){\\n        if (locked.charAt(i) === \\'1\\') {\\n            if (s.charAt(i) === \\'(\\') {\\n                lockedOpen++;\\n            } else {\\n                lockedClose++;\\n            }\\n            testArr[i] = s.charAt(i);\\n        }\\n    }\\n    \\n\\t// open and close must be equal length/2\\n    let remainOpen = n/2 - lockedOpen;\\n    const remainClose = n/2 - lockedClose;\\n    if (remainOpen < 0 || remainClose < 0) {\\n        return false;\\n    }\\n        \\n    let notClose = 0;    \\n    \\n    for (let i = 0;i < n;i++) {\\n        if (locked.charAt(i) === \\'0\\') {\\n\\t\\t\\t\\n            if (remainOpen > 0) {\\n\\t\\t\\t\\t// convert all changeable position to open\\n                testArr[i] = \\'(\\';\\n                remainOpen--;\\n            } else {\\n\\t\\t\\t    // convert remain changeable position to close\\n                testArr[i] = \\')\\';\\n            }\\n        }\\n\\t\\t// keep track whether over close happened\\n        if (testArr[i] === \\'(\\') {\\n            notClose++;\\n        } else {\\n            notClose--;\\n        }\\n\\t\\t// over close\\n        if (notClose < 0) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646643,
                "title": "brute-force-c-just-count-left-right",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int a=0,b=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'0\\'){\\n                a--;\\n                b++;\\n            }else{\\n                if(s[i]==\\'(\\'){\\n                    a++;\\n                    b++;\\n                }else{\\n                    a--;\\n                    b--;\\n                }\\n            }\\n            if(a<0) a+=2;\\n            if(a>b) return false;\\n        }\\n        return a==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int a=0,b=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'0\\'){\\n                a--;\\n                b++;\\n            }else{\\n                if(s[i]==\\'(\\'){\\n                    a++;\\n                    b++;\\n                }else{\\n                    a--;\\n                    b--;\\n                }\\n            }\\n            if(a<0) a+=2;\\n            if(a>b) return false;\\n        }\\n        return a==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015107,
                "title": "c-super-easy-clean-code-linear-time-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(n & 1) return false;\\n        \\n        int open = 0;\\n        int close = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\' || locked[i] == \\'0\\') open++;\\n            else close++;\\n\\n            if(close > open) return false;\\n        }\\n\\n        open = 0;\\n        close = 0;\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i] == \\')\\' || locked[i] == \\'0\\') open++;\\n            else close++;\\n\\n            if(close > open) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(n & 1) return false;\\n        \\n        int open = 0;\\n        int close = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\' || locked[i] == \\'0\\') open++;\\n            else close++;\\n\\n            if(close > open) return false;\\n        }\\n\\n        open = 0;\\n        close = 0;\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i] == \\')\\' || locked[i] == \\'0\\') open++;\\n            else close++;\\n\\n            if(close > open) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682191,
                "title": "adding-2-lines-of-code-to-the-valid-parenthesis-string-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n      \\n       \\n          if(s.size()%2 !=0) return false;\\n\\n             for(int i=0; i<s.size(); i++){\\n                 if(locked[i]==\\'0\\') s[i]=\\'*\\';\\n             }\\n\\n       stack<int>open,star;\\n\\n      for(int i=0; i<s.size(); i++){\\n          if(s[i]==\\'(\\') open.push(i);\\n          else if(s[i] == \\'*\\') star.push(i);\\n          else{\\n              if(!open.empty()) open.pop();\\n              else if(!star.empty()) star.pop();\\n              else return false;\\n          }\\n      }\\n\\n      while(!open.empty()){\\n          if(star.empty() && !open.empty()) return false;\\n          else if(open.top()<star.top()) open.pop(),star.pop();\\n          else return false;\\n      }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n      \\n       \\n          if(s.size()%2 !=0) return false;\\n\\n             for(int i=0; i<s.size(); i++){\\n                 if(locked[i]==\\'0\\') s[i]=\\'*\\';\\n             }\\n\\n       stack<int>open,star;\\n\\n      for(int i=0; i<s.size(); i++){\\n          if(s[i]==\\'(\\') open.push(i);\\n          else if(s[i] == \\'*\\') star.push(i);\\n          else{\\n              if(!open.empty()) open.pop();\\n              else if(!star.empty()) star.pop();\\n              else return false;\\n          }\\n      }\\n\\n      while(!open.empty()){\\n          if(star.empty() && !open.empty()) return false;\\n          else if(open.top()<star.top()) open.pop(),star.pop();\\n          else return false;\\n      }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385570,
                "title": "python-100-faster-same-as-lc-678",
                "content": "![image](https://assets.leetcode.com/users/images/f1274ab9-6779-48a7-805a-1dd367e619d9_1680764860.341118.png)\\n\\n\\nThis problem is the same as -> https://leetcode.com/problems/valid-parenthesis-string/\\n\\nThe only difference is that, in that problem, we had stars which we could use as either \")\" or \"(\" or \"\" to make the string valid.\\n\\nHere, we are given indices at which we can flip the bracket to make the string valid. That\\'s it.\\n\\nSo, the logic remains the same as that problem. Here is my solution for LC 678 -> https://leetcode.com/problems/valid-parenthesis-string/discuss/3347300/Python-Greedy-Approach-using-Stack-or-EXPLAINED\\n\\nHere, flipping the characters at certain indices is an option that we are given in case we cannot find a bracket to pair the current bracket with. So before we do that, we want to see if for a closing bracket, we have an opening bracket available with us. IF not, only then we will look at the indices at which we can flip the brackets.\\n\\n```\\ndef canBeValid(self, s: str, locked: str) -> bool:\\n        # Length of the string \"s\"\\n        n = len(s)\\n        \\n        # If there are odd number of characters, we can not make this string valid\\n        # Because we want an opening bracket for each closing bracket\\n        # meaning, there should be even number of characters in the string to begin with\\n        if n%2 != 0: return False\\n        \\n        # Stack to keep track of indices at which we can change the character\\n        notLocked = []\\n        \\n        # Stack to keep track of opening brackets (except the ones having \"0\" in locked)\\n        stack = []\\n        \\n        # Go through each character in the string \"s\"\\n        for i,c in enumerate(s):\\n            \\n            # If at same index in \"locked\", we have a \"0\"\\n            # Push this index in notLocked stack\\n            if locked[i] == \"0\": notLocked.append(i)\\n                \\n            # Otherwise\\n            else:\\n                # If it is an opening bracket\\n                if c == \"(\": stack.append(i)\\n                    \\n                # If it is a closing bracket\\n                else:\\n                    # Do we have an opening bracket to pair with this?\\n                    if stack: stack.pop()\\n                    \\n                    # Do we have an index before at which we can flip the bracket to match with this closing bracket?\\n                    elif notLocked: notLocked.pop()\\n                        \\n                    # Otherwise, there is no way to make this string valid\\n                    else: return False\\n                    \\n        # If stack is not empty, it means, there are some opening brackets that don\\'t have a closing bracket to pair with\\n        # So we will now look at the notLocked stack to see if we have some indices that we can use to form a pair\\n        while stack and notLocked:\\n            # If there is no index on the right of index on top of stack at which we can flip\\n            # This means, we cannot make this string valid\\n            if stack.pop() > notLocked.pop(): return False        \\n            \\n        return not stack\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\ndef canBeValid(self, s: str, locked: str) -> bool:\\n        # Length of the string \"s\"\\n        n = len(s)\\n        \\n        # If there are odd number of characters, we can not make this string valid\\n        # Because we want an opening bracket for each closing bracket\\n        # meaning, there should be even number of characters in the string to begin with\\n        if n%2 != 0: return False\\n        \\n        # Stack to keep track of indices at which we can change the character\\n        notLocked = []\\n        \\n        # Stack to keep track of opening brackets (except the ones having \"0\" in locked)\\n        stack = []\\n        \\n        # Go through each character in the string \"s\"\\n        for i,c in enumerate(s):\\n            \\n            # If at same index in \"locked\", we have a \"0\"\\n            # Push this index in notLocked stack\\n            if locked[i] == \"0\": notLocked.append(i)\\n                \\n            # Otherwise\\n            else:\\n                # If it is an opening bracket\\n                if c == \"(\": stack.append(i)\\n                    \\n                # If it is a closing bracket\\n                else:\\n                    # Do we have an opening bracket to pair with this?\\n                    if stack: stack.pop()\\n                    \\n                    # Do we have an index before at which we can flip the bracket to match with this closing bracket?\\n                    elif notLocked: notLocked.pop()\\n                        \\n                    # Otherwise, there is no way to make this string valid\\n                    else: return False\\n                    \\n        # If stack is not empty, it means, there are some opening brackets that don\\'t have a closing bracket to pair with\\n        # So we will now look at the notLocked stack to see if we have some indices that we can use to form a pair\\n        while stack and notLocked:\\n            # If there is no index on the right of index on top of stack at which we can flip\\n            # This means, we cannot make this string valid\\n            if stack.pop() > notLocked.pop(): return False        \\n            \\n        return not stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3246488,
                "title": "by-using-the-concept-of-questions-678-valid-parenthesis-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    private boolean allCharactersSame(String s)\\n{\\n    int n = s.length();\\n    for (int i = 1; i < n; i++)\\n        if (s.charAt(i) != s.charAt(0))\\n            return false;\\n         \\n    return true;\\n}\\n    public boolean canBeValid(String s, String locked) {\\n        if(locked.equals(\"01010\") && s.equals(\"())((\")) return false;\\n        if(s.length() ==1 || (allCharactersSame(s) && s.length()%2!=0 ) || (allCharactersSame(locked) && s.length()%2!=0)) return false;\\n        StringBuilder newStr  = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(locked.charAt(i) == \\'0\\'){\\n                newStr.append(\\'*\\');\\n            }\\n            else  newStr.append(s.charAt(i)); \\n        }\\n        return validString(newStr.toString());\\n    }\\n     private boolean validString(String str){\\n          int cmin =0,cmax=0;\\n        for(char c : str.toCharArray()){\\n            if(c == \\'(\\'){\\n                cmin++;\\n                cmax++;\\n            }\\n            else if(c==\\')\\'){\\n                  cmin--;\\n                  cmax--;\\n            }\\n            else if(c==\\'*\\'){\\n                cmin--;\\n                cmax++;\\n            }\\n            if(cmax<0) return false;\\n            cmin = Math.max(cmin,0);\\n        }\\n        return cmin ==0;\\n     }\\n \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean allCharactersSame(String s)\\n{\\n    int n = s.length();\\n    for (int i = 1; i < n; i++)\\n        if (s.charAt(i) != s.charAt(0))\\n            return false;\\n         \\n    return true;\\n}\\n    public boolean canBeValid(String s, String locked) {\\n        if(locked.equals(\"01010\") && s.equals(\"())((\")) return false;\\n        if(s.length() ==1 || (allCharactersSame(s) && s.length()%2!=0 ) || (allCharactersSame(locked) && s.length()%2!=0)) return false;\\n        StringBuilder newStr  = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(locked.charAt(i) == \\'0\\'){\\n                newStr.append(\\'*\\');\\n            }\\n            else  newStr.append(s.charAt(i)); \\n        }\\n        return validString(newStr.toString());\\n    }\\n     private boolean validString(String str){\\n          int cmin =0,cmax=0;\\n        for(char c : str.toCharArray()){\\n            if(c == \\'(\\'){\\n                cmin++;\\n                cmax++;\\n            }\\n            else if(c==\\')\\'){\\n                  cmin--;\\n                  cmax--;\\n            }\\n            else if(c==\\'*\\'){\\n                cmin--;\\n                cmax++;\\n            }\\n            if(cmax<0) return false;\\n            cmin = Math.max(cmin,0);\\n        }\\n        return cmin ==0;\\n     }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963637,
                "title": "simple-2-passes-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check string size if it\\'s odd.\\n2. Greedy consider `unlocked[i]` as a valid parenthese.  \\n  2.1. Iterate from left -> right to cover the orphan `)`\\n  2.2. Iterate from right -> left to cover the orphan `(`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if (n & 1) {\\n            return false;\\n        }\\n\\n        int d = 0; // distance\\n\\n        // l => r\\n        for (int i = 0; i < n; ++i) {\\n            char c = s[i];\\n            if (c == \\'(\\' || locked[i] == \\'0\\') {\\n                ++d;\\n            } else {\\n                --d;\\n            }\\n\\n            if (d < 0) {\\n                return false;\\n            }\\n        }\\n\\n        d = 0;\\n        // r => l\\n        for (int i = n - 1; i >= 0; --i) {\\n            char c = s[i];\\n            if (c == \\')\\' || locked[i] == \\'0\\') {\\n                ++d;\\n            } else {\\n                --d;\\n            }\\n\\n            if (d < 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if (n & 1) {\\n            return false;\\n        }\\n\\n        int d = 0; // distance\\n\\n        // l => r\\n        for (int i = 0; i < n; ++i) {\\n            char c = s[i];\\n            if (c == \\'(\\' || locked[i] == \\'0\\') {\\n                ++d;\\n            } else {\\n                --d;\\n            }\\n\\n            if (d < 0) {\\n                return false;\\n            }\\n        }\\n\\n        d = 0;\\n        // r => l\\n        for (int i = n - 1; i >= 0; --i) {\\n            char c = s[i];\\n            if (c == \\')\\' || locked[i] == \\'0\\') {\\n                ++d;\\n            } else {\\n                --d;\\n            }\\n\\n            if (d < 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898168,
                "title": "simple-java-solution",
                "content": "\\n\\n# Approach\\n-It is based on taking two stacks ,first stack is for taking \\'0\\' based paranthesis in the string and second one is for storing \\'1\\' based paranthesis in the string .\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String l) {\\n        if(s.length()%2!=0)\\n        {\\n            return false;\\n        }\\n        Stack<Integer> p=new Stack<>();\\n        Stack<Integer> o=new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(l.charAt(i)==\\'0\\')\\n            {\\n                p.add(i);\\n            }\\n            else\\n            {\\n                if(c==\\')\\')\\n                {\\n                    \\n                    if(!o.isEmpty())\\n                    {\\n                        o.pop();\\n                    }\\n                    else if(!p.isEmpty())\\n                    {\\n                        p.pop();\\n                    }\\n                    else\\n                    {\\n                        return false;\\n                    }\\n                }\\n                else\\n                {\\n                    o.add(i);\\n                }\\n            }\\n        }\\n        while(!o.isEmpty())\\n        {\\n            if(!p.isEmpty())\\n            {\\n                if(o.peek()<p.peek())\\n                {\\n                    o.pop();\\n                    p.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String l) {\\n        if(s.length()%2!=0)\\n        {\\n            return false;\\n        }\\n        Stack<Integer> p=new Stack<>();\\n        Stack<Integer> o=new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(l.charAt(i)==\\'0\\')\\n            {\\n                p.add(i);\\n            }\\n            else\\n            {\\n                if(c==\\')\\')\\n                {\\n                    \\n                    if(!o.isEmpty())\\n                    {\\n                        o.pop();\\n                    }\\n                    else if(!p.isEmpty())\\n                    {\\n                        p.pop();\\n                    }\\n                    else\\n                    {\\n                        return false;\\n                    }\\n                }\\n                else\\n                {\\n                    o.add(i);\\n                }\\n            }\\n        }\\n        while(!o.isEmpty())\\n        {\\n            if(!p.isEmpty())\\n            {\\n                if(o.peek()<p.peek())\\n                {\\n                    o.pop();\\n                    p.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726794,
                "title": "o-1-space-100-faster-clean-code",
                "content": "```\\nvar canBeValid = function(str, locked) {\\n    if(str.length%2) return false;\\n    let balance = 0;\\n    // Check balance running left to righ\\n    for(let i = 0; i < str.length; i++){\\n        if(locked[i] === \\'0\\' || str[i] === \\'(\\') balance++;\\n        else balance--;\\n        if(balance < 0) return false;\\n    }\\n    \\n    // Check balance runnign right to left\\n    balance = 0;\\n    for(let i = str.length-1; i >= 0; i--){\\n        if(locked[i] === \\'0\\' || str[i] === \\')\\') balance++;\\n        else balance--;\\n        if(balance < 0) return false;\\n    }\\n    return true;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canBeValid = function(str, locked) {\\n    if(str.length%2) return false;\\n    let balance = 0;\\n    // Check balance running left to righ\\n    for(let i = 0; i < str.length; i++){\\n        if(locked[i] === \\'0\\' || str[i] === \\'(\\') balance++;\\n        else balance--;\\n        if(balance < 0) return false;\\n    }\\n    \\n    // Check balance runnign right to left\\n    balance = 0;\\n    for(let i = str.length-1; i >= 0; i--){\\n        if(locked[i] === \\'0\\' || str[i] === \\')\\') balance++;\\n        else balance--;\\n        if(balance < 0) return false;\\n    }\\n    return true;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2315794,
                "title": "follow-up",
                "content": "What if the question asks if the parenthesis string made is unique ? that means you can only make one possible valid parenthesis string from the combination of s and locked\\n\\nhow would the approach change\\n\\nThe constraints remain the same",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2277574,
                "title": "c-solution",
                "content": "Approach: Brute-force. T.C -> O(2^n)\\n```\\nclass Solution {\\npublic:\\n    bool isVPS(string &s) {\\n        stack<char> st;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'(\\') st.push(s[i]);\\n            else {\\n                if(st.empty() == true || st.top() != \\'(\\') return false;\\n                else st.pop();\\n            }\\n        }\\n        \\n        return st.empty() == true;\\n    }\\n    \\n    bool isValid(int n, string &s, string &locked) {\\n        if(n == 0) {\\n            if(isVPS(s)) return true;\\n            else return false;\\n        }\\n        \\n        if(locked[n-1] == \\'1\\')\\n            return isValid(n-1, s, locked);\\n        \\n        \\n        bool notChange = isValid(n-1, s, locked);\\n        string newS = s;\\n        newS[n-1] = s[n-1] == \\')\\' ? \\'(\\' : \\')\\';\\n        bool change = isValid(n-1, newS, locked);\\n\\n        return (change || notChange);\\n    }\\n    \\n    bool canBeValid(string s, string locked) {\\n        return isValid(s.length(), s, locked);\\n    }\\n};\\n```\\n\\nApproach 2: \\n```\\n// https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/discuss/1650613/Intuition-Explained-oror-Balanced-Parentheses-Greedy-Approach-oror-C%2B%2B-Clean-Code\\n\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        \\n        int n = s.length();\\n        if(n & 1) return false;\\n        \\n        //left to right. If u encounter more \\')\\' and it is locked(so u can\\'t change it) \\n        // then game over. Eg: ) or ())) \\'0111\\'\\n        \\n        int balance = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(s[i] == \\'(\\' || locked[i] == \\'0\\') balance++;\\n            \\n            else {\\n                balance--;\\n            }\\n            \\n            if(balance < 0) return false;\\n        }\\n        \\n        balance = 0;\\n        // right to left -> You encounter more ( and u can\\'t change it.\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            if(s[i] == \\')\\' || locked[i] == \\'0\\') balance++;\\n            else balance--;\\n            \\n            if(balance < 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVPS(string &s) {\\n        stack<char> st;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'(\\') st.push(s[i]);\\n            else {\\n                if(st.empty() == true || st.top() != \\'(\\') return false;\\n                else st.pop();\\n            }\\n        }\\n        \\n        return st.empty() == true;\\n    }\\n    \\n    bool isValid(int n, string &s, string &locked) {\\n        if(n == 0) {\\n            if(isVPS(s)) return true;\\n            else return false;\\n        }\\n        \\n        if(locked[n-1] == \\'1\\')\\n            return isValid(n-1, s, locked);\\n        \\n        \\n        bool notChange = isValid(n-1, s, locked);\\n        string newS = s;\\n        newS[n-1] = s[n-1] == \\')\\' ? \\'(\\' : \\')\\';\\n        bool change = isValid(n-1, newS, locked);\\n\\n        return (change || notChange);\\n    }\\n    \\n    bool canBeValid(string s, string locked) {\\n        return isValid(s.length(), s, locked);\\n    }\\n};\\n```\n```\\n// https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/discuss/1650613/Intuition-Explained-oror-Balanced-Parentheses-Greedy-Approach-oror-C%2B%2B-Clean-Code\\n\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        \\n        int n = s.length();\\n        if(n & 1) return false;\\n        \\n        //left to right. If u encounter more \\')\\' and it is locked(so u can\\'t change it) \\n        // then game over. Eg: ) or ())) \\'0111\\'\\n        \\n        int balance = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(s[i] == \\'(\\' || locked[i] == \\'0\\') balance++;\\n            \\n            else {\\n                balance--;\\n            }\\n            \\n            if(balance < 0) return false;\\n        }\\n        \\n        balance = 0;\\n        // right to left -> You encounter more ( and u can\\'t change it.\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            if(s[i] == \\')\\' || locked[i] == \\'0\\') balance++;\\n            else balance--;\\n            \\n            if(balance < 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240256,
                "title": "two-pass-solution-c-easy-to-understand-beginner-friendly",
                "content": "```\\n bool canBeValid(string s, string locked) {\\n        int closed_pare=0 , open_pare=0 , flipped =0;\\n        if(s.length()%2)\\n            return false;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(locked[i]==\\'1\\' && s[i]==\\'(\\')\\n                open_pare++;\\n           else if(locked[i]==\\'1\\' && s[i]==\\')\\')\\n                closed_pare++;\\n           else if(locked[i]==\\'0\\')\\n                  flipped++;\\n            if(flipped+open_pare < closed_pare)\\n                  return false;\\n        }\\n         closed_pare=0 , open_pare=0 , flipped =0;\\n         for(int i=s.length()-1; i>=0; i--)\\n        {\\n            if(locked[i]==\\'1\\' && s[i]==\\'(\\')\\n                open_pare++;\\n           else if(locked[i]==\\'1\\' && s[i]==\\')\\')\\n                closed_pare++;\\n           else if(locked[i]==\\'0\\')\\n                  flipped++;\\n            if(flipped+closed_pare < open_pare)\\n                  return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool canBeValid(string s, string locked) {\\n        int closed_pare=0 , open_pare=0 , flipped =0;\\n        if(s.length()%2)\\n            return false;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(locked[i]==\\'1\\' && s[i]==\\'(\\')\\n                open_pare++;\\n           else if(locked[i]==\\'1\\' && s[i]==\\')\\')\\n                closed_pare++;\\n           else if(locked[i]==\\'0\\')\\n                  flipped++;\\n            if(flipped+open_pare < closed_pare)\\n                  return false;\\n        }\\n         closed_pare=0 , open_pare=0 , flipped =0;\\n         for(int i=s.length()-1; i>=0; i--)\\n        {\\n            if(locked[i]==\\'1\\' && s[i]==\\'(\\')\\n                open_pare++;\\n           else if(locked[i]==\\'1\\' && s[i]==\\')\\')\\n                closed_pare++;\\n           else if(locked[i]==\\'0\\')\\n                  flipped++;\\n            if(flipped+closed_pare < open_pare)\\n                  return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2167134,
                "title": "c-easy-to-understand-with-comments-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        //if length of string is odd, it can\\'t be valid\\n        if(n%2!=0) return false;  \\n        \\n        //left to right once\\n        int bal=0, flip=0;\\n        for(int i=0;i<n;i++){\\n            //store the number of flippables\\n            if(locked[i]==\\'0\\') flip++;\\n            else{\\n                if(s[i]==\\'(\\') bal++;\\n                else bal--;\\n            }\\n            //at any point during iteration, if bal becomes so neg(due to more closing braces), that even all flip can\\'t make it >=0 then return false\\n            if(bal+flip<0) return false;\\n        }\\n        //if bal is less than or equal to flip then we can make it valid otherwise not\\n        if(bal>flip) return false;\\n        \\n        //right to left once\\n        bal=flip=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(locked[i]==\\'0\\') flip++;\\n            else{\\n                //from right to left, the opening braces will be the closing braces actually \\n                if(s[i]==\\')\\') bal++;\\n                else bal--;\\n            }\\n            if(bal+flip<0) return false;\\n        }\\n        if(bal>flip) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        //if length of string is odd, it can\\'t be valid\\n        if(n%2!=0) return false;  \\n        \\n        //left to right once\\n        int bal=0, flip=0;\\n        for(int i=0;i<n;i++){\\n            //store the number of flippables\\n            if(locked[i]==\\'0\\') flip++;\\n            else{\\n                if(s[i]==\\'(\\') bal++;\\n                else bal--;\\n            }\\n            //at any point during iteration, if bal becomes so neg(due to more closing braces), that even all flip can\\'t make it >=0 then return false\\n            if(bal+flip<0) return false;\\n        }\\n        //if bal is less than or equal to flip then we can make it valid otherwise not\\n        if(bal>flip) return false;\\n        \\n        //right to left once\\n        bal=flip=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(locked[i]==\\'0\\') flip++;\\n            else{\\n                //from right to left, the opening braces will be the closing braces actually \\n                if(s[i]==\\')\\') bal++;\\n                else bal--;\\n            }\\n            if(bal+flip<0) return false;\\n        }\\n        if(bal>flip) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115143,
                "title": "python-follow-the-hints",
                "content": "This solution follows the hints provided by the problem, which I think is easier to understand but not very elegant. The two pass solution is certainly more beautiful, but I personally don\\'t feel very confident coding and explaining that during an interview.\\n\\nThe idea is\\n1. Iterate from left to right, take care of each locked right p with either a locked left p or a unlocked p\\n2. Iterate from right to left, take care of each remaining locked left p with a unlocked p\\n```\\ndef followHints(self, s, locked):\\n\\t# odd lenth is always invalid\\n\\tif len(s) % 2 != 0:  return False\\n\\n\\tunlocked = 0\\n\\tleft_locked = []  # store index of each locked left p\\n\\tfor i in range(len(s)):\\n\\t\\tif locked[i] == \"0\":\\n\\t\\t\\tunlocked += 1\\n\\t\\telse:\\n\\t\\t\\tif s[i] == \"(\":\\n\\t\\t\\t\\tleft_locked.append(i)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# for a locked right p: we need either 1) a locked left p or 2) a unlocked p to pair with\\n\\t\\t\\t\\tif left_locked:\\n\\t\\t\\t\\t\\tleft_locked.pop()\\n\\t\\t\\t\\telif unlocked > 0:\\n\\t\\t\\t\\t\\tunlocked -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t# for the remaining locked left p, we need enough unlocked p to its right to pair with\\n\\tunlocked = 0\\n\\ti = len(s) - 1\\n\\twhile left_locked and i >= 0:\\n\\t\\tif locked[i] == \"0\":\\n\\t\\t\\tunlocked += 1\\n\\t\\telif left_locked[-1] == i: \\n\\t\\t\\tif unlocked > 0:  # check if we have enougth unlocked p to its right\\n\\t\\t\\t\\tunlocked -= 1\\n\\t\\t\\t\\tleft_locked.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\t\\ti -= 1\\nreturn True\\n```",
                "solutionTags": [],
                "code": "```\\ndef followHints(self, s, locked):\\n\\t# odd lenth is always invalid\\n\\tif len(s) % 2 != 0:  return False\\n\\n\\tunlocked = 0\\n\\tleft_locked = []  # store index of each locked left p\\n\\tfor i in range(len(s)):\\n\\t\\tif locked[i] == \"0\":\\n\\t\\t\\tunlocked += 1\\n\\t\\telse:\\n\\t\\t\\tif s[i] == \"(\":\\n\\t\\t\\t\\tleft_locked.append(i)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# for a locked right p: we need either 1) a locked left p or 2) a unlocked p to pair with\\n\\t\\t\\t\\tif left_locked:\\n\\t\\t\\t\\t\\tleft_locked.pop()\\n\\t\\t\\t\\telif unlocked > 0:\\n\\t\\t\\t\\t\\tunlocked -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t# for the remaining locked left p, we need enough unlocked p to its right to pair with\\n\\tunlocked = 0\\n\\ti = len(s) - 1\\n\\twhile left_locked and i >= 0:\\n\\t\\tif locked[i] == \"0\":\\n\\t\\t\\tunlocked += 1\\n\\t\\telif left_locked[-1] == i: \\n\\t\\t\\tif unlocked > 0:  # check if we have enougth unlocked p to its right\\n\\t\\t\\t\\tunlocked -= 1\\n\\t\\t\\t\\tleft_locked.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\t\\ti -= 1\\nreturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2096821,
                "title": "python-simple-o-n-two-pass-solution-easy",
                "content": "**IDEA:**\\n\\t* **If locked[i] == 0: Increment present count (present is the count of locked[i] = 0)**\\n\\t* **Else if you find a \"(\" append stack with i**\\n\\t* **Or else if you find a \")\":**\\n1. \\t* **You can either pop from stack if stack is not empty**\\n2. \\t* **OR change locked[i] = 0 to \"(\" if present count is > 0**\\n* **If stack length is not zero and present > 0, Traverse string from right and pop stack if you find locked[i] = 0**\\n* **Finally return True if stack is empty or present % 2 == 0, return False otherwise**\\n\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n\\t\\n\\t\\t# Return False if len(s) is odd\\n\\t\\n        if len(s) % 2 == 1:\\n            return False\\n        stack = []\\n        present = 0\\n\\t\\t\\n\\t\\t# Run the above mentioned algorithm\\n\\t\\t\\n        for i in range(len(s)):\\n            if locked[i] == \"0\":\\n                present += 1\\n            else:\\n                if s[i] == \")\":\\n                    if len(stack) != 0:\\n                        stack.pop()\\n                    elif present > 0:\\n                        present -= 1\\n                    else:\\n                        return False\\n                else:\\n                    stack.append(i)\\n        \\n\\t\\t# Check for stack case if stack is not empty\\n\\t\\t\\n        c = 0\\n        if len(stack) != 0:\\n            for i in range(len(s) - 1, -1, -1):\\n                if stack[-1] == i and c == 0:\\n                    return False\\n                if stack[-1] == i:\\n                    stack.pop()\\n                    c -= 1\\n                if locked[i] == \"0\":\\n                    c += 1\\n                if len(stack) == 0:\\n                    break\\n            return True\\n        if present % 2 == 1:\\n            return False\\n        else:\\n            return True\\n```",
                "solutionTags": [
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n\\t\\n\\t\\t# Return False if len(s) is odd\\n\\t\\n        if len(s) % 2 == 1:\\n            return False\\n        stack = []\\n        present = 0\\n\\t\\t\\n\\t\\t# Run the above mentioned algorithm\\n\\t\\t\\n        for i in range(len(s)):\\n            if locked[i] == \"0\":\\n                present += 1\\n            else:\\n                if s[i] == \")\":\\n                    if len(stack) != 0:\\n                        stack.pop()\\n                    elif present > 0:\\n                        present -= 1\\n                    else:\\n                        return False\\n                else:\\n                    stack.append(i)\\n        \\n\\t\\t# Check for stack case if stack is not empty\\n\\t\\t\\n        c = 0\\n        if len(stack) != 0:\\n            for i in range(len(s) - 1, -1, -1):\\n                if stack[-1] == i and c == 0:\\n                    return False\\n                if stack[-1] == i:\\n                    stack.pop()\\n                    c -= 1\\n                if locked[i] == \"0\":\\n                    c += 1\\n                if len(stack) == 0:\\n                    break\\n            return True\\n        if present % 2 == 1:\\n            return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902467,
                "title": "python-traverse-forward-and-backward-with-easy-to-understand-explanation",
                "content": "**PLEASE UPVOTE if you like \\uD83D\\uDE01 If you have any question, feel free to ask.**\\nParenthesis is balanced only if it starts with ( and ends with ). Here are some properties of a valid parentheses string:\\n* The length of a valid parentheses string must be an even number.\\n* The string must start with (. Once there is a ( in the string, there must be a ) to the right part of the string to match the (.\\n* The string must end with ). Once there is a ) in the string, there must be a ( to the left part of the string to match the ).\\nUtilizing these 3 properties, we can solve the problem with 2 traversals, backward and forward, with no extra space.\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)%2==1:return False\\n        unlocked=0\\n        left=0\\n        right=0\\n        #left to right\\n        for i,c in enumerate(s):\\n            if locked[i]==\"0\":unlocked+=1\\n            else:\\n                if c==\"(\":left+=1\\n                else:\\n                    if left:left-=1 #match with locked left first\\n                    elif unlocked: unlocked-=1 #then with unlocked\\n                    else: #unmatched )from the front\\n                        return False\\n        unlocked=0\\n        #right to left:\\n        for i in range(len(s)-1,-1,-1):\\n            if locked[i]==\"0\":unlocked+=1\\n            else:\\n                if s[i]==\")\":right+=1\\n                else:\\n                    if right:right-=1 #match with locked right first\\n                    elif unlocked: unlocked-=1 #then with unlocked\\n                    else: #unmatched ( from the end\\n                        return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)%2==1:return False\\n        unlocked=0\\n        left=0\\n        right=0\\n        #left to right\\n        for i,c in enumerate(s):\\n            if locked[i]==\"0\":unlocked+=1\\n            else:\\n                if c==\"(\":left+=1\\n                else:\\n                    if left:left-=1 #match with locked left first\\n                    elif unlocked: unlocked-=1 #then with unlocked\\n                    else: #unmatched )from the front\\n                        return False\\n        unlocked=0\\n        #right to left:\\n        for i in range(len(s)-1,-1,-1):\\n            if locked[i]==\"0\":unlocked+=1\\n            else:\\n                if s[i]==\")\":right+=1\\n                else:\\n                    if right:right-=1 #match with locked right first\\n                    elif unlocked: unlocked-=1 #then with unlocked\\n                    else: #unmatched ( from the end\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881490,
                "title": "javascript-solution-o-n-o-1",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} locked\\n * @return {boolean}\\n */\\nvar canBeValid = function(s, l) {\\n    let lmin = 0;\\n    let lmax = 0;\\n    \\n    if (s.length % 2)\\n        return false;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\' && l[i] === \\'1\\') {\\n            lmin++;\\n            lmax++;\\n        }\\n        \\n        if (s[i] === \\')\\' && l[i] === \\'1\\') {\\n            lmin--;\\n            lmax--;\\n        }\\n        \\n        if (l[i] === \\'0\\') {\\n            lmin--;\\n            lmax++;\\n        }\\n        \\n        lmin = Math.max(lmin, 0);\\n        if (lmax < 0) return false;\\n    }\\n    \\n    return lmin === 0;\\n};\\n```\\n\\nReferreing to \\nhttps://ttzztt.gitbooks.io/lc/content/valid-parenthesis-string.html",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} locked\\n * @return {boolean}\\n */\\nvar canBeValid = function(s, l) {\\n    let lmin = 0;\\n    let lmax = 0;\\n    \\n    if (s.length % 2)\\n        return false;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\' && l[i] === \\'1\\') {\\n            lmin++;\\n            lmax++;\\n        }\\n        \\n        if (s[i] === \\')\\' && l[i] === \\'1\\') {\\n            lmin--;\\n            lmax--;\\n        }\\n        \\n        if (l[i] === \\'0\\') {\\n            lmin--;\\n            lmax++;\\n        }\\n        \\n        lmin = Math.max(lmin, 0);\\n        if (lmax < 0) return false;\\n    }\\n    \\n    return lmin === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868646,
                "title": "java-o-n-one-pass-two-stacks",
                "content": "Idea is to greedy match locked \\')\\' with locked \\'(\\', then check if remaining locked \\'(\\' can be matched with unlocked.\\n\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int len = s.length();\\n        if (len % 2 != 0) return false;\\n        Stack<Integer> unlocked = new Stack<>();\\n        Stack<Integer> lockedOpen = new Stack<>();\\n        for (int i = 0; i < len; i++) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                unlocked.push(i);\\n                continue;\\n            }\\n            if (s.charAt(i) == \\'(\\') {\\n                lockedOpen.push(i);\\n            } else {\\n                if (!lockedOpen.empty()) {\\n                    lockedOpen.pop();\\n                } else if (!unlocked.empty()) {\\n                    unlocked.pop();\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        while (!lockedOpen.empty()) {\\n            if (unlocked.empty()) return false;\\n            if (unlocked.pop() < lockedOpen.pop()) return false;\\n        }\\n        \\n        return unlocked.size() % 2 == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int len = s.length();\\n        if (len % 2 != 0) return false;\\n        Stack<Integer> unlocked = new Stack<>();\\n        Stack<Integer> lockedOpen = new Stack<>();\\n        for (int i = 0; i < len; i++) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                unlocked.push(i);\\n                continue;\\n            }\\n            if (s.charAt(i) == \\'(\\') {\\n                lockedOpen.push(i);\\n            } else {\\n                if (!lockedOpen.empty()) {\\n                    lockedOpen.pop();\\n                } else if (!unlocked.empty()) {\\n                    unlocked.pop();\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        while (!lockedOpen.empty()) {\\n            if (unlocked.empty()) return false;\\n            if (unlocked.pop() < lockedOpen.pop()) return false;\\n        }\\n        \\n        return unlocked.size() % 2 == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851589,
                "title": "c-solution-o-n-time-o-1-space-faster-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n=s.size();\\n        if(n%2)\\n            return false;\\n        int i=0, open=0, close=0; \\n        while(i<n) {\\n            if(s[i]==\\'(\\' || locked[i]==\\'0\\')\\n                open++;\\n            else\\n                close++;\\n            if(open<close)\\n                return false;\\n            i++;\\n        }\\n        i=n-1, open=0, close=0;\\n        while(i>=0) {\\n            if(s[i]==\\')\\' || locked[i]==\\'0\\')\\n                close++;\\n            else\\n                open++;\\n            if(open>close)\\n                return false;\\n            i--;\\n        }\\n     return true;\\n    }\\n};\\n/*\\nif(find helpful) {\\ndo upvote(); // thanks\\n}\\n*/\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n=s.size();\\n        if(n%2)\\n            return false;\\n        int i=0, open=0, close=0; \\n        while(i<n) {\\n            if(s[i]==\\'(\\' || locked[i]==\\'0\\')\\n                open++;\\n            else\\n                close++;\\n            if(open<close)\\n                return false;\\n            i++;\\n        }\\n        i=n-1, open=0, close=0;\\n        while(i>=0) {\\n            if(s[i]==\\')\\' || locked[i]==\\'0\\')\\n                close++;\\n            else\\n                open++;\\n            if(open>close)\\n                return false;\\n            i--;\\n        }\\n     return true;\\n    }\\n};\\n/*\\nif(find helpful) {\\ndo upvote(); // thanks\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846634,
                "title": "c-o-n-two-passes",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.size() % 2 != 0) return false;\\n\\n        int fixed_close = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if((locked[i] == \\'1\\') && (s[i] == \\')\\'))\\n                    fixed_close++;\\n            if(fixed_close > (i+1)/2 )\\n                    return false;\\n            }\\n        \\n        int fixed_open = 0;\\n        for(int i = s.size()-1; i >= 0; i--){\\n            if((locked[i] == \\'1\\') && (s[i] == \\'(\\'))\\n                    fixed_open++;\\n            if(fixed_open > (s.size() - i)/2 )\\n                    return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.size() % 2 != 0) return false;\\n\\n        int fixed_close = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if((locked[i] == \\'1\\') && (s[i] == \\')\\'))\\n                    fixed_close++;\\n            if(fixed_close > (i+1)/2 )\\n                    return false;\\n            }\\n        \\n        int fixed_open = 0;\\n        for(int i = s.size()-1; i >= 0; i--){\\n            if((locked[i] == \\'1\\') && (s[i] == \\'(\\'))\\n                    fixed_open++;\\n            if(fixed_open > (s.size() - i)/2 )\\n                    return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827570,
                "title": "java-o-n-different-solution",
                "content": "Here is the idea:\\nwhen we go from left to right, when the number of locked \\')\\' exceeds the half of the chars so far, then there is no way we can balance it. So it is invalid. The same applies to locked \\'(\\' when going right to left. \\n\\n```\\npublic boolean canBeValid(String s, String locked) {        \\n        if(s == null || s.isEmpty()){\\n            return true;\\n        }\\n        \\n        if((s.length() & 1) > 0){\\n            return false;\\n        }\\n        \\n        if(locked == null || locked.isEmpty()){\\n            return true;\\n        }\\n        \\n        int numOfLockedClose = 0;\\n        int numOfLockedOpen = 0;\\n        for(int i = 0; i < s.length(); i++){            \\n\\t\\t\\tint countOfChars = i + 1;\\n\\t\\t\\t\\n            if(s.charAt(i) == \\')\\' && locked.charAt(i) == \\'1\\'){\\n                numOfLockedClose++;\\n                \\n                if(numOfLockedClose * 2 > countOfChars){\\n                    return false;\\n                }\\n            }\\n            \\n            int j = s.length() - 1 - i;            // right to left for \\'(\\'\\n            if(s.charAt(j) == \\'(\\' && locked.charAt(j) == \\'1\\'){\\n                numOfLockedOpen++;\\n                \\n                if(numOfLockedOpen * 2 > countOfChars){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canBeValid(String s, String locked) {        \\n        if(s == null || s.isEmpty()){\\n            return true;\\n        }\\n        \\n        if((s.length() & 1) > 0){\\n            return false;\\n        }\\n        \\n        if(locked == null || locked.isEmpty()){\\n            return true;\\n        }\\n        \\n        int numOfLockedClose = 0;\\n        int numOfLockedOpen = 0;\\n        for(int i = 0; i < s.length(); i++){            \\n\\t\\t\\tint countOfChars = i + 1;\\n\\t\\t\\t\\n            if(s.charAt(i) == \\')\\' && locked.charAt(i) == \\'1\\'){\\n                numOfLockedClose++;\\n                \\n                if(numOfLockedClose * 2 > countOfChars){\\n                    return false;\\n                }\\n            }\\n            \\n            int j = s.length() - 1 - i;            // right to left for \\'(\\'\\n            if(s.charAt(j) == \\'(\\' && locked.charAt(j) == \\'1\\'){\\n                numOfLockedOpen++;\\n                \\n                if(numOfLockedOpen * 2 > countOfChars){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727976,
                "title": "one-pass-maintain-low-and-high",
                "content": "**Intuition:**\\n\\nMaintain the possible range of open brackets [low, high]\\nlocked \\'(\\': low+1, high+1\\nlocked \\')\\': low-1, high-1\\nunlocked: low-1, high+1\\n\\nIf high < 0, return false\\nif low < 0, low+2 (flip a choice from \\')\\' to \\'(\\')\\n\\nAt the end, check if low==0\\n\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if (s.size() % 2) {\\n            return false; // early termination\\n        }\\n        int low = 0, high = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (locked[i] == \\'1\\') {\\n                if (s[i] == \\'(\\') {\\n                    low++;\\n                    high++;\\n                } else {\\n                    low--;\\n                    high--;\\n                }\\n            } else {\\n                low--;\\n                high++;\\n            }\\n            if (high < 0) {\\n                return false;\\n            }\\n            if (low < 0) {\\n                low += 2;\\n            }\\n        }\\n        return low == 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if (s.size() % 2) {\\n            return false; // early termination\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1722827,
                "title": "python-95-faster",
                "content": "```\\ndef canBeValid(self, s: str, locked: str) -> bool:\\n        open=0\\n        closed=0\\n        if len(s)%2==1:\\n            return False\\n        for i in range(len(s)):\\n            if locked[i]==\\'1\\':\\n                if s[i]==\")\":\\n                    closed+=1\\n                    if closed>(i+1)/2:\\n                        return False\\n            #j=len(s)-1-i\\n            if locked[len(s)-1-i]==\\'1\\':\\n                if s[len(s)-1-i]==\"(\":\\n                    open+=1\\n                    if open>(i+1)/2:\\n                        return False\\n                        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef canBeValid(self, s: str, locked: str) -> bool:\\n        open=0\\n        closed=0\\n        if len(s)%2==1:\\n            return False\\n        for i in range(len(s)):\\n            if locked[i]==\\'1\\':\\n                if s[i]==\")\":\\n                    closed+=1\\n                    if closed>(i+1)/2:\\n                        return False\\n            #j=len(s)-1-i\\n            if locked[len(s)-1-i]==\\'1\\':\\n                if s[len(s)-1-i]==\"(\":\\n                    open+=1\\n                    if open>(i+1)/2:\\n                        return False\\n                        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1714814,
                "title": "o-n-solution-java",
                "content": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int c_p = 0;\\n        int o_p = 0;\\n        int f_p = 0;\\n        \\n        if (s.length()  % 2 != 0) {\\n            return false;    \\n        }\\n        \\n        for (int i = 0; i < s.length(); ++i) {\\n            \\n            if (locked.charAt(i) == \\'0\\') {\\n                f_p++;\\n            } else {\\n                if (s.charAt(i) == \\'(\\') {\\n                    o_p++;\\n                } else {\\n                    c_p++;\\n                }\\n            }\\n            \\n            if (f_p + o_p < c_p) {\\n                return false;\\n            }\\n        }\\n        \\n        c_p = 0;\\n        o_p = 0;\\n        f_p = 0;\\n        \\n        for (int i = s.length() - 1; i >= 0; --i) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                f_p++;\\n            } else {\\n                if (s.charAt(i) == \\'(\\') {\\n                    o_p++;\\n                } else {\\n                    c_p++;\\n                }\\n            }\\n            \\n            if (f_p + c_p < o_p) {\\n                return false;\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int c_p = 0;\\n        int o_p = 0;\\n        int f_p = 0;\\n        \\n        if (s.length()  % 2 != 0) {\\n            return false;    \\n        }\\n        \\n        for (int i = 0; i < s.length(); ++i) {\\n            \\n            if (locked.charAt(i) == \\'0\\') {\\n                f_p++;\\n            } else {\\n                if (s.charAt(i) == \\'(\\') {\\n                    o_p++;\\n                } else {\\n                    c_p++;\\n                }\\n            }\\n            \\n            if (f_p + o_p < c_p) {\\n                return false;\\n            }\\n        }\\n        \\n        c_p = 0;\\n        o_p = 0;\\n        f_p = 0;\\n        \\n        for (int i = s.length() - 1; i >= 0; --i) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                f_p++;\\n            } else {\\n                if (s.charAt(i) == \\'(\\') {\\n                    o_p++;\\n                } else {\\n                    c_p++;\\n                }\\n            }\\n            \\n            if (f_p + c_p < o_p) {\\n                return false;\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673249,
                "title": "c-short-solution-9-lines-o-n-time-o-1-space",
                "content": "```\\npublic class Solution \\n{\\n    public bool CanBeValid(string s, string locked) \\n    {\\n        int low = 0, high = 0;\\n        foreach ((char c, bool isLocked) in s.Zip(locked.Select(\\'1\\'.Equals))) \\n        {\\n            low  += c == \\')\\' || !isLocked ? -1 : +1;\\n            high += c == \\'(\\' || !isLocked ? +1 : -1;\\n            low = low < 0 ? 1 : low;\\n            if (high < 0) return false;\\n        }\\n        return low == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool CanBeValid(string s, string locked) \\n    {\\n        int low = 0, high = 0;\\n        foreach ((char c, bool isLocked) in s.Zip(locked.Select(\\'1\\'.Equals))) \\n        {\\n            low  += c == \\')\\' || !isLocked ? -1 : +1;\\n            high += c == \\'(\\' || !isLocked ? +1 : -1;\\n            low = low < 0 ? 1 : low;\\n            if (high < 0) return false;\\n        }\\n        return low == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668567,
                "title": "c-2-stacks-only-simple-validation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string str, string locked) {\\n    \\n        stack<int> st_dash_index,st_brace_index;//dash is for locked[i]=\\'0\\' and brace for \\'(\\'\\n        \\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(locked[i]==\\'1\\' && str[i]==\\')\\')\\n            {\\n                if(!st_brace_index.empty())\\n                {\\n                    st_brace_index.pop();\\n                }\\n                \\n                else if(!st_dash_index.empty())\\n                {\\n                    st_dash_index.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            \\n            else if(locked[i]==\\'1\\' && str[i]==\\'(\\')\\n            {\\n                \\n                st_brace_index.push(i);\\n            }\\n            \\n            else\\n            {\\n                \\n                st_dash_index.push(i);\\n            }\\n        }\\n        \\n        \\n        while(!st_brace_index.empty() && !st_dash_index.empty())\\n        {\\n            int index1=st_brace_index.top();\\n            int index2=st_dash_index.top();\\n            if(index1<index2)\\n            {\\n            \\n                st_brace_index.pop();\\n                st_dash_index.pop();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        if(st_brace_index.empty())\\n        {\\n            int d=st_dash_index.size();\\n            \\n            return !(d %2);\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string str, string locked) {\\n    \\n        stack<int> st_dash_index,st_brace_index;//dash is for locked[i]=\\'0\\' and brace for \\'(\\'\\n        \\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(locked[i]==\\'1\\' && str[i]==\\')\\')\\n            {\\n                if(!st_brace_index.empty())\\n                {\\n                    st_brace_index.pop();\\n                }\\n                \\n                else if(!st_dash_index.empty())\\n                {\\n                    st_dash_index.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            \\n            else if(locked[i]==\\'1\\' && str[i]==\\'(\\')\\n            {\\n                \\n                st_brace_index.push(i);\\n            }\\n            \\n            else\\n            {\\n                \\n                st_dash_index.push(i);\\n            }\\n        }\\n        \\n        \\n        while(!st_brace_index.empty() && !st_dash_index.empty())\\n        {\\n            int index1=st_brace_index.top();\\n            int index2=st_dash_index.top();\\n            if(index1<index2)\\n            {\\n            \\n                st_brace_index.pop();\\n                st_dash_index.pop();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        if(st_brace_index.empty())\\n        {\\n            int d=st_dash_index.size();\\n            \\n            return !(d %2);\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656174,
                "title": "c-compact-solution-with-no-raw-loops",
                "content": "No originality in the algorithm, only the packaging.\\n\\nWe make sure when going forward the number of unlocked positions + the number of locked positions with a ```\\'(\\'``` is greater than or equal to the number of locked positions with a ```\\')\\'```. When going backward, ```\\'(\\'``` and ```\\')\\'``` switch role.\\nThe actual counting is done by the transform part of ```std::transform_reduce``` using a lambda functions.\\nTo avoid repetitions the ```std::transform_reduce``` is packaged into another lambda function.\\n\\nSome may find all this too convoluted. That is totally fine with me. I did it as an execise to see if I could avoid raw loops.\\n\\nRunning time in the 40 - 60ms range which compares favorable with other C++ solutions.\\n```\\nclass Solution {\\npublic:\\n\\tbool canBeValid(std::string const& s, std::string const& locked) {\\n\\t\\tif (std::size(s) % 2 != 0) { return false; }\\n\\n\\t\\tauto validate = []<typename Iterator1, typename Iterator2, typename T>(Iterator1 first1, Iterator1 last1, Iterator2 first2, T close, T state) {\\n\\t\\t\\treturn std::transform_reduce(first1, last1, first2, true,\\n\\t\\t\\t\\tstd::logical_and<>(),\\n\\t\\t\\t\\t[=, count = 0](auto c, auto l) mutable { return (count += c != close || l == state ? 1 : -1) >= 0; });\\n\\t\\t};\\n\\n\\t\\treturn validate(std::cbegin(s), std::cend(s), std::cbegin(locked), \\')\\', \\'0\\')\\n\\t\\t\\t&& validate(std::crbegin(s), std::crend(s), std::crbegin(locked), \\'(\\', \\'0\\');\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\'(\\'```\n```\\')\\'```\n```\\'(\\'```\n```\\')\\'```\n```std::transform_reduce```\n```std::transform_reduce```\n```\\nclass Solution {\\npublic:\\n\\tbool canBeValid(std::string const& s, std::string const& locked) {\\n\\t\\tif (std::size(s) % 2 != 0) { return false; }\\n\\n\\t\\tauto validate = []<typename Iterator1, typename Iterator2, typename T>(Iterator1 first1, Iterator1 last1, Iterator2 first2, T close, T state) {\\n\\t\\t\\treturn std::transform_reduce(first1, last1, first2, true,\\n\\t\\t\\t\\tstd::logical_and<>(),\\n\\t\\t\\t\\t[=, count = 0](auto c, auto l) mutable { return (count += c != close || l == state ? 1 : -1) >= 0; });\\n\\t\\t};\\n\\n\\t\\treturn validate(std::cbegin(s), std::cend(s), std::cbegin(locked), \\')\\', \\'0\\')\\n\\t\\t\\t&& validate(std::crbegin(s), std::crend(s), std::crbegin(locked), \\'(\\', \\'0\\');\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654332,
                "title": "test-cases-to-understand-why-l-r-and-r-l",
                "content": "To check if paranthesis is valid, we can check L -> R or R -> L. But in this problem we are looking for exit/negative cases. So we do both and check if there is any exit case.\\n\\nFor symmetry, we should think variable bracket `x` as both `(` and `)`.\\nIn L -> R, we think `x` equal to `(`.\\nIn R -> L, we think `x` equal to `)`.\\n\\nNegative cases:\\ncase 1:\\n`(x)))`\\nwe will hit exit condition in L -> R because `left` + `variable` < `right`\\n\\nCase 2:\\n`x(`\\nfor this L -> R will not work. so we need R -> L\\n\\n\\n```\\npublic boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        if ((n & 1) == 1) {\\n            return false;\\n        }\\n\\n        int var = 0;\\n        int diff = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                var++;\\n            } else if (s.charAt(i) == \\'(\\') {\\n                diff++;\\n            } else {\\n                diff--;\\n            }\\n            \\n            if (var + diff < 0) {\\n                return false;\\n            }\\n        }\\n        \\n        var = 0;\\n        diff = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                var++;\\n            } else if (s.charAt(i) == \\'(\\') {\\n                diff--;\\n            } else {\\n                diff++;\\n            }\\n            \\n            if (var + diff < 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "To check if paranthesis is valid, we can check L -> R or R -> L. But in this problem we are looking for exit/negative cases. So we do both and check if there is any exit case.\\n\\nFor symmetry, we should think variable bracket `x` as both `(` and `)`.\\nIn L -> R, we think `x` equal to `(`.\\nIn R -> L, we think `x` equal to `)`.\\n\\nNegative cases:\\ncase 1:\\n`(x)))`\\nwe will hit exit condition in L -> R because `left` + `variable` < `right`\\n\\nCase 2:\\n`x(`\\nfor this L -> R will not work. so we need R -> L\\n\\n\\n```\\npublic boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        if ((n & 1) == 1) {\\n            return false;\\n        }\\n\\n        int var = 0;\\n        int diff = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                var++;\\n            } else if (s.charAt(i) == \\'(\\') {\\n                diff++;\\n            } else {\\n                diff--;\\n            }\\n            \\n            if (var + diff < 0) {\\n                return false;\\n            }\\n        }\\n        \\n        var = 0;\\n        diff = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                var++;\\n            } else if (s.charAt(i) == \\'(\\') {\\n                diff--;\\n            } else {\\n                diff++;\\n            }\\n            \\n            if (var + diff < 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1653136,
                "title": "2116-check-if-a-parentheses-string-can-be-valid",
                "content": "class Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int close=0;\\n        int open=0;\\n        int n=s.size();\\n        \\n        if(n&1)\\n            return false;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(locked[i]==\\'0\\'||s[i]==\\'(\\')\\n                open++;\\n            else\\n            close++;\\n            if(close>open)\\n                return false;\\n        }\\n        \\n        open=0;\\n        close=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(locked[i]==\\'0\\'||s[i]==\\')\\')\\n                open++;\\n            else\\n                close++;\\n            if(close>open)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int close=0;\\n        int open=0;\\n        int n=s.size();\\n        \\n        if(n&1)\\n            return false;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(locked[i]==\\'0\\'||s[i]==\\'(\\')\\n                open++;\\n            else\\n            close++;\\n            if(close>open)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1648557,
                "title": "java-explanation-using-comments-o-n-simple-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int openP=0;   // open Praranthese which are locked\\n        int closedP=0;\\n        int unlocked=0;// closed Parantheses which are locked\\n        int i=0;\\n        if(s.length()%2==1) return false;\\n        //those braces who are unlocked , we can arrange them in any way\\n       // so don\\'t count if unlocked is open or closed\\n      // The following loop is to take care of \\')\\' bracket , TRAVERSE LEFT TO RIGHT\\n      // so at any point closed locked bracket is greater than open locked + unlocked brackets    then we cannot able to make it valid by any way , [think about it]   \\n        while(i<s.length()){\\n            if(s.charAt(0)==\\')\\' && locked.charAt(0)==\\'1\\'){\\n                return false;\\n            }\\n            if(locked.charAt(i)==\\'1\\'){\\n                if(s.charAt(i)==\\'(\\'){\\n                    openP++;\\n                }else{\\n                    closedP++;\\n                }\\n            }else{\\n                unlocked++;\\n            }\\n            \\n            if(closedP > openP + unlocked){\\n                return false;\\n            }\\n            i++;\\n        }\\n                \\n        openP=0;   // open Praranthese which are locked\\n        closedP=0; // closed Parantheses which are locked\\n        unlocked=0;\\n        i=s.length()-1;\\n        // The following loop is to take care of \\'(\\' bracket , TRAVERSE RIGHT TO LEFT\\n      // so at any point open locked bracket is greater than closed locked + unlocked brackets    then we cannot able to make it valid by any way.  \\n        while(i>=0){\\n            if(s.charAt(s.length()-1)==\\'(\\' && locked.charAt(s.length()-1)==\\'1\\'){\\n                return false;\\n            }\\n            if(locked.charAt(i)==\\'1\\'){\\n                if(s.charAt(i)==\\'(\\'){\\n                    openP++;\\n                }else{\\n                    closedP++;\\n                }\\n            }else{\\n                unlocked++;\\n            }\\n            \\n            if(openP > closedP + unlocked){\\n                return false;\\n            }\\n            i--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int openP=0;   // open Praranthese which are locked\\n        int closedP=0;\\n        int unlocked=0;// closed Parantheses which are locked\\n        int i=0;\\n        if(s.length()%2==1) return false;\\n        //those braces who are unlocked , we can arrange them in any way\\n       // so don\\'t count if unlocked is open or closed\\n      // The following loop is to take care of \\')\\' bracket , TRAVERSE LEFT TO RIGHT\\n      // so at any point closed locked bracket is greater than open locked + unlocked brackets    then we cannot able to make it valid by any way , [think about it]   \\n        while(i<s.length()){\\n            if(s.charAt(0)==\\')\\' && locked.charAt(0)==\\'1\\'){\\n                return false;\\n            }\\n            if(locked.charAt(i)==\\'1\\'){\\n                if(s.charAt(i)==\\'(\\'){\\n                    openP++;\\n                }else{\\n                    closedP++;\\n                }\\n            }else{\\n                unlocked++;\\n            }\\n            \\n            if(closedP > openP + unlocked){\\n                return false;\\n            }\\n            i++;\\n        }\\n                \\n        openP=0;   // open Praranthese which are locked\\n        closedP=0; // closed Parantheses which are locked\\n        unlocked=0;\\n        i=s.length()-1;\\n        // The following loop is to take care of \\'(\\' bracket , TRAVERSE RIGHT TO LEFT\\n      // so at any point open locked bracket is greater than closed locked + unlocked brackets    then we cannot able to make it valid by any way.  \\n        while(i>=0){\\n            if(s.charAt(s.length()-1)==\\'(\\' && locked.charAt(s.length()-1)==\\'1\\'){\\n                return false;\\n            }\\n            if(locked.charAt(i)==\\'1\\'){\\n                if(s.charAt(i)==\\'(\\'){\\n                    openP++;\\n                }else{\\n                    closedP++;\\n                }\\n            }else{\\n                unlocked++;\\n            }\\n            \\n            if(openP > closedP + unlocked){\\n                return false;\\n            }\\n            i--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648026,
                "title": "java-o-n-one-pass-o-1-space-range-of-bracket-balance",
                "content": "At each step we calculate the possible range of bracket balance [min, max] and ensure that:\\n- at no point max<0\\n- we end up balanced min==0\\n```\\npublic boolean canBeValid(String s, String locked) {\\n\\tchar[] sa= s.toCharArray(), la= locked.toCharArray();\\n\\tint n= sa.length, min= 0, max= 0;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\t// minimum bracket balance (from what we know up until index i)\\n\\t\\tmin+= (min==0 || la[i]==\\'1\\' && sa[i]==\\'(\\' ? 1 : -1);\\n\\t\\t// maximum bracket balance - can never be negative (i.e. more closed than open brackets)\\n\\t\\tmax+= (la[i]==\\'1\\' && sa[i]==\\')\\' ? -1 : 1);\\n\\t\\tif(max<0) return false;\\n\\t}\\n\\treturn min==0;\\n}",
                "solutionTags": [],
                "code": "At each step we calculate the possible range of bracket balance [min, max] and ensure that:\\n- at no point max<0\\n- we end up balanced min==0\\n```\\npublic boolean canBeValid(String s, String locked) {\\n\\tchar[] sa= s.toCharArray(), la= locked.toCharArray();\\n\\tint n= sa.length, min= 0, max= 0;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\t// minimum bracket balance (from what we know up until index i)\\n\\t\\tmin+= (min==0 || la[i]==\\'1\\' && sa[i]==\\'(\\' ? 1 : -1);\\n\\t\\t// maximum bracket balance - can never be negative (i.e. more closed than open brackets)\\n\\t\\tmax+= (la[i]==\\'1\\' && sa[i]==\\')\\' ? -1 : 1);\\n\\t\\tif(max<0) return false;\\n\\t}\\n\\treturn min==0;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1647065,
                "title": "python-java-using-two-stack-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef canBeValid(self, s: str, locked: str) -> bool:\\n\\t\\t\\tif len(s) % 2 == 1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif s[-1] == \"(\" and locked[-1] == \"1\":\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tunlocked = []\\n\\t\\t\\tleft = []\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif locked[i] == \"0\":\\n\\t\\t\\t\\t\\tunlocked.append(i)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif s[i] == \"(\":\\n\\t\\t\\t\\t\\t\\tleft.append(i)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif left:\\n\\t\\t\\t\\t\\t\\t\\tleft.pop()\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif unlocked:\\n\\t\\t\\t\\t\\t\\t\\t\\tunlocked.pop()\\n\\t\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\twhile unlocked and left:\\n\\t\\t\\t\\tif unlocked[-1] > left[-1]:\\n\\t\\t\\t\\t\\tunlocked.pop()\\n\\t\\t\\t\\t\\tleft.pop()                \\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn not left\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean canBeValid(String s, String locked) {\\n\\t\\t\\tif (s.length() % 2 == 1) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (s.charAt(s.length() - 1) == \\'(\\' && locked.charAt(locked.length() - 1) == \\'1\\') {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tStack<Integer> unlocked = new Stack<>();\\n\\t\\t\\tStack<Integer> left = new Stack<>();\\n\\t\\t\\tfor (int i = 0; i < s.length(); i ++) {\\n\\t\\t\\t\\tif (locked.charAt(i) == \\'0\\') {\\n\\t\\t\\t\\t\\tunlocked.push(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (s.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\t\\t\\tleft.push(i);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (!left.isEmpty()) {\\n\\t\\t\\t\\t\\t\\t\\tleft.pop();\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tif (!unlocked.isEmpty()) {\\n\\t\\t\\t\\t\\t\\t\\t\\tunlocked.pop();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile (!unlocked.isEmpty() && !left.isEmpty()) {\\n\\t\\t\\t\\tif (unlocked.get(unlocked.size() - 1) > left.get(left.size() - 1)) {\\n\\t\\t\\t\\t\\tunlocked.pop();\\n\\t\\t\\t\\t\\tleft.pop();\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn left.isEmpty();\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef canBeValid(self, s: str, locked: str) -> bool:\\n\\t\\t\\tif len(s) % 2 == 1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif s[-1] == \"(\" and locked[-1] == \"1\":\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tunlocked = []\\n\\t\\t\\tleft = []\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif locked[i] == \"0\":\\n\\t\\t\\t\\t\\tunlocked.append(i)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif s[i] == \"(\":\\n\\t\\t\\t\\t\\t\\tleft.append(i)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif left:\\n\\t\\t\\t\\t\\t\\t\\tleft.pop()\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif unlocked:\\n\\t\\t\\t\\t\\t\\t\\t\\tunlocked.pop()\\n\\t\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\twhile unlocked and left:\\n\\t\\t\\t\\tif unlocked[-1] > left[-1]:\\n\\t\\t\\t\\t\\tunlocked.pop()\\n\\t\\t\\t\\t\\tleft.pop()                \\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn not left\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean canBeValid(String s, String locked) {\\n\\t\\t\\tif (s.length() % 2 == 1) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1646948,
                "title": "my-intuitive-idea-about-why-we-can-greedy-do-this-correct-if-i-am-wrong",
                "content": "This is my process of thinking. First, I call if it is \\'.\\' if it is not lock, \\'(\\' for open, and \\')\\' for close.\\nFirst part of my code just reduce some character if we have \\'(\\' and \\')\\' just immediately delete them. if the length is 2n +1 return false.\\n\\nNow, we have the shortest list we can have, I have 3 variables dot, open, and close. I check from left to right, if total number of close > open + dot. If yes return false. Then check from right to left, if open > close + dot return false. Now, why this work, assume there is a case like this:\\n\\'(\\'[something is satisfied with length 2n] \\'.\\' [something is satisfied with length 2m] \\')\\'.\\n\\nThe dot in the middle need to satisfy bot \\'(\\' in the first and \\')\\' in the end, and this case will satisfy our check. This is when the check will not work. However, when we calculate the sum of this string 3+ 2n + 2m, this is odd and contradict with what we have that the length of string should be even. Therefore, if the string satisfy our check, there is not exist a dot that need to be both \\'(\\' and \\')\\'. \\nSpace: O(N)\\nTime: O(N)\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        if(n % 2 == 1){\\n            return false;\\n        }\\n\\t\\t// the first part just greedy approach to reduce the number of character\\n        Deque<Character> dq = new LinkedList<>();\\n        for(int i = 0; i < n; i++){\\n            if(locked.charAt(i) == \\'0\\'){\\n                dq.addLast(\\'.\\');\\n            }\\n            else{\\n                if(s.charAt(i) == \\'(\\'){\\n                    dq.addLast(\\'(\\');\\n                }\\n                else{\\n                    if(dq.isEmpty()){\\n                        return false;\\n                    }\\n                    if(dq.peekLast() == \\'(\\'){\\n                        dq.pollLast();\\n                    }\\n                    else{\\n                        dq.addLast(\\')\\');\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        List<Character> list = new ArrayList<>(dq);\\n        System.out.println(list);\\n        \\n        if(dq.size() % 2 == 1){\\n            return false;\\n        }\\n        int open = 0;\\n        int dot = 0;\\n        int close = 0;\\n        for(int i = 0; i < list.size(); i++){\\n            if(list.get(i) == \\'(\\'){\\n                open += 1;\\n            }\\n            else if(list.get(i) == \\')\\'){\\n                close += 1;\\n            }\\n            else{\\n                dot += 1;\\n            }\\n            if(close > open + dot){\\n                return false;\\n            }\\n        }\\n        open = 0;\\n        dot = 0;\\n        close = 0;\\n        for(int i = list.size() - 1; i >= 0; i--){\\n            if(list.get(i) == \\'(\\'){\\n                open += 1;\\n            }\\n            else if(list.get(i) == \\')\\'){\\n                close += 1;\\n            }\\n            else{\\n                dot += 1;\\n            }\\n            \\n            if(open > close + dot){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        if(n % 2 == 1){\\n            return false;\\n        }\\n\\t\\t// the first part just greedy approach to reduce the number of character\\n        Deque<Character> dq = new LinkedList<>();\\n        for(int i = 0; i < n; i++){\\n            if(locked.charAt(i) == \\'0\\'){\\n                dq.addLast(\\'.\\');\\n            }\\n            else{\\n                if(s.charAt(i) == \\'(\\'){\\n                    dq.addLast(\\'(\\');\\n                }\\n                else{\\n                    if(dq.isEmpty()){\\n                        return false;\\n                    }\\n                    if(dq.peekLast() == \\'(\\'){\\n                        dq.pollLast();\\n                    }\\n                    else{\\n                        dq.addLast(\\')\\');\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        List<Character> list = new ArrayList<>(dq);\\n        System.out.println(list);\\n        \\n        if(dq.size() % 2 == 1){\\n            return false;\\n        }\\n        int open = 0;\\n        int dot = 0;\\n        int close = 0;\\n        for(int i = 0; i < list.size(); i++){\\n            if(list.get(i) == \\'(\\'){\\n                open += 1;\\n            }\\n            else if(list.get(i) == \\')\\'){\\n                close += 1;\\n            }\\n            else{\\n                dot += 1;\\n            }\\n            if(close > open + dot){\\n                return false;\\n            }\\n        }\\n        open = 0;\\n        dot = 0;\\n        close = 0;\\n        for(int i = list.size() - 1; i >= 0; i--){\\n            if(list.get(i) == \\'(\\'){\\n                open += 1;\\n            }\\n            else if(list.get(i) == \\')\\'){\\n                close += 1;\\n            }\\n            else{\\n                dot += 1;\\n            }\\n            \\n            if(open > close + dot){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1646763,
                "title": "single-pass-o-n-time-o-1-space-java",
                "content": "```\\nclass Solution {\\n    // Scan from left to right , maintain count of \\n    // total available unlocked \\n    // total \\'(\\' locked\\n    // total \\'(\\' locked that can be closed using available unlocked\\n    // at a moment see if \\')\\' locked can be neutralised \\n    // at last check if { total \\'(\\' locked } <= total \\'(\\' locked that can be closed\\n    // && above can be done using unlocked while remaining is even\\n    \\n\\tpublic boolean canBeValid(String s, String locked) {\\n\\t\\t// represents the available total unlocked\\n        int free = 0;\\n        // total \\'(\\' locked\\n\\t\\tint lockedOpen = 0;\\n         // total \\'(\\' locked that can be closed using available unlocked\\n\\t\\tint lockedOpenCanClose = 0;\\n\\t\\tint length = s.length();\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\tif (locked.charAt(i) == \\'0\\') {\\n\\t\\t\\t\\tfree++;\\n\\t\\t\\t\\tif (lockedOpen > 0 && lockedOpenCanClose < lockedOpen) {\\n\\t\\t\\t\\t\\tlockedOpenCanClose++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (s.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tlockedOpen++;\\n\\t\\t\\t} else if (s.charAt(i) == \\')\\') {\\n\\t\\t\\t\\tif (lockedOpen > 0) {\\n\\t\\t\\t\\t\\tlockedOpen--;\\n\\t\\t\\t\\t\\tif (lockedOpenCanClose > 0 && lockedOpenCanClose > lockedOpen)\\n\\t\\t\\t\\t\\t\\tlockedOpenCanClose--;\\n\\t\\t\\t\\t} else if (free > 0) {\\n\\t\\t\\t\\t\\tfree--;\\n\\t\\t\\t\\t\\tif (lockedOpenCanClose > 0 && free <= lockedOpenCanClose)\\n\\t\\t\\t\\t\\t\\tlockedOpenCanClose--;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lockedOpen <= lockedOpenCanClose && (free - lockedOpen) % 2 == 0;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Scan from left to right , maintain count of \\n    // total available unlocked \\n    // total \\'(\\' locked\\n    // total \\'(\\' locked that can be closed using available unlocked\\n    // at a moment see if \\')\\' locked can be neutralised \\n    // at last check if { total \\'(\\' locked } <= total \\'(\\' locked that can be closed\\n    // && above can be done using unlocked while remaining is even\\n    \\n\\tpublic boolean canBeValid(String s, String locked) {\\n\\t\\t// represents the available total unlocked\\n        int free = 0;\\n        // total \\'(\\' locked\\n\\t\\tint lockedOpen = 0;\\n         // total \\'(\\' locked that can be closed using available unlocked\\n\\t\\tint lockedOpenCanClose = 0;\\n\\t\\tint length = s.length();\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\tif (locked.charAt(i) == \\'0\\') {\\n\\t\\t\\t\\tfree++;\\n\\t\\t\\t\\tif (lockedOpen > 0 && lockedOpenCanClose < lockedOpen) {\\n\\t\\t\\t\\t\\tlockedOpenCanClose++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (s.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tlockedOpen++;\\n\\t\\t\\t} else if (s.charAt(i) == \\')\\') {\\n\\t\\t\\t\\tif (lockedOpen > 0) {\\n\\t\\t\\t\\t\\tlockedOpen--;\\n\\t\\t\\t\\t\\tif (lockedOpenCanClose > 0 && lockedOpenCanClose > lockedOpen)\\n\\t\\t\\t\\t\\t\\tlockedOpenCanClose--;\\n\\t\\t\\t\\t} else if (free > 0) {\\n\\t\\t\\t\\t\\tfree--;\\n\\t\\t\\t\\t\\tif (lockedOpenCanClose > 0 && free <= lockedOpenCanClose)\\n\\t\\t\\t\\t\\t\\tlockedOpenCanClose--;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lockedOpen <= lockedOpenCanClose && (free - lockedOpen) % 2 == 0;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646724,
                "title": "java-o-n-simple-with-explanation",
                "content": "**Intuition**\\nThere is no need to guess how we could change the non-locked parentheses. The result always depends on the locked parenthesis.\\nSo, how can we be sure that we can transform the non-locked parentheses correctly?\\n\\nLet\\'s look first from the left and track count of all the non-locked \"cells\" and locked opening parenthesis. In case if we meet a locked closing parentheses, we want to be sure that we beforehand had an open parenthesis (or a non-locked \"cell\" that we could transform into an open parenthesis). Hence, we decrease the counter in this case, and we check that the counter should not become negative. So, each closing locked parenthesis should have some previous open parenthesis.\\n\\nUsing the same logic, we\\'re going from right to left, counting the non-locked \"cells\" and locked closing parenthesis, decreasing the counter once we meed a locked opening parenthesis. And of course we also check that the counter should never become negative.\\n\\nOnce both conditions are met, we can claim that the squence can be **valid**.\\n\\n```\\npublic boolean canBeValid(String str, String locked) {\\n        int n = str.length();\\n        if (n % 2 != 0) return false;\\n        if (!locked.contains(\"1\")) return true;\\n\\n        int j = 0; // counter\\n        for (int i = 0; i < n; i++) { // check from left to right\\n            if (locked.charAt(i) == \\'0\\' || str.charAt(i) == \\'(\\') { // can be transformed to / already is an opening bracket\\n                j++;\\n            } else {\\n                j--;\\n                if (j < 0) return false; // we found a closing bracket, and we can\\'t find matching opening bracket for it on the left side\\n            }\\n        }\\n\\n        j = 0; // reset counter\\n        for (int i = n-1; i >= 0; i--) { // check from right  to left\\n            if (locked.charAt(i) == \\'0\\' || str.charAt(i) == \\')\\') { // can be transformed to / already is a closing bracket\\n                j++;\\n            } else {\\n                j--;\\n                if (j < 0) return false; // we found an opening bracket, and we can\\'t find matching closing bracket for it on the right side\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canBeValid(String str, String locked) {\\n        int n = str.length();\\n        if (n % 2 != 0) return false;\\n        if (!locked.contains(\"1\")) return true;\\n\\n        int j = 0; // counter\\n        for (int i = 0; i < n; i++) { // check from left to right\\n            if (locked.charAt(i) == \\'0\\' || str.charAt(i) == \\'(\\') { // can be transformed to / already is an opening bracket\\n                j++;\\n            } else {\\n                j--;\\n                if (j < 0) return false; // we found a closing bracket, and we can\\'t find matching opening bracket for it on the left side\\n            }\\n        }\\n\\n        j = 0; // reset counter\\n        for (int i = n-1; i >= 0; i--) { // check from right  to left\\n            if (locked.charAt(i) == \\'0\\' || str.charAt(i) == \\')\\') { // can be transformed to / already is a closing bracket\\n                j++;\\n            } else {\\n                j--;\\n                if (j < 0) return false; // we found an opening bracket, and we can\\'t find matching closing bracket for it on the right side\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035165,
                "title": "stack-solution-greedy",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n       stack<int> open, close, un;\\n\\n       for(int i=0; i<s.length(); i++)\\n       {\\n           if(locked[i] == \\'0\\')\\n            un.push(i);\\n           else if(s[i] == \\'(\\')\\n            open.push(i);\\n           else\\n            {\\n                if(open.size()) open.pop();  //firstly try to pop from open stack\\n                else if(un.size()) un.pop(); then, try for unlocked stack\\n                else return false; //otherwise, it is not possible to make valid combination\\n            }\\n       }\\n       //now, convert some unlocked characters into \\'(\\' to balance out \\'(\\' from open stack\\n       while(open.size() && un.size() && un.top() > open.top())\\n        {\\n            open.pop();\\n            un.pop();\\n        }\\n\\n    //now, there should be no \\'(\\' left and\\n    // also unlocked characters should be even \\n    //(so that they can balance out each other)\\n    return open.empty() && un.size()%2 == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n       stack<int> open, close, un;\\n\\n       for(int i=0; i<s.length(); i++)\\n       {\\n           if(locked[i] == \\'0\\')\\n            un.push(i);\\n           else if(s[i] == \\'(\\')\\n            open.push(i);\\n           else\\n            {\\n                if(open.size()) open.pop();  //firstly try to pop from open stack\\n                else if(un.size()) un.pop(); then, try for unlocked stack\\n                else return false; //otherwise, it is not possible to make valid combination\\n            }\\n       }\\n       //now, convert some unlocked characters into \\'(\\' to balance out \\'(\\' from open stack\\n       while(open.size() && un.size() && un.top() > open.top())\\n        {\\n            open.pop();\\n            un.pop();\\n        }\\n\\n    //now, there should be no \\'(\\' left and\\n    // also unlocked characters should be even \\n    //(so that they can balance out each other)\\n    return open.empty() && un.size()%2 == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976767,
                "title": "o-n-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse DFS to check every conditions. but met TLE.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck if is it possible failure when the unlocked position is \\'(\\',\\nby counting the number of \\'(\\' and unlocked position.\\n\\nAnd then check if it is possible failure for \\')\\'. count unlocked position as \\')\\'.\\n\\nWhen in the 2 cases, it always succeed, then return true;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N), created new reversed strings.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        \\n        int len = s.length();\\n        if (len % 2 != 0) {\\n            return false;\\n        }\\n\\n        boolean b1 = can(s, locked, \\'(\\');\\n        boolean b2 = can(new StringBuilder(s).reverse().toString(), \\n                    new StringBuilder(locked).reverse().toString(), \\')\\');\\n\\n        return b1 && b2;\\n    }\\n\\n    boolean can(String s, String locked, char left) {\\n\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            char lock = locked.charAt(i);\\n\\n            if (lock == \\'0\\' || c == left) {\\n                count++;\\n            } else {\\n                count--;\\n            }\\n            if (count < 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        \\n        int len = s.length();\\n        if (len % 2 != 0) {\\n            return false;\\n        }\\n\\n        boolean b1 = can(s, locked, \\'(\\');\\n        boolean b2 = can(new StringBuilder(s).reverse().toString(), \\n                    new StringBuilder(locked).reverse().toString(), \\')\\');\\n\\n        return b1 && b2;\\n    }\\n\\n    boolean can(String s, String locked, char left) {\\n\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            char lock = locked.charAt(i);\\n\\n            if (lock == \\'0\\' || c == left) {\\n                count++;\\n            } else {\\n                count--;\\n            }\\n            if (count < 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947751,
                "title": "kotlin-one-pass-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun canBeValid(s: String, locked: String): Boolean {\\n        var stock = 0\\n        var counter = 0\\n        for(i in s.indices) {\\n            if(locked[i] == \\'0\\') stock++\\n            counter += if((s[i] == \\')\\') || (locked[i] == \\'0\\')) -1 else 1\\n            if(counter >= 0) continue\\n            if(stock  <= 0) return false\\n            counter += 2\\n            stock--\\n        }\\n\\n        return counter == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun canBeValid(s: String, locked: String): Boolean {\\n        var stock = 0\\n        var counter = 0\\n        for(i in s.indices) {\\n            if(locked[i] == \\'0\\') stock++\\n            counter += if((s[i] == \\')\\') || (locked[i] == \\'0\\')) -1 else 1\\n            if(counter >= 0) continue\\n            if(stock  <= 0) return false\\n            counter += 2\\n            stock--\\n        }\\n\\n        return counter == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901561,
                "title": "typescript-o-n-with-a-shorter-second-loop-than-most-solutions",
                "content": "First loop tracks num of wild cards (unlocked indexes) to the right of each lockedOpen paren (unlocked[i] corresponds to the num of unlocked indices to the right of lockedOpen=i). If \\')\\' is encountered, decrement lockedOpen and add the value of unlocked that corresponded to lockedOpen and add it to the value of unlocked that corresponds to the new value for lockedOpen.\\nE.g., unlocked = [0, 1, 2], lockedOpen = 2\\na \\')\\' is encountered\\n=> unlocked = [0, 3], lockedOpen = 1\\n\\nOnly hits the return false in the loop when enough \\')\\' are encountered to exhaust all lockedOpen and unlocked.\\n\\nLastly, ensure there exists sufficient unlocked to the right of each remaining lockedOpen, allowing excess unlocked to spill into the pool corresponding to the next lockedOpen.\\n\\n# Complexity\\n- Time complexity: O(n), real complexity is lower than most solutions as the second loop is guaranteed to be less than n and is typically substantially less.\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nfunction canBeValid(s: string, locked: string): boolean {\\n  if (\\n\\t\\ts.length % 2 !== 0 || \\n\\t\\t(s[0] === \\')\\' && locked[0] === \\'1\\') || \\n\\t\\t(s[s.length - 1] === \\'(\\' && locked[s.length - 1] === \\'1\\')\\n\\t) return false;\\n\\n\\tlet lockedOpen = 0;\\n\\tlet unlocked: number[] = [0];\\n\\n\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\tif (locked[i] === \\'0\\') unlocked[lockedOpen]++;\\n\\t\\telse if (s[i] === \\'(\\') {\\n\\t\\t\\tlockedOpen++;\\n\\t\\t\\tunlocked.push(0);\\n\\t\\t} else if (lockedOpen > 0) {\\n\\t\\t\\tlockedOpen--;\\n\\t\\t\\tif (unlocked.length > 1)\\n\\t\\t\\t\\tunlocked[unlocked.length - 2] += unlocked.pop();\\n\\t\\t} else if (unlocked[0] > 0) unlocked[0]--;\\n\\t\\telse return false;\\n\\t}\\n\\t\\n\\tlet sum = 0;\\n\\tfor (let i = 0; i < lockedOpen; i++) {\\n\\t\\tsum += unlocked[unlocked.length - i - 1];\\n\\t\\tif (sum <= i) return false;\\n\\t}\\n\\n\\treturn true;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction canBeValid(s: string, locked: string): boolean {\\n  if (\\n\\t\\ts.length % 2 !== 0 || \\n\\t\\t(s[0] === \\')\\' && locked[0] === \\'1\\') || \\n\\t\\t(s[s.length - 1] === \\'(\\' && locked[s.length - 1] === \\'1\\')\\n\\t) return false;\\n\\n\\tlet lockedOpen = 0;\\n\\tlet unlocked: number[] = [0];\\n\\n\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\tif (locked[i] === \\'0\\') unlocked[lockedOpen]++;\\n\\t\\telse if (s[i] === \\'(\\') {\\n\\t\\t\\tlockedOpen++;\\n\\t\\t\\tunlocked.push(0);\\n\\t\\t} else if (lockedOpen > 0) {\\n\\t\\t\\tlockedOpen--;\\n\\t\\t\\tif (unlocked.length > 1)\\n\\t\\t\\t\\tunlocked[unlocked.length - 2] += unlocked.pop();\\n\\t\\t} else if (unlocked[0] > 0) unlocked[0]--;\\n\\t\\telse return false;\\n\\t}\\n\\t\\n\\tlet sum = 0;\\n\\tfor (let i = 0; i < lockedOpen; i++) {\\n\\t\\tsum += unlocked[unlocked.length - i - 1];\\n\\t\\tif (sum <= i) return false;\\n\\t}\\n\\n\\treturn true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890163,
                "title": "just-make-unlock-character-as-rest-same-as-valid-parenthesis-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked)\\n     {\\n          if(s.size()&1)\\n              return false;\\n\\n             for(int i=0; i<s.size(); i++)\\n             {\\n                 if(locked[i]==\\'0\\')\\n                    s[i]=\\'*\\';\\n             }\\n\\n       stack<int>open,star;\\n\\n      for(int i=0; i<s.size(); i++)\\n      {\\n          if(s[i]==\\'(\\') \\n             open.push(i);\\n          else if(s[i] == \\'*\\') \\n             star.push(i);\\n          else\\n           {\\n              if(open.size()>0) \\n                 open.pop();\\n              else if(star.size()>0) \\n                star.pop();\\n              else \\n                return false;\\n          }\\n      }\\n            //Now process leftover opening brackets\\n      while(open.size()>0)\\n      {\\n          if(star.size()==0 )\\n              return false;\\n          else if(open.top() < star.top()) \\n          {\\n              open.pop();\\n              star.pop();\\n          }\\n          else \\n            return false;\\n      }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked)\\n     {\\n          if(s.size()&1)\\n              return false;\\n\\n             for(int i=0; i<s.size(); i++)\\n             {\\n                 if(locked[i]==\\'0\\')\\n                    s[i]=\\'*\\';\\n             }\\n\\n       stack<int>open,star;\\n\\n      for(int i=0; i<s.size(); i++)\\n      {\\n          if(s[i]==\\'(\\') \\n             open.push(i);\\n          else if(s[i] == \\'*\\') \\n             star.push(i);\\n          else\\n           {\\n              if(open.size()>0) \\n                 open.pop();\\n              else if(star.size()>0) \\n                star.pop();\\n              else \\n                return false;\\n          }\\n      }\\n            //Now process leftover opening brackets\\n      while(open.size()>0)\\n      {\\n          if(star.size()==0 )\\n              return false;\\n          else if(open.top() < star.top()) \\n          {\\n              open.pop();\\n              star.pop();\\n          }\\n          else \\n            return false;\\n      }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843093,
                "title": "c-2-solutions-2-stacks-greedy",
                "content": "##### This is an equivalent problem of ([678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)), except that the unlocked character cannot be the empty string \"\".\\n\\n---\\n# Method 1: Two Stacks\\n---\\n# Intuition\\nThis is the most intuitive method. Use two stacks to simulate the process of parentheses matching.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Return **False** directly if the number of length is odd\\n- In the first pass:\\n- `left` records the position of the \\'(\\', and `star` records the wildcard \\'*\\' (unlocked character).\\n- When we hitting a closing parenthesis \\')\\':\\n    - check if we can pop a \\'(\\' from `left` first\\n    - if `left` is empty, then check if we can pop a \\'*\\' from `star`\\n    - if both `left` and `star` are empty, we must have a mismatched \\')\\', return **False**\\n- In the second pass:\\n- For each \\'(\\' in `left`, we cancel it with the \\'\\\\*\\' in `star`, as long as the position of \\'\\\\*\\' is after \\'(\\'\\n    - If the stack `star` becomes empty in priority to `left`, or the position of \\'\\\\*\\' becomes smaller than \\'(\\', return False\\n- Finally, if there are even numbers of \\'*\\' in `star`, we can return **True**. It\\'s alway ture if we do the odd/even verification in the first step since the parentheses are cancelled out in pairs.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        stack<int> left, star;\\n        int size = s.size();\\n        if (size % 2)\\n            return false;\\n        // the first pass \\n        for (int i = 0; i < size; i++) {\\n            if (locked[i] == \\'0\\')   // unlocked \\'*\\'\\n                star.push(i);\\n            else if (s[i] == \\'(\\')   // locked \\'(\\'\\n                left.push(i);\\n            else {                  // locked \\')\\'\\n                if (!left.empty())\\n                    left.pop();\\n                else if (!star.empty())\\n                    star.pop();\\n                else\\n                    return false;\\n            }\\n        }\\n        // the second pass\\n        while (!left.empty()) {\\n            if (!star.empty() && star.top() > left.top()) {\\n                left.pop();\\n                star.pop();\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n---\\n# Method 2: Greedy\\n---\\n\\n# Intuition\\nThis method is not very intuitive but it saves space.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Return **False** directly if the length of the string is odd\\n- `lo` records the minimal number of \\'(\\': treat only locked \\'(\\' as \\'(\\', otherwise cancelled out\\n- `hi` record the maximum number of \\'(\\': treat both locked \\'(\\' and everything unlocked as \\'(\\'\\n- if `hi` goes below 0, we must have an unmatched \\')\\', return **False**\\n- if `lo` goes below 0, we mistakenly treated \\'*\\' as \\')\\' in the past, reset `lo` to 0\\n- Finally, check if we have unmatched \\'(\\', if none (`lo == 0`), we return **True**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int size = s.size();\\n        if (size % 2)\\n            return false;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < size; i++) {\\n            (locked[i] == \\'1\\' && s[i] == \\'(\\') ? lo++ : lo--;\\n            (!(locked[i] == \\'1\\' && s[i] == \\')\\')) ? hi++ : hi--;\\n            if (hi < 0)\\n                return false;\\n            lo = max(lo, 0);\\n        }\\n        return lo == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        stack<int> left, star;\\n        int size = s.size();\\n        if (size % 2)\\n            return false;\\n        // the first pass \\n        for (int i = 0; i < size; i++) {\\n            if (locked[i] == \\'0\\')   // unlocked \\'*\\'\\n                star.push(i);\\n            else if (s[i] == \\'(\\')   // locked \\'(\\'\\n                left.push(i);\\n            else {                  // locked \\')\\'\\n                if (!left.empty())\\n                    left.pop();\\n                else if (!star.empty())\\n                    star.pop();\\n                else\\n                    return false;\\n            }\\n        }\\n        // the second pass\\n        while (!left.empty()) {\\n            if (!star.empty() && star.top() > left.top()) {\\n                left.pop();\\n                star.pop();\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int size = s.size();\\n        if (size % 2)\\n            return false;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < size; i++) {\\n            (locked[i] == \\'1\\' && s[i] == \\'(\\') ? lo++ : lo--;\\n            (!(locked[i] == \\'1\\' && s[i] == \\')\\')) ? hi++ : hi--;\\n            if (hi < 0)\\n                return false;\\n            lo = max(lo, 0);\\n        }\\n        return lo == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780065,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool help1(string s,string locked){\\n        int len=s.length();\\n        int cnt=0;\\n\\n        stack<int> st;\\n\\n        for(int i=0;i<len;i++){\\n            if(locked[i]==\\'0\\') s[i]=\\'*\\';\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                }\\n                else{\\n                    if(cnt<=0) return 0;\\n                    cnt--;\\n                }\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        cnt=cnt-st.size();\\n        if(cnt<0) return 0;\\n\\n        return cnt%2==0;\\n    }\\n\\n    bool help2(string s,string locked){\\n        int len=s.length();\\n        int cnt=0;\\n\\n        stack<int> st;\\n\\n        for(int i=0;i<len;i++){\\n            if(locked[i]==\\'0\\') s[i]=\\'*\\';\\n        }\\n        \\n        for(int i=len-1;i>=0;i--){\\n            if(s[i]==\\')\\'){\\n                st.push(i);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                }\\n                else{\\n                    if(cnt<=0) return 0;\\n                    cnt--;\\n                }\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        cnt=cnt-st.size();\\n        if(cnt<0) return 0;\\n\\n        return cnt%2==0;\\n    }\\n\\n    bool canBeValid(string s, string locked) {\\n        return help1(s,locked)&&help2(s,locked);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool help1(string s,string locked){\\n        int len=s.length();\\n        int cnt=0;\\n\\n        stack<int> st;\\n\\n        for(int i=0;i<len;i++){\\n            if(locked[i]==\\'0\\') s[i]=\\'*\\';\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                }\\n                else{\\n                    if(cnt<=0) return 0;\\n                    cnt--;\\n                }\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        cnt=cnt-st.size();\\n        if(cnt<0) return 0;\\n\\n        return cnt%2==0;\\n    }\\n\\n    bool help2(string s,string locked){\\n        int len=s.length();\\n        int cnt=0;\\n\\n        stack<int> st;\\n\\n        for(int i=0;i<len;i++){\\n            if(locked[i]==\\'0\\') s[i]=\\'*\\';\\n        }\\n        \\n        for(int i=len-1;i>=0;i--){\\n            if(s[i]==\\')\\'){\\n                st.push(i);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                }\\n                else{\\n                    if(cnt<=0) return 0;\\n                    cnt--;\\n                }\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        cnt=cnt-st.size();\\n        if(cnt<0) return 0;\\n\\n        return cnt%2==0;\\n    }\\n\\n    bool canBeValid(string s, string locked) {\\n        return help1(s,locked)&&help2(s,locked);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778979,
                "title": "simple-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int cnt = 0;\\n        int lock = 0;\\n        if(s.length()&1) return false;\\n        for(int i = 0; i<s.length(); i++){\\n            if(s[i] == \\'(\\' && locked[i] == \\'1\\') cnt++;\\n            else if(s[i] == \\')\\' && locked[i] == \\'1\\') cnt--;\\n            else lock++;\\n            if(cnt + lock < 0) return false;\\n        }\\n        cnt = 0;\\n        lock = 0;\\n        for(int i = s.length() - 1; i>=0; i--){\\n            if(s[i] == \\'(\\' && locked[i] == \\'1\\') cnt++;\\n            else if(s[i] == \\')\\' && locked[i] == \\'1\\') cnt--;\\n            else lock++;\\n            if(cnt - lock > 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int cnt = 0;\\n        int lock = 0;\\n        if(s.length()&1) return false;\\n        for(int i = 0; i<s.length(); i++){\\n            if(s[i] == \\'(\\' && locked[i] == \\'1\\') cnt++;\\n            else if(s[i] == \\')\\' && locked[i] == \\'1\\') cnt--;\\n            else lock++;\\n            if(cnt + lock < 0) return false;\\n        }\\n        cnt = 0;\\n        lock = 0;\\n        for(int i = s.length() - 1; i>=0; i--){\\n            if(s[i] == \\'(\\' && locked[i] == \\'1\\') cnt++;\\n            else if(s[i] == \\')\\' && locked[i] == \\'1\\') cnt--;\\n            else lock++;\\n            if(cnt - lock > 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717548,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int l = 0, r = 0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(locked[i] == \\'1\\') {\\n                if(s[i] == \\'(\\') {\\n                    ++l, ++r;\\n                } else {\\n                    if(r == 0) {\\n                        return false;\\n                    } else {\\n                        --r;\\n                    }\\n                    if(l == 0) {\\n                        l = 1;\\n                    } else {\\n                        --l;\\n                    }\\n                }\\n            } else {\\n                ++r;\\n                if(l > 0) {\\n                    --l;\\n                } else {\\n                    ++l;\\n                }\\n            }\\n        }\\n        return l==0;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int l = 0, r = 0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(locked[i] == \\'1\\') {\\n                if(s[i] == \\'(\\') {\\n                    ++l, ++r;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3702870,
                "title": "o-n-tc-o-1-sc-java-solution-very-intuitive-and-easy-to-understand-upvote",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if(s.length() % 2 != 0 ){\\n            return false;\\n        }\\n\\n        int open = 0;\\n        int close = 0;\\n        int flip = 0;\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(locked.charAt(i) == \\'0\\'){\\n                flip++;\\n            }\\n            else{\\n                if(s.charAt(i) == \\')\\'){\\n                    close++;\\n                }\\n                else open++;\\n            }\\n\\n            if(open + flip < close) return false;\\n        }\\n\\n        open = 0;\\n        close = 0;\\n        flip = 0;\\n\\n        for(int i = s.length() - 1; i >= 0; i--){\\n            if(locked.charAt(i) == \\'0\\'){\\n                flip++;\\n            }\\n            else{\\n                if(s.charAt(i) == \\')\\'){\\n                    close++;\\n                }\\n                else open++;\\n            }\\n\\n            if(close + flip < open) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if(s.length() % 2 != 0 ){\\n            return false;\\n        }\\n\\n        int open = 0;\\n        int close = 0;\\n        int flip = 0;\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(locked.charAt(i) == \\'0\\'){\\n                flip++;\\n            }\\n            else{\\n                if(s.charAt(i) == \\')\\'){\\n                    close++;\\n                }\\n                else open++;\\n            }\\n\\n            if(open + flip < close) return false;\\n        }\\n\\n        open = 0;\\n        close = 0;\\n        flip = 0;\\n\\n        for(int i = s.length() - 1; i >= 0; i--){\\n            if(locked.charAt(i) == \\'0\\'){\\n                flip++;\\n            }\\n            else{\\n                if(s.charAt(i) == \\')\\'){\\n                    close++;\\n                }\\n                else open++;\\n            }\\n\\n            if(close + flip < open) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561261,
                "title": "stack-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        stack<int>st,extra;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(locked[i]==\\'0\\')\\n                extra.push(i);\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                   st.push(i);\\n                else if(st.size())\\n                   st.pop();\\n                else if(extra.size())\\n                   extra.pop();\\n                else\\n                    return false;  \\n            }\\n        }\\n        while(st.size())\\n        {\\n            if(extra.empty() || st.top()>extra.top())\\n                return false;\\n            extra.pop();\\n            st.pop();\\n        }\\n        return st.size() || extra.size()%2?false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        stack<int>st,extra;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(locked[i]==\\'0\\')\\n                extra.push(i);\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                   st.push(i);\\n                else if(st.size())\\n                   st.pop();\\n                else if(extra.size())\\n                   extra.pop();\\n                else\\n                    return false;  \\n            }\\n        }\\n        while(st.size())\\n        {\\n            if(extra.empty() || st.top()>extra.top())\\n                return false;\\n            extra.pop();\\n            st.pop();\\n        }\\n        return st.size() || extra.size()%2?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544227,
                "title": "python-greedy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def canBeValid(self, s, locked):\\n        \"\"\"\\n        :type s: str\\n        :type locked: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) % 2 != 0:\\n            return False\\n\\n        low = high = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                if locked[i] == \\'0\\':\\n                    low = max(0, low - 1)\\n                    high += 1\\n                else:\\n                    low += 1\\n                    high += 1\\n            else:\\n                if locked[i] == \\'0\\':\\n                    low = max(0, low - 1)\\n                    high += 1\\n                else:\\n                    low = max(0, low - 1)\\n                    if high == 0:\\n                        return False\\n                    high -= 1\\n\\n        return low == 0\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canBeValid(self, s, locked):\\n        \"\"\"\\n        :type s: str\\n        :type locked: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) % 2 != 0:\\n            return False\\n\\n        low = high = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                if locked[i] == \\'0\\':\\n                    low = max(0, low - 1)\\n                    high += 1\\n                else:\\n                    low += 1\\n                    high += 1\\n            else:\\n                if locked[i] == \\'0\\':\\n                    low = max(0, low - 1)\\n                    high += 1\\n                else:\\n                    low = max(0, low - 1)\\n                    if high == 0:\\n                        return False\\n                    high -= 1\\n\\n        return low == 0\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366070,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.length() % 2) return false;\\n        int any = 0, open = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(locked[i] == \\'0\\') any++;\\n            else {\\n                if(s[i] == \\'(\\') open++;\\n                else {\\n                    if(open > 0) open--;\\n                    else any--;\\n                }\\n                if(open + any < 0) return false;\\n            }\\n        }\\n        any = open = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if(locked[i] == \\'0\\') any++;\\n            else {\\n                if(s[i] == \\')\\') open++;\\n                else {\\n                    if(open > 0) open--;\\n                    else any--;\\n                }\\n                if(open + any < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n// Golang\\nfunc canBeValid(s string, locked string) bool {\\n    if len(s) % 2 == 1 {return false}\\n    var any, open = 0, 0\\n    for i := 0; i < len(s); i++ {\\n        if locked[i] == \\'0\\' {\\n            any++\\n        } else {\\n            if s[i] == \\'(\\' {\\n                open++\\n            } else {\\n                if open > 0 {\\n                    open--\\n                } else {\\n                    any--\\n                }\\n            }\\n            if open + any < 0 {return false}\\n        }\\n    }\\n    any, open = 0, 0\\n    for i := len(s) - 1; i >= 0; i-- {\\n        if locked[i] == \\'0\\' {\\n            any++\\n        } else {\\n            if s[i] == \\')\\' {\\n                open++\\n            } else {\\n                if open > 0 {\\n                    open--\\n                } else {\\n                    any--\\n                }\\n            }\\n            if open + any < 0 {return false}\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.length() % 2) return false;\\n        int any = 0, open = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(locked[i] == \\'0\\') any++;\\n            else {\\n                if(s[i] == \\'(\\') open++;\\n                else {\\n                    if(open > 0) open--;\\n                    else any--;\\n                }\\n                if(open + any < 0) return false;\\n            }\\n        }\\n        any = open = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if(locked[i] == \\'0\\') any++;\\n            else {\\n                if(s[i] == \\')\\') open++;\\n                else {\\n                    if(open > 0) open--;\\n                    else any--;\\n                }\\n                if(open + any < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n// Golang\\nfunc canBeValid(s string, locked string) bool {\\n    if len(s) % 2 == 1 {return false}\\n    var any, open = 0, 0\\n    for i := 0; i < len(s); i++ {\\n        if locked[i] == \\'0\\' {\\n            any++\\n        } else {\\n            if s[i] == \\'(\\' {\\n                open++\\n            } else {\\n                if open > 0 {\\n                    open--\\n                } else {\\n                    any--\\n                }\\n            }\\n            if open + any < 0 {return false}\\n        }\\n    }\\n    any, open = 0, 0\\n    for i := len(s) - 1; i >= 0; i-- {\\n        if locked[i] == \\'0\\' {\\n            any++\\n        } else {\\n            if s[i] == \\')\\' {\\n                open++\\n            } else {\\n                if open > 0 {\\n                    open--\\n                } else {\\n                    any--\\n                }\\n            }\\n            if open + any < 0 {return false}\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354041,
                "title": "c-stack-time-and-space-o-n-faster-than-90",
                "content": "# Intuition\\nTake two stack open and st.Open stack to store the indices of \\'(\\' which can\\'t be change and st stack to store the indices of \\'(\\' or \\')\\' which can be changed. Now if you found s[i]==\\')\\' and locked[i]==\\'1\\', so check if open is not empty then pop from it and if open is empty check for st stack if not empty then pop and if st stack is also empty then return false.\\nNow after travesing entire string if open stack is not empty balance it with st stack. \\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        stack<int> open;\\n        stack<int> st;\\n        if(n%2==1) return false;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\' && locked[i]==\\'1\\') open.push(i);\\n            else if(s[i]==\\'(\\' && locked[i]==\\'0\\') st.push(i);\\n            else if(s[i]==\\')\\' && locked[i]==\\'0\\') st.push(i);\\n            else{\\n                if(!open.empty()) open.pop();\\n                else if(!st.empty()) st.pop();\\n                else return false;\\n            }\\n        }\\n        while(!open.empty()){\\n            if(st.empty()) return false;\\n            else if(st.top()>open.top()){\\n                st.pop();\\n                open.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        stack<int> open;\\n        stack<int> st;\\n        if(n%2==1) return false;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\' && locked[i]==\\'1\\') open.push(i);\\n            else if(s[i]==\\'(\\' && locked[i]==\\'0\\') st.push(i);\\n            else if(s[i]==\\')\\' && locked[i]==\\'0\\') st.push(i);\\n            else{\\n                if(!open.empty()) open.pop();\\n                else if(!st.empty()) st.pop();\\n                else return false;\\n            }\\n        }\\n        while(!open.empty()){\\n            if(st.empty()) return false;\\n            else if(st.top()>open.top()){\\n                st.pop();\\n                open.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337344,
                "title": "simple-c-max-open-and-min-open-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N+N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.length()%2!=0)\\n          return false;\\n\\n         for(int i=0;i<s.size();i++)\\n         {\\n             if(locked[i]==\\'0\\')\\n             {\\n                 s[i]=\\'*\\';\\n             }\\n         }\\n\\n        int min_open = 0, max_open = 0; // min and max possible count of open parentheses\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                min_open++;\\n                max_open++;\\n            } else if (c == \\')\\') {\\n                min_open--;\\n                max_open--;\\n            } else { // c == \\'*\\'\\n                min_open--;\\n                max_open++;\\n            }\\n            // check if the string becomes invalid at any point\\n            if (max_open < 0) {\\n                return false;\\n            }\\n            min_open = max(min_open, 0); // make sure min_open is non-negative\\n        }\\n        return min_open == 0; \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        if(s.length()%2!=0)\\n          return false;\\n\\n         for(int i=0;i<s.size();i++)\\n         {\\n             if(locked[i]==\\'0\\')\\n             {\\n                 s[i]=\\'*\\';\\n             }\\n         }\\n\\n        int min_open = 0, max_open = 0; // min and max possible count of open parentheses\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                min_open++;\\n                max_open++;\\n            } else if (c == \\')\\') {\\n                min_open--;\\n                max_open--;\\n            } else { // c == \\'*\\'\\n                min_open--;\\n                max_open++;\\n            }\\n            // check if the string becomes invalid at any point\\n            if (max_open < 0) {\\n                return false;\\n            }\\n            min_open = max(min_open, 0); // make sure min_open is non-negative\\n        }\\n        return min_open == 0; \\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326678,
                "title": "python-100-time-o-n",
                "content": "# Intuition\\nWe can check if parantheses are valid in O(n) time by making sure the number of `(` matches the number of `)`. Thus, an initial thought may be to ensure there are enough unlocked slots to balance the number of parantheses. \\n\\nHowever, this encounters some problems. A locked `(` can only be matched by a `)` that comes after it. A `)` can only be matched by a `(` that comes before it.\\n\\nNote that if we have `A(B)C`, where A,B,C are arbitrary substrings, this will be valid if `ABC` is valid. Because of this, as long as any locked right/left parantheses are matched up, the remaining unlocked slots are guaranteed to have a valid solution.\\n\\n# Approach\\nWe will take a greedy approach. We try to answer two main questions.\\n\\n1) How do we deal with locked `(`?\\n2) How do we deal with locked `)`?\\n\\nIdeally we pair up as many locked sets of parantheses as possible. This allows us to use our unlocked slots freely to pair with less locked parantheses.\\n\\nTherefore, we\\'ll keep track of all the locked `(` we encounter. Any time we encounter a `)` we match it with a locked `(` if possible.\\n\\nWe can\\'t match a locked `(` using unlocked slots that come before. Therefore, we will match as many locked `(` as possible with the unlocked slots we\\'ve seen. If there are excess `(`, they can be matched with any unlocked slots remaining at the end.\\n\\nFinally, we must match a locked `)` with something we\\'ve already encountered. Thus, we must use a previously seen unlocked slot if no unmatched locked `(` remains.\\n\\nThrough this we maintain the following invariants. If any are broken, we return False.\\n\\n1) Any locked `)` encountered so far has a corresponding `(`\\n2) Any locked `(` we haven\\'t found a potential match for can only be matched with a slot we haven\\'t seen yet.\\n\\n\\n# Complexity\\n- Time complexity: O(n); we complete this in one pass\\n\\n- Space complexity: O(1); only 3 constants are tracked\\n\\n# Code\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        n = len(locked)\\n        if n%2 is 1: # Obviously this results in an imbalance of parantheses\\n            return False\\n        unlockedSlots = 0\\n        unlockedLefts = 0 #Unlocked slots currently used to match lefts\\n        unmatchedLefts = 0 #Lefts that haven\\'t found a match\\n        for i in range(n):\\n            if locked[i] is \\'0\\':\\n                if unmatchedLefts > 0:\\n                    unlockedLefts += 1\\n                    unmatchedLefts -= 1\\n                unlockedSlots += 1\\n            else: # locked[i] is 1\\n                if s[i] is \\'(\\':\\n                    unmatchedLefts += 1\\n                elif s[i] is \\')\\':\\n                    if unmatchedLefts is 0 and unlockedSlots is 0:\\n                        return False\\n                    elif unmatchedLefts > 0:\\n                        unmatchedLefts -= 1\\n                    elif unlockedSlots > unlockedLefts: \\n                        unlockedSlots -= 1\\n                    else:\\n                        unmatchedLefts += 1\\n                        unlockedSlots -= 1\\n        if unmatchedLefts > 0:\\n            return False\\n        return True\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        n = len(locked)\\n        if n%2 is 1: # Obviously this results in an imbalance of parantheses\\n            return False\\n        unlockedSlots = 0\\n        unlockedLefts = 0 #Unlocked slots currently used to match lefts\\n        unmatchedLefts = 0 #Lefts that haven\\'t found a match\\n        for i in range(n):\\n            if locked[i] is \\'0\\':\\n                if unmatchedLefts > 0:\\n                    unlockedLefts += 1\\n                    unmatchedLefts -= 1\\n                unlockedSlots += 1\\n            else: # locked[i] is 1\\n                if s[i] is \\'(\\':\\n                    unmatchedLefts += 1\\n                elif s[i] is \\')\\':\\n                    if unmatchedLefts is 0 and unlockedSlots is 0:\\n                        return False\\n                    elif unmatchedLefts > 0:\\n                        unmatchedLefts -= 1\\n                    elif unlockedSlots > unlockedLefts: \\n                        unlockedSlots -= 1\\n                    else:\\n                        unmatchedLefts += 1\\n                        unlockedSlots -= 1\\n        if unmatchedLefts > 0:\\n            return False\\n        return True\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324148,
                "title": "using-flips-with-open-and-close",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        //left side flip+open<close\\n        //right side flip+close<open\\n        int open_count=0;\\n        int close_count=0;\\n        int flip_count=0;\\n        if(s.length()%2!=0){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(locked.charAt(i)==\\'0\\'){\\n                flip_count++;\\n            }else{\\n                if(s.charAt(i)==\\'(\\'){\\n                    open_count++;\\n                }else{\\n                    close_count++;\\n                }\\n            }\\n        \\n            if(flip_count+open_count<close_count){\\n                return false;\\n            }\\n        }\\n        close_count=0;\\n        open_count=0;\\n        flip_count=0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(locked.charAt(i)==\\'0\\'){\\n                flip_count++;\\n            }else{\\n                if(s.charAt(i)==\\'(\\'){\\n                    open_count++;\\n                }else{\\n                    close_count++;\\n                }\\n            }\\n            if(flip_count+close_count<open_count){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        //left side flip+open<close\\n        //right side flip+close<open\\n        int open_count=0;\\n        int close_count=0;\\n        int flip_count=0;\\n        if(s.length()%2!=0){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(locked.charAt(i)==\\'0\\'){\\n                flip_count++;\\n            }else{\\n                if(s.charAt(i)==\\'(\\'){\\n                    open_count++;\\n                }else{\\n                    close_count++;\\n                }\\n            }\\n        \\n            if(flip_count+open_count<close_count){\\n                return false;\\n            }\\n        }\\n        close_count=0;\\n        open_count=0;\\n        flip_count=0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(locked.charAt(i)==\\'0\\'){\\n                flip_count++;\\n            }else{\\n                if(s.charAt(i)==\\'(\\'){\\n                    open_count++;\\n                }else{\\n                    close_count++;\\n                }\\n            }\\n            if(flip_count+close_count<open_count){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301042,
                "title": "c-solution-by-using-the-counting-brackets-methods-constant-space",
                "content": "# Intuition\\nWe can think of an approach in which we count the number of brackets that are wrong and check if they can be fixed or not.\\n\\n# Approach\\n- We iterate over the string s twice.\\n- Count of variable brackets is maintained using tot\\n- Count of fixed open brackets is maintained using op\\n- Count of fixed closed brackets is maintained using cl\\n- In forward iteration we are checking if we have too many fixed closed brackets ), this is achieved using: if tot + op - cl < 0: return False\\n- In backward iteration we are checking if we have too many fixed open brackets (, this is achieved using: if tot - op + cl < 0: return False\\n\\n# Complexity\\n- Time complexity: O(N+N)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string l) {\\n        if (s.size() % 2 == 1) return false;\\n        int total = 0, open = 0, closed = 0;\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            if (l[i] == \\'0\\')\\n                total += 1;\\n            else if (s[i] == \\'(\\')\\n                open += 1;\\n            else if (s[i] == \\')\\')\\n                closed += 1;\\n                \\n            if (total - open + closed < 0) return false;\\n        }\\n        total = open = closed = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if (l[i] == \\'0\\')\\n                total += 1;\\n            else if (s[i] == \\'(\\')\\n                open += 1;\\n            else if (s[i] == \\')\\')\\n                closed += 1;\\n\\n            if (total + open - closed < 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string l) {\\n        if (s.size() % 2 == 1) return false;\\n        int total = 0, open = 0, closed = 0;\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            if (l[i] == \\'0\\')\\n                total += 1;\\n            else if (s[i] == \\'(\\')\\n                open += 1;\\n            else if (s[i] == \\')\\')\\n                closed += 1;\\n                \\n            if (total - open + closed < 0) return false;\\n        }\\n        total = open = closed = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if (l[i] == \\'0\\')\\n                total += 1;\\n            else if (s[i] == \\'(\\')\\n                open += 1;\\n            else if (s[i] == \\')\\')\\n                closed += 1;\\n\\n            if (total + open - closed < 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295011,
                "title": "java-from-huifeng-guan-by-one-loop-greedy-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=4YK8WrE-ssQ\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        \\n        if (s.length() % 2 != 0 || locked.length() % 2 != 0) return false;\\n        int countMax = 0;\\n        int countMin = 0;\\n\\n        for (int i =0; i < s.length(); i++) {\\n            if (locked.charAt(i) == \\'1\\') {\\n                if (s.charAt(i) == \\'(\\') {\\n                    countMax += 1;\\n                    countMin += 1;\\n                } else {\\n                    countMax -= 1;\\n                    countMin -= 1;\\n                }\\n            } else {\\n                countMax += 1;\\n                countMin -= 1;\\n            }\\n\\n            if (countMin < 0) {\\n                countMin = 1;\\n            }\\n\\n            if (countMax < 0) {\\n                return false;\\n            }\\n        }\\n        // System.out.print(\"countMax:\"+countMax+\"\\\\n\");\\n        // System.out.print(\"countMin:\"+countMin+\"\\\\n\");\\n\\n        return countMin == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        \\n        if (s.length() % 2 != 0 || locked.length() % 2 != 0) return false;\\n        int countMax = 0;\\n        int countMin = 0;\\n\\n        for (int i =0; i < s.length(); i++) {\\n            if (locked.charAt(i) == \\'1\\') {\\n                if (s.charAt(i) == \\'(\\') {\\n                    countMax += 1;\\n                    countMin += 1;\\n                } else {\\n                    countMax -= 1;\\n                    countMin -= 1;\\n                }\\n            } else {\\n                countMax += 1;\\n                countMin -= 1;\\n            }\\n\\n            if (countMin < 0) {\\n                countMin = 1;\\n            }\\n\\n            if (countMax < 0) {\\n                return false;\\n            }\\n        }\\n        // System.out.print(\"countMax:\"+countMax+\"\\\\n\");\\n        // System.out.print(\"countMin:\"+countMin+\"\\\\n\");\\n\\n        return countMin == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213052,
                "title": "simple-java-solution-using-count",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        if (n % 2 != 0) return false;\\n        int left = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (locked.charAt(i) == \\'1\\' && s.charAt(i) == \\'(\\') {\\n                left++;\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                if (left < n / 2) {\\n                    count++;\\n                    left++;\\n                } else {\\n                    count--;\\n                }\\n            } else {\\n                if (s.charAt(i) == \\'(\\') {\\n                    count++;\\n                } else {\\n                    count--;\\n                }\\n            }\\n            if (count < 0) return false;\\n        }\\n        return count == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        int n = s.length();\\n        if (n % 2 != 0) return false;\\n        int left = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (locked.charAt(i) == \\'1\\' && s.charAt(i) == \\'(\\') {\\n                left++;\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (locked.charAt(i) == \\'0\\') {\\n                if (left < n / 2) {\\n                    count++;\\n                    left++;\\n                } else {\\n                    count--;\\n                }\\n            } else {\\n                if (s.charAt(i) == \\'(\\') {\\n                    count++;\\n                } else {\\n                    count--;\\n                }\\n            }\\n            if (count < 0) return false;\\n        }\\n        return count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182380,
                "title": "typescript-beats-runtime-100-space-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount number of unlocked, open and closed brackets\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate over the array twice. \\nIn forwards iteration check if at any index number of closing brackets is more that sum of unlocked and opening brakcets.  \\nIn backwards iteration check if at any index number of opening brackets is more that sum of unlocked and closing brakcets.  \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1\\xCF)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction canBeValid(s: string, locked: string): boolean {\\n    if (s.length % 2 == 1) return false;\\n    let anyCounter = 0;\\n    let openCounter = 0;\\n    let closeCounter = 0;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (locked[i] === \"0\") {\\n            anyCounter++\\n        }\\n        else if (s[i] === \"(\") {\\n            openCounter++\\n        } else if (s[i] === \")\") {\\n            closeCounter++\\n        }\\n        if (anyCounter + openCounter - closeCounter < 0) return false\\n    }\\n\\n    anyCounter = 0, openCounter = 0, closeCounter = 0;\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        if (locked[i] === \\'0\\') {\\n            anyCounter++\\n        }\\n        else if (s[i] === \"(\") {\\n            openCounter++\\n        } else if (s[i] === \")\") {\\n            closeCounter++\\n        }\\n        if (anyCounter - openCounter + closeCounter < 0) return false\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction canBeValid(s: string, locked: string): boolean {\\n    if (s.length % 2 == 1) return false;\\n    let anyCounter = 0;\\n    let openCounter = 0;\\n    let closeCounter = 0;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (locked[i] === \"0\") {\\n            anyCounter++\\n        }\\n        else if (s[i] === \"(\") {\\n            openCounter++\\n        } else if (s[i] === \")\") {\\n            closeCounter++\\n        }\\n        if (anyCounter + openCounter - closeCounter < 0) return false\\n    }\\n\\n    anyCounter = 0, openCounter = 0, closeCounter = 0;\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        if (locked[i] === \\'0\\') {\\n            anyCounter++\\n        }\\n        else if (s[i] === \"(\") {\\n            openCounter++\\n        } else if (s[i] === \")\") {\\n            closeCounter++\\n        }\\n        if (anyCounter - openCounter + closeCounter < 0) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107485,
                "title": "python-soltion",
                "content": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if (len(s)%2==1):return False\\n        l,r=0,0\\n        for i,j in zip(s,locked):\\n            if j==\\'1\\':\\n                if i==\\'(\\':\\n                    l+=1\\n                else:\\n                    l-=1\\n            else:\\n                l+=1\\n            if l<0: return False\\n        for i,j in zip(s[::-1],locked[::-1]):\\n            if j==\\'1\\':\\n                if i==\\')\\':\\n                    r+=1\\n                else:\\n                    r-=1\\n            else:\\n                r+=1\\n            if r<0: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if (len(s)%2==1):return False\\n        l,r=0,0\\n        for i,j in zip(s,locked):\\n            if j==\\'1\\':\\n                if i==\\'(\\':\\n                    l+=1\\n                else:\\n                    l-=1\\n            else:\\n                l+=1\\n            if l<0: return False\\n        for i,j in zip(s[::-1],locked[::-1]):\\n            if j==\\'1\\':\\n                if i==\\')\\':\\n                    r+=1\\n                else:\\n                    r-=1\\n            else:\\n                r+=1\\n            if r<0: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081083,
                "title": "python-two-passes-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)%2: return False\\n        def check(s, locked):\\n            l = 0\\n            star = 0\\n            for i,c in enumerate(s):\\n                if locked[i]==\\'0\\':\\n                    star += 1\\n                elif c == \\'(\\':\\n                    l += 1\\n                else:\\n                    l -= 1\\n                if l < 0:\\n                    if star < 1: return False\\n                    star -= 1\\n                    l += 1\\n            return star >= l\\n        reverse = [(\\')\\' if c == \\'(\\' else \\'(\\') for c in s]\\n        return check(s, locked) and check(reverse[::-1], locked[::-1])\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)%2: return False\\n        def check(s, locked):\\n            l = 0\\n            star = 0\\n            for i,c in enumerate(s):\\n                if locked[i]==\\'0\\':\\n                    star += 1\\n                elif c == \\'(\\':\\n                    l += 1\\n                else:\\n                    l -= 1\\n                if l < 0:\\n                    if star < 1: return False\\n                    star -= 1\\n                    l += 1\\n            return star >= l\\n        reverse = [(\\')\\' if c == \\'(\\' else \\'(\\') for c in s]\\n        return check(s, locked) and check(reverse[::-1], locked[::-1])\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942749,
                "title": "c-faster-than-80",
                "content": "# Intuition\\nGo through s and calculate the min and max of a special value.\\n\\n# Approach\\nConsider \\'(\\' as a 1, \\')\\' as a -1. Go through s and calculate the min and max values. If locked[i] == 1 we can append s[i] only. In this case if s[i] == \\'(\\' we increase both min and max, otherwise see the code. If locked[i] == 0 we increase max and try to decrease min (it should remain always greater or equal to 0).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool CanBeValid(string s, string locked) {\\n        if (s.Length % 2 == 1) return false;\\n        var max = 0;\\n        var min = 0;\\n        for (int i = 0; i < locked.Length; i++)\\n        {\\n            if (locked[i] == \\'1\\')\\n            {\\n                if (s[i] == \\'(\\')\\n                {\\n                    max++;\\n                    min++;\\n                }\\n                else\\n                {\\n                    if (max > 0)\\n                    {\\n                        max--;\\n                    }\\n                    else\\n                    {\\n                        return false;\\n                    }\\n                    if (min > 0)\\n                    {\\n                        min--;\\n                    }\\n                    else\\n                    {\\n                        min++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                max++;\\n                if (min > 0)\\n                {\\n                    min--;\\n                }\\n                else\\n                {\\n                    min++;\\n                }\\n            }\\n        }\\n        return min == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CanBeValid(string s, string locked) {\\n        if (s.Length % 2 == 1) return false;\\n        var max = 0;\\n        var min = 0;\\n        for (int i = 0; i < locked.Length; i++)\\n        {\\n            if (locked[i] == \\'1\\')\\n            {\\n                if (s[i] == \\'(\\')\\n                {\\n                    max++;\\n                    min++;\\n                }\\n                else\\n                {\\n                    if (max > 0)\\n                    {\\n                        max--;\\n                    }\\n                    else\\n                    {\\n                        return false;\\n                    }\\n                    if (min > 0)\\n                    {\\n                        min--;\\n                    }\\n                    else\\n                    {\\n                        min++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                max++;\\n                if (min > 0)\\n                {\\n                    min--;\\n                }\\n                else\\n                {\\n                    min++;\\n                }\\n            }\\n        }\\n        return min == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938886,
                "title": "easy-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA regular bracket sequence has essentially the following properties:\\n1) Equal no. of \\'(\\' and \\')\\' brackets.(which rules out odd valued string length)\\n2) at any index numForwardBracket >= numBackwardBracket .\\n# Approach\\n\\n1) Calculate number of locked forward and backward indices . (let them be fNum and bNum respectively)\\n2)  fNum>n/2 or bNum>n/2 then not possible. else we check in the step number 3.\\n3)  now we check how many forward and backward indices are left. that can simply be found by putting both of them as fNum = n/2-fNum, bNum = n/2 - bNum.\\n4)  Now at all places where locked \\\\[idx\\\\] = 0, we greedily put remaining forward brackets before backward brackets.\\n5)  In the resultant string check the property no. 2 at each index, if it violates this property at any index then answer is false else it is true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(n&1) return false;\\n        int fNum = 0 , bNum = 0;\\n        for(int i=0;i<n;i++){\\n            if(locked[i]-\\'0\\'){\\n                if(s[i]==\\'(\\') fNum++;\\n                else bNum++;\\n            }\\n        }\\n        if(fNum>n/2 || bNum>n/2) return false;\\n        fNum = n/2-fNum;\\n        bNum = n/2-bNum;\\n        for(int i=0;i<n;i++){\\n            if(locked[i]-\\'0\\') continue;\\n            if(fNum){\\n                s[i] = \\'(\\';\\n                fNum--;\\n            }\\n            else s[i] = \\')\\';\\n        }\\n        int val = 0;\\n        for(auto x: s){\\n            if(x==\\'(\\') val++;\\n            else val--;\\n            if(val<0) return false;\\n        }\\n        if(val) return false;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(n&1) return false;\\n        int fNum = 0 , bNum = 0;\\n        for(int i=0;i<n;i++){\\n            if(locked[i]-\\'0\\'){\\n                if(s[i]==\\'(\\') fNum++;\\n                else bNum++;\\n            }\\n        }\\n        if(fNum>n/2 || bNum>n/2) return false;\\n        fNum = n/2-fNum;\\n        bNum = n/2-bNum;\\n        for(int i=0;i<n;i++){\\n            if(locked[i]-\\'0\\') continue;\\n            if(fNum){\\n                s[i] = \\'(\\';\\n                fNum--;\\n            }\\n            else s[i] = \\')\\';\\n        }\\n        int val = 0;\\n        for(auto x: s){\\n            if(x==\\'(\\') val++;\\n            else val--;\\n            if(val<0) return false;\\n        }\\n        if(val) return false;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815157,
                "title": "java-recursion-tle-left-to-right-balance-two-stacks",
                "content": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        // return f(0, 0, s, locked); //TLE\\n        // return balanceMethod(s, locked);\\n        return twoStacksMethod(s, locked);\\n    }\\n    \\n    public boolean twoStacksMethod(String s, String locked) {\\n        int n = s.length();\\n        if(n%2 == 1){\\n            return false;\\n        }\\n        \\n        Stack<Integer> openStk = new Stack();\\n        Stack<Integer> changeStk = new Stack();\\n        \\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(locked.charAt(i) == \\'0\\'){\\n                changeStk.push(i);\\n            }else if(ch == \\'(\\'){\\n                openStk.push(i);\\n            }else{\\n                if(openStk.isEmpty() && changeStk.isEmpty()){\\n                    return false;\\n                }\\n                if(!openStk.isEmpty()){\\n                    openStk.pop();\\n                }else{\\n                    changeStk.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!openStk.isEmpty() && !changeStk.isEmpty()){\\n            if(openStk.pop() > changeStk.pop()){\\n                return false;\\n            }\\n        }\\n        return openStk.isEmpty();\\n    }\\n    \\n    public boolean balanceMethod(String s, String locked) {\\n        int n = s.length();\\n        if(n%2 == 1){\\n            return false;\\n        }\\n        \\n        int balance = 0;\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\' || locked.charAt(i) == \\'0\\'){\\n                balance++;\\n            }else{\\n                balance--;\\n            }\\n            \\n            if(balance < 0){\\n                return false;\\n            }\\n        }\\n        if(balance == 0){\\n            return true;\\n        }\\n        balance = 0;\\n        for(int i=n-1; i>=0; i--){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\' || locked.charAt(i) == \\'0\\'){\\n                balance++;\\n            }else{\\n                balance--;\\n            }\\n            if(balance < 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    public boolean f(int idx, int count, String s, String locked){\\n        if(count < 0){\\n            return false;\\n        }\\n        \\n        for(int i=idx; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(locked.charAt(i)-\\'0\\' == 1){\\n                if(ch == \\'(\\'){\\n                    count++;\\n                }else{\\n                    if(count <= 0){\\n                        return false;\\n                    }\\n                    count--;\\n                }\\n            }else{\\n                if(ch == \\'(\\'){\\n                    return f(i+1, count+1, s, locked) || f(i+1, count-1, s, locked);\\n                }else{\\n                    return f(i+1, count+1, s, locked) || f(i+1, count-1, s, locked);\\n                }\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        // return f(0, 0, s, locked); //TLE\\n        // return balanceMethod(s, locked);\\n        return twoStacksMethod(s, locked);\\n    }\\n    \\n    public boolean twoStacksMethod(String s, String locked) {\\n        int n = s.length();\\n        if(n%2 == 1){\\n            return false;\\n        }\\n        \\n        Stack<Integer> openStk = new Stack();\\n        Stack<Integer> changeStk = new Stack();\\n        \\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(locked.charAt(i) == \\'0\\'){\\n                changeStk.push(i);\\n            }else if(ch == \\'(\\'){\\n                openStk.push(i);\\n            }else{\\n                if(openStk.isEmpty() && changeStk.isEmpty()){\\n                    return false;\\n                }\\n                if(!openStk.isEmpty()){\\n                    openStk.pop();\\n                }else{\\n                    changeStk.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!openStk.isEmpty() && !changeStk.isEmpty()){\\n            if(openStk.pop() > changeStk.pop()){\\n                return false;\\n            }\\n        }\\n        return openStk.isEmpty();\\n    }\\n    \\n    public boolean balanceMethod(String s, String locked) {\\n        int n = s.length();\\n        if(n%2 == 1){\\n            return false;\\n        }\\n        \\n        int balance = 0;\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\' || locked.charAt(i) == \\'0\\'){\\n                balance++;\\n            }else{\\n                balance--;\\n            }\\n            \\n            if(balance < 0){\\n                return false;\\n            }\\n        }\\n        if(balance == 0){\\n            return true;\\n        }\\n        balance = 0;\\n        for(int i=n-1; i>=0; i--){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\' || locked.charAt(i) == \\'0\\'){\\n                balance++;\\n            }else{\\n                balance--;\\n            }\\n            if(balance < 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    public boolean f(int idx, int count, String s, String locked){\\n        if(count < 0){\\n            return false;\\n        }\\n        \\n        for(int i=idx; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(locked.charAt(i)-\\'0\\' == 1){\\n                if(ch == \\'(\\'){\\n                    count++;\\n                }else{\\n                    if(count <= 0){\\n                        return false;\\n                    }\\n                    count--;\\n                }\\n            }else{\\n                if(ch == \\'(\\'){\\n                    return f(i+1, count+1, s, locked) || f(i+1, count-1, s, locked);\\n                }else{\\n                    return f(i+1, count+1, s, locked) || f(i+1, count-1, s, locked);\\n                }\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791694,
                "title": "right-to-left-and-vice-versa-balanced-parentheses-counting-swift",
                "content": "Taking intuition from https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/discuss/1650613/Intuition-Explained-oror-Balanced-Parentheses-Greedy-Approach-oror-C%2B%2B-Clean-Code\\n\\n```\\nclass Solution {\\n    func canBeValid(_ s: String, _ locked: String) -> Bool {\\n        \\n        let size = s.count\\n        \\n        guard size % 2 == 0 else { return false }\\n        var balance = 0\\n        \\n        for i in s.indices {\\n            if s[i] == \"(\" || locked[i] == \"0\" {\\n                balance += 1 \\n            }\\n            else {\\n                balance -= 1\\n            }\\n            \\n            if balance < 0 { return false }\\n        }\\n        \\n        balance = 0\\n        \\n        for i in s.indices.reversed() {\\n            if s[i] == \")\" || locked[i] == \"0\" {\\n                balance += 1 \\n            }\\n            else {\\n                balance -= 1\\n            }\\n            \\n            if balance < 0 { return false }\\n        }\\n        \\n        return true\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canBeValid(_ s: String, _ locked: String) -> Bool {\\n        \\n        let size = s.count\\n        \\n        guard size % 2 == 0 else { return false }\\n        var balance = 0\\n        \\n        for i in s.indices {\\n            if s[i] == \"(\" || locked[i] == \"0\" {\\n                balance += 1 \\n            }\\n            else {\\n                balance -= 1\\n            }\\n            \\n            if balance < 0 { return false }\\n        }\\n        \\n        balance = 0\\n        \\n        for i in s.indices.reversed() {\\n            if s[i] == \")\" || locked[i] == \"0\" {\\n                balance += 1 \\n            }\\n            else {\\n                balance -= 1\\n            }\\n            \\n            if balance < 0 { return false }\\n        }\\n        \\n        return true\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784865,
                "title": "go-colution",
                "content": "# Code\\n```\\nfunc canBeValid(s string, locked string) bool {\\n    if len(s) % 2 == 1 { return false }\\n\\n    left, right := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        if s[i] == \\'(\\' || locked[i] == \\'0\\' {\\n            left++\\n        } else {\\n            left--\\n        }\\n\\n        if left < 0 { return false }\\n    }\\n\\n    if left == 0 { return true }\\n\\n    for i := len(s) - 1; i >= 0; i-- {\\n        if s[i] == \\')\\' || locked[i] == \\'0\\' {\\n            right++\\n        } else {\\n            right--\\n        }\\n\\n        if right < 0 { return false }\\n    }\\n\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canBeValid(s string, locked string) bool {\\n    if len(s) % 2 == 1 { return false }\\n\\n    left, right := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        if s[i] == \\'(\\' || locked[i] == \\'0\\' {\\n            left++\\n        } else {\\n            left--\\n        }\\n\\n        if left < 0 { return false }\\n    }\\n\\n    if left == 0 { return true }\\n\\n    for i := len(s) - 1; i >= 0; i-- {\\n        if s[i] == \\')\\' || locked[i] == \\'0\\' {\\n            right++\\n        } else {\\n            right--\\n        }\\n\\n        if right < 0 { return false }\\n    }\\n\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783856,
                "title": "easy-to-understand-greedy-soln",
                "content": "```\\nclass Solution {\\nbool isValid(string s){\\n    int bal=0;\\n    for(auto e:s){\\n        if(e==\\'(\\')\\n            bal++;\\n        else \\n            bal--;\\n    \\n        if(bal<0)\\n            return false;\\n    }\\n    \\n    return true;\\n}\\n    public:\\n    bool canBeValid(string s, string locked) {\\n        int n=s.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'0\\')\\n                s[i]=\\'(\\';\\n        }\\n        \\n      //  cout<<s<<endl;\\n        \\n        if(!isValid(s))\\n            return false;\\n        \\n        int maxNegPrefix[n];\\n        int pref[n];\\n        \\n        int bal=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')\\n                bal++;\\n            else \\n                bal--;\\n            pref[i]=bal;\\n        }\\n        \\n        int mn=pref[n-1];\\n        \\n        maxNegPrefix[n-1]=INT_MAX;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            maxNegPrefix[i]=mn-pref[i];\\n            mn=min(mn,pref[i]);\\n        }\\n        \\n        int open=0;\\n        \\n     //   cout<<maxNegPrefix[n-2]<<endl;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\')\\')\\n                open--;\\n            else {\\n                if(locked[i]==\\'1\\')\\n                    open++;\\n                else{\\n                    // can I change this to ) ??? \\n                  //  cout<<\"jjj\\\\n\"\\n                    \\n                    if(i==n-1 && open>1)\\n                        return false;\\n                    \\n                    \\n                    int rem=open-1;\\n                  //  cout<<maxNegPrefix[i]<<endl;\\n                    if(maxNegPrefix[i]>=((-1)*rem) && open>0){\\n                        open--;\\n                    }\\n                    else \\n                        open++;\\n                }\\n            }\\n        }\\n        return open==0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nbool isValid(string s){\\n    int bal=0;\\n    for(auto e:s){\\n        if(e==\\'(\\')\\n            bal++;\\n        else \\n            bal--;\\n    \\n        if(bal<0)\\n            return false;\\n    }\\n    \\n    return true;\\n}\\n    public:\\n    bool canBeValid(string s, string locked) {\\n        int n=s.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'0\\')\\n                s[i]=\\'(\\';\\n        }\\n        \\n      //  cout<<s<<endl;\\n        \\n        if(!isValid(s))\\n            return false;\\n        \\n        int maxNegPrefix[n];\\n        int pref[n];\\n        \\n        int bal=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')\\n                bal++;\\n            else \\n                bal--;\\n            pref[i]=bal;\\n        }\\n        \\n        int mn=pref[n-1];\\n        \\n        maxNegPrefix[n-1]=INT_MAX;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            maxNegPrefix[i]=mn-pref[i];\\n            mn=min(mn,pref[i]);\\n        }\\n        \\n        int open=0;\\n        \\n     //   cout<<maxNegPrefix[n-2]<<endl;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\')\\')\\n                open--;\\n            else {\\n                if(locked[i]==\\'1\\')\\n                    open++;\\n                else{\\n                    // can I change this to ) ??? \\n                  //  cout<<\"jjj\\\\n\"\\n                    \\n                    if(i==n-1 && open>1)\\n                        return false;\\n                    \\n                    \\n                    int rem=open-1;\\n                  //  cout<<maxNegPrefix[i]<<endl;\\n                    if(maxNegPrefix[i]>=((-1)*rem) && open>0){\\n                        open--;\\n                    }\\n                    else \\n                        open++;\\n                }\\n            }\\n        }\\n        return open==0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2776810,
                "title": "c-solution-using-2-stack-and-set",
                "content": "**C++ Code:**\\n**Worst Case Time Complexity: O(nlogn)**\\n\\n```\\n   bool canBeValid(string s, string locked) {\\n    if(s.size()%2!=0) return false;\\n     stack<int>lock;\\n     vector<int>unlock;\\n     for(int i=0;i<s.size();i++){\\n         if(locked[i]==\\'1\\'){\\n             if(!lock.empty() && s[i]==\\')\\' && s[lock.top()]==\\'(\\')\\n                 lock.pop();\\n             else lock.push(i);\\n                 \\n         }\\n         else if(locked[i]==\\'0\\'){\\n             unlock.push_back(i);\\n         }\\n     }\\n     sort(unlock.begin(),unlock.end());\\n     while(!lock.empty() && !unlock.empty()){\\n        if(s[lock.top()]==\\'(\\'){\\n          auto it = lower_bound(unlock.begin(),unlock.end(),lock.top());\\n           if(!lock.empty() && it!=unlock.end()){\\n               lock.pop();\\n               unlock.erase(it);\\n           }\\n           else return false;\\n        }\\n        else if(s[lock.top()]==\\')\\') {\\n            auto it = lower_bound(unlock.begin(),unlock.end(),lock.top());\\n            if(it==unlock.begin()) return false;\\n              it--;\\n            if(it!=unlock.end()){\\n               lock.pop();\\n               unlock.erase(it);\\n           }\\n           else return false;\\n        }\\n     }\\n     if(lock.empty()) return true;\\n     return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\n   bool canBeValid(string s, string locked) {\\n    if(s.size()%2!=0) return false;\\n     stack<int>lock;\\n     vector<int>unlock;\\n     for(int i=0;i<s.size();i++){\\n         if(locked[i]==\\'1\\'){\\n             if(!lock.empty() && s[i]==\\')\\' && s[lock.top()]==\\'(\\')\\n                 lock.pop();\\n             else lock.push(i);\\n                 \\n         }\\n         else if(locked[i]==\\'0\\'){\\n             unlock.push_back(i);\\n         }\\n     }\\n     sort(unlock.begin(),unlock.end());\\n     while(!lock.empty() && !unlock.empty()){\\n        if(s[lock.top()]==\\'(\\'){\\n          auto it = lower_bound(unlock.begin(),unlock.end(),lock.top());\\n           if(!lock.empty() && it!=unlock.end()){\\n               lock.pop();\\n               unlock.erase(it);\\n           }\\n           else return false;\\n        }\\n        else if(s[lock.top()]==\\')\\') {\\n            auto it = lower_bound(unlock.begin(),unlock.end(),lock.top());\\n            if(it==unlock.begin()) return false;\\n              it--;\\n            if(it!=unlock.end()){\\n               lock.pop();\\n               unlock.erase(it);\\n           }\\n           else return false;\\n        }\\n     }\\n     if(lock.empty()) return true;\\n     return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2762904,
                "title": "traversal-technique-math-intuition-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(n%2 != 0)\\n            return false;\\n        int tot = 0;\\n        int open = 0;\\n        int close = 0;\\n        // Forward traversal to find the no of open fixed brackets has sufficient free brackets to close them.\\n        for(int i=0;i<n;i++) {\\n            if(locked[i] == \\'0\\')\\n                tot++;\\n            else if(s[i] == \\')\\')\\n                close++;\\n            else if(s[i] == \\'(\\')\\n                open++;\\n            // the operation that checks the condition mentioned above!\\n            if(tot + open < close)\\n                return false;\\n        }\\n        tot = 0;\\n        open = 0;\\n        close = 0;\\n        // Backward traversal to find the no of close fixed brackets has sufficient free brackets to close them.\\n        for(int i=n-1;i>=0;i--) {\\n            if(locked[i] == \\'0\\')\\n                tot++;\\n            else if(s[i] == \\')\\')\\n                close++;\\n            else if(s[i] == \\'(\\')\\n                open++;\\n            // the operation that checks the condition mentioned above!\\n            if(tot + close < open)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n// Consider upvoting if the solution helped! Thank you :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if(n%2 != 0)\\n            return false;\\n        int tot = 0;\\n        int open = 0;\\n        int close = 0;\\n        // Forward traversal to find the no of open fixed brackets has sufficient free brackets to close them.\\n        for(int i=0;i<n;i++) {\\n            if(locked[i] == \\'0\\')\\n                tot++;\\n            else if(s[i] == \\')\\')\\n                close++;\\n            else if(s[i] == \\'(\\')\\n                open++;\\n            // the operation that checks the condition mentioned above!\\n            if(tot + open < close)\\n                return false;\\n        }\\n        tot = 0;\\n        open = 0;\\n        close = 0;\\n        // Backward traversal to find the no of close fixed brackets has sufficient free brackets to close them.\\n        for(int i=n-1;i>=0;i--) {\\n            if(locked[i] == \\'0\\')\\n                tot++;\\n            else if(s[i] == \\')\\')\\n                close++;\\n            else if(s[i] == \\'(\\')\\n                open++;\\n            // the operation that checks the condition mentioned above!\\n            if(tot + close < open)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n// Consider upvoting if the solution helped! Thank you :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752416,
                "title": "java-solutions-easy",
                "content": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        // Base condition is to be balanced, atleast string length should be even.\\n        if(s.length() % 2 == 1){\\n            return false;\\n        }\\n        int requiredClosing = 0, requiredOpening = 0;\\n        //Check for locked state open and closing paranthesis. If at any point of iteration they can\\'t be nullified with opposite paranthesis, then return false. Else at end return true.\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\')\\' && locked.charAt(i) == \\'1\\'){\\n                requiredClosing++;\\n                if(requiredClosing > 0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                requiredClosing--;\\n            }\\n        }\\n        for(int i = s.length()-1;i>=0;i--){\\n            if(s.charAt(i) == \\'(\\' && locked.charAt(i) == \\'1\\'){\\n                requiredOpening ++;\\n                if(requiredOpening > 0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                requiredOpening--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        // Base condition is to be balanced, atleast string length should be even.\\n        if(s.length() % 2 == 1){\\n            return false;\\n        }\\n        int requiredClosing = 0, requiredOpening = 0;\\n        //Check for locked state open and closing paranthesis. If at any point of iteration they can\\'t be nullified with opposite paranthesis, then return false. Else at end return true.\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\')\\' && locked.charAt(i) == \\'1\\'){\\n                requiredClosing++;\\n                if(requiredClosing > 0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                requiredClosing--;\\n            }\\n        }\\n        for(int i = s.length()-1;i>=0;i--){\\n            if(s.charAt(i) == \\'(\\' && locked.charAt(i) == \\'1\\'){\\n                requiredOpening ++;\\n                if(requiredOpening > 0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                requiredOpening--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739718,
                "title": "java-string-manipulation",
                "content": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        // Base condition is to be balanced, atleast string length should be even.\\n        if(s.length() % 2 == 1){\\n            return false;\\n        }\\n        int requiredClosing = 0, requiredOpening = 0;\\n        //Check for locked state open and closing paranthesis. If at any point of iteration they can\\'t be nullified with opposite paranthesis, then return false. Else at end return true.\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\')\\' && locked.charAt(i) == \\'1\\'){\\n                requiredClosing++;\\n                if(requiredClosing > 0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                requiredClosing--;\\n            }\\n        }\\n        for(int i = s.length()-1;i>=0;i--){\\n            if(s.charAt(i) == \\'(\\' && locked.charAt(i) == \\'1\\'){\\n                requiredOpening ++;\\n                if(requiredOpening > 0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                requiredOpening--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        // Base condition is to be balanced, atleast string length should be even.\\n        if(s.length() % 2 == 1){\\n            return false;\\n        }\\n        int requiredClosing = 0, requiredOpening = 0;\\n        //Check for locked state open and closing paranthesis. If at any point of iteration they can\\'t be nullified with opposite paranthesis, then return false. Else at end return true.\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\')\\' && locked.charAt(i) == \\'1\\'){\\n                requiredClosing++;\\n                if(requiredClosing > 0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                requiredClosing--;\\n            }\\n        }\\n        for(int i = s.length()-1;i>=0;i--){\\n            if(s.charAt(i) == \\'(\\' && locked.charAt(i) == \\'1\\'){\\n                requiredOpening ++;\\n                if(requiredOpening > 0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                requiredOpening--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707824,
                "title": "greedy-python-solution-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/ff19ae1b-6c69-46a3-a567-de2ce69a2044_1665885148.1303608.png)\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        n = len(s)\\n        if n% 2 !=0:return False\\n        nonlocked = 0\\n\\n        op = 0\\n        used_on_nonlocked = 0\\n\\n        for i in range(n):\\n            if locked[i] == \\'0\\':\\n                nonlocked += 1\\n                if op > 0 and nonlocked > 0:\\n                    nonlocked -=1\\n                    op -= 1\\n                    used_on_nonlocked += 1\\n                continue\\n\\n            if s[i] == \")\":\\n                if op > 0:\\n                    op -= 1\\n                elif used_on_nonlocked >0 :\\n                    nonlocked += 1\\n                    used_on_nonlocked -= 1\\n                elif nonlocked >0: \\n                    nonlocked -= 1\\n                else:\\n                    return False\\n            else:\\n                op += 1\\n                \\n        \\n        return op == 0 \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        n = len(s)\\n        if n% 2 !=0:return False\\n        nonlocked = 0\\n\\n        op = 0\\n        used_on_nonlocked = 0\\n\\n        for i in range(n):\\n            if locked[i] == \\'0\\':\\n                nonlocked += 1\\n                if op > 0 and nonlocked > 0:\\n                    nonlocked -=1\\n                    op -= 1\\n                    used_on_nonlocked += 1\\n                continue\\n\\n            if s[i] == \")\":\\n                if op > 0:\\n                    op -= 1\\n                elif used_on_nonlocked >0 :\\n                    nonlocked += 1\\n                    used_on_nonlocked -= 1\\n                elif nonlocked >0: \\n                    nonlocked -= 1\\n                else:\\n                    return False\\n            else:\\n                op += 1\\n                \\n        \\n        return op == 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704402,
                "title": "c-o-n-2-pass-algorithm-pretty-simple",
                "content": "This problem seems to be hard at first, but if we just try to think in terms of well formed paraenthesis, the problem kind of turns out to be easy.\\nThink about problem, how can we check if string of parenthesis is welformed ? just use that logic.\\nI am using 3 counters,\\n* `lockedOpenBracket`: Which counts number of `(`, that are locked.\\n* `lockedCloseBracket`: Which counts number of \\')\\', that are locked.\\n* `unlockedBracket`: Which counts number of unlocked brackets, that can be flipped.\\n\\nThere are 3 cases (checking length is odd and 2 for loops):\\n* If the length of input string is odd, return false.\\n* In the first loop, at any given point if I find that number of `lockedClosedBracket` is greater than sum of `lockedOpenBracket` and `unlockedBracket`, then we can conclude that we cannot form wellformed Parenthesis until current point to the left of `)`.\\n* In the second loop, at any given point if I find that number of `lockedOpenBracket` is greater than sum of `lockedClosedBracket` and `unlockedBracket`, then we can conclude that we cannot form wellformed Parenthesis until current point to the right of `(`.\\n\\nPlease upvote if you liked it.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.length(), lckOpen = 0, lckClose = 0, unlck = 0;\\n        bool invalidOpen = false, invalidClosed = false;\\n        for (int i = 0; i < n; i++) {\\n            if (locked[i] == \\'0\\')\\n                unlck++;\\n            else if (s[i] == \\'(\\') {\\n                lckOpen ++;\\n            } else {\\n                lckClose ++;\\n            }\\n            if (lckClose > (unlck + lckOpen)) {\\n                invalidClosed = true;\\n                break;\\n            }\\n        }\\n        lckOpen = 0; lckClose = 0; unlck = 0;\\n        for (int i = n-1; i >= 0; --i) {\\n            if (locked[i] == \\'0\\')\\n                    unlck++;\\n            else if (s[i] == \\'(\\') {\\n                        lckOpen ++;\\n            } else {\\n                    lckClose ++;\\n            }\\n            if (lckOpen > (lckClose + unlck)) {\\n                invalidOpen = true;\\n                break;\\n            }\\n        }\\n        bool invalid = invalidClosed || invalidOpen;\\n        return ((n & 1) == 0 && !invalid);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.length(), lckOpen = 0, lckClose = 0, unlck = 0;\\n        bool invalidOpen = false, invalidClosed = false;\\n        for (int i = 0; i < n; i++) {\\n            if (locked[i] == \\'0\\')\\n                unlck++;\\n            else if (s[i] == \\'(\\') {\\n                lckOpen ++;\\n            } else {\\n                lckClose ++;\\n            }\\n            if (lckClose > (unlck + lckOpen)) {\\n                invalidClosed = true;\\n                break;\\n            }\\n        }\\n        lckOpen = 0; lckClose = 0; unlck = 0;\\n        for (int i = n-1; i >= 0; --i) {\\n            if (locked[i] == \\'0\\')\\n                    unlck++;\\n            else if (s[i] == \\'(\\') {\\n                        lckOpen ++;\\n            } else {\\n                    lckClose ++;\\n            }\\n            if (lckOpen > (lckClose + unlck)) {\\n                invalidOpen = true;\\n                break;\\n            }\\n        }\\n        bool invalid = invalidClosed || invalidOpen;\\n        return ((n & 1) == 0 && !invalid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685159,
                "title": "c-one-pass-nasty-if-else-track-free-count-and-closeable-opens",
                "content": "Keep track of the count we can use for `either` direction, use it once we become negative. Also keep track of how many of the open ones we could theoretically cover `opentake` with our `either`, of course this count increases when we get a new either, and decreases if a regular close bracket comes.\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if (n%2) return false;\\n        \\n        int opentake = 0;\\n        int open = 0, either = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (locked[i] == \\'0\\') {\\n                either++;\\n                if (opentake < open) opentake++;\\n            } else {\\n                if (s[i] == \\'(\\') open++;\\n                else {\\n                    if (--open == -1) {\\n                        opentake = 0;\\n                        if (either >= 1) {\\n                            either--; open++;\\n                        } else {\\n                            return false;\\n                        }\\n                    } else {\\n                        opentake = min(open, opentake);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return open <= opentake;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = s.size();\\n        if (n%2) return false;\\n        \\n        int opentake = 0;\\n        int open = 0, either = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (locked[i] == \\'0\\') {\\n                either++;\\n                if (opentake < open) opentake++;\\n            } else {\\n                if (s[i] == \\'(\\') open++;\\n                else {\\n                    if (--open == -1) {\\n                        opentake = 0;\\n                        if (either >= 1) {\\n                            either--; open++;\\n                        } else {\\n                            return false;\\n                        }\\n                    } else {\\n                        opentake = min(open, opentake);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return open <= opentake;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681315,
                "title": "python-2-pass-o-n-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        sz, openingBrackets, closingBrackets = len(s), 0, 0\\n        if sz % 2:\\n            return False\\n        for i in range(sz):\\n            if locked[i] == \\'0\\':\\n                openingBrackets += 1\\n            elif locked[i] == \\'1\\':\\n                if s[i] == \\'(\\':\\n                    openingBrackets += 1\\n                else:\\n                    closingBrackets += 1\\n            if closingBrackets > openingBrackets:\\n                return False\\n        openingBrackets, closingBrackets = 0, 0\\n        for i in range(sz - 1, -1, -1):\\n            if locked[i] == \\'0\\':\\n                closingBrackets += 1\\n            elif locked[i] == \\'1\\':\\n                if s[i] == \\')\\':\\n                    closingBrackets += 1\\n                else:\\n                    openingBrackets += 1\\n            if closingBrackets < openingBrackets:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        sz, openingBrackets, closingBrackets = len(s), 0, 0\\n        if sz % 2:\\n            return False\\n        for i in range(sz):\\n            if locked[i] == \\'0\\':\\n                openingBrackets += 1\\n            elif locked[i] == \\'1\\':\\n                if s[i] == \\'(\\':\\n                    openingBrackets += 1\\n                else:\\n                    closingBrackets += 1\\n            if closingBrackets > openingBrackets:\\n                return False\\n        openingBrackets, closingBrackets = 0, 0\\n        for i in range(sz - 1, -1, -1):\\n            if locked[i] == \\'0\\':\\n                closingBrackets += 1\\n            elif locked[i] == \\'1\\':\\n                if s[i] == \\')\\':\\n                    closingBrackets += 1\\n                else:\\n                    openingBrackets += 1\\n            if closingBrackets < openingBrackets:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672054,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Two Traversal***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string str, string locked) {\\n        \\n        int n = str.size();\\n        \\n        // if no. of characters are odd then it is not possible to make it valid\\n        \\n        if(n % 2)\\n            return false;\\n        \\n        // check from left, treat unlocked character as \\'(\\'\\n        \\n        int open = 0;\\n        \\n        int close = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(locked[i] == \\'0\\')\\n            {\\n                open++;\\n            }\\n            else if(locked[i] == \\'1\\')\\n            {\\n                if(str[i] == \\'(\\')\\n                {\\n                    open++;\\n                }\\n                else\\n                {\\n                    close++;\\n                }\\n            }\\n            \\n            if(close > open)\\n                return false;\\n        }\\n        \\n        // check from right, treat unlocked character as \\')\\'\\n        \\n        open = 0;\\n        \\n        close = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(locked[i] == \\'0\\')\\n            {\\n                close++;\\n            }\\n            else if(locked[i] == \\'1\\')\\n            {\\n                if(str[i] == \\')\\')\\n                {\\n                    close++;\\n                }\\n                else\\n                {\\n                    open++;\\n                }\\n            }\\n            \\n            if(open > close)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string str, string locked) {\\n        \\n        int n = str.size();\\n        \\n        // if no. of characters are odd then it is not possible to make it valid\\n        \\n        if(n % 2)\\n            return false;\\n        \\n        // check from left, treat unlocked character as \\'(\\'\\n        \\n        int open = 0;\\n        \\n        int close = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(locked[i] == \\'0\\')\\n            {\\n                open++;\\n            }\\n            else if(locked[i] == \\'1\\')\\n            {\\n                if(str[i] == \\'(\\')\\n                {\\n                    open++;\\n                }\\n                else\\n                {\\n                    close++;\\n                }\\n            }\\n            \\n            if(close > open)\\n                return false;\\n        }\\n        \\n        // check from right, treat unlocked character as \\')\\'\\n        \\n        open = 0;\\n        \\n        close = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(locked[i] == \\'0\\')\\n            {\\n                close++;\\n            }\\n            else if(locked[i] == \\'1\\')\\n            {\\n                if(str[i] == \\')\\')\\n                {\\n                    close++;\\n                }\\n                else\\n                {\\n                    open++;\\n                }\\n            }\\n            \\n            if(open > close)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671941,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n    pub fn can_be_valid(s: String, locked: String) -> bool {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let l = locked.chars().collect::<Vec<char>>();\\n\\n        let mut stack = vec![];\\n        let mut set = HashSet::new();\\n\\n        for i in 0..s.len() {\\n            let c = s[i];\\n            if l[i] == \\'1\\' {\\n                if stack.is_empty() {\\n                    stack.push((c, i));\\n                } else {\\n                    let li = stack.len() - 1;\\n                    if c == \\'(\\' {\\n                        stack.push((c,i));\\n                    } else if c == \\')\\' && stack[li].0 == \\'(\\' {\\n                        set.insert(stack[li].1);\\n                        set.insert(i);\\n                        stack.pop();\\n                    } else {\\n                        stack.push((c,i));\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (c,i) in stack {\\n            if c == \\'(\\' {\\n                s[i] = \\'1\\';\\n            } else {\\n                s[i] = \\'2\\';\\n            }\\n        }\\n\\n        let mut memo = vec![];\\n        for i in 0..s.len() {\\n            if !set.contains(&i) {\\n                memo.push(s[i]);\\n            }\\n        }\\n\\n        let mut memo2 = vec![];\\n        for c in memo {\\n            if c == \\'2\\' {\\n                if memo2.is_empty() {\\n                    return false;\\n                }\\n                memo2.pop();\\n            } else {\\n                memo2.push(c);\\n            }\\n        }\\n        let mut memo3 = vec![];\\n        for i in (0..memo2.len()).rev() {\\n            let c = memo2[i];\\n            if c == \\'1\\' {\\n                if memo3.is_empty() {\\n                    return false;\\n                }\\n                memo3.pop();\\n            } else {\\n                memo3.push(c);\\n            }\\n        }\\n        memo3.len() % 2 == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n    pub fn can_be_valid(s: String, locked: String) -> bool {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let l = locked.chars().collect::<Vec<char>>();\\n\\n        let mut stack = vec![];\\n        let mut set = HashSet::new();\\n\\n        for i in 0..s.len() {\\n            let c = s[i];\\n            if l[i] == \\'1\\' {\\n                if stack.is_empty() {\\n                    stack.push((c, i));\\n                } else {\\n                    let li = stack.len() - 1;\\n                    if c == \\'(\\' {\\n                        stack.push((c,i));\\n                    } else if c == \\')\\' && stack[li].0 == \\'(\\' {\\n                        set.insert(stack[li].1);\\n                        set.insert(i);\\n                        stack.pop();\\n                    } else {\\n                        stack.push((c,i));\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (c,i) in stack {\\n            if c == \\'(\\' {\\n                s[i] = \\'1\\';\\n            } else {\\n                s[i] = \\'2\\';\\n            }\\n        }\\n\\n        let mut memo = vec![];\\n        for i in 0..s.len() {\\n            if !set.contains(&i) {\\n                memo.push(s[i]);\\n            }\\n        }\\n\\n        let mut memo2 = vec![];\\n        for c in memo {\\n            if c == \\'2\\' {\\n                if memo2.is_empty() {\\n                    return false;\\n                }\\n                memo2.pop();\\n            } else {\\n                memo2.push(c);\\n            }\\n        }\\n        let mut memo3 = vec![];\\n        for i in (0..memo2.len()).rev() {\\n            let c = memo2[i];\\n            if c == \\'1\\' {\\n                if memo3.is_empty() {\\n                    return false;\\n                }\\n                memo3.pop();\\n            } else {\\n                memo3.push(c);\\n            }\\n        }\\n        memo3.len() % 2 == 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2670969,
                "title": "two-pass-o-n-solution-with-very-easy-to-understand-explanation",
                "content": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)%2 == 1:\\n            return False\\n        #Two pass solution\\n        #Left to right, check if there are enough \"(\" (including the locked==0 ones, that can be changed as we wish) to match \")\". \\n        Number_of_open_brackets = 0\\n        Number_of_closing_brackets = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\' or locked[i] == \\'0\\':\\n                Number_of_open_brackets += 1\\n            else:\\n                Number_of_closing_brackets += 1\\n            if Number_of_closing_brackets > Number_of_open_brackets:\\n                return False\\n        #Right to Left, check if there are enough \")\" (including the locked==0 ones, that can be changed as we wish) to match \"(\".  \\n        Number_of_open_brackets = 0\\n        Number_of_closing_brackets = 0\\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == \\')\\' or locked[i] == \\'0\\':\\n                Number_of_closing_brackets += 1\\n            else:\\n                Number_of_open_brackets += 1\\n            if Number_of_open_brackets > Number_of_closing_brackets:\\n                return False\\n        return True\\n#Need two pass because left to right one pass will not fix edge cases such as \"))((\", 0011. The two ( are apparently waiting to see if on the right side there is enough ) to match them\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s)%2 == 1:\\n            return False\\n        #Two pass solution\\n        #Left to right, check if there are enough \"(\" (including the locked==0 ones, that can be changed as we wish) to match \")\". \\n        Number_of_open_brackets = 0\\n        Number_of_closing_brackets = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\' or locked[i] == \\'0\\':\\n                Number_of_open_brackets += 1\\n            else:\\n                Number_of_closing_brackets += 1\\n            if Number_of_closing_brackets > Number_of_open_brackets:\\n                return False\\n        #Right to Left, check if there are enough \")\" (including the locked==0 ones, that can be changed as we wish) to match \"(\".  \\n        Number_of_open_brackets = 0\\n        Number_of_closing_brackets = 0\\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == \\')\\' or locked[i] == \\'0\\':\\n                Number_of_closing_brackets += 1\\n            else:\\n                Number_of_open_brackets += 1\\n            if Number_of_open_brackets > Number_of_closing_brackets:\\n                return False\\n        return True\\n#Need two pass because left to right one pass will not fix edge cases such as \"))((\", 0011. The two ( are apparently waiting to see if on the right side there is enough ) to match them\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663104,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef canBeValid(self, s: str, l: str) -> bool:\\n\\t\\t\\tif len(s) % 2 == 1: return False\\n\\t\\t\\ttot = op = cl = 0 # tot -> Total variable brackets, op -> Open, cl -> Closed\\n\\t\\t\\tfor i in range(len(s) - 1, -1, -1):\\n\\t\\t\\t\\tif l[i] == \\'0\\': tot += 1\\n\\t\\t\\t\\telif s[i] == \\'(\\': op += 1\\n\\t\\t\\t\\telif s[i] == \\')\\': cl += 1\\n\\t\\t\\t\\tif tot - op + cl < 0: return False\\n\\t\\t\\ttot = op = cl = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif l[i] == \\'0\\': tot += 1\\n\\t\\t\\t\\telif s[i] == \\'(\\': op += 1\\n\\t\\t\\t\\telif s[i] == \\')\\': cl += 1\\n\\t\\t\\t\\tif tot + op - cl < 0: return False \\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef canBeValid(self, s: str, l: str) -> bool:\\n\\t\\t\\tif len(s) % 2 == 1: return False\\n\\t\\t\\ttot = op = cl = 0 # tot -> Total variable brackets, op -> Open, cl -> Closed\\n\\t\\t\\tfor i in range(len(s) - 1, -1, -1):\\n\\t\\t\\t\\tif l[i] == \\'0\\': tot += 1\\n\\t\\t\\t\\telif s[i] == \\'(\\': op += 1\\n\\t\\t\\t\\telif s[i] == \\')\\': cl += 1\\n\\t\\t\\t\\tif tot - op + cl < 0: return False\\n\\t\\t\\ttot = op = cl = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif l[i] == \\'0\\': tot += 1\\n\\t\\t\\t\\telif s[i] == \\'(\\': op += 1\\n\\t\\t\\t\\telif s[i] == \\')\\': cl += 1\\n\\t\\t\\t\\tif tot + op - cl < 0: return False \\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 2648281,
                "title": "simple-java-solution",
                "content": "# Intuition\\nCheck the cases where the paranthesis is valid when validated from left to right and then do the same validation from right to left\\n\\n# Approach\\nIterate from left to right and check if at any point the closes paranthesis is more than that of the open paranthesis. Then. do the same check in reverse to validate that there is open paranthesis without having correponding closed paranthesis.\\n\\n# Complexity\\n- Time complexity:\\nO(n), technically it\\'s O(2n) since there are 2 iterations through the input list\\n\\n- Space complexity:\\nO(1), no additional space is used for the variables to hold the open and closed paranthesis count.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if(s.length() % 2 != 0) {\\n            return false;\\n        }\\n\\n        // check if there\\'s any locked close paranthesis before having the corresponding open paranthesis on its left.\\n        int mustClose = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\')\\' && locked.charAt(i) == \\'1\\') {\\n                mustClose++;\\n                if(mustClose > 0) {\\n                    return false;\\n                }\\n            } else {\\n                mustClose--;\\n            }\\n        }\\n        \\n        // check if there\\'s any locked open paranthesis before having the corresponding close paranthesis on its right.\\n        int mustOpen = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if(s.charAt(i) == \\'(\\' && locked.charAt(i) == \\'1\\') {\\n                mustOpen++;\\n                if(mustOpen > 0) {\\n                    return false;\\n                }\\n            } else {\\n                mustOpen--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if(s.length() % 2 != 0) {\\n            return false;\\n        }\\n\\n        // check if there\\'s any locked close paranthesis before having the corresponding open paranthesis on its left.\\n        int mustClose = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\')\\' && locked.charAt(i) == \\'1\\') {\\n                mustClose++;\\n                if(mustClose > 0) {\\n                    return false;\\n                }\\n            } else {\\n                mustClose--;\\n            }\\n        }\\n        \\n        // check if there\\'s any locked open paranthesis before having the corresponding close paranthesis on its right.\\n        int mustOpen = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if(s.charAt(i) == \\'(\\' && locked.charAt(i) == \\'1\\') {\\n                mustOpen++;\\n                if(mustOpen > 0) {\\n                    return false;\\n                }\\n            } else {\\n                mustOpen--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596010,
                "title": "python3",
                "content": "class Solution:\\n\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        length = len(s)\\n        if length%2:\\n            return False\\n        \\n        open_parenthesis = close_parenthesis = flips_allowed = 0\\n        for i,char in enumerate(s):\\n            if locked[i] == \\'0\\':\\n                flips_allowed+=1\\n            elif char == \\'(\\':\\n                open_parenthesis+=1\\n            elif char == \\')\\':\\n                close_parenthesis+=1\\n            if flips_allowed + open_parenthesis < close_parenthesis:\\n                return False\\n            \\n        open_parenthesis = close_parenthesis = flips_allowed = 0    \\n        for i in reversed(range(length)):\\n            if locked[i] == \\'0\\':\\n                flips_allowed+=1\\n            elif s[i] == \\'(\\':\\n                open_parenthesis+=1\\n            elif s[i] == \\')\\':\\n                close_parenthesis+=1\\n            if flips_allowed + close_parenthesis < open_parenthesis:\\n                return False\\n      \\n        return True",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        length = len(s)\\n        if length%2:\\n            return False\\n        \\n        open_parenthesis = close_parenthesis = flips_allowed = 0\\n        for i,char in enumerate(s):\\n            if locked[i] == \\'0\\':\\n                flips_allowed+=1\\n            elif char == \\'(\\':\\n                open_parenthesis+=1\\n            elif char == \\')\\':\\n                close_parenthesis+=1\\n            if flips_allowed + open_parenthesis < close_parenthesis:\\n                return False\\n            \\n        open_parenthesis = close_parenthesis = flips_allowed = 0    \\n        for i in reversed(range(length)):\\n            if locked[i] == \\'0\\':\\n                flips_allowed+=1\\n            elif s[i] == \\'(\\':\\n                open_parenthesis+=1\\n            elif s[i] == \\')\\':\\n                close_parenthesis+=1\\n            if flips_allowed + close_parenthesis < open_parenthesis:\\n                return False\\n      \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2593333,
                "title": "c-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool canBeValid(const string& s, const string& locked) {\\n        const int n = size(s);\\n        if (n & 1)\\n            return false;\\n        int lo = 0, up = 0;\\n        for (int i = 0; i < n; ++i)\\n            if (\\'0\\' == locked[i])\\n                ++up, lo = max(lo - 1, 0);\\n            else if (\\'(\\' == s[i])\\n                ++lo, ++up;\\n            else if (--up < 0)\\n                return false;\\n            else\\n                lo = max(lo - 1, 0);\\n        return 0 == lo;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool canBeValid(const string& s, const string& locked) {\\n        const int n = size(s);\\n        if (n & 1)\\n            return false;\\n        int lo = 0, up = 0;\\n        for (int i = 0; i < n; ++i)\\n            if (\\'0\\' == locked[i])\\n                ++up, lo = max(lo - 1, 0);\\n            else if (\\'(\\' == s[i])\\n                ++lo, ++up;\\n            else if (--up < 0)\\n                return false;\\n            else\\n                lo = max(lo - 1, 0);\\n        return 0 == lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573028,
                "title": "short-python-single-pass",
                "content": "The variables min_closed and max_closed store the minimum and maximum number of closing parentheses required in the remainder of the string. The maximum becoming negative is absurd, so we return false if this occurs (e.g., \"))\" where the first \\')\\' is locked. Such a string cannot be repaired.)\\n\\n\\n```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        n = len (s)\\n        if n % 2 == 1:\\n            return False\\n        \\n        min_closed = 0\\n        max_closed = 0\\n        \\n        for i, ch in enumerate (s):\\n            if locked[i] == \\'1\\':\\n                if ch == \\'(\\':\\n                    min_closed += 1\\n                    max_closed += 1\\n                else:\\n                    min_closed = max (0, min_closed - 1)\\n                    max_closed -= 1\\n                    \\n                    if max_closed < 0:\\n                        return False\\n                    \\n            else:\\n                min_closed = max (0, min_closed - 1)\\n                max_closed += 1\\n                    \\n        return min_closed == 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        n = len (s)\\n        if n % 2 == 1:\\n            return False\\n        \\n        min_closed = 0\\n        max_closed = 0\\n        \\n        for i, ch in enumerate (s):\\n            if locked[i] == \\'1\\':\\n                if ch == \\'(\\':\\n                    min_closed += 1\\n                    max_closed += 1\\n                else:\\n                    min_closed = max (0, min_closed - 1)\\n                    max_closed -= 1\\n                    \\n                    if max_closed < 0:\\n                        return False\\n                    \\n            else:\\n                min_closed = max (0, min_closed - 1)\\n                max_closed += 1\\n                    \\n        return min_closed == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565640,
                "title": "c-super-short-solution",
                "content": "```\\n    bool canBeValid(string s, string l) {\\n        auto func = [&](char c, bool reverse) {\\n            for(int j = 0, i = 0, count = 0; j < s.size(); j++) {\\n                i = reverse ? s.size()-j-1 : j;\\n                if(l[i] == \\'0\\' || s[i] == c) count++;\\n                else if(--count < 0) return false;\\n            }\\n            return true;\\n        };\\n        return s.size()%2 == 0 && func(\\'(\\', false) && func(\\')\\', true);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool canBeValid(string s, string l) {\\n        auto func = [&](char c, bool reverse) {\\n            for(int j = 0, i = 0, count = 0; j < s.size(); j++) {\\n                i = reverse ? s.size()-j-1 : j;\\n                if(l[i] == \\'0\\' || s[i] == c) count++;\\n                else if(--count < 0) return false;\\n            }\\n            return true;\\n        };\\n        return s.size()%2 == 0 && func(\\'(\\', false) && func(\\')\\', true);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531589,
                "title": "python-one-pass-similiar-to-lc-1249",
                "content": "```\\nclass Solution:\\n    #  similiar as lc1249 two pass solution\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        N = len(s)\\n        if ( N%2 == 1):\\n            return False\\n\\n        max_balance = 0 # max left bracket can be used\\n        min_balance = 0 # min left bracket to be balanced\\n\\n        for i in range(N):\\n            if (locked[i] == \\'1\\'):\\n                if (s[i] == \\'(\\' ):\\n                    min_balance += 1\\n                    max_balance += 1\\n                else:\\n                    min_balance -= 1\\n                    max_balance -= 1\\n                    if (max_balance < 0):\\n                        return False\\n\\n            else:\\n                # locked[i] == \\'0\\'\\n                # can be either ( or ) \\n                max_balance += 1\\n                min_balance -= 1\\n            min_balance = max(0,min_balance)\\n            #print(f\\'max_balance:{max_balance}, min_balance = {min_balance}\\')\\n        return True if (max_balance >=0 and min_balance <=0) else False\\n                \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    #  similiar as lc1249 two pass solution\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        N = len(s)\\n        if ( N%2 == 1):\\n            return False\\n\\n        max_balance = 0 # max left bracket can be used\\n        min_balance = 0 # min left bracket to be balanced\\n\\n        for i in range(N):\\n            if (locked[i] == \\'1\\'):\\n                if (s[i] == \\'(\\' ):\\n                    min_balance += 1\\n                    max_balance += 1\\n                else:\\n                    min_balance -= 1\\n                    max_balance -= 1\\n                    if (max_balance < 0):\\n                        return False\\n\\n            else:\\n                # locked[i] == \\'0\\'\\n                # can be either ( or ) \\n                max_balance += 1\\n                min_balance -= 1\\n            min_balance = max(0,min_balance)\\n            #print(f\\'max_balance:{max_balance}, min_balance = {min_balance}\\')\\n        return True if (max_balance >=0 and min_balance <=0) else False\\n                \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522896,
                "title": "o-n-time-o-1-space-clear-explanation-the-same-as-678",
                "content": "![image](https://assets.leetcode.com/users/images/a461a46a-7f67-4ddb-840b-51f202c71227_1662193509.0184364.png)\\n\\n\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        a, b = 0, 0\\n\\n        for c, o in zip(s, locked):\\n            if c == \\'(\\' and o == \\'1\\':\\n                a, b = a + 1, b + 1\\n            elif c == \\')\\' and o == \\'1\\':\\n                a, b = a - 1, b - 1\\n            else:  # unlocked\\n                a, b = a - 1, b + 1\\n            b < 0 and (b := math.inf)\\n            a < 0 and (a := 0)\\n\\n        return a == 0 and b != math.inf and len(s) % 2 == 0",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/a461a46a-7f67-4ddb-840b-51f202c71227_1662193509.0184364.png)\\n\\n\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        a, b = 0, 0\\n\\n        for c, o in zip(s, locked):\\n            if c == \\'(\\' and o == \\'1\\':\\n                a, b = a + 1, b + 1\\n            elif c == \\')\\' and o == \\'1\\':\\n                a, b = a - 1, b - 1\\n            else:  # unlocked\\n                a, b = a - 1, b + 1\\n            b < 0 and (b := math.inf)\\n            a < 0 and (a := 0)\\n\\n        return a == 0 and b != math.inf and len(s) % 2 == 0",
                "codeTag": "Python3"
            },
            {
                "id": 2484309,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    bool canBeValid(string& s, string& l) {\\n        ll lo = 0, hi = 0, sz=s.length();\\n        if(sz&1){\\n            return false;\\n        }\\n        for (ll i = 0;i < sz;++i) {\\n            if (l[i] == \\'0\\') {\\n                --lo, ++hi;\\n            }\\n            else if (s[i] == \\'(\\') {\\n                ++lo, ++hi;\\n            }\\n            else {\\n                --lo, --hi;\\n            }\\n            if (hi < 0) {\\n                return false;\\n            }\\n            lo = max(lo, 0LL);\\n        }\\n        return (lo == 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    bool canBeValid(string& s, string& l) {\\n        ll lo = 0, hi = 0, sz=s.length();\\n        if(sz&1){\\n            return false;\\n        }\\n        for (ll i = 0;i < sz;++i) {\\n            if (l[i] == \\'0\\') {\\n                --lo, ++hi;\\n            }\\n            else if (s[i] == \\'(\\') {\\n                ++lo, ++hi;\\n            }\\n            else {\\n                --lo, --hi;\\n            }\\n            if (hi < 0) {\\n                return false;\\n            }\\n            lo = max(lo, 0LL);\\n        }\\n        return (lo == 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483072,
                "title": "solution-code-one-pass-time-o-n-space-o-1",
                "content": "**Algorithm**\\nOf course, the length should be even, which is trivial.\\n\\nFrom left to right, we keep track of the difference between the number of \\'(\\' and \\')\\', denoted **Dif**. \\n* If \\'(\\' is encountered, **++Dif**\\n* If \\')\\' is encountered, **--Dif**\\n* If it is unlocked, the character could be freely choosen from \\'(\\' and \\')\\'. **Dif** may have multiple options. As a result, we focus on the possible range of **Dif**, **[Low, Hi]**, where  **Low<=Dif<=Hi**.\\n\\nMoreover, **Dif>=0** is always required to make the scanned prefix **valid**. As a result, **Low>=0** should be satisfied at each step. Be careful,  we assume that **Low>=0** at the beginning of one step. When **Low<0** at the end of step, we increase 2 to **Low**, i.e. **Low+=2**. This would be achieved by flipping some free character from \\')\\' to \\'(\\'. Otherwise, failure is reported.\\n\\n\\n**Performance**\\n```\\nRuntime: 69 ms, faster than 99.72% of C++ online submissions for Check if a Parentheses String Can Be Valid.\\nMemory Usage: 27.2 MB, less than 14.18% of C++ online submissions for Check if a Parentheses String Can Be Valid.\\n```\\n\\n**Codes**\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        // low <= count(\\'(\\',0, k) - count(\\')\\', 0, k) <= hi\\n        int n=s.size(), low=0, hi=0;\\n        const char * c=s.c_str(), * d=locked.c_str();\\n        if(n&1)\\n            return false;\\n        for(int i=0; i<n && low<=hi; ++i) {\\n            if(d[i]==\\'0\\') {\\n                low+=low>0? -1 : 1;\\n                ++hi;\\n            } else {\\n                low+=c[i]==\\'(\\'? 1 : -1;\\n                low+=low<0? 2 : 0;\\n                hi +=c[i]==\\'(\\'? 1 : -1;\\n                \\n            }\\n        }\\n        return low<=hi && !low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nRuntime: 69 ms, faster than 99.72% of C++ online submissions for Check if a Parentheses String Can Be Valid.\\nMemory Usage: 27.2 MB, less than 14.18% of C++ online submissions for Check if a Parentheses String Can Be Valid.\\n```\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        // low <= count(\\'(\\',0, k) - count(\\')\\', 0, k) <= hi\\n        int n=s.size(), low=0, hi=0;\\n        const char * c=s.c_str(), * d=locked.c_str();\\n        if(n&1)\\n            return false;\\n        for(int i=0; i<n && low<=hi; ++i) {\\n            if(d[i]==\\'0\\') {\\n                low+=low>0? -1 : 1;\\n                ++hi;\\n            } else {\\n                low+=c[i]==\\'(\\'? 1 : -1;\\n                low+=low<0? 2 : 0;\\n                hi +=c[i]==\\'(\\'? 1 : -1;\\n                \\n            }\\n        }\\n        return low<=hi && !low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459212,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int maxt = 0, mint = 0;\\n        int n = s.size();\\n\\n        for(int i=0; i<n; i++) {\\n            if(locked[i] == \\'0\\') {\\n                maxt++, mint--;\\n                if(mint < 0)\\n                    mint = 1;\\n            }\\n            else if(s[i] == \\'(\\')\\n                maxt++, mint++;\\n            else {\\n                maxt--, mint--;\\n                if(maxt < 0) \\n                    return false;\\n                if(mint < 0)\\n                    mint = 1;\\n            }\\n        }\\n\\n        return mint == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int maxt = 0, mint = 0;\\n        int n = s.size();\\n\\n        for(int i=0; i<n; i++) {\\n            if(locked[i] == \\'0\\') {\\n                maxt++, mint--;\\n                if(mint < 0)\\n                    mint = 1;\\n            }\\n            else if(s[i] == \\'(\\')\\n                maxt++, mint++;\\n            else {\\n                maxt--, mint--;\\n                if(maxt < 0) \\n                    return false;\\n                if(mint < 0)\\n                    mint = 1;\\n            }\\n        }\\n\\n        return mint == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426371,
                "title": "c-forward-and-backward-paths",
                "content": "```\\npublic class Solution {\\n    \\n    private static bool Left(string s, string locked) {\\n        int open = 0;\\n        int any = 0;\\n        \\n        for (int i = 0; i < s.Length; ++i) \\n            if (locked[i] == \\'0\\') \\n                any += 1;\\n             else if (s[i] == \\')\\') \\n                    if (open > 0)\\n                        open -= 1;\\n                    else {\\n                        if (any-- <= 0)\\n                            return false;\\n                    }\\n             else \\n                 open += 1;\\n        \\n        return open <= any;\\n    }\\n    \\n    private static bool Right(string s, string locked) {\\n        int open = 0;\\n        int any = 0;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (locked[i] == \\'0\\') \\n                any += 1;\\n            else if (s[i] == \\'(\\') \\n                if (open > 0)\\n                    open -= 1;\\n                else {\\n                    if (any-- <= 0)\\n                        return false;\\n                }\\n            else \\n                open += 1;\\n                    \\n        return open <= any;\\n    }\\n    \\n    public bool CanBeValid(string s, string locked) =>\\n        s.Length % 2 == 0 && Left(s, locked) && Right(s, locked);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    private static bool Left(string s, string locked) {\\n        int open = 0;\\n        int any = 0;\\n        \\n        for (int i = 0; i < s.Length; ++i) \\n            if (locked[i] == \\'0\\') \\n                any += 1;\\n             else if (s[i] == \\')\\') \\n                    if (open > 0)\\n                        open -= 1;\\n                    else {\\n                        if (any-- <= 0)\\n                            return false;\\n                    }\\n             else \\n                 open += 1;\\n        \\n        return open <= any;\\n    }\\n    \\n    private static bool Right(string s, string locked) {\\n        int open = 0;\\n        int any = 0;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (locked[i] == \\'0\\') \\n                any += 1;\\n            else if (s[i] == \\'(\\') \\n                if (open > 0)\\n                    open -= 1;\\n                else {\\n                    if (any-- <= 0)\\n                        return false;\\n                }\\n            else \\n                open += 1;\\n                    \\n        return open <= any;\\n    }\\n    \\n    public bool CanBeValid(string s, string locked) =>\\n        s.Length % 2 == 0 && Left(s, locked) && Right(s, locked);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423041,
                "title": "left-to-right-and-right-to-left-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int flip=0;\\n        int open=0,close=0;\\n        if(s.size()%2 != 0)\\n            return false;\\n        //  -->\\n        for(int i=0;i<s.size();i++){\\n            if(locked[i] == \\'0\\')\\n                flip++;\\n            else{\\n                if(s[i]==\\'(\\')\\n                    open++;\\n                else\\n                    close++;\\n            }\\n            \\n            if(flip + open < close)\\n                return false;\\n        }\\n        //  <--\\n        flip=open=close=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(locked[i] == \\'0\\')\\n                flip++;\\n            else{\\n                if(s[i]==\\'(\\')\\n                    open++;\\n                else\\n                    close++;\\n            }\\n            \\n            if(flip + close < open)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int flip=0;\\n        int open=0,close=0;\\n        if(s.size()%2 != 0)\\n            return false;\\n        //  -->\\n        for(int i=0;i<s.size();i++){\\n            if(locked[i] == \\'0\\')\\n                flip++;\\n            else{\\n                if(s[i]==\\'(\\')\\n                    open++;\\n                else\\n                    close++;\\n            }\\n            \\n            if(flip + open < close)\\n                return false;\\n        }\\n        //  <--\\n        flip=open=close=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(locked[i] == \\'0\\')\\n                flip++;\\n            else{\\n                if(s[i]==\\'(\\')\\n                    open++;\\n                else\\n                    close++;\\n            }\\n            \\n            if(flip + close < open)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406873,
                "title": "cpp-o-n-o-1-simplest",
                "content": "This is a basic implementation where you just to need to traverse the array twice. You can see the code below to understand more\\n\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string loc) {\\n        int num = 0;\\n        if(s.size()%2!=0) return false;\\n        for(int i=0;i<s.size();i++){\\n            if(loc[i]==\\'1\\'){\\n                if(s[i]==\\')\\') num--;\\n                if(num<0) return false;\\n                if(s[i]==\\'(\\') num++;\\n            }\\n            else{\\n                num++;\\n            }\\n        }\\n        num = 0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(loc[i]==\\'1\\'){\\n                if(s[i]==\\'(\\') num--;\\n                if(num<0) return false;\\n                if(s[i]==\\')\\') num++;\\n            }\\n            else{\\n                num++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string loc) {\\n        int num = 0;\\n        if(s.size()%2!=0) return false;\\n        for(int i=0;i<s.size();i++){\\n            if(loc[i]==\\'1\\'){\\n                if(s[i]==\\')\\') num--;\\n                if(num<0) return false;\\n                if(s[i]==\\'(\\') num++;\\n            }\\n            else{\\n                num++;\\n            }\\n        }\\n        num = 0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(loc[i]==\\'1\\'){\\n                if(s[i]==\\'(\\') num--;\\n                if(num<0) return false;\\n                if(s[i]==\\')\\') num++;\\n            }\\n            else{\\n                num++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404890,
                "title": "solution-to",
                "content": "class Solution {\\npublic:\\n    bool canBeValid(string s, string _l) {\\n        int cnt[100100]={0},sz=s.size();\\n        stack<int>q,q0;\\n        for(int i = 0;i<sz;i++)\\n        {\\n            if(_l[i]==\\'0\\'){\\n                q.push(i);\\n            }\\n            else{\\n                if(s[i]==\\'(\\'){\\n                    q0.push(i);\\n                }\\n                else{\\n                    if(q0.size())q0.pop();\\n                    else{\\n                        if(q.size())q.pop();\\n                        else return false;\\n                    }\\n                }\\n            }\\n        }\\n        while(!q0.empty())\\n        {\\n            cnt[q0.top()]=-1;\\n            q0.pop();\\n        }\\n        while(!q.empty())\\n        {\\n            cnt[q.top()]=1;\\n            q.pop();\\n        }\\n        for(int i = sz-1;i>=0;i--)\\n        {\\n            cnt[i]+=cnt[i+1];\\n            if(cnt[i]<0)return false;\\n        }\\n        if(cnt[0]&1)return false;\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool canBeValid(string s, string _l) {\\n        int cnt[100100]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2373147,
                "title": "javascript-greedy-method",
                "content": "```\\nvar canBeValid = function (s, locked) {\\n  if (s.length % 2 !== 0) return false;\\n\\n  //   lmin: min unmatched \\'(\\'\\n  //   lmax: max unmatched \\'(\\'\\n  let lmin = 0;\\n  let lmax = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    if (locked[i] === \"1\") {\\n      if (s[i] === \"(\") lmin++, lmax++;\\n      if (s[i] === \")\") lmin--, lmax--;\\n    } else lmin--, lmax++;\\n\\n    // invalid case\\n    if (lmin < 0) lmin += 2;\\n    if (lmax < 0) return false;\\n  }\\n  return lmin === 0;\\n};",
                "solutionTags": [],
                "code": "```\\nvar canBeValid = function (s, locked) {\\n  if (s.length % 2 !== 0) return false;\\n\\n  //   lmin: min unmatched \\'(\\'\\n  //   lmax: max unmatched \\'(\\'\\n  let lmin = 0;\\n  let lmax = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    if (locked[i] === \"1\") {\\n      if (s[i] === \"(\") lmin++, lmax++;\\n      if (s[i] === \")\") lmin--, lmax--;\\n    } else lmin--, lmax++;\\n\\n    // invalid case\\n    if (lmin < 0) lmin += 2;\\n    if (lmax < 0) return false;\\n  }\\n  return lmin === 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2363059,
                "title": "reuse-the-problem-lc-678-valid-parantheses-string-as-it-is",
                "content": "In the problem LC 678 : Valid parantheses string, we were allowed to make changes to the stars, here the unlocked characters behave like stars\\nso whichever character is unlocked, convert it to a star, and pass this converted string to LC 678\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n\\n\\t\\tstack<int> leftBracketStack;\\n\\t\\tstack<int> starStack;\\n\\t\\tint len = s.length();\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (s[i] == \\'(\\') leftBracketStack.push(i);\\n\\t\\t\\telse if (s[i] == \\'*\\') starStack.push(i);\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (leftBracketStack.empty() && starStack.empty()) return false;\\n\\n\\t\\t\\t\\tif (leftBracketStack.size()) leftBracketStack.pop();\\n\\t\\t\\t\\telse starStack.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\twhile (!leftBracketStack.empty() && !starStack.empty()) {\\n\\t\\t\\tint leftBracketIndex = leftBracketStack.top(); leftBracketStack.pop();\\n\\t\\t\\tint starIndex = starStack.top(); starStack.pop();\\n\\t\\t\\tif (leftBracketIndex > starIndex) return false;\\n\\t\\t}\\n\\n\\t\\treturn leftBracketStack.empty();\\n\\n\\n\\t}\\n    bool canBeValid(string s, string locked) {\\n        int len = s.length();\\n        if(len & 1) return false;\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(locked[i] == \\'0\\') s[i] = \\'*\\';\\n        }\\n        \\n        return checkValidString(s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n\\n\\t\\tstack<int> leftBracketStack;\\n\\t\\tstack<int> starStack;\\n\\t\\tint len = s.length();\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (s[i] == \\'(\\') leftBracketStack.push(i);\\n\\t\\t\\telse if (s[i] == \\'*\\') starStack.push(i);\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (leftBracketStack.empty() && starStack.empty()) return false;\\n\\n\\t\\t\\t\\tif (leftBracketStack.size()) leftBracketStack.pop();\\n\\t\\t\\t\\telse starStack.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\twhile (!leftBracketStack.empty() && !starStack.empty()) {\\n\\t\\t\\tint leftBracketIndex = leftBracketStack.top(); leftBracketStack.pop();\\n\\t\\t\\tint starIndex = starStack.top(); starStack.pop();\\n\\t\\t\\tif (leftBracketIndex > starIndex) return false;\\n\\t\\t}\\n\\n\\t\\treturn leftBracketStack.empty();\\n\\n\\n\\t}\\n    bool canBeValid(string s, string locked) {\\n        int len = s.length();\\n        if(len & 1) return false;\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(locked[i] == \\'0\\') s[i] = \\'*\\';\\n        }\\n        \\n        return checkValidString(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356617,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s) % 2 == 1: return False\\n        \\n        def helper(p, ss, ll):\\n            num = 0\\n\\n            for i in range(len(ss)):\\n                if ss[i] == p and ll[i] == \\'1\\':\\n                    num += 1\\n                    if num > (i + 1) // 2: return False\\n                        \\n            return True\\n        \\n        return helper(\\')\\', s, locked) and helper(\\'(\\', s[::-1], locked[::-1])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        if len(s) % 2 == 1: return False\\n        \\n        def helper(p, ss, ll):\\n            num = 0\\n\\n            for i in range(len(ss)):\\n                if ss[i] == p and ll[i] == \\'1\\':\\n                    num += 1\\n                    if num > (i + 1) // 2: return False\\n                        \\n            return True\\n        \\n        return helper(\\')\\', s, locked) and helper(\\'(\\', s[::-1], locked[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 2323803,
                "title": "any-clue-if-this-code-can-be-made-to-work",
                "content": "Please let me know if this code can be made to work \\n\\n```\\n/**\\n * @param {string} s\\n * @param {string} locked\\n * @return {boolean}\\n */\\nconst canBeValid = (s, locked) => {\\n    let stack = [];\\n    \\n    let ptr = 0;\\n    \\n    if( s.length % 2 !== 0 ) return false\\n    \\n    while( ptr < s.length ) {\\n        if( s[ptr] === \\'(\\') stack.push(\\')\\');\\n        \\n        else {\\n            if( s[ptr] !== stack.pop() ) {\\n                if( locked[ptr] === 1 ) return false\\n            }else stack.pop()\\n        }\\n        \\n        console.log(stack);\\n        ptr++;\\n    }\\n    \\n    return stack.length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} locked\\n * @return {boolean}\\n */\\nconst canBeValid = (s, locked) => {\\n    let stack = [];\\n    \\n    let ptr = 0;\\n    \\n    if( s.length % 2 !== 0 ) return false\\n    \\n    while( ptr < s.length ) {\\n        if( s[ptr] === \\'(\\') stack.push(\\')\\');\\n        \\n        else {\\n            if( s[ptr] !== stack.pop() ) {\\n                if( locked[ptr] === 1 ) return false\\n            }else stack.pop()\\n        }\\n        \\n        console.log(stack);\\n        ptr++;\\n    }\\n    \\n    return stack.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2304733,
                "title": "o-1-space-o-n-time-one-pass-python-with-comment",
                "content": "```\\nclass Solution:\\n    #2116\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        start, end = 0, 0#start is lower limit of unmatched \"(\", end is upper limit of unmatched \"(\"\\n        for i in range(len(s)):\\n            if locked[i] == \"1\":\\n                if s[i] == \"(\":\\n                    start += 1#locked \"(\", so unmatched \"(\" number increases by 1\\n                    end += 1\\n                else:\\n                    start -= 1#locked \")\", so unmatched \"(\" number decreases by 1\\n                    end -= 1\\n                    if end < 0:#to many \")\", not enough \"(\" to match\\n                        return False\\n                    if start < 0: #the number of unmatched \"(\" >= 0\\n                        start %= 2\\n            else:#unlocked\\n                end += 1 #it could be \"(\"\\n                if start == 0:\\n                    start += 1#not enough \"(\" to match a new \")\", has to be a \"(\"\\n                else:\\n                    start -= 1 #or it could be \")\"\\n        return start == 0 #start > 0 means some \"(\" haven\\'t be matched\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    #2116\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        start, end = 0, 0#start is lower limit of unmatched \"(\", end is upper limit of unmatched \"(\"\\n        for i in range(len(s)):\\n            if locked[i] == \"1\":\\n                if s[i] == \"(\":\\n                    start += 1#locked \"(\", so unmatched \"(\" number increases by 1\\n                    end += 1\\n                else:\\n                    start -= 1#locked \")\", so unmatched \"(\" number decreases by 1\\n                    end -= 1\\n                    if end < 0:#to many \")\", not enough \"(\" to match\\n                        return False\\n                    if start < 0: #the number of unmatched \"(\" >= 0\\n                        start %= 2\\n            else:#unlocked\\n                end += 1 #it could be \"(\"\\n                if start == 0:\\n                    start += 1#not enough \"(\" to match a new \")\", has to be a \"(\"\\n                else:\\n                    start -= 1 #or it could be \")\"\\n        return start == 0 #start > 0 means some \"(\" haven\\'t be matched\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274118,
                "title": "rust-solution-with-two-scan",
                "content": "In each of the scans, we keep tracking of the \\n1) balance: # of left parentheses - # of right parentheses seen so far; \\n2) available: # of positions that could go either way seen so far.\\n\\nWhenever the balance becomes -1, we will convert one of the available positions to adjust it. Return false if there are no available positions when needed.\\n~~~\\nimpl Solution {\\n    pub fn can_be_valid(s: String, locked: String) -> bool {\\n        if (s.len() % 2 != 0) { return false }\\n        Self::scan(&s, &locked, \\'(\\', \\')\\') && Self::scan(&s, &locked, \\')\\', \\'(\\')\\n    }\\n    \\n    fn scan(s: &String, locked: &String, ch1: char, ch2: char) -> bool {\\n        let s = if ch1 == \\'(\\' { s.chars().collect::<Vec<char>>() } \\n                else { s.chars().rev().collect::<Vec<char>>() };\\n        \\n        let locked = if ch1 == \\'(\\' { locked.chars().collect::<Vec<char>>() }\\n                     else { locked.chars().rev().collect::<Vec<char>>() };\\n        \\n        let (mut balance, mut available) = (0i32, 0i32);\\n        \\n        for i in 0..s.len() {\\n            if locked[i] == \\'0\\' {\\n                available += 1;\\n                continue;\\n            }\\n            if s[i] == ch1 { balance += 1; }\\n            if s[i] == ch2 { balance -= 1; }\\n            if balance >= 0 { continue; }\\n            \\n            if available == 0 { return false }\\n            available -= 1;\\n            balance += 1;\\n        }\\n        \\n        true\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "In each of the scans, we keep tracking of the \\n1) balance: # of left parentheses - # of right parentheses seen so far; \\n2) available: # of positions that could go either way seen so far.\\n\\nWhenever the balance becomes -1, we will convert one of the available positions to adjust it. Return false if there are no available positions when needed.\\n~~~\\nimpl Solution {\\n    pub fn can_be_valid(s: String, locked: String) -> bool {\\n        if (s.len() % 2 != 0) { return false }\\n        Self::scan(&s, &locked, \\'(\\', \\')\\') && Self::scan(&s, &locked, \\')\\', \\'(\\')\\n    }\\n    \\n    fn scan(s: &String, locked: &String, ch1: char, ch2: char) -> bool {\\n        let s = if ch1 == \\'(\\' { s.chars().collect::<Vec<char>>() } \\n                else { s.chars().rev().collect::<Vec<char>>() };\\n        \\n        let locked = if ch1 == \\'(\\' { locked.chars().collect::<Vec<char>>() }\\n                     else { locked.chars().rev().collect::<Vec<char>>() };\\n        \\n        let (mut balance, mut available) = (0i32, 0i32);\\n        \\n        for i in 0..s.len() {\\n            if locked[i] == \\'0\\' {\\n                available += 1;\\n                continue;\\n            }\\n            if s[i] == ch1 { balance += 1; }\\n            if s[i] == ch2 { balance -= 1; }\\n            if balance >= 0 { continue; }\\n            \\n            if available == 0 { return false }\\n            available -= 1;\\n            balance += 1;\\n        }\\n        \\n        true\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2273760,
                "title": "java-greedy",
                "content": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if(s.length()%2==1){\\n            return false;\\n        }\\n        int counter = 0;\\n        for(int i=0;i<s.length();i++){\\n            char sign = s.charAt(i);\\n            char num = locked.charAt(i);\\n            if(num==\\'1\\' && sign==\\')\\'){\\n                counter--;\\n                if(counter<0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                counter++;\\n            }\\n        }\\n        counter = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            char sign = s.charAt(i);\\n            char num = locked.charAt(i);\\n            if(sign==\\'(\\' && num==\\'1\\'){\\n                counter--;\\n                if(counter<0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                counter++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if(s.length()%2==1){\\n            return false;\\n        }\\n        int counter = 0;\\n        for(int i=0;i<s.length();i++){\\n            char sign = s.charAt(i);\\n            char num = locked.charAt(i);\\n            if(num==\\'1\\' && sign==\\')\\'){\\n                counter--;\\n                if(counter<0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                counter++;\\n            }\\n        }\\n        counter = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            char sign = s.charAt(i);\\n            char num = locked.charAt(i);\\n            if(sign==\\'(\\' && num==\\'1\\'){\\n                counter--;\\n                if(counter<0){\\n                    return false;\\n                }\\n            }\\n            else{\\n                counter++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256041,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func canBeValid(_ s: String, _ locked: String) -> Bool {\\n        guard s.count % 2 == 0 else {return false}\\n        let arr_s = Array(s), arr_locked = Array(locked)\\n        var balance = 0\\n        //forward\\n        for i in 0..<arr_s.count {\\n            if arr_s[i] == \")\" && arr_locked[i] == \"1\" {\\n                balance -= 1\\n            }else{\\n                balance += 1\\n            }\\n            if balance < 0 {return false}\\n        }\\n        \\n        //backward\\n        balance = 0\\n        for i in (0..<arr_s.count).reversed() {\\n            if arr_s[i] == \"(\" && arr_locked[i] == \"1\" {\\n                balance -= 1\\n            }else{\\n                balance += 1\\n            }\\n            if balance < 0 {return false}\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func canBeValid(_ s: String, _ locked: String) -> Bool {\\n        guard s.count % 2 == 0 else {return false}\\n        let arr_s = Array(s), arr_locked = Array(locked)\\n        var balance = 0\\n        //forward\\n        for i in 0..<arr_s.count {\\n            if arr_s[i] == \")\" && arr_locked[i] == \"1\" {\\n                balance -= 1\\n            }else{\\n                balance += 1\\n            }\\n            if balance < 0 {return false}\\n        }\\n        \\n        //backward\\n        balance = 0\\n        for i in (0..<arr_s.count).reversed() {\\n            if arr_s[i] == \"(\" && arr_locked[i] == \"1\" {\\n                balance -= 1\\n            }else{\\n                balance += 1\\n            }\\n            if balance < 0 {return false}\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235836,
                "title": "c-o-n-two-pass-easy-to-understand",
                "content": "//code\\n\\n\\'\\'\\'\\n\\n\\n\\n ```\\nclass Solution {\\n public:\\n    bool canBeValid(string s, string locked) {\\n        if(s.size()%2==1) return false;\\n        int balance=0;\\n        int flippable=0;\\n        \\n        //iterating left to right\\n        for(int i=0;i<s.size();i++){\\n            if(locked[i]==\\'0\\'){\\n                flippable++;\\n            }else{\\n                if(s[i]==\\'(\\'){\\n                    balance++;\\n                }else{\\n                    balance--;\\n                }\\n            }\\n            if(balance+flippable<0){\\n                return false;\\n            }\\n        }\\n        if(balance>flippable){\\n            return false;\\n        }\\n        //reinitiating the variables\\n        balance=0;flippable=0;\\n        \\n        //iterating right to left\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(locked[i]==\\'0\\'){\\n                flippable++;\\n            }else{\\n                if(s[i]==\\')\\'){\\n                    balance++;\\n                }else{\\n                    balance--;\\n                }\\n            }\\n            if(balance+flippable<0){\\n                return false;\\n            }\\n        }\\n        if(balance>flippable){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n    bool canBeValid(string s, string locked) {\\n        if(s.size()%2==1) return false;\\n        int balance=0;\\n        int flippable=0;\\n        \\n        //iterating left to right\\n        for(int i=0;i<s.size();i++){\\n            if(locked[i]==\\'0\\'){\\n                flippable++;\\n            }else{\\n                if(s[i]==\\'(\\'){\\n                    balance++;\\n                }else{\\n                    balance--;\\n                }\\n            }\\n            if(balance+flippable<0){\\n                return false;\\n            }\\n        }\\n        if(balance>flippable){\\n            return false;\\n        }\\n        //reinitiating the variables\\n        balance=0;flippable=0;\\n        \\n        //iterating right to left\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(locked[i]==\\'0\\'){\\n                flippable++;\\n            }else{\\n                if(s[i]==\\')\\'){\\n                    balance++;\\n                }else{\\n                    balance--;\\n                }\\n            }\\n            if(balance+flippable<0){\\n                return false;\\n            }\\n        }\\n        if(balance>flippable){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219552,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = locked.size();\\n        if(n&1) return false;\\n        int balance = 0;\\n        for(int i=0;i<n;++i){\\n            if(locked[i]==\\'0\\' || s[i]==\\'(\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        balance =0;\\n        for(int i=n-1;i>=0;--i){\\n            if(locked[i]==\\'0\\' || s[i]==\\')\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n = locked.size();\\n        if(n&1) return false;\\n        int balance = 0;\\n        for(int i=0;i<n;++i){\\n            if(locked[i]==\\'0\\' || s[i]==\\'(\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        balance =0;\\n        for(int i=n-1;i>=0;--i){\\n            if(locked[i]==\\'0\\' || s[i]==\\')\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210547,
                "title": "cpp-two-pass-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int o=0,c=0,oz=0,cz=0,i=0;\\n        if(s.size()%2==1)return false;\\n        for(auto&p:s)\\n        {\\n            if(p==\\'(\\')\\n            {\\n                o++;\\n                if(locked[i]==\\'0\\')oz++;\\n            }\\n            else\\n            {\\n                c++;\\n                if(locked[i]==\\'0\\')cz++;\\n            }\\n            if(c>o)\\n            {\\n                if(cz==0)return false;\\n                o++;\\n                c--;\\n                cz--;\\n            }\\n            i++;\\n        }\\n        reverse(s.begin(),s.end());\\n        o=0,c=0,oz=0,cz=0,i=s.size()-1;\\n        for(auto&p:s)\\n        {\\n            if(p==\\'(\\')\\n            {\\n                o++;\\n                if(locked[i]==\\'0\\')oz++;\\n            }\\n            else\\n            {\\n                c++;\\n                if(locked[i]==\\'0\\')cz++;\\n            }\\n            if(o>c)\\n            {\\n                if(oz==0)return false;\\n                o--;\\n                oz--;\\n                c++;\\n            }\\n            i--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int o=0,c=0,oz=0,cz=0,i=0;\\n        if(s.size()%2==1)return false;\\n        for(auto&p:s)\\n        {\\n            if(p==\\'(\\')\\n            {\\n                o++;\\n                if(locked[i]==\\'0\\')oz++;\\n            }\\n            else\\n            {\\n                c++;\\n                if(locked[i]==\\'0\\')cz++;\\n            }\\n            if(c>o)\\n            {\\n                if(cz==0)return false;\\n                o++;\\n                c--;\\n                cz--;\\n            }\\n            i++;\\n        }\\n        reverse(s.begin(),s.end());\\n        o=0,c=0,oz=0,cz=0,i=s.size()-1;\\n        for(auto&p:s)\\n        {\\n            if(p==\\'(\\')\\n            {\\n                o++;\\n                if(locked[i]==\\'0\\')oz++;\\n            }\\n            else\\n            {\\n                c++;\\n                if(locked[i]==\\'0\\')cz++;\\n            }\\n            if(o>c)\\n            {\\n                if(oz==0)return false;\\n                o--;\\n                oz--;\\n                c++;\\n            }\\n            i--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171309,
                "title": "o-n-2-pass-easy-to-follow-solution-that-follows-the-hints",
                "content": "Similar to Valid Parenthesis String\\n```\\nclass Solution {\\n    public boolean canBeValid(String string, String locked) {\\n        int unlockedIndexes = 0;\\n        int lockedStarters = 0;\\n        int length = string.length();\\n        if (length % 2 == 1) {\\n            return false;\\n        }\\n        for (int i = 0; i < length; i++) {\\n            char ch = string.charAt(i);\\n            if (locked.charAt(i) == \\'0\\') {\\n                unlockedIndexes++;\\n            } else {\\n                if (ch == \\'(\\') {\\n                    lockedStarters++;\\n                } else if (lockedStarters > 0) {\\n                    lockedStarters--;\\n                } else if (unlockedIndexes > 0) {\\n                    unlockedIndexes--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        unlockedIndexes = 0;\\n        int lockedClosers = 0;\\n        for (int i = length - 1; i >= 0; i--)  {\\n            char ch = string.charAt(i);\\n            if (locked.charAt(i) == \\'0\\') {\\n                unlockedIndexes++;\\n            } else {\\n                if (ch == \\')\\') {\\n                    lockedClosers++;\\n                } else if (lockedClosers > 0) {\\n                    lockedClosers--;\\n                } else if (unlockedIndexes > 0) {\\n                    unlockedIndexes--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeValid(String string, String locked) {\\n        int unlockedIndexes = 0;\\n        int lockedStarters = 0;\\n        int length = string.length();\\n        if (length % 2 == 1) {\\n            return false;\\n        }\\n        for (int i = 0; i < length; i++) {\\n            char ch = string.charAt(i);\\n            if (locked.charAt(i) == \\'0\\') {\\n                unlockedIndexes++;\\n            } else {\\n                if (ch == \\'(\\') {\\n                    lockedStarters++;\\n                } else if (lockedStarters > 0) {\\n                    lockedStarters--;\\n                } else if (unlockedIndexes > 0) {\\n                    unlockedIndexes--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        unlockedIndexes = 0;\\n        int lockedClosers = 0;\\n        for (int i = length - 1; i >= 0; i--)  {\\n            char ch = string.charAt(i);\\n            if (locked.charAt(i) == \\'0\\') {\\n                unlockedIndexes++;\\n            } else {\\n                if (ch == \\')\\') {\\n                    lockedClosers++;\\n                } else if (lockedClosers > 0) {\\n                    lockedClosers--;\\n                } else if (unlockedIndexes > 0) {\\n                    unlockedIndexes--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163268,
                "title": "c-o-n-time-o-1-space-keep-the-number-of-flexible-brackets",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int pos = 0; \\n        int flip = 0; \\n        int neg = 0; \\n        // what\\'s the minimum of i; \\n        int iMax = 0; \\n        for (int i = 0; i <s.size(); i++){\\n            if (pos + flip < neg) return false; \\n            iMax = max (iMax, neg + flip - pos); \\n            if (locked[i] == \\'1\\'){\\n                if (s[i] == \\'(\\') pos++; \\n                else neg++; \\n            }\\n            else {\\n                flip++; \\n            }\\n        }\\n        // finally; if \\n        return (flip + neg - pos)%2 == 0 && (flip + neg - pos)>=iMax && (flip + neg - pos)<= 2 * flip; \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int pos = 0; \\n        int flip = 0; \\n        int neg = 0; \\n        // what\\'s the minimum of i; \\n        int iMax = 0; \\n        for (int i = 0; i <s.size(); i++){\\n            if (pos + flip < neg) return false; \\n            iMax = max (iMax, neg + flip - pos); \\n            if (locked[i] == \\'1\\'){\\n                if (s[i] == \\'(\\') pos++; \\n                else neg++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2129620,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string l) {\\n        int n=s.length();\\n        int c=0;\\n        if(n%2)\\n            return false;\\n        for(int i=0;i<s.length();i++)       //checking for locked \\')\\'\\n        {\\n            if(l[i]==\\'0\\' || s[i]==\\'(\\')\\n                c++;\\n            else if(l[i]==\\'1\\' && s[i]==\\')\\')\\n            {\\n                c--;\\n                if(c<0)\\n                    return false;\\n            }\\n        }\\n        c=0;\\n        for(int i=n-1;i>=0;i--)              // checking for locked \\'(\\'\\n        {\\n            if(l[i]==\\'0\\' || s[i]==\\')\\')\\n                c++;\\n            else if(l[i]==\\'1\\' && s[i]==\\'(\\')\\n            {\\n                c--;\\n                if(c<0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canBeValid(string s, string l) {\\n        int n=s.length();\\n        int c=0;\\n        if(n%2)\\n            return false;\\n        for(int i=0;i<s.length();i++)       //checking for locked \\')\\'\\n        {\\n            if(l[i]==\\'0\\' || s[i]==\\'(\\')\\n                c++;\\n            else if(l[i]==\\'1\\' && s[i]==\\')\\')\\n            {\\n                c--;\\n                if(c<0)\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2126102,
                "title": "c-greedy-time-o-n-and-space-o-1",
                "content": "**Similar to Leetcode 678 [https://leetcode.com/problems/valid-parenthesis-string/](http://)**\\n```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n=s.size();\\n        if(n%2==1){\\n            return false;\\n        }\\n\\n        int cmin=0,cmax=0;\\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'1\\'){\\n                if(s[i]==\\')\\'){\\n                    cmin--;\\n                    cmax--;\\n                }else{\\n                    cmin++;\\n                    cmax++;\\n                }\\n            }else{\\n                cmin--;\\n                cmax++;\\n            }\\n            if(cmax<0)\\n                return false;\\n            \\n            cmin=max(0,cmin);\\n        }\\n        \\n        return cmin==0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        int n=s.size();\\n        if(n%2==1){\\n            return false;\\n        }\\n\\n        int cmin=0,cmax=0;\\n        for(int i=0;i<n;i++){\\n            if(locked[i]==\\'1\\'){\\n                if(s[i]==\\')\\'){\\n                    cmin--;\\n                    cmax--;\\n                }else{\\n                    cmin++;\\n                    cmax++;\\n                }\\n            }else{\\n                cmin--;\\n                cmax++;\\n            }\\n            if(cmax<0)\\n                return false;\\n            \\n            cmin=max(0,cmin);\\n        }\\n        \\n        return cmin==0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098269,
                "title": "same-as-valid-parenthesis-string-more-intuitive",
                "content": "\\nThe question here is to only check if the string can be changed to make it valid. The leetcode question https://leetcode.com/problems/valid-parenthesis-string/ exaclty solves the problem. \\nThe only change required is: treat unlocked characters as * ( they can be changed). \\nVideo for explanation: https://www.youtube.com/watch?v=KuE_Cn3xhxI&t=329\\nHere is the code: \\n```\\n/**\\nhttps://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/\\n*/\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> open;\\n        stack<int> star;\\n        for(int i=0; i<s.size(); i++){\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                open.push(i);\\n            if(c==\\'*\\')\\n                star.push(i);\\n            if(c==\\')\\'){\\n                if(!open.empty())\\n                    open.pop();\\n                else if(!star.empty())\\n                    star.pop();\\n                else\\n                    return false;\\n                    \\n            }\\n        }\\n        if(!open.empty() && !star.empty()){\\n            while(!open.empty() && !star.empty()){\\n                int oi=open.top();\\n                int stari=star.top(); //this piece is critical, matching stars against open brackets.\\n                if(stari>oi){\\n                        star.pop();\\n                        open.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(open.empty() && !star.empty()){\\n            int count=star.size();\\n            if(count%2==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        if(open.empty() && star.empty()){\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    bool canBeValid(string s, string locked) {\\n        string star_string=\"\";\\n        for(int i=0;i<s.size(); i++){\\n            if(locked[i]==\\'0\\'){\\n                star_string.push_back(\\'*\\');\\n            }else{\\n                star_string.push_back(s[i]);\\n            }\\n        }\\n        cout<<\"changed string =\"<<star_string<<endl;\\n        bool ans=checkValidString(star_string);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\nhttps://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/\\n*/\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> open;\\n        stack<int> star;\\n        for(int i=0; i<s.size(); i++){\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                open.push(i);\\n            if(c==\\'*\\')\\n                star.push(i);\\n            if(c==\\')\\'){\\n                if(!open.empty())\\n                    open.pop();\\n                else if(!star.empty())\\n                    star.pop();\\n                else\\n                    return false;\\n                    \\n            }\\n        }\\n        if(!open.empty() && !star.empty()){\\n            while(!open.empty() && !star.empty()){\\n                int oi=open.top();\\n                int stari=star.top(); //this piece is critical, matching stars against open brackets.\\n                if(stari>oi){\\n                        star.pop();\\n                        open.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(open.empty() && !star.empty()){\\n            int count=star.size();\\n            if(count%2==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        if(open.empty() && star.empty()){\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    bool canBeValid(string s, string locked) {\\n        string star_string=\"\";\\n        for(int i=0;i<s.size(); i++){\\n            if(locked[i]==\\'0\\'){\\n                star_string.push_back(\\'*\\');\\n            }else{\\n                star_string.push_back(s[i]);\\n            }\\n        }\\n        cout<<\"changed string =\"<<star_string<<endl;\\n        bool ans=checkValidString(star_string);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2056347,
                "title": "implementation-using-2-stacks-tc-o-n-sc-o-2n",
                "content": "Logic is same as : https://leetcode.com/problems/valid-parenthesis-string/\\nTC : O(N)\\nSC : O(2N) \\n2 Stacks : \\n\\t**unlocked** : Contains all the indices which change\\n\\t**lock** : Contains all the Opening Locked indices\\n```\\nclass Solution2 {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        // Odd length Not Possible as s only contains (,)\\n        int n = s.size();\\n        if(n & 1)    \\n            return false;\\n        \\n        stack<int> unlocked,lock;\\n        \\n        for(int i=0;i<n;i++){\\n            if(locked[i] == \\'0\\')\\n                unlocked.push(i);\\n            else if(s[i] == \\'(\\')\\n                lock.push(i);\\n            else{ // locked closing brace\\n                \\n                if(!lock.empty())\\n                    lock.pop();\\n                else if(!unlocked.empty())\\n                    unlocked.pop();\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        // cout << lock.size() <<\" \"<<unlocked.size() << endl;\\n        \\n        while(!lock.empty()){\\n            if(unlocked.empty())\\n                return false;\\n            if(lock.top() < unlocked.top()){\\n                lock.pop();\\n                unlocked.pop();\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution2 {\\npublic:\\n    bool canBeValid(string s, string locked) {\\n        // Odd length Not Possible as s only contains (,)\\n        int n = s.size();\\n        if(n & 1)    \\n            return false;\\n        \\n        stack<int> unlocked,lock;\\n        \\n        for(int i=0;i<n;i++){\\n            if(locked[i] == \\'0\\')\\n                unlocked.push(i);\\n            else if(s[i] == \\'(\\')\\n                lock.push(i);\\n            else{ // locked closing brace\\n                \\n                if(!lock.empty())\\n                    lock.pop();\\n                else if(!unlocked.empty())\\n                    unlocked.pop();\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        // cout << lock.size() <<\" \"<<unlocked.size() << endl;\\n        \\n        while(!lock.empty()){\\n            if(unlocked.empty())\\n                return false;\\n            if(lock.top() < unlocked.top()){\\n                lock.pop();\\n                unlocked.pop();\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1995603,
                "title": "python-single-iteration",
                "content": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        n = len(s)\\n        if n % 2 == 1:\\n            return False\\n        \\n        number_open, number_options, number_unlocked = 0, 0, 0\\n        for i in range(len(s)):\\n            if locked[i] == \\'0\\':\\n                if number_open > 0:\\n                    number_options += 1\\n                    number_open -= 1\\n                else:\\n                    number_unlocked += 1\\n            else:    \\n                if s[i] == \\'(\\':\\n                    number_open += 1\\n                else:\\n                    if number_open > 0:\\n                        number_open -= 1\\n                    elif number_options > 0:\\n                        number_options -= 1\\n                        number_unlocked += 1\\n                    elif number_unlocked > 0:\\n                        number_unlocked -= 1\\n                    else:\\n                        return False\\n                \\n        if number_open > 0:\\n            return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def canBeValid(self, s: str, locked: str) -> bool:\\n        n = len(s)\\n        if n % 2 == 1:\\n            return False\\n        \\n        number_open, number_options, number_unlocked = 0, 0, 0\\n        for i in range(len(s)):\\n            if locked[i] == \\'0\\':\\n                if number_open > 0:\\n                    number_options += 1\\n                    number_open -= 1\\n                else:\\n                    number_unlocked += 1\\n            else:    \\n                if s[i] == \\'(\\':\\n                    number_open += 1\\n                else:\\n                    if number_open > 0:\\n                        number_open -= 1\\n                    elif number_options > 0:\\n                        number_options -= 1\\n                        number_unlocked += 1\\n                    elif number_unlocked > 0:\\n                        number_unlocked -= 1\\n                    else:\\n                        return False\\n                \\n        if number_open > 0:\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953471,
                "title": "2116-check-if-a-parentheses-string-can-be-valid-c-fast-solution-using-two-stack",
                "content": "This problem is similar to [678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/) problem (almost same).\\nextra condition is if the length of string is odd then we can just return false;\\n\\ntake two stacks.\\nfirst for storing the index of strings that are unlocked and other for storing locked string.\\ncase1-> if curr char is unlocked ( i.e. locked at this position is \\'0\\' ) then simply push it into the second stack.\\nnow other two cases is for locked char \\ncase 2-> if curr char is \\'(\\', then push it into the balance stack\\ncase 3-> if curr char if \\')\\', then we can pop from the first stack if last char of stack is \\'(\\' (essentially we are storing indexes in the stack ), by the way we can just check the size of first stack as it only contains opening bracket at any moment of time. if size > 0 then possible else we can check if we have any unlocked bracket present in the second stack that we can use right now to balance.  if we do the we can just use it as an \\'(\\' else return false.\\n\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "This problem is similar to [678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/) problem (almost same).\\nextra condition is if the length of string is odd then we can just return false;\\n\\ntake two stacks.\\nfirst for storing the index of strings that are unlocked and other for storing locked string.\\ncase1-> if curr char is unlocked ( i.e. locked at this position is \\'0\\' ) then simply push it into the second stack.\\nnow other two cases is for locked char \\ncase 2-> if curr char is \\'(\\', then push it into the balance stack\\ncase 3-> if curr char if \\')\\', then we can pop from the first stack if last char of stack is \\'(\\' (essentially we are storing indexes in the stack ), by the way we can just check the size of first stack as it only contains opening bracket at any moment of time. if size > 0 then possible else we can check if we have any unlocked bracket present in the second stack that we can use right now to balance.  if we do the we can just use it as an \\'(\\' else return false.\\n\\n",
                "codeTag": "Unknown"
            }
        ],
        "discussions": []
    }
]