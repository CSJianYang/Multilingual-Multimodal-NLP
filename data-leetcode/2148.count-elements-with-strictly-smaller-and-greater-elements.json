[
    {
        "title": "Count Elements With Strictly Smaller and Greater Elements ",
        "question_content": "Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.\n&nbsp;\nExample 1:\n\nInput: nums = [11,7,2,15]\nOutput: 2\nExplanation: The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\nElement 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\nIn total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.\n\nExample 2:\n\nInput: nums = [-3,3,3,90]\nOutput: 2\nExplanation: The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.\nSince there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t-105 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 1711307,
                "title": "c-o-n-time-o-1-space-100-efficient-3-approaches",
                "content": "# 3 Approaches Discussed \\u26A1\\n## 1. Min Max using Multiple passes [Easy Understanding]\\nCredits to [Apurva Sharma (Github)](https://github.com/Apurva-tech)\\n## Algorithm \\n* Find the max and min element of array, store in M and m variables\\n* Compare each element with Min and Max and count while iterating through array in O(N) time\\n* Return the count as result. \\n* **Space Complexity:** O(1) \\n* **Time Complexity:** O(N) \\n\\n## Intuition: \\nIf you find the max and min of complete array, each element compared will satisfy the condition that needs to checked.\\n\\n```\\nArray = [11, 7, 2, 15]\\nMax = 15 \\nMin = 2\\n\\nFor iteration i = 0: check if (11>2 && 11 <15)\\nincrease count\\n\\nAnd so on.. \\n\\nFinally return count\\n```\\n\\n## C++ Code: \\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int M = *max_element(nums.begin(), nums.end()); \\n        int m = *min_element(nums.begin(), nums.end()); \\n        int res = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > m && nums[i] < M) res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nConsidering the comments on this post, these 2 approaches were also discussed: \\n## 2. Min Max using Single passes [Map]\\n#### [Credits (link)](https://leetcode.com/problems/count-elements-with-strictly-smaller-and-greater-elements/discuss/1711307/C++-or-O(N)-Time-or-O(1)-Space-or-100-Efficient/1233043) to [suryamshrivastav1](https://leetcode.com/suryamshrivastav1)\\n\\n## Algorithm \\n* Find the max and min element of array, store in m and l variables\\n* In the same loop use an unordered map to store the frequenecy of each element \\n* Return the value of nums.size()-map[m]-map[l] as result. \\n* **Space Complexity:** O(N) \\n* **Time Complexity:** O(N) Single Pass\\n\\n## C++ Code: \\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        unordered_map<int,int>map;\\n        int m=INT_MIN;\\n        int l=INT_MAX;\\n        for(int x:nums){\\n            map[x]++;\\n            m=max(m,x);\\n            l=min(l,x);\\n        }\\n        if(m==l){\\n            return 0;\\n        }\\n        return nums.size()-map[m]-map[l];\\n    }\\n};\\n```\\n\\n## 3. Min Max using Single passes [Count occurences without Map]\\n#### [Credits (link)](https://leetcode.com/problems/count-elements-with-strictly-smaller-and-greater-elements/discuss/1711307/C++-or-O(N)-Time-or-O(1)-Space-or-100-Efficient/1233264) to [ezpzm9](https://leetcode.com/ezpzm9)\\n\\n## Algorithm \\n* Find the max and min element of array.\\n* Count occurences in the same loop.\\n* **Space Complexity:** O(1) \\n* **Time Complexity:** O(N) Single Pass\\n\\n## Intuition\\n```\\n[11,7,2,15] \\nmin = 11, minOcc = 1, max = 11, maxOcc = 1;\\n\\nFor i = 1: minOcc = 2 and maxOcc = 2; \\nFor i = 2: min = 7, minOcc = 1, maxOCc = 2;\\nand so on..\\n\\nFinally check if min == max then return 0\\nor else return nums.size() - minOccurrences - maxOccurrences\\n\\n```\\n\\n## C++ Code: \\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\t    int n = nums.size(); \\n        if (n == 0) return 0;\\n\\t\\tint m = nums[0], minOcc = 1, M = nums[0], maxOcc = 1;\\n\\t\\tfor (int i = 1; i < n; ++i) {\\n\\t\\t\\tif (nums[i] < m) {\\n\\t\\t\\t\\tm = nums[i];\\n\\t\\t\\t\\tminOcc = 1;\\n\\t\\t\\t} else if (nums[i] == m) {\\n\\t\\t\\t\\tminOcc++;\\n\\t\\t\\t}\\n\\t\\t\\tif (M < nums[i]) {\\n\\t\\t\\t\\tM = nums[i];\\n\\t\\t\\t\\tmaxOcc = 1;\\n\\t\\t\\t} else if (M == nums[i]) {\\n\\t\\t\\t\\tmaxOcc++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn m == M ? 0 : n - minOcc - maxOcc;\\n\\t\\t}\\n};\\n```\\n\\n### Please upvote the solution if it helped you \\u2B50\\u2728",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nArray = [11, 7, 2, 15]\\nMax = 15 \\nMin = 2\\n\\nFor iteration i = 0: check if (11>2 && 11 <15)\\nincrease count\\n\\nAnd so on.. \\n\\nFinally return count\\n```\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int M = *max_element(nums.begin(), nums.end()); \\n        int m = *min_element(nums.begin(), nums.end()); \\n        int res = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > m && nums[i] < M) res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        unordered_map<int,int>map;\\n        int m=INT_MIN;\\n        int l=INT_MAX;\\n        for(int x:nums){\\n            map[x]++;\\n            m=max(m,x);\\n            l=min(l,x);\\n        }\\n        if(m==l){\\n            return 0;\\n        }\\n        return nums.size()-map[m]-map[l];\\n    }\\n};\\n```\n```\\n[11,7,2,15] \\nmin = 11, minOcc = 1, max = 11, maxOcc = 1;\\n\\nFor i = 1: minOcc = 2 and maxOcc = 2; \\nFor i = 2: min = 7, minOcc = 1, maxOCc = 2;\\nand so on..\\n\\nFinally check if min == max then return 0\\nor else return nums.size() - minOccurrences - maxOccurrences\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\t    int n = nums.size(); \\n        if (n == 0) return 0;\\n\\t\\tint m = nums[0], minOcc = 1, M = nums[0], maxOcc = 1;\\n\\t\\tfor (int i = 1; i < n; ++i) {\\n\\t\\t\\tif (nums[i] < m) {\\n\\t\\t\\t\\tm = nums[i];\\n\\t\\t\\t\\tminOcc = 1;\\n\\t\\t\\t} else if (nums[i] == m) {\\n\\t\\t\\t\\tminOcc++;\\n\\t\\t\\t}\\n\\t\\t\\tif (M < nums[i]) {\\n\\t\\t\\t\\tM = nums[i];\\n\\t\\t\\t\\tmaxOcc = 1;\\n\\t\\t\\t} else if (M == nums[i]) {\\n\\t\\t\\t\\tmaxOcc++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn m == M ? 0 : n - minOcc - maxOcc;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711240,
                "title": "java-simple-solution-of-finding-min-and-max",
                "content": "Just find min and max of array, then scan 1 by 1\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; ++i) {\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] > min && nums[i] < max) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; ++i) {\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] > min && nums[i] < max) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711350,
                "title": "exclude-min-and-max",
                "content": "After unpacking the problem description, we can realize that the only elements that do not fit the criteria are min and max elements of the array.\\n\\n> And what the heck is the difference between \"smaller\" and \"strictly smaller\"?  \\n\\n**C++**\\n```cpp\\nint countElements(vector<int>& n) {\\n    const auto mm = minmax_element(begin(n), end(n));\\n    return count_if(begin(n), end(n), [&](int n){ return n > *mm.first && n < *mm.second; });\\n}\\n```\\nAnd here is a single-pass solution, which is quite mouthful...\\n**C++**\\n```cpp\\nint countElements(vector<int>& nums) {\\n    int low = INT_MAX, low_cnt = 0, hi = INT_MIN, hi_cnt = 0;\\n    for (int n : nums) {\\n        if (n < low) {\\n            low = n;\\n            low_cnt = 0;\\n        }\\n        if (n > hi) {\\n            hi = n;\\n            hi_cnt = 0;\\n        }\\n        low_cnt += n == low;\\n        hi_cnt += n == hi;\\n    }\\n    return nums.size() - low_cnt - (low == hi ? 0 : hi_cnt);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countElements(vector<int>& n) {\\n    const auto mm = minmax_element(begin(n), end(n));\\n    return count_if(begin(n), end(n), [&](int n){ return n > *mm.first && n < *mm.second; });\\n}\\n```\n```cpp\\nint countElements(vector<int>& nums) {\\n    int low = INT_MAX, low_cnt = 0, hi = INT_MIN, hi_cnt = 0;\\n    for (int n : nums) {\\n        if (n < low) {\\n            low = n;\\n            low_cnt = 0;\\n        }\\n        if (n > hi) {\\n            hi = n;\\n            hi_cnt = 0;\\n        }\\n        low_cnt += n == low;\\n        hi_cnt += n == hi;\\n    }\\n    return nums.size() - low_cnt - (low == hi ? 0 : hi_cnt);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1712249,
                "title": "python-simple-solution-100-faster-o-n-time-o-1-space",
                "content": "Understanding: \\nElements that are both smaller than max and greater than min will be included in the count.\\n\\nAlgorithm:\\n- Find minimum and maximum element\\n- Loop through the array and increase count every time the element lies between the min and max of the array\\n- Return count\\n\\nPython code :\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        M = max(nums)\\n        m = min(nums)\\n        return sum(1 for i in nums if m<i<M)\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        M = max(nums)\\n        m = min(nums)\\n        return sum(1 for i in nums if m<i<M)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711236,
                "title": "c-solution-o-1-space-using-min-max-with-full-explanations",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Will give ***Run Tine Error*** \\n- We sorted the array & if the first and last 2 elements are not the same then simply return `n-2`\\n- Else take i & j to iterate over all similar numbers from first and last.\\n- If j is greater than i then `return j-i+1` else `return 0.`\\n- **Time complexity:** O(nlogn).\\n\\n### Solution 02\\n\\n- Here we find the max and min value from the array.\\n- Iterate once to find the elements which are greater than max and less then min, count all.\\n- Return the count.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        if(n<=2) return 0;\\n        if(nums[0] != nums[1] && nums[n-1] != nums[n-2]) return n-2;\\n        \\n        int i=0, j=n-1;\\n        \\n        while(i<n && nums[i]==nums[i+1]) i++;\\n        while(j>=0 && nums[j]==nums[j-1]) j--;\\n        \\n        if(j>i) return j-i-1;\\n        \\n        return 0;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        int mn = INT_MAX, mx = INT_MIN;\\n        \\n        for(auto x: nums){\\n            mx = max(mx, x);\\n            mn = min(mn, x);\\n        }\\n        \\n        for(auto x: nums){\\n            if(x>mn && x<mx) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n> \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        if(n<=2) return 0;\\n        if(nums[0] != nums[1] && nums[n-1] != nums[n-2]) return n-2;\\n        \\n        int i=0, j=n-1;\\n        \\n        while(i<n && nums[i]==nums[i+1]) i++;\\n        while(j>=0 && nums[j]==nums[j-1]) j--;\\n        \\n        if(j>i) return j-i-1;\\n        \\n        return 0;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        int mn = INT_MAX, mx = INT_MIN;\\n        \\n        for(auto x: nums){\\n            mx = max(mx, x);\\n            mn = min(mn, x);\\n        }\\n        \\n        for(auto x: nums){\\n            if(x>mn && x<mx) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523898,
                "title": "2-lines-of-code-java-with-comentary",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int countElements(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int k = 0;\\n        for(int i=1;i< nums.length-1;i++) {\\n            if(nums[i] > nums[0] && nums[i] < nums[nums.length-1]) k++;\\n        }\\n        return k;\\n    }\\n}\\n/*\\n1.First we need to sort the array,if we do so the first element will not have\\na min and the last element will not have a max and because of that we start \\nthe loop from the second element and we end the loop at length - 2.\\n\\n2.Next for every element is mandatory to have a min and max to increment the counter\\nso we do \" if(nums[i] > nums[0] && nums[i] < nums[nums.length-1]) k++ \";\\n\\nPLEASE UPVOTE\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int countElements(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int k = 0;\\n        for(int i=1;i< nums.length-1;i++) {\\n            if(nums[i] > nums[0] && nums[i] < nums[nums.length-1]) k++;\\n        }\\n        return k;\\n    }\\n}\\n/*\\n1.First we need to sort the array,if we do so the first element will not have\\na min and the last element will not have a max and because of that we start \\nthe loop from the second element and we end the loop at length - 2.\\n\\n2.Next for every element is mandatory to have a min and max to increment the counter\\nso we do \" if(nums[i] > nums[0] && nums[i] < nums[nums.length-1]) k++ \";\\n\\nPLEASE UPVOTE\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507825,
                "title": "very-very-easy-code-in-just-3-lines-using-python",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        res = 0\\n        mn = min(nums)\\n        mx = max(nums)\\n        for i in nums:\\n            if i > mn and i < mx:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        res = 0\\n        mn = min(nums)\\n        mx = max(nums)\\n        for i in nums:\\n            if i > mn and i < mx:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712586,
                "title": "java-one-pass-o-n-time-o-1-space-100-efficient",
                "content": "# One pass approach\\nOne every iteration,\\n1. Keep track of the maximum and minimum nummber so far\\n2. Keep track of number of duplicates of the current maximum and minimum \\n\\n In the loop we have the following cases:\\n\\n1. *The current number is equal to maximum*: Increment max_duplicate.\\n2.  *The current number is equal to minimum*: Increment min_duplicate.\\n3.  *The current number is the new maximum*: Update maximum and reset max_duplicate.\\n4.  *The current number is the new minimum*: Update minimum and reset min_duplicate.\\n\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int max = -100001, min = 100001, n = nums.length, max_duplicate = 0, min_duplicate = 0;\\n        if( n <= 1) return 0; \\n        for(int i:nums){\\n            if( i == max ) max_duplicate++;\\n            if( i == min ) min_duplicate++;\\n            if( i > max) {\\n                max = i;\\n                max_duplicate = 0;\\n            }\\n            if(i < min){\\n                min = i;\\n                min_duplicate = 0;\\n            }\\n        }\\n        int res = (n - 2) - max_duplicate - min_duplicate; // If no duplicates are present, answer will be length of nums - 2\\n        return res < 0 ? 0: res; // In case adding duplicates lead to negative sum \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int max = -100001, min = 100001, n = nums.length, max_duplicate = 0, min_duplicate = 0;\\n        if( n <= 1) return 0; \\n        for(int i:nums){\\n            if( i == max ) max_duplicate++;\\n            if( i == min ) min_duplicate++;\\n            if( i > max) {\\n                max = i;\\n                max_duplicate = 0;\\n            }\\n            if(i < min){\\n                min = i;\\n                min_duplicate = 0;\\n            }\\n        }\\n        int res = (n - 2) - max_duplicate - min_duplicate; // If no duplicates are present, answer will be length of nums - 2\\n        return res < 0 ? 0: res; // In case adding duplicates lead to negative sum \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772923,
                "title": "python-min-and-max-solution",
                "content": "**Python :**\\n\\n```\\ndef countElements(self, nums: List[int]) -> int:\\n\\tmin_ = min(nums)\\n\\tmax_ = max(nums)\\n\\n\\treturn sum(1 for i in nums if min_ < i < max_)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countElements(self, nums: List[int]) -> int:\\n\\tmin_ = min(nums)\\n\\tmax_ = max(nums)\\n\\n\\treturn sum(1 for i in nums if min_ < i < max_)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1713871,
                "title": "java-easy-and-fast-solution-beat-0ms",
                "content": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int nmin=Integer.MAX_VALUE;\\n        int nmax=Integer.MIN_VALUE;\\n        for(int a:nums)\\n        {\\n            nmin=Math.min(a,nmin);\\n            nmax=Math.max(a,nmax);\\n        }\\n        int count=0;\\n        for(int a:nums)\\n        {\\n            if(a>nmin && a<nmax)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int nmin=Integer.MAX_VALUE;\\n        int nmax=Integer.MIN_VALUE;\\n        for(int a:nums)\\n        {\\n            nmin=Math.min(a,nmin);\\n            nmax=Math.max(a,nmax);\\n        }\\n        int count=0;\\n        for(int a:nums)\\n        {\\n            if(a>nmin && a<nmax)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309864,
                "title": "easiest-7-liner-code-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        maxval=max(nums)\\n        minval=min(nums)\\n        while maxval in nums:\\n            nums.remove(maxval)\\n        while minval in nums:\\n            nums.remove(minval)\\n        return len(nums)\\n        #please do upvote it would be encouraging to post more solutions.\\n\\n```\\n## Consider upvoting if found helpful\\n    \\n![4m44lc.jpg](https://assets.leetcode.com/users/images/ae24a724-7925-43e0-9155-3f99db393d3d_1679115609.1123905.jpeg)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        maxval=max(nums)\\n        minval=min(nums)\\n        while maxval in nums:\\n            nums.remove(maxval)\\n        while minval in nums:\\n            nums.remove(minval)\\n        return len(nums)\\n        #please do upvote it would be encouraging to post more solutions.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712822,
                "title": "java-o-n-time-100-efficient-and-simple",
                "content": "* Find the max and min element of array, store in max and min variables\\n Compare each element with Min and Max and count while iterating through array in O(N) time\\nReturn the count as result.\\n\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            min=Math.min(min,nums[i]);\\n            max=Math.max(max,nums[i]);\\n        }\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<max && nums[i]>min) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Space Complexity: O(1)\\nTime Complexity: O(N)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            min=Math.min(min,nums[i]);\\n            max=Math.max(max,nums[i]);\\n        }\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<max && nums[i]>min) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711489,
                "title": "python-easy-o-n-solution",
                "content": "find the max and min values in the nums, and count the value that strictly in the range (min, max).\\n\\n```python\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        lo, hi = min(nums), max(nums)\\n        return sum(1 for x in nums if lo<x<hi)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        lo, hi = min(nums), max(nums)\\n        return sum(1 for x in nums if lo<x<hi)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225277,
                "title": "c-easy-solution-brute-force",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Find the maximum and minimum elements in the vector using the STL function \\n2. Iterate across the vector and increase the count if the current element is greater than minimum element of the array and less than the maximum element of the array. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int cnt = 0 ; \\n        int maxi = *max_element(nums.begin(), nums.end()) ;\\n        int mini = *min_element(nums.begin(), nums.end()) ; \\n\\n        for (int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (nums[i] < maxi && nums[i] > mini)\\n            {\\n                cnt ++ ;\\n            }\\n        }\\n        return cnt ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/7cb01bac-f820-4596-88c8-482ad7f80a27_1677246190.4181592.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int cnt = 0 ; \\n        int maxi = *max_element(nums.begin(), nums.end()) ;\\n        int mini = *min_element(nums.begin(), nums.end()) ; \\n\\n        for (int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (nums[i] < maxi && nums[i] > mini)\\n            {\\n                cnt ++ ;\\n            }\\n        }\\n        return cnt ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719859,
                "title": "short-javascript-solution",
                "content": "Time: O(n)\\nSpace: O(1)\\n```\\nvar countElements = function (nums) {\\n    const max = Math.max(...nums);\\n    const min = Math.min(...nums);\\n    let count = 0;\\n\\n    nums.forEach(ele => {\\n        if (ele < max && ele > min) count++\\n    })\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countElements = function (nums) {\\n    const max = Math.max(...nums);\\n    const min = Math.min(...nums);\\n    let count = 0;\\n\\n    nums.forEach(ele => {\\n        if (ele < max && ele > min) count++\\n    })\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711447,
                "title": "easy-python-solution-100",
                "content": "Runtime: 36 ms, faster than 100.00% of Python3 online submissions for Count Elements With Strictly Smaller and Greater Elements .\\nMemory Usage: 14.1 MB, less than 77.78% of Python3 online submissions for Count Elements With Strictly Smaller and Greater Elements .\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mi=min(nums)\\n        ma=max(nums)\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i]>mi and nums[i]<ma:\\n                c+=1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 36 ms, faster than 100.00% of Python3 online submissions for Count Elements With Strictly Smaller and Greater Elements .\\nMemory Usage: 14.1 MB, less than 77.78% of Python3 online submissions for Count Elements With Strictly Smaller and Greater Elements .\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mi=min(nums)\\n        ma=max(nums)\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i]>mi and nums[i]<ma:\\n                c+=1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 3871718,
                "title": "c-python-brute-force-with-optimized-approach-too-easy-fully-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose we have the following input vector:\\n```\\nvector<int> nums = {3, 1, 7, 4, 2, 6};\\n```\\n\\nNow, let\\'s go through the function step by step:\\n\\n1. Initialize two boolean variables, `mx` (for \"maximum\") and `mn` (for \"minimum\"), to false.\\n2. Initialize `cnt` (count of elements that satisfy the condition) to 0.\\n3. Start a loop to iterate through the `nums` vector.\\n   - First iteration: `i` is 0, `nums[i]` is 3.\\n     - Initialize `mx` and `mn` to false.\\n     - Start another loop to compare the current element (`nums[i]`) with all the elements in the `nums` vector.\\n       - First comparison: `nums[i]` (which is 3) is not greater than `nums[j]` (which is 3), so no change in `mx`.\\n       - First comparison: `nums[i]` (which is 3) is not smaller than `nums[j]` (which is 3), so no change in `mn`.\\n       - Second comparison: `nums[i]` (which is 3) is not greater than `nums[j]` (which is 1), so no change in `mx`.\\n       - Second comparison: `nums[i]` (which is 3) is greater than `nums[j]` (which is 1). Set `mn` to true.\\n       - Third comparison: `nums[i]` (which is 3) is greater than `nums[j]` (which is 7). Set `mn` to true.\\n       - Fourth comparison: `nums[i]` (which is 3) is not greater than `nums[j]` (which is 4), so no change in `mx`.\\n       - Fourth comparison: `nums[i]` (which is 3) is not smaller than `nums[j]` (which is 4), so no change in `mn`.\\n       - Fifth comparison: `nums[i]` (which is 3) is not greater than `nums[j]` (which is 2), so no change in `mx`.\\n       - Fifth comparison: `nums[i]` (which is 3) is greater than `nums[j]` (which is 2). Set `mn` to true.\\n       - Sixth comparison: `nums[i]` (which is 3) is greater than `nums[j]` (which is 6). Set `mn` to true.\\n     - Since both `mx` and `mn` are true, increment `cnt` to 1.\\n   - The loop continues for the remaining elements in the `nums` vector.\\n\\n4. The loop ends, and `cnt` contains the count of elements in the `nums` vector that have both greater and smaller elements.\\n\\nIn this example, only the element 4 satisfies the condition of having both greater and smaller elements in the given `nums` vector.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        bool mx = false;\\n        bool mn = false;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            mx = false;\\n            mn = false;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(nums[i] > nums[j])\\n                    mn = true;\\n                if(nums[i] < nums[j])\\n                    mx = true;\\n            }\\n            if(mn == true && mx == true)\\n                cnt++;\\n        }\\n    return cnt;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        cnt = 0\\n        for i in range(len(nums)):\\n            mn = min(nums)\\n            mx = max(nums)\\n\\n            if(mn < nums[i] and mx > nums[i] ):\\n                cnt += 1\\n        return cnt\\n```\\n# Approach\\nSuppose we have the following input vector:\\n```\\nvector<int> nums = {3, 1, 7, 4, 2, 6};\\n```\\n\\nNow, let\\'s go through the function step by step:\\n\\n1. Initialize `mx` (maximum value) to INT_MIN (the minimum value that can be represented by the `int` data type) and `mn` (minimum value) to INT_MAX (the maximum value that can be represented by the `int` data type).\\n2. Start a loop to iterate through the `nums` vector using the range-based for loop.\\n   - First iteration: `it` is 3.\\n     - Update `mx` to the maximum of `mx` (which is INT_MIN) and `it` (which is 3), so `mx` becomes 3.\\n     - Update `mn` to the minimum of `mn` (which is INT_MAX) and `it` (which is 3), so `mn` becomes 3.\\n   - Second iteration: `it` is 1.\\n     - Update `mx` to the maximum of `mx` (which is 3) and `it` (which is 1), so `mx` remains 3.\\n     - Update `mn` to the minimum of `mn` (which is 3) and `it` (which is 1), so `mn` becomes 1.\\n   - Third iteration: `it` is 7.\\n     - Update `mx` to the maximum of `mx` (which is 3) and `it` (which is 7), so `mx` becomes 7.\\n     - Update `mn` to the minimum of `mn` (which is 1) and `it` (which is 7), so `mn` remains 1.\\n   - Fourth iteration: `it` is 4.\\n     - Update `mx` to the maximum of `mx` (which is 7) and `it` (which is 4), so `mx` remains 7.\\n     - Update `mn` to the minimum of `mn` (which is 1) and `it` (which is 4), so `mn` remains 1.\\n   - Fifth iteration: `it` is 2.\\n     - Update `mx` to the maximum of `mx` (which is 7) and `it` (which is 2), so `mx` remains 7.\\n     - Update `mn` to the minimum of `mn` (which is 1) and `it` (which is 2), so `mn` remains 1.\\n   - Sixth iteration: `it` is 6.\\n     - Update `mx` to the maximum of `mx` (which is 7) and `it` (which is 6), so `mx` remains 7.\\n     - Update `mn` to the minimum of `mn` (which is 1) and `it` (which is 6), so `mn` remains 1.\\n\\n3. After the first loop, `mx` is 7, and `mn` is 1, which represent the maximum and minimum values in the `nums` vector, respectively.\\n4. Initialize `cnt` (count of elements that satisfy the condition) to 0.\\n5. Start a loop to iterate through the `nums` vector using a traditional for loop.\\n   - First iteration: `i` is 0, `nums[i]` is 3.\\n     - Check if `nums[i]` (which is 3) is greater than `mn` (which is 1) and less than `mx` (which is 7). It satisfies the condition, so increment `cnt` to 1.\\n   - Second iteration: `i` is 1, `nums[i]` is 1.\\n     - Check if `nums[i]` (which is 1) is greater than `mn` (which is 1) and less than `mx` (which is 7). It does not satisfy the condition, so no change in `cnt`.\\n   - The loop continues for the remaining elements in the `nums` vector.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int mx = INT_MIN;\\n        int mn = INT_MAX;\\n        for(auto it:nums){\\n            mx = max(mx, it);\\n            mn = min(mn, it);\\n        }\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > mn && nums[i] < mx)\\n                cnt++;\\n        }\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nvector<int> nums = {3, 1, 7, 4, 2, 6};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        bool mx = false;\\n        bool mn = false;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            mx = false;\\n            mn = false;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(nums[i] > nums[j])\\n                    mn = true;\\n                if(nums[i] < nums[j])\\n                    mx = true;\\n            }\\n            if(mn == true && mx == true)\\n                cnt++;\\n        }\\n    return cnt;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        cnt = 0\\n        for i in range(len(nums)):\\n            mn = min(nums)\\n            mx = max(nums)\\n\\n            if(mn < nums[i] and mx > nums[i] ):\\n                cnt += 1\\n        return cnt\\n```\n```\\nvector<int> nums = {3, 1, 7, 4, 2, 6};\\n```\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int mx = INT_MIN;\\n        int mn = INT_MAX;\\n        for(auto it:nums){\\n            mx = max(mx, it);\\n            mn = min(mn, it);\\n        }\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > mn && nums[i] < mx)\\n                cnt++;\\n        }\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320602,
                "title": "simple-python-one-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        return len(nums) - nums.count(max(nums)) - nums.count(min(nums)) if max(nums) != min(nums) else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        return len(nums) - nums.count(max(nums)) - nums.count(min(nums)) if max(nums) != min(nums) else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305387,
                "title": "c-easy-beginner-friendly-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort the array and than count smallest number occurance in array and same for largest number ..\\nsubtract it from array size..\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nJAI SHREE RAM\\nUPVOTE IF YOU FIND IT HELPFULL\\nTHANK YOU\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        //check if size if 1 return 0\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        \\n        int n=nums.size();\\n        int b=1,c=1;\\n        int ans=n;\\n        //Sort the vector nums\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=1;i<n;i++){\\n            //count the number small values same..in b++;\\n           if(nums[0]==nums[i]){\\n               b++;\\n           }\\n           else{\\n               break;\\n           }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            //count the number largest values same ..in c++;\\n            if(nums[n-1]==nums[i]){\\n                c++;\\n           }\\n        }\\n        int res = ans-b-c;//save answer here..\\n        return (res >= 0) ? res : 0;//if answer come negative return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        //check if size if 1 return 0\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        \\n        int n=nums.size();\\n        int b=1,c=1;\\n        int ans=n;\\n        //Sort the vector nums\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=1;i<n;i++){\\n            //count the number small values same..in b++;\\n           if(nums[0]==nums[i]){\\n               b++;\\n           }\\n           else{\\n               break;\\n           }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            //count the number largest values same ..in c++;\\n            if(nums[n-1]==nums[i]){\\n                c++;\\n           }\\n        }\\n        int res = ans-b-c;//save answer here..\\n        return (res >= 0) ? res : 0;//if answer come negative return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838996,
                "title": "cpp-easy-to-understand-simple-and-clean-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n         int mini=INT_MAX;\\n        map<int,int>mp;\\n          int ans=0, n=nums.size();\\n        for(auto i:nums)\\n       {\\n            mp[i]++;\\n           maxi=max(maxi,i);\\n           mini=min(mini,i);\\n       }\\n        if(maxi==mini)return 0;\\n        return n-(mp[maxi]+mp[mini]);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n         int mini=INT_MAX;\\n        map<int,int>mp;\\n          int ans=0, n=nums.size();\\n        for(auto i:nums)\\n       {\\n            mp[i]++;\\n           maxi=max(maxi,i);\\n           mini=min(mini,i);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2254995,
                "title": "easy-java-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        //only the min and the max elements satisfy the conditions\\n        for(int x: nums){\\n            min = Math.min(x, min);\\n            max = Math.max(x, max);\\n        }\\n        \\n        if(min == max) return 0; //all the elements in the array are same\\n        \\n        int minCount = 0;\\n        int maxCount = 0;\\n        \\n        //all occurances of the maxElement and the minElement must be removed\\n        for(int x: nums){\\n            if(x == min) minCount++;\\n            if(x == max) maxCount++;\\n        }\\n        \\n        return nums.length - minCount - maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        //only the min and the max elements satisfy the conditions\\n        for(int x: nums){\\n            min = Math.min(x, min);\\n            max = Math.max(x, max);\\n        }\\n        \\n        if(min == max) return 0; //all the elements in the array are same\\n        \\n        int minCount = 0;\\n        int maxCount = 0;\\n        \\n        //all occurances of the maxElement and the minElement must be removed\\n        for(int x: nums){\\n            if(x == min) minCount++;\\n            if(x == max) maxCount++;\\n        }\\n        \\n        return nums.length - minCount - maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798973,
                "title": "java-easy-sort-solution",
                "content": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums);\\n        int min=nums[0];\\n        int max=nums[nums.length-1];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if(nums[i]!=min && nums[i]!=max)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums);\\n        int min=nums[0];\\n        int max=nums[nums.length-1];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if(nums[i]!=min && nums[i]!=max)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727376,
                "title": "c-o-nlogn-time-o-1-space-well-commented-75-faster",
                "content": "```class Solution {\\npublic:\\n    int countElements(vector<int>& v) {\\n        \\n        if(v.size()<3)\\n            return 0;\\n        \\n        int n = v.size()-1, i = 0, cnt1 = 0,cnt2 = 0;\\n        sort(v.begin(), v.end());  //sort the array\\n        \\n         if(v[0] == v[v.size()-1]) return 0;  //if first element is same as last that means only one element is present\\n        \\n        while(i<n-1&&v[i] == v[i+1])  //check cnt of the first repeating element in sorted array\\n        {\\n            cnt1++;\\n            i++;\\n        }\\n        \\n        while(n>0&&v[n] == v[n-1])   //check cnt of the second repeating element in sorted array\\n        {\\n            cnt2++;n--;\\n        }\\n        \\n      \\n        int j = v.size();\\n        int ans = j-(cnt1+cnt2)-2;  //ans will be size minus the count of first and last element as only those two will not have a value smaller or greater respectively.\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int countElements(vector<int>& v) {\\n        \\n        if(v.size()<3)\\n            return 0;\\n        \\n        int n = v.size()-1, i = 0, cnt1 = 0,cnt2 = 0;\\n        sort(v.begin(), v.end());  //sort the array\\n        \\n         if(v[0] == v[v.size()-1]) return 0;  //if first element is same as last that means only one element is present\\n        \\n        while(i<n-1&&v[i] == v[i+1])  //check cnt of the first repeating element in sorted array\\n        {\\n            cnt1++;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1713686,
                "title": "python3-runtime-o-n",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mi = min(nums)\\n        ma = max(nums)\\n        check = Counter(nums)\\n        ans = max(0,len(nums)-check[mi]-check[ma])\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mi = min(nums)\\n        ma = max(nums)\\n        check = Counter(nums)\\n        ans = max(0,len(nums)-check[mi]-check[ma])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713052,
                "title": "two-c-approaches-1-brute-force-2-optimised",
                "content": "* Brute force :\\n class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n      int count =0;\\n        for(int i =0;i<nums.size();i++){\\n            int f1 =0;\\n            int f2 =0;\\n            for(int j =0;j<nums.size();j++){\\n                if(nums[j]>nums[i])f1 =1;\\n                if(nums[j]<nums[i])f2 =1;\\n            }\\n            if(f1 ==1 and f2==1)count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n* Optimized approach \\n ```\\n class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int mini = INT_MAX;\\n        int maxi =INT_MIN;\\n        for(int i =0;i<nums.size();i++){\\n            mini = min(mini,nums[i]);\\n            maxi = max(maxi,nums[i]);\\n        }\\n        int count =0;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i]>mini and nums[i]<maxi)count++;\\n            \\n        }\\n        return count;\\n        \\n    } \\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n      int count =0;\\n        for(int i =0;i<nums.size();i++){\\n            int f1 =0;\\n            int f2 =0;\\n            for(int j =0;j<nums.size();j++){\\n                if(nums[j]>nums[i])f1 =1;\\n                if(nums[j]<nums[i])f2 =1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1711239,
                "title": "python-solution-using-sorting-and-counter",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        freq_table = Counter(nums)\\n        arr = list(freq_table.keys())\\n        arr.sort()\\n        ans = len(nums)\\n        ans -= freq_table[arr[0]]\\n        ans -= freq_table[arr[-1]]\\n        return max(ans,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        freq_table = Counter(nums)\\n        arr = list(freq_table.keys())\\n        arr.sort()\\n        ans = len(nums)\\n        ans -= freq_table[arr[0]]\\n        ans -= freq_table[arr[-1]]\\n        return max(ans,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872068,
                "title": "c-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Intitalize count wit {0} and a pointer j with {0}.\\n2. Calculate the maximum element and a minimum element.\\n3. Store maximum element in {maxi}.\\n4. Store minimum element in {mini}.\\n5. Iterate through the loop and check whether nums{j} is greater than maxi && smaller than mini.\\n6. If both condition fulfills -->> INCREMENT COUNT -> +1.\\n7. return count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int count=0;\\n        int j=0;\\n        int maxi = *max_element(nums.begin(),nums.end());\\n        int mini = *min_element(nums.begin(),nums.end());\\n        while(j < nums.size())\\n        {\\n            if((nums[j] > mini) && (nums[j] < maxi)) count++;\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int count=0;\\n        int j=0;\\n        int maxi = *max_element(nums.begin(),nums.end());\\n        int mini = *min_element(nums.begin(),nums.end());\\n        while(j < nums.size())\\n        {\\n            if((nums[j] > mini) && (nums[j] < maxi)) count++;\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701649,
                "title": "easy-c-solution-t-c-o-n-s-c-o-1",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int count =0;\\n        int maxi =  *max_element(nums.begin(),nums.end());\\n        int mini = *min_element(nums.begin(),nums.end());\\n\\n        cout<<maxi<<\" \"<<mini;\\n        for(int i=0; i<nums.size();i++){\\n            if(nums[i]>mini && nums[i]<maxi){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int count =0;\\n        int maxi =  *max_element(nums.begin(),nums.end());\\n        int mini = *min_element(nums.begin(),nums.end());\\n\\n        cout<<maxi<<\" \"<<mini;\\n        for(int i=0; i<nums.size();i++){\\n            if(nums[i]>mini && nums[i]<maxi){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3642183,
                "title": "c-super-easy-single-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini = nums[0];\\n        int maxi = nums[0];\\n        int cntmin = 1;\\n        int cntmax = 1;\\n        for(int i=1; i<n; i++){\\n            if(nums[i] < mini){\\n                mini = nums[i];\\n                cntmin = 1;\\n            }\\n            else if(nums[i] == mini) cntmin++;\\n\\n            if(nums[i] > maxi){\\n                maxi = nums[i];\\n                cntmax = 1;\\n            }\\n            else if(nums[i] == maxi) cntmax++;\\n        }\\n\\n        if(mini == maxi) return 0;\\n\\n        return n - (cntmin + cntmax);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini = nums[0];\\n        int maxi = nums[0];\\n        int cntmin = 1;\\n        int cntmax = 1;\\n        for(int i=1; i<n; i++){\\n            if(nums[i] < mini){\\n                mini = nums[i];\\n                cntmin = 1;\\n            }\\n            else if(nums[i] == mini) cntmin++;\\n\\n            if(nums[i] > maxi){\\n                maxi = nums[i];\\n                cntmax = 1;\\n            }\\n            else if(nums[i] == maxi) cntmax++;\\n        }\\n\\n        if(mini == maxi) return 0;\\n\\n        return n - (cntmin + cntmax);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619460,
                "title": "100-faster-intuitive",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        short start_index = 0;\\n        short end_index = nums.size() - 1;\\n        \\n        if (nums.size() <= 2) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (nums[i] == nums[i + 1]) {\\n                start_index += 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        // all elements are same\\n        // example - [0,0,0,0,0,0,0]\\n        if (start_index + 1 == nums.size()) {\\n            return 0;\\n        }\\n        \\n        // all elements not same, proceed\\n        for (int i = nums.size() - 1; i >= start_index + 1; i--) {\\n            if (nums[i] == nums[i - 1]) {\\n                end_index -= 1;\\n            } else {\\n                break;\\n            }\\n        }        \\n        \\n        // example - [11,7,2,15]\\n        if (start_index == 0 && end_index == nums.size() - 1) {\\n            cout<<\"first\"<<endl;\\n            return nums.size() - 2;\\n        }\\n        \\n        // example - [3,45,90,180,180,180]\\n        else if (start_index == 0) {\\n            cout<<\"2nd last\"<<endl;\\n            return end_index - 1;\\n        }\\n        \\n        // example - [3,3,3,45,90,180,180,180] and [3,3,3,3,45,90,180]\\n        else {\\n            cout<<\"last\"<<endl;\\n            return end_index - start_index - 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        short start_index = 0;\\n        short end_index = nums.size() - 1;\\n        \\n        if (nums.size() <= 2) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (nums[i] == nums[i + 1]) {\\n                start_index += 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        // all elements are same\\n        // example - [0,0,0,0,0,0,0]\\n        if (start_index + 1 == nums.size()) {\\n            return 0;\\n        }\\n        \\n        // all elements not same, proceed\\n        for (int i = nums.size() - 1; i >= start_index + 1; i--) {\\n            if (nums[i] == nums[i - 1]) {\\n                end_index -= 1;\\n            } else {\\n                break;\\n            }\\n        }        \\n        \\n        // example - [11,7,2,15]\\n        if (start_index == 0 && end_index == nums.size() - 1) {\\n            cout<<\"first\"<<endl;\\n            return nums.size() - 2;\\n        }\\n        \\n        // example - [3,45,90,180,180,180]\\n        else if (start_index == 0) {\\n            cout<<\"2nd last\"<<endl;\\n            return end_index - 1;\\n        }\\n        \\n        // example - [3,3,3,45,90,180,180,180] and [3,3,3,3,45,90,180]\\n        else {\\n            cout<<\"last\"<<endl;\\n            return end_index - start_index - 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3398359,
                "title": "count-elements-with-strictly-smaller-and-greater-elements-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int i, count=0;\\n        sort(nums.begin(), nums.end());\\n        for(i=1 ; i<nums.size()-1 ; i++)\\n        {\\n            if(nums[i]>nums[0] && nums[i]<nums[nums.size()-1])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int i, count=0;\\n        sort(nums.begin(), nums.end());\\n        for(i=1 ; i<nums.size()-1 ; i++)\\n        {\\n            if(nums[i]>nums[0] && nums[i]<nums[nums.size()-1])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300433,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\n    sort(nums.begin(),nums.end());\\n    int n=nums.size();\\n    if(n<3 || (nums[0]==nums[n-1]) )\\n        return 0;\\n    int count = 0;\\n    for (int i = 1; i < n - 1; i++)\\n        if (nums[i] > nums[0] && nums[i] < nums[n - 1])\\n            count++;\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\n    sort(nums.begin(),nums.end());\\n    int n=nums.size();\\n    if(n<3 || (nums[0]==nums[n-1]) )\\n        return 0;\\n    int count = 0;\\n    for (int i = 1; i < n - 1; i++)\\n        if (nums[i] > nums[0] && nums[i] < nums[n - 1])\\n            count++;\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421096,
                "title": "c-simple-and-clean-solution-with-sorting",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\n int countElements(vector<int>& nums) \\n    {\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        int maximum=nums[nums.size()-1];\\n        int minimum=nums[0];\\n        if(maximum==minimum)\\n            return 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==minimum || nums[i]==maximum)\\n                count++;\\n        }\\n        return nums.size()-count;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int countElements(vector<int>& nums) \\n    {\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        int maximum=nums[nums.size()-1];\\n        int minimum=nums[0];\\n        if(maximum==minimum)\\n            return 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==minimum || nums[i]==maximum)\\n                count++;\\n        }\\n        return nums.size()-count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2331808,
                "title": "simple-cpp-solutions-using-counting-technique-and-primitive-brute-force-approach",
                "content": "**Simple Solution using counting technique**\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int maxi = *max_element(nums.begin() , nums.end()); \\n        int mini = *min_element(nums.begin() , nums.end());\\n        int a = count(nums.begin() , nums.end() ,maxi);\\n        int b = count(nums.begin() , nums.end() ,mini);\\n        if(maxi==mini)\\n            return 0;\\n        return nums.size()-a-b;\\n        \\n    }\\n};\\n```\\n**Using Brute Force technique**\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int counter = 0;\\n        int scounter = 0;\\n        int lcounter = 0;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                if(i==j)\\n                    continue;\\n                if(nums[i]>nums[j])\\n                    lcounter++;\\n                if(nums[i]<nums[j])\\n                    scounter++;\\n            }\\n            if(lcounter>=1 && scounter>=1)\\n              counter++;\\n            lcounter = 0 , scounter = 0;\\n        }\\n            return counter;\\n    }\\n};\\n```\\n**Note : The brute force technique used here does not have good time complexity**\\n**Please upvote if you find this helpful**\\n**Do checkout my github repository**\\n[https://github.com/Reehan9/Leetcode-Solutions]",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int maxi = *max_element(nums.begin() , nums.end()); \\n        int mini = *min_element(nums.begin() , nums.end());\\n        int a = count(nums.begin() , nums.end() ,maxi);\\n        int b = count(nums.begin() , nums.end() ,mini);\\n        if(maxi==mini)\\n            return 0;\\n        return nums.size()-a-b;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int counter = 0;\\n        int scounter = 0;\\n        int lcounter = 0;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                if(i==j)\\n                    continue;\\n                if(nums[i]>nums[j])\\n                    lcounter++;\\n                if(nums[i]<nums[j])\\n                    scounter++;\\n            }\\n            if(lcounter>=1 && scounter>=1)\\n              counter++;\\n            lcounter = 0 , scounter = 0;\\n        }\\n            return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885981,
                "title": "3-liner-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n       int maxel=*max_element(begin(nums),end(nums));\\n       int minel=*min_element(begin(nums),end(nums));\\n        \\n       return count_if(nums.begin(),nums.end(),[&](int n){return n>minel and n<maxel;});\\n       \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n       int maxel=*max_element(begin(nums),end(nums));\\n       int minel=*min_element(begin(nums),end(nums));\\n        \\n       return count_if(nums.begin(),nums.end(),[&](int n){return n>minel and n<maxel;});\\n       \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798411,
                "title": "using-unordered-map-c-super-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<3) return 0;\\n        int mn = INT_MAX;\\n        int mx = INT_MIN;\\n        \\n        unordered_map<int, int> mp;\\n        for(auto& it: nums){\\n            mp[it]++;\\n            mn = min(mn, it);\\n            mx = max(mx, it);\\n        }\\n        \\n        if(mp.size()<3) return 0;\\n        return n-mp[mn]-mp[mx];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<3) return 0;\\n        int mn = INT_MAX;\\n        int mx = INT_MIN;\\n        \\n        unordered_map<int, int> mp;\\n        for(auto& it: nums){\\n            mp[it]++;\\n            mn = min(mn, it);\\n            mx = max(mx, it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1774093,
                "title": "python3-simple",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mx=mn=nums[0]\\n        for el in nums:\\n            mx=max(mx,el)\\n            mn=min(mn,el)\\n        return sum(mn<el<mx for el in nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mx=mn=nums[0]\\n        for el in nums:\\n            mx=max(mx,el)\\n            mn=min(mn,el)\\n        return sum(mn<el<mx for el in nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760099,
                "title": "python-solution-with-explanation",
                "content": "Here we use simple maths and basic understanding concept , that if we have to find number of values which have strictly greater and lesser values than once we sort them they should be the numbers which lie in between the first and last value in the sorted array.\\nWe also take the side condition into consideration which is when we have more than one same value in the given list with max and min value in the list.(eg [2,2,3,5,6,8,8,8]) \\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        x=len(nums)\\n        y=nums.count(nums[0])\\n        z=0\\n        if(nums[0]!=nums[-1]):\\n            z+=nums.count(nums[-1])\\n        \\n        return(x-(y+z))\\n```\\nIf u understood the code then plz....UPVOTE....Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        x=len(nums)\\n        y=nums.count(nums[0])\\n        z=0\\n        if(nums[0]!=nums[-1]):\\n            z+=nums.count(nums[-1])\\n        \\n        return(x-(y+z))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726874,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int countElements(int[] n) {\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        for(int k:n)\\n        {\\n            nm.put(k , nm.getOrDefault(k,0)+1);\\n        }\\n        Arrays.sort(n);\\n        int p=n.length;\\n        if(n[0]==n[p-1])\\n            return 0;\\n        int c=0;\\n        for(int k : nm.keySet())\\n        {\\n            if(k!=n[0]&&k!=n[p-1])\\n            {\\n                c=c+nm.get(k);\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int countElements(int[] n) {\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        for(int k:n)\\n        {\\n            nm.put(k , nm.getOrDefault(k,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1720186,
                "title": "easy-python-1-liner",
                "content": "```\\ndef countElements(self, nums: List[int]) -> int:\\n        return sum(1 for i in nums if min(nums)<i<max(nums))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countElements(self, nums: List[int]) -> int:\\n        return sum(1 for i in nums if min(nums)<i<max(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1720181,
                "title": "easy-python-solution",
                "content": "```\\n    def countElements(self, nums: List[int]) -> int:\\n        c=0\\n        for i in nums:\\n            if min(nums)<i<max(nums):\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def countElements(self, nums: List[int]) -> int:\\n        c=0\\n        for i in nums:\\n            if min(nums)<i<max(nums):\\n                c+=1\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1714916,
                "title": "java-simple-and-easy-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        //lets consider each element of nums as -- target\\n        //and search max and min of it \\n        \\n        int count = 0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            boolean max = func_max(nums, nums[i]);\\n            boolean min = func_min(nums, nums[i]);\\n            \\n            if(max == true && min == true)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public boolean func_max(int[] nums, int target)\\n    {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] > target)\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean func_min(int[] nums, int target)\\n    {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] < target)\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int countElements(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        //lets consider each element of nums as -- target\\n        //and search max and min of it \\n        \\n        int count = 0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            boolean max = func_max(nums, nums[i]);\\n            boolean min = func_min(nums, nums[i]);\\n            \\n            if(max == true && min == true)\\n            {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1713466,
                "title": "c-simple-and-clear-two-line-solution-explained",
                "content": "First, we find the maximum and minimum in the array - `mx` and `mn`.\\nIf `mx` and `mn` are equal, all the elenemts in the array are equal and the answer is 0.\\nOtherwise, we count how many times we have `mx` and `mn` in the array and return the array size minus those.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(), nums.end()), mn = *min_element(nums.begin(), nums.end());\\n        return mx == mn ? 0 : nums.size() - count(nums.begin(), nums.end(), mx) - count(nums.begin(), nums.end(), mn);\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(), nums.end()), mn = *min_element(nums.begin(), nums.end());\\n        return mx == mn ? 0 : nums.size() - count(nums.begin(), nums.end(), mx) - count(nums.begin(), nums.end(), mn);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712746,
                "title": "c-iterating-loops-sorting-method-easy-way",
                "content": "``` \\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n        int m = nums.size(); \\n        int cnt=0;\\n        \\n        for ( int i=1 ; i<m-1 ; i++) \\n        {\\n        sort(nums.begin() , nums.end() ); \\n        if(nums[i] > nums[i-1] && nums[i] < nums[m-1] ) \\n            cnt++;  \\n            \\n            if ( nums[i] == nums[i+1] && (nums[i] > nums[0] && nums[i] < nums[m-1] ) ) \\n                cnt++ ; \\n            \\n        }\\n        return cnt ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n        int m = nums.size(); \\n        int cnt=0;\\n        \\n        for ( int i=1 ; i<m-1 ; i++) \\n        {\\n        sort(nums.begin() , nums.end() ); \\n        if(nums[i] > nums[i-1] && nums[i] < nums[m-1] ) \\n            cnt++;  \\n            \\n            if ( nums[i] == nums[i+1] && (nums[i] > nums[0] && nums[i] < nums[m-1] ) ) \\n                cnt++ ; \\n            \\n        }\\n        return cnt ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711888,
                "title": "c-optimise-naive-approach",
                "content": "# **C++ Brute Force Approach**\\n1. We need to check for every element if there present a element which is greater than the present element and a element which is smaller than the present element.\\n2. scount will store the number of element smaller than the present element and gcount will store the number of element greater than the present element.\\n\\n```\\nint countElements(vector<int>& nums) {\\n        int n = nums.size();\\n        int scount=0,gcount=0;\\n        int totalcount=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[i]<nums[j])\\n                    scount++;\\n                else if(nums[i]>nums[j])\\n                    gcount++;\\n            }\\n            if(scount>=1 && gcount>=1)\\n                totalcount+=1;\\n            scount=0;gcount=0;\\n        }\\n        return totalcount;\\n    }\\n```\\n**TIme Complexity - O(n2)**\\n**Space Complexity - O(n)**\\n\\n\\n# **C++ Efficient/Optimised Solution**\\n1. We need to sort the vector first using the inbuilt sort() function.\\n2. Then by traversing the vector from index 1 to ondex n-1 we can check if the element is not equal to the first and last element present in the vector.\\n3. We are storing the count in the interger variable name res,\\n\\n```\\nint countElements(vector<int>& nums) {\\n        int res = 0;\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        for(int i = 1; i < n-1; i++)\\n        {\\n            if(nums[i] != nums[0] and nums[i] != nums[n-1])res++;\\n        }\\n        return res;\\n    }\\n```\\n**TIme Complexity - O(nlogn)**\\n**Space Complexity - O(n)**\\n\\n\\n**Please Upvote if you liked the solution**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countElements(vector<int>& nums) {\\n        int n = nums.size();\\n        int scount=0,gcount=0;\\n        int totalcount=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[i]<nums[j])\\n                    scount++;\\n                else if(nums[i]>nums[j])\\n                    gcount++;\\n            }\\n            if(scount>=1 && gcount>=1)\\n                totalcount+=1;\\n            scount=0;gcount=0;\\n        }\\n        return totalcount;\\n    }\\n```\n```\\nint countElements(vector<int>& nums) {\\n        int res = 0;\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        for(int i = 1; i < n-1; i++)\\n        {\\n            if(nums[i] != nums[0] and nums[i] != nums[n-1])res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711814,
                "title": "c-easy-to-understand-optimal-count-elements-with-strictly-smaller-and-greater-elements",
                "content": "**Using Sorting :**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countElements(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin() , nums.end());\\n        \\n        int minimum=nums[0];\\n        int maximum=nums[n-1];\\n        \\n        int count=0;\\n        \\n        for(int i=0 ; i<n ;i++)\\n        {\\n            if(nums[i]>minimum && nums[i]<maximum)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n\\t\\t}\\n\\t};\\n\\t\\nTime Complexity :- O(n logn)\\nSpace Complexity :- O(1)\\n\\n**With out Sorting :**\\n\\n\\tint countElements(vector<int>& nums) {\\n\\n    int mn=INT_MAX;\\n    int mx=INT_MIN;\\n    int ans=0;\\n    \\n    for(int i=0;i<nums.size();i++){\\n        mn = min(mn,nums[i]);\\n        mx = max(mx,nums[i]);\\n    }\\n    \\n    for(int i=0;i<nums.size();i++){\\n        if(nums[i]>mn && nums[i]<mx){\\n            ans++;\\n        }\\n    }\\n    return ans;\\n    }\\nTime Complexity :- O(N)\\nSpace Complexity :- O(1)\\n\\n**if you like this solution. so please upvoted.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countElements(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin() , nums.end());\\n        \\n        int minimum=nums[0];\\n        int maximum=nums[n-1];\\n        \\n        int count=0;\\n        \\n        for(int i=0 ; i<n ;i++)\\n        {\\n            if(nums[i]>minimum && nums[i]<maximum)\\n            {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1711634,
                "title": "simplest-and-easy-to-understand-java-code",
                "content": "class Solution {\\n      public int countElements(int[] nums) {\\n          Arrays.sort(nums);\\n          int n=nums.length,count=0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            int low=0,high=n-1;\\n            while(low<high){\\n                if(nums[i]>nums[low] && nums[i]<nums[high]){\\n                    count++;\\n                    break;\\n                }\\n                low++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int countElements(int[] nums) {\\n          Arrays.sort(nums);\\n          int n=nums.length,count=0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            int low=0,high=n-1;\\n            while(low<high){\\n                if(nums[i]>nums[low] && nums[i]<nums[high]){\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1711556,
                "title": "java-o-n-solution-max-and-min",
                "content": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Arrays.stream(nums).min().getAsInt();\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        int c = 0;\\n        for(int i = 0; i < nums.length; ++i) {\\n            if(nums[i] < max && nums[i] > min) c++;\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Arrays.stream(nums).min().getAsInt();\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        int c = 0;\\n        for(int i = 0; i < nums.length; ++i) {\\n            if(nums[i] < max && nums[i] > min) c++;\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711224,
                "title": "java-simple-single-loop-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, minCount = 0, maxCount = 0;\\n        \\n        for (int i = 0; i < nums.length; ++ i) {\\n            if (nums[i] < min) {\\n                min = nums[i];\\n                minCount = 1;\\n            } else if (nums[i] == min) {\\n                ++ minCount;\\n            } \\n            \\n            if (nums[i] > max) {\\n                max = nums[i];\\n                maxCount = 1;\\n            } else if (nums[i] == max) {\\n                ++ maxCount;\\n            }\\n        }\\n        \\n        return min == max ? 0 : nums.length - minCount - maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, minCount = 0, maxCount = 0;\\n        \\n        for (int i = 0; i < nums.length; ++ i) {\\n            if (nums[i] < min) {\\n                min = nums[i];\\n                minCount = 1;\\n            } else if (nums[i] == min) {\\n                ++ minCount;\\n            } \\n            \\n            if (nums[i] > max) {\\n                max = nums[i];\\n                maxCount = 1;\\n            } else if (nums[i] == max) {\\n                ++ maxCount;\\n            }\\n        }\\n        \\n        return min == max ? 0 : nums.length - minCount - maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831520,
                "title": "fastest-solution-constant-space-100-beats-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int countElements(int[] nums){\\n        int n = nums.length;\\n        if(n<3) return 0;\\n        int[] arr = minmax(nums);\\n        int min = arr[0];\\n        int max = arr[1];\\n        int c = 0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]!=min && nums[i]!=max) c++;\\n        }\\n        return c;\\n    }\\n\\n    public int[] minmax(int[] arr){\\n        int[] ans = new int[2];\\n        int max = arr[0], min = arr[0];\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max) max = arr[i];\\n            if(arr[i]<min) min = arr[i];\\n        }\\n        ans[0] = min;\\n        ans[1] = max;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int countElements(int[] nums){\\n        int n = nums.length;\\n        if(n<3) return 0;\\n        int[] arr = minmax(nums);\\n        int min = arr[0];\\n        int max = arr[1];\\n        int c = 0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]!=min && nums[i]!=max) c++;\\n        }\\n        return c;\\n    }\\n\\n    public int[] minmax(int[] arr){\\n        int[] ans = new int[2];\\n        int max = arr[0], min = arr[0];\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max) max = arr[i];\\n            if(arr[i]<min) min = arr[i];\\n        }\\n        ans[0] = min;\\n        ans[1] = max;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645040,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        d=dict()\\n        cnt=0\\n        for i in nums:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        nums=list(set(nums))\\n        nums.sort()\\n        if len(nums)>=3:\\n            for i in range(1,len(nums)-1):\\n                cnt+=d[nums[i]]\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        d=dict()\\n        cnt=0\\n        for i in nums:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        nums=list(set(nums))\\n        nums.sort()\\n        if len(nums)>=3:\\n            for i in range(1,len(nums)-1):\\n                cnt+=d[nums[i]]\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615745,
                "title": "recommended-stl-appoach-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\n        if(nums.size() == 1 || nums.size() == 2) return 0;\\n        int ma = *max_element(nums.begin(),nums.end());\\n        int countma = count(nums.begin(),nums.end(),ma);\\n        int mi = *min_element(nums.begin(),nums.end());\\n        int countmi = count(nums.begin(),nums.end(),mi);\\n        int ans = nums.size() - (countma+countmi);\\n        if(ans <= 0) return 0;\\n        return nums.size() - (countma+countmi);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\n        if(nums.size() == 1 || nums.size() == 2) return 0;\\n        int ma = *max_element(nums.begin(),nums.end());\\n        int countma = count(nums.begin(),nums.end(),ma);\\n        int mi = *min_element(nums.begin(),nums.end());\\n        int countmi = count(nums.begin(),nums.end(),mi);\\n        int ans = nums.size() - (countma+countmi);\\n        if(ans <= 0) return 0;\\n        return nums.size() - (countma+countmi);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398371,
                "title": "count-elements-with-strictly-smaller-and-greater-elements-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int min, max, i, count=0;\\n        min = *min_element(nums.begin(), nums.end());\\n        max = *max_element(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]>min && nums[i]<max)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int min, max, i, count=0;\\n        min = *min_element(nums.begin(), nums.end());\\n        max = *max_element(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]>min && nums[i]<max)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222782,
                "title": "easy-min-max-reduce-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countElements = function(nums) {\\n    const min = Math.min(...nums);\\n    const max = Math.max(...nums);\\n\\n    return nums.reduce((acc, num) => {\\n        if (num > min && num < max) {\\n            return acc + 1;\\n        }\\n        return acc;\\n    }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countElements = function(nums) {\\n    const min = Math.min(...nums);\\n    const max = Math.max(...nums);\\n\\n    return nums.reduce((acc, num) => {\\n        if (num > min && num < max) {\\n            return acc + 1;\\n        }\\n        return acc;\\n    }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206128,
                "title": "golang-w-o-map-sorting-time-n-log-n-space-0-1",
                "content": "\\n```\\nfunc countElements(nums []int) (res int) {\\n    sort.Ints(nums)\\n\\n    for _, v := range nums {\\n        if  v != nums[0] && v != nums[len(nums)-1] {\\n         res++\\n        }\\n    }\\n    return\\n \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countElements(nums []int) (res int) {\\n    sort.Ints(nums)\\n\\n    for _, v := range nums {\\n        if  v != nums[0] && v != nums[len(nums)-1] {\\n         res++\\n        }\\n    }\\n    return\\n \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2996172,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def countElements(self,nums:List[int])->int:\\n        ans=0\\n        mn=min(nums)\\n        mx=max(nums)\\n        for i in nums:\\n            if mn<i<mx:\\n                ans+=1\\n\\n        return ans                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self,nums:List[int])->int:\\n        ans=0\\n        mn=min(nums)\\n        mx=max(nums)\\n        for i in nums:\\n            if mn<i<mx:\\n                ans+=1\\n\\n        return ans                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882601,
                "title": "java-easy-solution-o-n-4ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums);\\n        int count =0;\\n        int count1 =0;\\n        int a = nums[0];\\n        int b = nums[nums.length-1];\\n        for(int i=0;i<nums.length;i++){\\n            if(a==nums[i]){\\n                count++;\\n            }\\n            else if(b == nums[i]){\\n                count++;\\n            }\\n        }\\n        return nums.length-(count+count1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums);\\n        int count =0;\\n        int count1 =0;\\n        int a = nums[0];\\n        int b = nums[nums.length-1];\\n        for(int i=0;i<nums.length;i++){\\n            if(a==nums[i]){\\n                count++;\\n            }\\n            else if(b == nums[i]){\\n                count++;\\n            }\\n        }\\n        return nums.length-(count+count1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876001,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int mn=nums[0];\\n        int mx=nums[n-1];\\n        int count=0;\\n        for(auto it:nums){\\n            if(it>mn&&it<mx){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int mn=nums[0];\\n        int mx=nums[n-1];\\n        int count=0;\\n        for(auto it:nums){\\n            if(it>mn&&it<mx){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2732983,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int maxi=INT_MIN,n=nums.size();\\n        int mini=INT_MAX,count=0,cnt=0;\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second==n)\\n                return 0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n            mini=min(mini,nums[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n             if(maxi==nums[i])\\n                 cnt++;\\n            if(mini==nums[i])\\n               count++;\\n        }\\n        \\n        return n-cnt-count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int maxi=INT_MIN,n=nums.size();\\n        int mini=INT_MAX,count=0,cnt=0;\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2675918,
                "title": "python-one-liner-o-n-time-o-1-space",
                "content": "Basic Python written under test conditions in under 3mins:\\n\\n```python\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Python solution takes the sum of values which are not the min or max of the\\n        array. The sum is calculated for i in nums if i is strictly between the min\\n        value of nums and the max value of nums.\\n        \\n        :param nums: the array to be analysed. (List[int])\\n        :return: val: the outcome value. (int)\\n        \"\"\"\\n        return sum(1 for i in nums if min(nums)<i<max(nums))",
                "solutionTags": [
                    "Python"
                ],
                "code": "Basic Python written under test conditions in under 3mins:\\n\\n```python\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Python solution takes the sum of values which are not the min or max of the\\n        array. The sum is calculated for i in nums if i is strictly between the min\\n        value of nums and the max value of nums.\\n        \\n        :param nums: the array to be analysed. (List[int])\\n        :return: val: the outcome value. (int)\\n        \"\"\"\\n        return sum(1 for i in nums if min(nums)<i<max(nums))",
                "codeTag": "Java"
            },
            {
                "id": 2611737,
                "title": "faster-approach-short-and-readable-beginner-s-friendly",
                "content": "def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        first_nums=nums[0]\\n        last_nums=nums[-1]\\n        count=0\\n        for i in range(1, len(nums)-1):\\n            if (nums[i]>first_nums and nums[i]<last_nums):\\n                count+=1\\n        return count",
                "solutionTags": [],
                "code": "def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        first_nums=nums[0]\\n        last_nums=nums[-1]\\n        count=0\\n        for i in range(1, len(nums)-1):\\n            if (nums[i]>first_nums and nums[i]<last_nums):\\n                count+=1\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2597337,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n        //what we will do\\n        sort(nums.begin(),nums.end());\\n        \\n        int x=nums[0];\\n        int y=nums[nums.size()-1];\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=x and nums[i]!=y)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n        //what we will do\\n        sort(nums.begin(),nums.end());\\n        \\n        int x=nums[0];\\n        int y=nums[nums.size()-1];\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=x and nums[i]!=y)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587469,
                "title": "easy-solution-o-n-1ms",
                "content": "class Solution {\\n    public int countElements(int[] nums) {\\n\\t\\n        int max=Integer.MIN_VALUE;\\n        int min=Integer.MAX_VALUE;\\n\\t\\t\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }\\n            if(min>nums[i]){\\n                min=nums[i];\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>min && nums[i]<max){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countElements(int[] nums) {\\n\\t\\n        int max=Integer.MIN_VALUE;\\n        int min=Integer.MAX_VALUE;\\n\\t\\t\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2552188,
                "title": "c-sorting-100-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count =0;\\n        int greatest = nums[nums.size()-1];\\n        int smallest = nums[0];\\n        for(int i =nums.size()-1;i>=0;){\\n           if ( nums[i] != greatest && nums[i] != smallest )\\n               count++;\\n               i--;\\n                                  \\n}\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count =0;\\n        int greatest = nums[nums.size()-1];\\n        int smallest = nums[0];\\n        for(int i =nums.size()-1;i>=0;){\\n           if ( nums[i] != greatest && nums[i] != smallest )\\n               count++;\\n               i--;\\n                                  \\n}\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510752,
                "title": "2148-count-elements-with-strictly-smaller-and-greater-elements",
                "content": "```\\n// DRY RUN IS THE MASTER KEY \\n// use both concepts that were used in celing and floor questions play smartly with start and end \\nclass Solution {\\n    public static boolean smaller(int arr1[],int target1)   {\\n       int start=0;\\n        int end =arr1.length-1;\\n        while(start<=end)  {\\n          int  mid=start+(end-start)/2; \\n          \\n           if(arr1[mid]>=target1)  \\n               end=mid-1;        \\n            else \\n               start=mid+1;\\n        }\\n      if(end ==-1 )\\n    return false ;\\n        else \\n            return true;\\n    }\\n\\n      public  static boolean greater(int arr2[],int target2)   {\\n       int start=0;\\n        int end =arr2.length-1;\\n        while(start<=end)  {\\n          int  mid=start+(end-start)/2;   \\n          \\n           if(arr2[mid]>target2)\\n               end=mid-1;\\n            else \\n               start=mid+1;\\n        }\\n      if(start ==arr2.length )\\n    return false ;\\n        else \\n            return true;\\n    }\\n    \\n    public int countElements(int[] nums)     {\\n        Arrays.sort(nums);     \\n        int count=0;\\n        for(int i=0;i<nums.length;i++)  {\\n            if(smaller(nums,nums[i])==true && greater(nums,nums[i]) ==true)  {\\n                count++;   \\n\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n        return count;  \\n\\t\\t} \\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public static boolean smaller(int arr1[],int target1)   {\\n       int start=0;\\n        int end =arr1.length-1;\\n        while(start<=end)  {\\n          int  mid=start+(end-start)/2; \\n          \\n           if(arr1[mid]>=target1)  \\n               end=mid-1;        \\n            else \\n               start=mid+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2459322,
                "title": "go-simple",
                "content": "```\\nfunc countElements(nums []int) int {\\n    min, max := nums[0], nums[0]\\n    numMap := make(map[int]int)\\n    \\n    for _, v := range nums {\\n        numMap[v]++\\n        if v > max {\\n            max = v\\n        } else if v < min {\\n            min = v\\n        }\\n    }\\n    \\n    if min == max {\\n        return 0\\n    }\\n    \\n    return len(nums) - numMap[max] - numMap[min]\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countElements(nums []int) int {\\n    min, max := nums[0], nums[0]\\n    numMap := make(map[int]int)\\n    \\n    for _, v := range nums {\\n        numMap[v]++\\n        if v > max {\\n            max = v\\n        } else if v < min {\\n            min = v\\n        }\\n    }\\n    \\n    if min == max {\\n        return 0\\n    }\\n    \\n    return len(nums) - numMap[max] - numMap[min]\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2450287,
                "title": "ruby-linear-time-o-n-memory-with-hash",
                "content": "```\\n\\tmax_val=-Float::INFINITY\\n    min_val=Float::INFINITY\\n    \\n    count=Hash.new(0)\\n    \\n    l=0\\n    while l<nums.length do    \\n        max_val=[max_val,nums[l]].max\\n        min_val=[min_val,nums[l]].min\\n        count[nums[l]]+=1\\n        l+=1\\n    end\\n    sum=nums.length-count[max_val]-count[min_val]\\n    sum<0 ? 0 : sum\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Math"
                ],
                "code": "```\\n\\tmax_val=-Float::INFINITY\\n    min_val=Float::INFINITY\\n    \\n    count=Hash.new(0)\\n    \\n    l=0\\n    while l<nums.length do    \\n        max_val=[max_val,nums[l]].max\\n        min_val=[min_val,nums[l]].min\\n        count[nums[l]]+=1\\n        l+=1\\n    end\\n    sum=nums.length-count[max_val]-count[min_val]\\n    sum<0 ? 0 : sum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2435423,
                "title": "100-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n\\t\\tint max = -100000;\\n        int maxCount = 0;\\n\\n        int min = 100000;\\n        int minCount = 0;\\n\\n        for (int i: nums){\\n            \\n            if (i < min){\\n                min = i;\\n                minCount = 1;\\n            } \\n            else if (i == min) {\\n                minCount++;\\n            }\\n\\n            if (i > max){\\n                max = i;\\n                maxCount = 1;\\n            }\\n            else if (i == max) {\\n                maxCount++;\\n            }\\n\\n        }\\n\\t\\t\\n        if (nums.length <= minCount + maxCount) return 0;\\n\\n        return nums.length - minCount - maxCount;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2381291,
                "title": "easy-javascript-solution-with-loop-based",
                "content": "```\\nvar countElements = function (nums) {\\n    let count = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        let icount = 0;\\n        let dcount = 0;\\n        for (let j = 0; j < nums.length; j++) {\\n            if (i != j && nums[i] > nums[j]) {\\n                icount += 1;\\n            }\\n            if (i != j && nums[i] < nums[j]) {\\n                dcount += 1;\\n            }\\n        }\\n        if (icount >= 1 && dcount >= 1) {\\n            count += 1;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countElements = function (nums) {\\n    let count = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        let icount = 0;\\n        let dcount = 0;\\n        for (let j = 0; j < nums.length; j++) {\\n            if (i != j && nums[i] > nums[j]) {\\n                icount += 1;\\n            }\\n            if (i != j && nums[i] < nums[j]) {\\n                dcount += 1;\\n            }\\n        }\\n        if (icount >= 1 && dcount >= 1) {\\n            count += 1;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2372110,
                "title": "very-easy-python",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        min_=min(nums)\\n        max_=max(nums)\\n        c=0\\n        for i in nums:\\n            if min_<i<max_:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        min_=min(nums)\\n        max_=max(nums)\\n        c=0\\n        for i in nums:\\n            if min_<i<max_:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321322,
                "title": "py3-simple-o-n",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        \\n        mn=float(\"inf\")\\n        mx=float(\\'-inf\\')\\n        \\n        d={}\\n        for i in nums:\\n            mn=min(mn,i)\\n            mx=max(mx,i)\\n            if i in d:d[i]+=1\\n            else:d[i]=1\\n        c=0\\n        for i in d: \\n            if i>mn and i<mx:c+=d[i]\\n        \\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        \\n        mn=float(\"inf\")\\n        mx=float(\\'-inf\\')\\n        \\n        d={}\\n        for i in nums:\\n            mn=min(mn,i)\\n            mx=max(mx,i)\\n            if i in d:d[i]+=1\\n            else:d[i]=1\\n        c=0\\n        for i in d: \\n            if i>mn and i<mx:c+=d[i]\\n        \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302173,
                "title": "python-solution",
                "content": "```class Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mn=min(nums)\\n        mx=max(nums)\\n        c=0\\n        for i in nums:\\n            if i< mx and i>mn:\\n                c+=1\\n        return c",
                "solutionTags": [],
                "code": "```class Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mn=min(nums)\\n        mx=max(nums)\\n        c=0\\n        for i in nums:\\n            if i< mx and i>mn:\\n                c+=1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 2300268,
                "title": "java-0ms-faster-than-100-o-n-1-pass-3-approaches",
                "content": "- 0ms solution, faster than 100%. Single pass using min-max\\n[https://leetcode.com/submissions/detail/750370398/](https://leetcode.com/submissions/detail/750370398/)\\n\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int min = nums[0], minOccurrences = 1, max = nums[0], maxOccurrences = 1;\\n        for (int i = 1; i < nums.length; ++i) {\\n            if (nums[i] < min) {\\n                min = nums[i];\\n                minOccurrences = 1;\\n            } else if (nums[i] == min) {\\n                minOccurrences++;\\n            }\\n            if (max < nums[i]) {\\n                max = nums[i];\\n                maxOccurrences = 1;\\n            } else if (max == nums[i]) {\\n                maxOccurrences++;\\n            }\\n        }\\n        return min == max ? nums.length - minOccurrences : nums.length - minOccurrences - maxOccurrences;\\n    }\\n}\\n\\n```\\n\\n- Approach 2: 1ms solution using min-max but in 2 passes\\n\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n;i++) {\\n            min = Math.min(nums[i], min);\\n            max = Math.max(nums[i], max);\\n        }\\n        for(int i=0; i<n;i++) {\\n            if(nums[i]>min && nums[i]<max) {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n- Approach 3: Using Map & SortedSet\\n\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        SortedSet<Integer> ss = new TreeSet<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int n: nums) {\\n            ss.add(n);\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        for(int s: ss) {\\n            if(s!=ss.first() && s!=ss.last()) {\\n                count += map.get(s);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int min = nums[0], minOccurrences = 1, max = nums[0], maxOccurrences = 1;\\n        for (int i = 1; i < nums.length; ++i) {\\n            if (nums[i] < min) {\\n                min = nums[i];\\n                minOccurrences = 1;\\n            } else if (nums[i] == min) {\\n                minOccurrences++;\\n            }\\n            if (max < nums[i]) {\\n                max = nums[i];\\n                maxOccurrences = 1;\\n            } else if (max == nums[i]) {\\n                maxOccurrences++;\\n            }\\n        }\\n        return min == max ? nums.length - minOccurrences : nums.length - minOccurrences - maxOccurrences;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n;i++) {\\n            min = Math.min(nums[i], min);\\n            max = Math.max(nums[i], max);\\n        }\\n        for(int i=0; i<n;i++) {\\n            if(nums[i]>min && nums[i]<max) {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        SortedSet<Integer> ss = new TreeSet<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int n: nums) {\\n            ss.add(n);\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        for(int s: ss) {\\n            if(s!=ss.first() && s!=ss.last()) {\\n                count += map.get(s);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243894,
                "title": "simple-javascript-solution-with-40-faster",
                "content": "Runtime: 96 ms, faster than 39.31% of JavaScript online submissions for Count Elements With Strictly Smaller and Greater Elements .\\nMemory Usage: 41.9 MB, less than 86.90% of JavaScript online submissions for Count Elements With Strictly Smaller and Greater Elements \\n\\nvar countElements = function(nums) {\\n    const minEl = Math.min(...nums)\\n    const maxEl = Math.max(...nums)\\n    if (minEl === maxEl) return 0\\n    const minCount = nums.filter(el => el === minEl).length\\n    const maxCount = nums.filter(el => el === maxEl).length\\n    \\n    return nums.length - minCount - maxCount\\n    \\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Runtime: 96 ms, faster than 39.31% of JavaScript online submissions for Count Elements With Strictly Smaller and Greater Elements .\\nMemory Usage: 41.9 MB, less than 86.90% of JavaScript online submissions for Count Elements With Strictly Smaller and Greater Elements \\n\\nvar countElements = function(nums) {\\n    const minEl = Math.min(...nums)\\n    const maxEl = Math.max(...nums)\\n    if (minEl === maxEl) return 0\\n    const minCount = nums.filter(el => el === minEl).length\\n    const maxCount = nums.filter(el => el === maxEl).length\\n    \\n    return nums.length - minCount - maxCount\\n    \\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2193796,
                "title": "c-0ms-100-faster-solution-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        map<int,int> m;\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        ans=nums.size()-(m.begin())->second-(--(m.end()))->second;\\n        if(ans>0)\\n        return ans;\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        map<int,int> m;\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        ans=nums.size()-(m.begin())->second-(--(m.end()))->second;\\n        if(ans>0)\\n        return ans;\\n        return 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2159347,
                "title": "c-easy-to-understand-touch-of-binary-search-to-find-min-and-max",
                "content": "**Approch : **\\n\\tFor each nums[i], we will find lesser element than it in its left side and greater element than it in its right side. If we found both greater and smaller element then we will increase our answer count by one.\\n\\n1. Sort the array - position of element does not matter to solve problem.\\n2. Outer for loop for travers through array.\\n3. First while for checking availability of lesser value than nums[i] , if found than will set min=1.\\n4. Second while for checking availability of greater value than nums[i] , if found will set max=1.\\n5. If for the same nums[i], min and max both are 1 then we will increase count by 1 which is our ans at the end of array.\\n\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n        if(nums.size()==1)  return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int count=0,min=0,max=0;\\n        int low=0,high=nums.size()-1,mid;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            while(low<=high)\\n            {\\n                mid =low + (high-low)/2;\\n                if(nums[mid]<nums[i])   {min=1;break;}\\n                else    high=mid-1;\\n            }\\n            \\n            low=0,high=nums.size()-1;\\n            while(low<=high)\\n            {\\n                mid =low + (high-low)/2;\\n                if(nums[mid]>nums[i])   {max=1;break;}\\n                else    low=mid+1;\\n            }\\n            \\n            if(min==1 && max==1)    {count++;}\\n            \\n            min=0;max=0;\\n            low=0,high=nums.size()-1;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nDon\\'t forgot to upvote in case you liked it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n        if(nums.size()==1)  return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int count=0,min=0,max=0;\\n        int low=0,high=nums.size()-1,mid;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            while(low<=high)\\n            {\\n                mid =low + (high-low)/2;\\n                if(nums[mid]<nums[i])   {min=1;break;}\\n                else    high=mid-1;\\n            }\\n            \\n            low=0,high=nums.size()-1;\\n            while(low<=high)\\n            {\\n                mid =low + (high-low)/2;\\n                if(nums[mid]>nums[i])   {max=1;break;}\\n                else    low=mid+1;\\n            }\\n            \\n            if(min==1 && max==1)    {count++;}\\n            \\n            min=0;max=0;\\n            low=0,high=nums.size()-1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100348,
                "title": "java-solution-in-one-pass-without-extra-memory",
                "content": "the idea is you need to know the minimum and maximum value of the array then all the points left will satisfy given condition which means find the occurences of all min\\'s and max\\'s and remove from total array items. here we have a cornor case when all the element are same which gives -> min == max so in this case o/p will be 0\\n\\n![image](https://assets.leetcode.com/users/images/8588a0a5-a355-4471-b289-7aa3ab9ea444_1654137116.6236634.png)\\n\\n```\\nclass Solution {\\n    public int countElements(int[] a) {\\n      int min = a[0] , max = a[0];\\n      int minocr = 1, maxocr= 1;\\n      for(int i = 1 ; i < a.length ; ++i){\\n          {\\n          if(a[i] < min) {min = a[i]; minocr = 1;}\\n          else if(a[i] == min) minocr ++;\\n          }\\n          {\\n          if(a[i] > max) {max = a[i]; maxocr = 1;}\\n          else if(a[i] == max) maxocr ++;\\n          }\\n      }\\n        return (min==max) ? 0: a.length - minocr - maxocr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] a) {\\n      int min = a[0] , max = a[0];\\n      int minocr = 1, maxocr= 1;\\n      for(int i = 1 ; i < a.length ; ++i){\\n          {\\n          if(a[i] < min) {min = a[i]; minocr = 1;}\\n          else if(a[i] == min) minocr ++;\\n          }\\n          {\\n          if(a[i] > max) {max = a[i]; maxocr = 1;}\\n          else if(a[i] == max) maxocr ++;\\n          }\\n      }\\n        return (min==max) ? 0: a.length - minocr - maxocr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074572,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\t  int count=0;\\n        int n=nums.size();\\n        int min=nums[0],max=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(min>nums[i])\\n                min=nums[i];\\n            if(max<nums[i])\\n                max=nums[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=min && nums[i]!=max)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\t  int count=0;\\n        int n=nums.size();\\n        int min=nums[0],max=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(min>nums[i])\\n                min=nums[i];\\n            if(max<nums[i])\\n                max=nums[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=min && nums[i]!=max)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068677,
                "title": "cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int l=nums[0];\\n        int h=nums[nums.size()-1];\\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>l&&nums[i]<h)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int l=nums[0];\\n        int h=nums[nums.size()-1];\\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>l&&nums[i]<h)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066883,
                "title": "85-faster-c-solution-easy-understanding-time-o-n-logn-space-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/77549938-3be2-4f1b-beb9-2e422cf205cc_1653313340.3997054.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int cnt = 0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n-1;i++){\\n            if(nums[i]>nums[0] and nums[i]<nums[n-1]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int cnt = 0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n-1;i++){\\n            if(nums[i]>nums[0] and nums[i]<nums[n-1]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982622,
                "title": "c-o-n-time-o-1-space-0ms-faster-than-100-9-1mb-less-than-82",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count Elements With Strictly Smaller and Greater Elements .\\nMemory Usage: 9.1 MB, less than 82.22% of C++ online submissions for Count Elements With Strictly Smaller and Greater Elements .\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int countElements(vector<int>& nums) \\n    {\\n        if (nums.size() <= 2)\\n            return 0;\\n        \\n        int ma = INT_MIN, mi = INT_MAX;\\n        for (const int& n : nums)\\n        {\\n            if (ma < n)\\n                ma = n;\\n            if (mi > n)\\n                mi = n;\\n        }\\n        \\n        int count = 0;\\n        for (const int& n : nums)\\n        {\\n            if (n > mi && n < ma)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countElements(vector<int>& nums) \\n    {\\n        if (nums.size() <= 2)\\n            return 0;\\n        \\n        int ma = INT_MIN, mi = INT_MAX;\\n        for (const int& n : nums)\\n        {\\n            if (ma < n)\\n                ma = n;\\n            if (mi > n)\\n                mi = n;\\n        }\\n        \\n        int count = 0;\\n        for (const int& n : nums)\\n        {\\n            if (n > mi && n < ma)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943367,
                "title": "java-faster-than-100-with-min-max-variables",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Count Elements With Strictly Smaller and Greater Elements .\\nMemory Usage: 40.6 MB, less than 87.69% of Java online submissions for Count Elements With Strictly Smaller and Greater Elements .\\n\\n```\\npublic int countElements(int[] nums) {\\n        \\n        int ans = 0; \\n        /*\\n        //Sort solution\\n        Arrays.sort(nums);\\n        int l =0;\\n        int r = nums.length -1;\\n        \\n        while(l < nums.length -2 && nums[l] == nums[l+1]) l++;\\n        while(r > 1 && nums[r] == nums[r-1]) r--;\\n        \\n        return Math.max(r - l-1, 0);\\n        */\\n        \\n        //No sort solution\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int i=0; i< nums.length;i++){\\n            if(min > nums[i]) min = nums[i];\\n            if(max < nums[i]) max = nums[i];\\n        }\\n        \\n        for(int i=0; i< nums.length;i++){\\n            if(nums[i] > min && nums[i] < max) ans++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Count Elements With Strictly Smaller and Greater Elements .\\nMemory Usage: 40.6 MB, less than 87.69% of Java online submissions for Count Elements With Strictly Smaller and Greater Elements .\\n\\n```\\npublic int countElements(int[] nums) {\\n        \\n        int ans = 0; \\n        /*\\n        //Sort solution\\n        Arrays.sort(nums);\\n        int l =0;\\n        int r = nums.length -1;\\n        \\n        while(l < nums.length -2 && nums[l] == nums[l+1]) l++;\\n        while(r > 1 && nums[r] == nums[r-1]) r--;\\n        \\n        return Math.max(r - l-1, 0);\\n        */\\n        \\n        //No sort solution\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int i=0; i< nums.length;i++){\\n            if(min > nums[i]) min = nums[i];\\n            if(max < nums[i]) max = nums[i];\\n        }\\n        \\n        for(int i=0; i< nums.length;i++){\\n            if(nums[i] > min && nums[i] < max) ans++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1885959,
                "title": "actually-easy-to-understand-solution-o-n-c-one-for-loop",
                "content": "class Solution {\\npublic:\\n\\n    int countElements(vector<int>& nums) {\\n        int len = nums.size();\\n        if(len < 2) return 0; // Early exit\\n         \\n        int min = nums[0];\\n        int minCount = 1;\\n        int max = min;\\n        int maxCount = 1;\\n        \\n        // Count how many same min and same max numbers exist.\\n        // Reset count if you find lower than current min or\\n        // higher than current max.\\n        for(int i = 1; i < len; i++){\\n            if(nums[i] < min){\\n                min = nums[i];\\n                minCount = 1;\\n            }\\n            else if(nums[i] == min){\\n                minCount++;\\n            }\\n            if(nums[i] > max){\\n                max = nums[i];\\n                maxCount = 1;\\n            }\\n            else if(nums[i] == max){\\n                maxCount++;\\n            }\\n        }\\n        \\n        // If min and max are the same than there are no numbers in between.\\n        // Else number of elements in between is len - count of min and max numbers.\\n        if(min == max) return 0;\\n        return len - maxCount - minCount;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int countElements(vector<int>& nums) {\\n        int len = nums.size();\\n        if(len < 2) return 0; // Early exit\\n         \\n        int min = nums[0];\\n        int minCount = 1;\\n        int max = min;\\n        int maxCount = 1;\\n        \\n        // Count how many same min and same max numbers exist.\\n        // Reset count if you find lower than current min or\\n        // higher than current max.\\n        for(int i = 1; i < len; i++){\\n            if(nums[i] < min){\\n                min = nums[i];\\n                minCount = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1880319,
                "title": "simple-javascript-solution",
                "content": "```\\nvar countElements = function(nums) {\\n    let map = {}, total = 0;\\n    \\n    // adding elements to map\\n    for(let i of nums) map[i] ? map[i]++ : map[i] = 1;\\n    \\n    // Removing repeated elements\\n    let newNums = [... new Set(nums)];\\n    \\n    // If length of array after removing repeated nums is less than three return 0;\\n    if(newNums.length < 3) return 0;\\n    \\n    // sort the newNums array and remove the first and last element.\\n    // for all the remaining elements check their number in map and add it to total variable\\n    newNums.sort((a,b) => a-b).slice(1, newNums.length-1).forEach(num => total += map[num]);\\n    \\n    // return total variable\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countElements = function(nums) {\\n    let map = {}, total = 0;\\n    \\n    // adding elements to map\\n    for(let i of nums) map[i] ? map[i]++ : map[i] = 1;\\n    \\n    // Removing repeated elements\\n    let newNums = [... new Set(nums)];\\n    \\n    // If length of array after removing repeated nums is less than three return 0;\\n    if(newNums.length < 3) return 0;\\n    \\n    // sort the newNums array and remove the first and last element.\\n    // for all the remaining elements check their number in map and add it to total variable\\n    newNums.sort((a,b) => a-b).slice(1, newNums.length-1).forEach(num => total += map[num]);\\n    \\n    // return total variable\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1837794,
                "title": "python-one-of-the-best-approach-with-explaination",
                "content": "In the discussions  i can see posts of many people doing this problem using max and min but here i thought a bit differently.though its not that effcient approach i thought may be you should know another way of solving this\\n\\n\\n** Here comes the idea we need to check that whether each and every elem has a greater elem or smaller elem so what if they are sorted then we can simply check whether they have any greater elem or smaller element next to them so we should start iterating from 1 to last before element leaving first and last elem because since they are sorted there can be no element which is greather than last elem and smaller than first elem. but the problem is what if we have duplicates suppose -3 3 3 90  in this 3 compares with the next elem 3 should be greateer but not equal so what we do is we remove duplicates by using sets and we also find the frequency because if we remove the duplicates then array will be [-3,3,90] since 3<90 and 3>-1 we have two such 3\\'s so we add our count with the frequency of that element**\\n\\n```\\n        c=0\\n        from collections import Counter\\n        d=Counter(nums)\\n        nums=list(set(nums))\\n        nums.sort()\\n        for i in range(1,len(nums)-1):\\n            if nums[i]<nums[i+1] and nums[i]>nums[i-1]:\\n                c+=d[nums[i]]\\n        return c\\n```\\n\\n\\n\\n\\n\\n*I HOPE U UNDERSTOOD MY EXPLAINATION IF YES PLEASE UPVOTE THIS ANSWER*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\n        c=0\\n        from collections import Counter\\n        d=Counter(nums)\\n        nums=list(set(nums))\\n        nums.sort()\\n        for i in range(1,len(nums)-1):\\n            if nums[i]<nums[i+1] and nums[i]>nums[i-1]:\\n                c+=d[nums[i]]\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1828746,
                "title": "python-99-28-faster-approach",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        if len(set(nums))<=2:\\n            return 0\\n        count = nums.count(min(nums))\\n        for i in range(count):\\n            nums.remove(min(nums))\\n        count = nums.count(max(nums))\\n        for i in range(count):\\n            nums.remove(max(nums))\\n        return len(nums)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        if len(set(nums))<=2:\\n            return 0\\n        count = nums.count(min(nums))\\n        for i in range(count):\\n            nums.remove(min(nums))\\n        count = nums.count(max(nums))\\n        for i in range(count):\\n            nums.remove(max(nums))\\n        return len(nums)",
                "codeTag": "Java"
            },
            {
                "id": 1818673,
                "title": "1-line-python-solution-memory-less-than-99",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        return len([num for num in nums if num not in {min(nums),max(nums)}])\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        return len([num for num in nums if num not in {min(nums),max(nums)}])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789742,
                "title": "easy-and-short-python-solutions",
                "content": "```\\nclass Solution:\\n    def countElements_v1(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Mimic the procedure\\n        \"\"\"\\n        nums.sort()\\n        head = nums[0]\\n        tail = nums[-1]\\n        while nums and nums[-1] == tail:\\n            nums.pop()\\n        while nums and nums[0] == head:\\n            nums.pop(0)       \\n        return len(nums)\\n    \\n    def countElements(self, nums: List[int]) -> int:\\n        \"\"\"two-pointer, while it is in fact brute force\"\"\"\\n        \\n        nums.sort()\\n        n = len(nums)\\n        i = 1\\n        while i < n:\\n            if nums[i] == nums[0]:\\n                i += 1\\n            else:\\n                break\\n        j = n - 2\\n        while j >= 0:\\n            if nums[j] == nums[n-1]:\\n                j -= 1\\n            else:\\n                break\\n        return j - i + 1 if j - i + 1 >= 0 else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countElements_v1(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Mimic the procedure\\n        \"\"\"\\n        nums.sort()\\n        head = nums[0]\\n        tail = nums[-1]\\n        while nums and nums[-1] == tail:\\n            nums.pop()\\n        while nums and nums[0] == head:\\n            nums.pop(0)       \\n        return len(nums)\\n    \\n    def countElements(self, nums: List[int]) -> int:\\n        \"\"\"two-pointer, while it is in fact brute force\"\"\"\\n        \\n        nums.sort()\\n        n = len(nums)\\n        i = 1\\n        while i < n:\\n            if nums[i] == nums[0]:\\n                i += 1\\n            else:\\n                break\\n        j = n - 2\\n        while j >= 0:\\n            if nums[j] == nums[n-1]:\\n                j -= 1\\n            else:\\n                break\\n        return j - i + 1 if j - i + 1 >= 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749951,
                "title": "java-0ms-100-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If nums.length is 0,1 or 2 then there can not be such \"special\" number. Return 0.\\n        2. In order for such \"special\" numbers to exist, they need to be greater than the smallest number \\n           and lesser than the greatest number.\\n        3. From #2, deduct that all it is required to do is to count/get the cardinal of smallest and greatest number.\\n           The number of \"special\" numbers is the difference between the total numbers and cardinal (smallest, greatest)\\n           Putting this into a different perspective:\\n             [4,2,4,7,5,6,2] -> (sorted) [2,2,4,4,5,6,7]\\n             What is required is to know how many numbers are between idx 2 and 5 (including)\\n           \\n           EG: [5,2,1,5,7,1,7,2,7]\\n           The min is 1 and there are 2 ones.\\n           The max is 7 and there are 3 sevens.\\n           The array has a length of 9.\\n           The total number of special numbers is 9 - (2+3). = 4;\\n    */\\n    public int countElements(int[] nums) {\\n        if (nums.length < 3) {\\n            return 0;\\n        }\\n        int minCount = 0, minValue = nums[0];\\n        int maxCount = 0, maxValue = nums[nums.length -1];\\n        for (int num : nums) {\\n            if (num < minValue) {\\n                minValue = num;\\n                minCount = 1;\\n            } else if (num == minValue) {\\n                minCount++;\\n            }\\n            if (num > maxValue) {\\n                maxValue =  num;\\n                maxCount = 1;\\n            } else if (num == maxValue) {\\n                maxCount++;\\n            }\\n        }\\n        return minValue == maxValue ? 0 : (nums.length - (minCount + maxCount));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If nums.length is 0,1 or 2 then there can not be such \"special\" number. Return 0.\\n        2. In order for such \"special\" numbers to exist, they need to be greater than the smallest number \\n           and lesser than the greatest number.\\n        3. From #2, deduct that all it is required to do is to count/get the cardinal of smallest and greatest number.\\n           The number of \"special\" numbers is the difference between the total numbers and cardinal (smallest, greatest)\\n           Putting this into a different perspective:\\n             [4,2,4,7,5,6,2] -> (sorted) [2,2,4,4,5,6,7]\\n             What is required is to know how many numbers are between idx 2 and 5 (including)\\n           \\n           EG: [5,2,1,5,7,1,7,2,7]\\n           The min is 1 and there are 2 ones.\\n           The max is 7 and there are 3 sevens.\\n           The array has a length of 9.\\n           The total number of special numbers is 9 - (2+3). = 4;\\n    */\\n    public int countElements(int[] nums) {\\n        if (nums.length < 3) {\\n            return 0;\\n        }\\n        int minCount = 0, minValue = nums[0];\\n        int maxCount = 0, maxValue = nums[nums.length -1];\\n        for (int num : nums) {\\n            if (num < minValue) {\\n                minValue = num;\\n                minCount = 1;\\n            } else if (num == minValue) {\\n                minCount++;\\n            }\\n            if (num > maxValue) {\\n                maxValue =  num;\\n                maxCount = 1;\\n            } else if (num == maxValue) {\\n                maxCount++;\\n            }\\n        }\\n        return minValue == maxValue ? 0 : (nums.length - (minCount + maxCount));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717291,
                "title": "go-golang-solution",
                "content": "```go\\nfunc countElements(nums []int) int {\\n    sort.Ints(nums)\\n    min, max := nums[0], nums[len(nums) - 1]\\n    minC, maxC := 0, 0\\n    if min == max { return 0 }\\n    for _, v := range nums {\\n        if v == min { minC++ }\\n        if v == max { maxC++ }\\n    }\\n    return len(nums) - minC - maxC\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc countElements(nums []int) int {\\n    sort.Ints(nums)\\n    min, max := nums[0], nums[len(nums) - 1]\\n    minC, maxC := 0, 0\\n    if min == max { return 0 }\\n    for _, v := range nums {\\n        if v == min { minC++ }\\n        if v == max { maxC++ }\\n    }\\n    return len(nums) - minC - maxC\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1716322,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n    \\n        for (int i = 0; i < nums.length; i++) {\\n            min = Math.min(min, nums[i]);\\n        }\\n        \\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != max) {\\n                if (nums[i] > min && nums[i] < max) \\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n    \\n        for (int i = 0; i < nums.length; i++) {\\n            min = Math.min(min, nums[i]);\\n        }\\n        \\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != max) {\\n                if (nums[i] > min && nums[i] < max) \\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716013,
                "title": "a-few-solutions",
                "content": "Return the accumulated count of each value `x` of the input array `A` where `lo < x < hi`.\\n    \\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countElements(A: IntArray): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1 + m.getOrDefault(x, 0)\\n        var (lo, hi) = Pair(A.min(), A.max())\\n        return m.map{ (x, _) -> if (lo!! < x && x < hi!!) m[x]!! else 0 }.sum()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countElements = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1 + (m.get(x) || 0));\\n    let lo = Math.min(...A),\\n        hi = Math.max(...A);\\n    return _.sum([...m].map(([x, _]) => lo < x && x < hi ? m.get(x) : 0));\\n};\\n```\\n\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countElements(self, A: List[int]) -> int:\\n        m = Counter(A)\\n        lo, hi = min(A), max(A)\\n        return sum(m[x] for x in m.keys() if lo < x < hi)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_elements(A: VI) -> i32 {\\n        let mut m = std::collections::HashMap::new();\\n        let (lo, hi) = (&A.iter().min().unwrap(), &A.iter().max().unwrap());\\n        for x in &A {\\n            let cnt = m.entry(x).or_insert(0); *cnt += 1;\\n        }\\n        return m.iter().map(|(x, cnt)| if (lo < x && x < hi) { *cnt } else { 0 }).sum();\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int countElements(VI& A, Map m = {}, int t = 0) {\\n        for (auto x: A)\\n            ++m[x];\\n        auto [lo, hi] = minmax_element(A.begin(), A.end());\\n        for (auto [x, _]: m)\\n            if (*lo < x && x < *hi)\\n                t += m[x];\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countElements(A: IntArray): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1 + m.getOrDefault(x, 0)\\n        var (lo, hi) = Pair(A.min(), A.max())\\n        return m.map{ (x, _) -> if (lo!! < x && x < hi!!) m[x]!! else 0 }.sum()!!\\n    }\\n}\\n```\n```\\nlet countElements = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1 + (m.get(x) || 0));\\n    let lo = Math.min(...A),\\n        hi = Math.max(...A);\\n    return _.sum([...m].map(([x, _]) => lo < x && x < hi ? m.get(x) : 0));\\n};\\n```\n```\\nclass Solution:\\n    def countElements(self, A: List[int]) -> int:\\n        m = Counter(A)\\n        lo, hi = min(A), max(A)\\n        return sum(m[x] for x in m.keys() if lo < x < hi)\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_elements(A: VI) -> i32 {\\n        let mut m = std::collections::HashMap::new();\\n        let (lo, hi) = (&A.iter().min().unwrap(), &A.iter().max().unwrap());\\n        for x in &A {\\n            let cnt = m.entry(x).or_insert(0); *cnt += 1;\\n        }\\n        return m.iter().map(|(x, cnt)| if (lo < x && x < hi) { *cnt } else { 0 }).sum();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int countElements(VI& A, Map m = {}, int t = 0) {\\n        for (auto x: A)\\n            ++m[x];\\n        auto [lo, hi] = minmax_element(A.begin(), A.end());\\n        for (auto [x, _]: m)\\n            if (*lo < x && x < *hi)\\n                t += m[x];\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715518,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn count_elements(nums: Vec<i32>) -> i32 {\\n        let (mut min_val, mut max_val) = (i32::MAX, i32::MIN);\\n        nums.iter().for_each(|&x| {\\n            if x < min_val {\\n                min_val = x\\n            }\\n            if x > max_val {\\n                max_val = x\\n            }\\n        });\\n        nums.iter().filter(|&&x| x > min_val && x < max_val).count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_elements(nums: Vec<i32>) -> i32 {\\n        let (mut min_val, mut max_val) = (i32::MAX, i32::MIN);\\n        nums.iter().for_each(|&x| {\\n            if x < min_val {\\n                min_val = x\\n            }\\n            if x > max_val {\\n                max_val = x\\n            }\\n        });\\n        nums.iter().filter(|&&x| x > min_val && x < max_val).count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715168,
                "title": "python-easy-100-faster-2-lines-simple-method",
                "content": "**Approach:** Find the total number of repetation of max and min number and subtract it from total numbers in list. \\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        count=len(nums)-nums.count(max(nums))-nums.count(min(nums))\\n        return max(count,0)\\n```\\n![image](https://assets.leetcode.com/users/images/ea32efe2-cae6-4ca7-a737-353da140d753_1643009538.7241454.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        count=len(nums)-nums.count(max(nums))-nums.count(min(nums))\\n        return max(count,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714311,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n       \\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int n = nums.length-1;\\n        \\n        for(int i :nums){\\n            min = Math.min(min, i);\\n            max = Math.max(max,i);\\n        }\\n        \\n        for(int i :nums){\\n            if(i == min || i == max){\\n                n--;\\n            }\\n        }\\n        return n+1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countElements(int[] nums) {\\n       \\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int n = nums.length-1;\\n        \\n        for(int i :nums){\\n            min = Math.min(min, i);\\n            max = Math.max(max,i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1712661,
                "title": "min-and-max",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        \\n        mn = min(nums) \\n        mx = max(nums)\\n        \\n        res = 0\\n        \\n        for i in nums:\\n            if i!=mn and i!=mx:\\n                res += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        \\n        mn = min(nums) \\n        mx = max(nums)\\n        \\n        res = 0\\n        \\n        for i in nums:\\n            if i!=mn and i!=mx:\\n                res += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712417,
                "title": "c-sorting-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n          int n = nums.size();\\n          \\n          if(n==1) return 0;\\n        \\n          int ans =0;\\n          sort(nums.begin(), nums.end());\\n        \\n          for(int i=1; i<n-1; i++){\\n              if(nums[i] != nums[0] && nums[i]!=nums[n-1]) ans++;\\n          }\\n         \\n          return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n          int n = nums.size();\\n          \\n          if(n==1) return 0;\\n        \\n          int ans =0;\\n          sort(nums.begin(), nums.end());\\n        \\n          for(int i=1; i<n-1; i++){\\n              if(nums[i] != nums[0] && nums[i]!=nums[n-1]) ans++;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1711779,
                "title": "best-c-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countElements(vector<int>& nums) {\\n\\t\\t\\tsort(begin(nums),end(nums));\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]!=nums[0] && nums[i]!=nums.back())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countElements(vector<int>& nums) {\\n\\t\\t\\tsort(begin(nums),end(nums));\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]!=nums[0] && nums[i]!=nums.back())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1711663,
                "title": "c-exclude-min-max-o-1-space-solution",
                "content": "**C++ Code with Explanation  **\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t//for vector of size 1 or 2 , it is impossible\\n        if(n<3) return 0; \\n\\t\\t\\n        \\n\\t\\t// [x, 1,2,3,4,5,y] ---> if x&y are not present in [1,2,3,4,5]...then our answer is 1,2,3,4,5\\n\\t\\t\\n        if(find(nums.begin()+1,nums.end()-1,nums[0])==nums.end() && find(nums.begin()+1,nums.end()-1,nums[n-1])==nums.end()) {\\n            return n-2;\\n        }\\n        \\n\\t\\t// [x, 1,x,3,y,y,y] ---> if x&y are both present in [1,2,3,4,5]...then our answer is 1,3 (because x & y are not strictly greater or smaller than itself)\\n\\t\\t\\n        else if(find(nums.begin()+1,nums.end()-1,nums[0])!=nums.end() && find(nums.begin()+1,nums.end()-1,nums[n-1])!=nums.end() && nums[0]!=nums[n-1]) {\\n\\t\\t\\n\\t\\t//a= number of times x appear in between x & y\\n\\t\\t//b= number of times y appear in between x & y\\n\\t\\t\\n            int a = count(nums.begin()+1,nums.end()-1,nums[0]);\\n            int b = count(nums.begin()+1,nums.end()-1,nums[n-1]);\\n            return n-2-a-b;\\n        }\\n\\t\\n        return 0;\\n    }\\n};\\n```\\n\\n**For better readability :**\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        if(n<3) return 0; \\n        \\n        if(find(nums.begin()+1,nums.end()-1,nums[0])==nums.end() && find(nums.begin()+1,nums.end()-1,nums[n-1])==nums.end()) {\\n            return n-2;\\n        }\\n        \\n       else if(find(nums.begin()+1,nums.end()-1,nums[0])!=nums.end() && find(nums.begin()+1,nums.end()-1,nums[n-1])!=nums.end() && nums[0]!=nums[n-1]) {\\n            int a = count(nums.begin()+1,nums.end()-1,nums[0]);\\n            int b = count(nums.begin()+1,nums.end()-1,nums[n-1]);\\n            return n-2-a-b;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t//for vector of size 1 or 2 , it is impossible\\n        if(n<3) return 0; \\n\\t\\t\\n        \\n\\t\\t// [x, 1,2,3,4,5,y] ---> if x&y are not present in [1,2,3,4,5]...then our answer is 1,2,3,4,5\\n\\t\\t\\n        if(find(nums.begin()+1,nums.end()-1,nums[0])==nums.end() && find(nums.begin()+1,nums.end()-1,nums[n-1])==nums.end()) {\\n            return n-2;\\n        }\\n        \\n\\t\\t// [x, 1,x,3,y,y,y] ---> if x&y are both present in [1,2,3,4,5]...then our answer is 1,3 (because x & y are not strictly greater or smaller than itself)\\n\\t\\t\\n        else if(find(nums.begin()+1,nums.end()-1,nums[0])!=nums.end() && find(nums.begin()+1,nums.end()-1,nums[n-1])!=nums.end() && nums[0]!=nums[n-1]) {\\n\\t\\t\\n\\t\\t//a= number of times x appear in between x & y\\n\\t\\t//b= number of times y appear in between x & y\\n\\t\\t\\n            int a = count(nums.begin()+1,nums.end()-1,nums[0]);\\n            int b = count(nums.begin()+1,nums.end()-1,nums[n-1]);\\n            return n-2-a-b;\\n        }\\n\\t\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        if(n<3) return 0; \\n        \\n        if(find(nums.begin()+1,nums.end()-1,nums[0])==nums.end() && find(nums.begin()+1,nums.end()-1,nums[n-1])==nums.end()) {\\n            return n-2;\\n        }\\n        \\n       else if(find(nums.begin()+1,nums.end()-1,nums[0])!=nums.end() && find(nums.begin()+1,nums.end()-1,nums[n-1])!=nums.end() && nums[0]!=nums[n-1]) {\\n            int a = count(nums.begin()+1,nums.end()-1,nums[0]);\\n            int b = count(nums.begin()+1,nums.end()-1,nums[n-1]);\\n            return n-2-a-b;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711601,
                "title": "c-simple-solution-count-all-except-min-and-max",
                "content": "**T.C:** O(n)\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int mini = INT_MAX, maxi = INT_MIN, n = nums.size();\\n\\t\\tfor(auto& num:nums){\\n\\t\\t\\tif(num > maxi) maxi = num;\\n\\t\\t\\tif(num < mini) mini = num;\\n\\t\\t}\\n        int count = 0;\\n        for(int i=0; i<n;i++){\\n            if(nums[i] > mini && nums[i] <maxi) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int mini = INT_MAX, maxi = INT_MIN, n = nums.size();\\n\\t\\tfor(auto& num:nums){\\n\\t\\t\\tif(num > maxi) maxi = num;\\n\\t\\t\\tif(num < mini) mini = num;\\n\\t\\t}\\n        int count = 0;\\n        for(int i=0; i<n;i++){\\n            if(nums[i] > mini && nums[i] <maxi) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711565,
                "title": "single-pass-o-n-c-time-o-1",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int countElements(vector<int>& nums) \\n    {        \\n        int minVal      = INT_MAX;\\n        int minValCount = 0;\\n        int maxVal      = INT_MIN;\\n        int maxValCount = 0;\\n        \\n        for (int num: nums)\\n        {\\n\\t\\t    // Find smallest value and its count\\n            if (num < minVal)\\n            {\\n                minVal      = num;\\n                minValCount = 1;\\n            }\\n            else if (num == minVal)\\n                minValCount++;\\n\\n\\t\\t    // Find largest value and its count\\n            if (num > maxVal)\\n            {\\n                maxVal      = num;\\n                maxValCount = 1;\\n            }\\n            else if (num == maxVal)\\n                maxValCount++;\\n        }\\n        \\n        if (minVal == INT_MAX || maxVal == INT_MIN || minVal == maxVal)\\n            return 0;\\n        else\\n            return (nums.size()-(minValCount+maxValCount));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int countElements(vector<int>& nums) \\n    {        \\n        int minVal      = INT_MAX;\\n        int minValCount = 0;\\n        int maxVal      = INT_MIN;\\n        int maxValCount = 0;\\n        \\n        for (int num: nums)\\n        {\\n\\t\\t    // Find smallest value and its count\\n            if (num < minVal)\\n            {\\n                minVal      = num;\\n                minValCount = 1;\\n            }\\n            else if (num == minVal)\\n                minValCount++;\\n\\n\\t\\t    // Find largest value and its count\\n            if (num > maxVal)\\n            {\\n                maxVal      = num;\\n                maxValCount = 1;\\n            }\\n            else if (num == maxVal)\\n                maxValCount++;\\n        }\\n        \\n        if (minVal == INT_MAX || maxVal == INT_MIN || minVal == maxVal)\\n            return 0;\\n        else\\n            return (nums.size()-(minValCount+maxValCount));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711521,
                "title": "simple-solution-in-java-using-sort",
                "content": "Time Complexity: O(nlogn)\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length,count=0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            int low=0,high=n-1;\\n            while(low<high){\\n                if(nums[i]>nums[low] && nums[i]<nums[high]){\\n                    count++;\\n                    break;\\n                }\\n                low++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length,count=0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            int low=0,high=n-1;\\n            while(low<high){\\n                if(nums[i]>nums[low] && nums[i]<nums[high]){\\n                    count++;\\n                    break;\\n                }\\n                low++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711401,
                "title": "python-o-n-no-need-to-complicate-simple-things",
                "content": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        min_, max_ = min(nums), max(nums)\\n        return sum(min_ < n < max_ for n in nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        min_, max_ = min(nums), max(nums)\\n        return sum(min_ < n < max_ for n in nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711361,
                "title": "c-2148-count-elements-with-strictly-smaller-and-greater-elements",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int ans = 0, mx = *max_element(nums.begin(), nums.end()), mn = *min_element(nums.begin(), nums.end()); \\n        for (auto& x : nums) \\n            if (mn < x && x < mx) ++ans; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int ans = 0, mx = *max_element(nums.begin(), nums.end()), mn = *min_element(nums.begin(), nums.end()); \\n        for (auto& x : nums) \\n            if (mn < x && x < mx) ++ans; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711289,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def countElements(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        ans = 0 \\n        left, right = nums[0], nums[-1]\\n        for i in range(1, len(nums)-1):\\n            if nums[i] > left and nums[i] < right:\\n                ans += 1\\n                \\n        return ans \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def countElements(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        ans = 0 \\n        left, right = nums[0], nums[-1]\\n        for i in range(1, len(nums)-1):\\n            if nums[i] > left and nums[i] < right:\\n                ans += 1\\n                \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711231,
                "title": "python3-check-numbers",
                "content": "\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mn, mx = min(nums), max(nums)\\n        return sum(mn < x < mx for x in nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        mn, mx = min(nums), max(nums)\\n        return sum(mn < x < mx for x in nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711229,
                "title": "python-java-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef countElements(self, nums: List[int]) -> int:\\n\\t\\t\\treturn sum([num != min(nums) and num != max(nums) for num in nums])\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int countElements(int[] nums) {\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int num: nums) {\\n\\t\\t\\t\\tmin = Math.min(min, num);\\n\\t\\t\\t\\tmax = Math.max(max, num);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int num: nums) {\\n\\t\\t\\t\\tif (num != min && num != max) {\\n\\t\\t\\t\\t\\tres ++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef countElements(self, nums: List[int]) -> int:\\n\\t\\t\\treturn sum([num != min(nums) and num != max(nums) for num in nums])\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int countElements(int[] nums) {\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int num: nums) {\\n\\t\\t\\t\\tmin = Math.min(min, num);\\n\\t\\t\\t\\tmax = Math.max(max, num);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1711225,
                "title": "java-sort-simple",
                "content": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        \\n        Arrays.sort(nums);   \\n        int count=0;   \\n        for(int i=1;i<nums.length;i++){\\n            \\n            int duplicate=0;\\n            int j=i;\\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\\n                i++;\\n                duplicate++;\\n            }\\n            \\n            if(i<nums.length-1 && nums[j-1]<nums[i] && nums[i+1]>nums[i])\\n            count+=1+duplicate;\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        \\n        Arrays.sort(nums);   \\n        int count=0;   \\n        for(int i=1;i<nums.length;i++){\\n            \\n            int duplicate=0;\\n            int j=i;\\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\\n                i++;\\n                duplicate++;\\n            }\\n            \\n            if(i<nums.length-1 && nums[j-1]<nums[i] && nums[i+1]>nums[i])\\n            count+=1+duplicate;\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075507,
                "title": "sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        count=0\\n        for i in range(1,n-1):\\n            if nums[0]<nums[i] and nums[i]<nums[-1]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        count=0\\n        for i in range(1,n-1):\\n            if nums[0]<nums[i] and nums[i]<nums[-1]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068036,
                "title": "one-line-solution-runtime-99",
                "content": "![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-09-20 \\u0432 02.54.19.png](https://assets.leetcode.com/users/images/b7db31aa-eba1-449f-9e50-297111893bdb_1695205845.0257843.png)\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        return ans if (ans := len(nums) - nums.count(min(nums)) - nums.count(max(nums))) > 0 else 0     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        return ans if (ans := len(nums) - nums.count(min(nums)) - nums.count(max(nums))) > 0 else 0     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066928,
                "title": "strictly-greater-and-strictly-smaller",
                "content": "# Intuition\\n<!--I would recognize that I need to iterate through each element in the nums array and for each element, check if there exists at least one element that is strictly smaller and at least one element that is strictly greater. -->\\n\\n# Approach\\n<!-- To keep track of whether there are such elements, I would use two separate flags: flag_smaller and flag_greater. These flags would start as false (0) for each element being considered.\\n\\nI would then iterate through the array again, comparing the current element with all other elements (excluding itself) in the array. If I find an element that is strictly smaller than the current element, I would set flag_smaller to 1. If I find an element that is strictly greater than the current element, I would set flag_greater to 1.\\n\\nAfter iterating through the array for the current element, if both flag_smaller and flag_greater are set to 1, it means that the current element meets the criteria of having both a strictly smaller and a strictly greater element in the array. I would then increment the count variable.\\n\\nFinally, I would return the count as the result, which represents the number of elements that satisfy the condition.\\n\\nOverall, the logic involves two nested loops to compare each element with every other element in the array, keeping track of whether there are smaller and greater elements, and incrementing the count when both conditions are met.\\n-->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n^2)-->\\n\\n- Space complexity:\\n<!-- O(1) -->\\n\\n# Code\\n```\\nint countElements(int* nums, int numsSize){\\n   int count = 0;\\n\\n   for(int i = 0; i < numsSize; i++) {\\n       int flag_smaller = 0;\\n       int flag_greater = 0;\\n       \\n       for(int j = 0; j < numsSize; j++) {\\n           if (i != j) {\\n               if (nums[i] > nums[j]) {\\n                   flag_greater = 1;  \\n               } else if (nums[i] < nums[j]) {\\n                   flag_smaller = 1;  \\n               }\\n           }\\n       }\\n       \\n       if (flag_smaller && flag_greater) {\\n           count++;\\n       }\\n   }\\n   \\n   return count;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countElements(int* nums, int numsSize){\\n   int count = 0;\\n\\n   for(int i = 0; i < numsSize; i++) {\\n       int flag_smaller = 0;\\n       int flag_greater = 0;\\n       \\n       for(int j = 0; j < numsSize; j++) {\\n           if (i != j) {\\n               if (nums[i] > nums[j]) {\\n                   flag_greater = 1;  \\n               } else if (nums[i] < nums[j]) {\\n                   flag_smaller = 1;  \\n               }\\n           }\\n       }\\n       \\n       if (flag_smaller && flag_greater) {\\n           count++;\\n       }\\n   }\\n   \\n   return count;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057201,
                "title": "simple-solution-count-elements-with-strictly-smaller-and-greater-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition for solving this problem is to iterate through the array and for each element, check if there exists at least one element that is strictly smaller and at least one element that is strictly greater than the current element in the same array. If both conditions are met, increment a counter.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize a counter count to keep track of the elements that meet the criteria.\\nIterate through the array nums, considering each element as the current element.\\nFor each current element, initialize two boolean variables isGreater and isSmaller to false to keep track of whether we find elements greater and smaller than the current element.\\nNest another loop to iterate through the entire array again.\\nIn the inner loop, compare the current element with each element in the array (excluding itself). If you find an element greater than the current element, set isGreater to true. If you find an element smaller than the current element, set isSmaller to true.\\nAfter the inner loop finishes, check if both isGreater and isSmaller are true. If they are, increment the count variable.\\nFinally, return the count as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2) where n is the length of the input array nums. This is because we have a nested loop that iterates through the array twice.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1) as we are using only a constant amount of extra space, regardless of the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int p=nums[i];\\n            boolean isgreater= false;\\n            boolean issmaller=false;\\n\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]>p){\\n                    isgreater=true;\\n                    break;\\n                }\\n            }\\n              for(int j=0;j<nums.length;j++){\\n                if(nums[j]<p){\\n                    issmaller=true;\\n                    break;\\n                }\\n            }\\n            if(issmaller && isgreater){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int p=nums[i];\\n            boolean isgreater= false;\\n            boolean issmaller=false;\\n\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]>p){\\n                    isgreater=true;\\n                    break;\\n                }\\n            }\\n              for(int j=0;j<nums.length;j++){\\n                if(nums[j]<p){\\n                    issmaller=true;\\n                    break;\\n                }\\n            }\\n            if(issmaller && isgreater){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036183,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\nvar countElements = function(nums) {\\n    let res = 0\\n    for(let i = 0; i < nums.length; i++) {\\n        let isLeft,isRight\\n        for(let j = 0; j < nums.length; j++) {\\n            if(i == j || nums[i] === nums[j]) continue\\n            if(nums[i] > nums[j]) {\\n                isLeft = true \\n            } else if(nums[i] < nums[j]) {\\n                isRight = true\\n            }\\n       }\\n       if(isLeft && isRight) {\\n           res++\\n       }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countElements = function(nums) {\\n    let res = 0\\n    for(let i = 0; i < nums.length; i++) {\\n        let isLeft,isRight\\n        for(let j = 0; j < nums.length; j++) {\\n            if(i == j || nums[i] === nums[j]) continue\\n            if(nums[i] > nums[j]) {\\n                isLeft = true \\n            } else if(nums[i] < nums[j]) {\\n                isRight = true\\n            }\\n       }\\n       if(isLeft && isRight) {\\n           res++\\n       }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036181,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\nvar countElements = function(nums) {\\n    let res = 0\\n    for(let i = 0; i < nums.length; i++) {\\n        let isLeft,isRight\\n        for(let j = 0; j < nums.length; j++) {\\n            if(i == j || nums[i] === nums[j]) continue\\n            if(nums[i] > nums[j]) {\\n                isLeft = true \\n            } else if(nums[i] < nums[j]) {\\n                isRight = true\\n            }\\n       }\\n       if(isLeft && isRight) {\\n           res++\\n       }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countElements = function(nums) {\\n    let res = 0\\n    for(let i = 0; i < nums.length; i++) {\\n        let isLeft,isRight\\n        for(let j = 0; j < nums.length; j++) {\\n            if(i == j || nums[i] === nums[j]) continue\\n            if(nums[i] > nums[j]) {\\n                isLeft = true \\n            } else if(nums[i] < nums[j]) {\\n                isRight = true\\n            }\\n       }\\n       if(isLeft && isRight) {\\n           res++\\n       }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011286,
                "title": "0ms-o-n-time-and-o-1-space-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, count = nums.length;\\n\\n        for (int i : nums) {\\n            if (i > max) {\\n                max = i;\\n            }\\n\\n            if (i < min) {\\n                min = i;\\n            }\\n        }\\n\\n        for (int i : nums) {\\n            if (i == min || i == max) {\\n                count--;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, count = nums.length;\\n\\n        for (int i : nums) {\\n            if (i > max) {\\n                max = i;\\n            }\\n\\n            if (i < min) {\\n                min = i;\\n            }\\n        }\\n\\n        for (int i : nums) {\\n            if (i == min || i == max) {\\n                count--;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000420,
                "title": "go-solution-without-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWalk through array and find min/max elems and then repeat this one more time to calculate result\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n + n) = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc countElements(nums []int) int {\\n    minE := nums[0]\\n    maxE := nums[0]\\n    \\n    for _, e := range nums {\\n        if e < minE {\\n            minE = e\\n        }\\n        if e > maxE {\\n            maxE = e\\n        }\\n    }\\n\\n    res := 0\\n    for i := 0; i < len(nums); i++ {\\n        if minE < nums[i] && nums[i] < maxE {\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countElements(nums []int) int {\\n    minE := nums[0]\\n    maxE := nums[0]\\n    \\n    for _, e := range nums {\\n        if e < minE {\\n            minE = e\\n        }\\n        if e > maxE {\\n            maxE = e\\n        }\\n    }\\n\\n    res := 0\\n    for i := 0; i < len(nums); i++ {\\n        if minE < nums[i] && nums[i] < maxE {\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990148,
                "title": "o-1-space-o-n-time-javascript-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countElements = function(nums) {\\n\\n    let n = nums.length, min = nums[0],max = nums[0],minOcc = 1, maxOcc = 1;\\n\\n    if (n == 0) return 0;\\n\\n    for(let i = 1; i< n;i++){\\n\\n        if(nums[i] > max){\\n            max = nums[i];\\n            maxOcc = 1;\\n        }else if(nums[i] == max){\\n            maxOcc++;\\n        }\\n\\n        if(nums[i] < min){\\n             min = nums[i];\\n              minOcc = 1;    \\n            }else if(nums[i] == min){\\n                 minOcc++;\\n            }\\n\\n    }\\n    return max === min ? 0 : n - minOcc - maxOcc;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countElements = function(nums) {\\n\\n    let n = nums.length, min = nums[0],max = nums[0],minOcc = 1, maxOcc = 1;\\n\\n    if (n == 0) return 0;\\n\\n    for(let i = 1; i< n;i++){\\n\\n        if(nums[i] > max){\\n            max = nums[i];\\n            maxOcc = 1;\\n        }else if(nums[i] == max){\\n            maxOcc++;\\n        }\\n\\n        if(nums[i] < min){\\n             min = nums[i];\\n              minOcc = 1;    \\n            }else if(nums[i] == min){\\n                 minOcc++;\\n            }\\n\\n    }\\n    return max === min ? 0 : n - minOcc - maxOcc;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982159,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        \\n        int minele = nums[0];\\n        int maxele = nums[0];\\n\\n        for(int ele: nums){\\n            minele = Math.min(ele,minele);\\n            maxele = Math.max(ele,maxele);\\n        }\\n\\n        int count =0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>minele && nums[i]<maxele){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        \\n        int minele = nums[0];\\n        int maxele = nums[0];\\n\\n        for(int ele: nums){\\n            minele = Math.min(ele,minele);\\n            maxele = Math.max(ele,maxele);\\n        }\\n\\n        int count =0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>minele && nums[i]<maxele){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979500,
                "title": "easy-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n      int c=0,p=0,k=0;\\n      for(int i=0;i<nums.length;i++)\\n      {\\n         for(int j=0;j<nums.length;j++)\\n         {\\n                  if(nums[i]<nums[j])\\n                  {\\n                      k=1;\\n                  }\\n                  if(nums[i]>nums[j])\\n                  {\\n                      p=1;\\n                  }\\n                  if(p==1 && k==1)\\n                  {      \\n                         c++;\\n                         break;\\n                  }  \\n         }\\n         k=0;\\n         p=0;\\n      }\\n      return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n      int c=0,p=0,k=0;\\n      for(int i=0;i<nums.length;i++)\\n      {\\n         for(int j=0;j<nums.length;j++)\\n         {\\n                  if(nums[i]<nums[j])\\n                  {\\n                      k=1;\\n                  }\\n                  if(nums[i]>nums[j])\\n                  {\\n                      p=1;\\n                  }\\n                  if(p==1 && k==1)\\n                  {      \\n                         c++;\\n                         break;\\n                  }  \\n         }\\n         k=0;\\n         p=0;\\n      }\\n      return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970285,
                "title": "easist-way-for-this-problem-85-faster-than-other-submissions",
                "content": "```\\nvar countElements = function (nums) {\\n  nums = nums.sort((a, b) => a - b);\\n  nums = nums.filter((i) => i !== nums[0]);\\n  nums = nums.filter((i) => i !== nums[nums.length - 1]);\\n  return nums.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countElements = function (nums) {\\n  nums = nums.sort((a, b) => a - b);\\n  nums = nums.filter((i) => i !== nums[0]);\\n  nums = nums.filter((i) => i !== nums[nums.length - 1]);\\n  return nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959454,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int countElements(List<int> nums) {\\n        final mini = nums.reduce(min);\\n        final maxi = nums.reduce(max);\\n        var c = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > mini && nums[i] < maxi) {\\n                c += 1;\\n            }\\n        }\\n\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n    int countElements(List<int> nums) {\\n        final mini = nums.reduce(min);\\n        final maxi = nums.reduce(max);\\n        var c = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > mini && nums[i] < maxi) {\\n                c += 1;\\n            }\\n        }\\n\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958287,
                "title": "fast-and-efficient",
                "content": "# One for loop, a sum and a comparison\\n\\n# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        amount = 0\\n        for i in nums:\\n            if min(nums) < i < max(nums):\\n                amount += 1\\n        return amount\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        amount = 0\\n        for i in nums:\\n            if min(nums) < i < max(nums):\\n                amount += 1\\n        return amount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950405,
                "title": "ruby-one-liner-41ms",
                "content": "```\\ndef count_elements(nums)\\n  nums.count{|n| n > nums.min && n < nums.max}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef count_elements(nums)\\n  nums.count{|n| n > nums.min && n < nums.max}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3946154,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int count = 0;\\n        int c = 0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int l = 0;\\n            int s = 0;\\n        \\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]<nums[j]){\\n                  s++;\\n                }\\n                else if(nums[i]>nums[j]){\\n                  l++;\\n                }\\n            }\\n            if(l!=0 && s!=0){\\n                count = count + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int count = 0;\\n        int c = 0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int l = 0;\\n            int s = 0;\\n        \\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]<nums[j]){\\n                  s++;\\n                }\\n                else if(nums[i]>nums[j]){\\n                  l++;\\n                }\\n            }\\n            if(l!=0 && s!=0){\\n                count = count + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946010,
                "title": "simplest-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        nums1=list(set(nums))\\n        nums1=sorted(nums1)\\n        ct=0\\n        for i in range(1,len(nums1)-1):\\n            ct+=nums.count(nums1[i])\\n        return ct\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        nums1=list(set(nums))\\n        nums1=sorted(nums1)\\n        ct=0\\n        for i in range(1,len(nums1)-1):\\n            ct+=nums.count(nums1[i])\\n        return ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931181,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int n = nums.length;\\n        int count=0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(found(nums[i], nums))\\n            {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n    private boolean found(int target, int[] arr)\\n    {\\n        boolean check1 = false;\\n        //for smaller element\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            if(target > arr[i])\\n            {\\n                check1 = true;\\n                break;\\n            }\\n        }\\n\\n        boolean check2 = false;\\n        //for bigger element\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            if(target < arr[i])\\n            {\\n                check2 = true;\\n                break;\\n            }\\n        }\\n        return (check1&&check2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int n = nums.length;\\n        int count=0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(found(nums[i], nums))\\n            {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n    private boolean found(int target, int[] arr)\\n    {\\n        boolean check1 = false;\\n        //for smaller element\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            if(target > arr[i])\\n            {\\n                check1 = true;\\n                break;\\n            }\\n        }\\n\\n        boolean check2 = false;\\n        //for bigger element\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            if(target < arr[i])\\n            {\\n                check2 = true;\\n                break;\\n            }\\n        }\\n        return (check1&&check2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914028,
                "title": "easy-solution-in-java-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums); // sorting the array\\n        int count = 0; // inetializing count\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]>nums[0] && nums[i]<nums[nums.length-1]) count++; // what basically happens here is we check if the number is strictly greater or less than the iteration array number.\\n        }\\n        return count; // and then we just return the count!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums); // sorting the array\\n        int count = 0; // inetializing count\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]>nums[0] && nums[i]<nums[nums.length-1]) count++; // what basically happens here is we check if the number is strictly greater or less than the iteration array number.\\n        }\\n        return count; // and then we just return the count!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890518,
                "title": "easy-element-counting-without-sorting",
                "content": "# Intuition\\n****The intuition behind this solution is to find the count of elements in the given array that are strictly greater than the minimum value and strictly smaller than the maximum value present in the array.****\\n\\n# Approach\\n1. Calculate the maximum and minimum values in the given array using the max_element and min_element functions.\\n\\n2. Initialize a counter variable cnt to keep track of the count of elements that satisfy the condition.\\n\\n3. Iterate through the array and for each element num:\\nCheck if num is greater than the minimum value and smaller than the maximum value.\\n\\n4. If the condition is satisfied, increment the cnt counter.\\nFinally, return the value of cnt, which represents the count of elements meeting the specified condition.\\n\\n# Complexity\\n- Time complexity:\\n **O(n) -** The algorithm iterates through the array once to find the maximum and minimum values, and then iterates through the array again to count the elements meeting the condition.\\n\\n- Space complexity:\\n **O(1) -** The algorithm uses a constant amount of extra space to store the maxi, mini, and cnt variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int mini=*min_element(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>mini and nums[i]<maxi)\\n            {\\n                cnt++;\\n            }\\n        }  \\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int mini=*min_element(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>mini and nums[i]<maxi)\\n            {\\n                cnt++;\\n            }\\n        }  \\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875020,
                "title": "easy-java-runtime-memory-40-19",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int[] minMax = minMax(nums);\\n        int min = minMax[0];\\n        int max = minMax[1];\\n        int c = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != min && nums[i] != max) ++c;\\n        }\\n\\n        return c;\\n    }\\n\\n    static int[] minMax(int[] nums) {\\n        int min = nums[0], max = nums[0];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < min) min = nums[i];\\n            if (nums[i] > max) max = nums[i];\\n        }\\n\\n        return new int[]{min, max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int[] minMax = minMax(nums);\\n        int min = minMax[0];\\n        int max = minMax[1];\\n        int c = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != min && nums[i] != max) ++c;\\n        }\\n\\n        return c;\\n    }\\n\\n    static int[] minMax(int[] nums) {\\n        int min = nums[0], max = nums[0];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < min) min = nums[i];\\n            if (nums[i] > max) max = nums[i];\\n        }\\n\\n        return new int[]{min, max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866954,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            bool g=false;\\n            bool s=false;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                continue;\\n                if(!g && nums[i]<nums[j])\\n                g=true;\\n\\n                if(!s && nums[i]>nums[j])\\n                s=true;\\n            }\\n            if(g && s)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            bool g=false;\\n            bool s=false;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                continue;\\n                if(!g && nums[i]<nums[j])\\n                g=true;\\n\\n                if(!s && nums[i]>nums[j])\\n                s=true;\\n            }\\n            if(g && s)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863408,
                "title": "simple-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int min=nums[0];\\n        int max=nums[nums.length-1];\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]!=min && nums[i]!=max){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int min=nums[0];\\n        int max=nums[nums.length-1];\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]!=min && nums[i]!=max){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849896,
                "title": "easy-solution-in-c-using-max-and-min-element-beginner-freindly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int a=0;\\n        int c=*max_element(nums.begin(),nums.end());\\n        int d=*min_element(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<c && nums[i]>d)\\n            {\\n                a++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int a=0;\\n        int c=*max_element(nums.begin(),nums.end());\\n        int d=*min_element(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<c && nums[i]>d)\\n            {\\n                a++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841916,
                "title": "count-elements-with-strictly-smaller-and-greater-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            boolean flag = false;\\n            boolean flag1 = false;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                flag = true;\\n                if(nums[i]<nums[j])\\n                flag1 = true;\\n            }\\n            if(flag==true&&flag1==true)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            boolean flag = false;\\n            boolean flag1 = false;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                flag = true;\\n                if(nums[i]<nums[j])\\n                flag1 = true;\\n            }\\n            if(flag==true&&flag1==true)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833259,
                "title": "overthinking-with-dictionary-c",
                "content": "#### If you have just learned dictionary and want to practice.\\n\\nYou could solve this task this way.   \\n\\nActually it\\'s solving just by counting all element of the array without min and max elements. But here you create dictionary, iterate over a dictionary, clear it and remove elements. \\nEnjoy `=^_^=`.\\n\\n\\n![drink(1).png](https://assets.leetcode.com/users/images/264f9c4c-1b47-49eb-b843-2f19f19ad205_1690628727.4270222.png)\\n\\nBy the way, it doesn\\\\`t need to sort `nums`.\\n\\n\\n```\\npublic class Solution {\\n\\n        Dictionary<int, int> di = new();\\n\\n    public int CountElements(int[] nums)\\n    {\\n        di.Clear();\\n        foreach (int i in nums)\\n        {\\n            if (di.ContainsKey(i))\\n                di[i]++;\\n            else\\n                di.Add(i, 1);\\n        }\\n        int res = 0;\\n        di.Remove(nums.Max());\\n        di.Remove(nums.Min());\\n        foreach (var entry in di.Values)\\n        {            \\n            res += entry;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n        Dictionary<int, int> di = new();\\n\\n    public int CountElements(int[] nums)\\n    {\\n        di.Clear();\\n        foreach (int i in nums)\\n        {\\n            if (di.ContainsKey(i))\\n                di[i]++;\\n            else\\n                di.Add(i, 1);\\n        }\\n        int res = 0;\\n        di.Remove(nums.Max());\\n        di.Remove(nums.Min());\\n        foreach (var entry in di.Values)\\n        {            \\n            res += entry;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817135,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        a=max(nums)\\n        b=min(nums)\\n        nums.remove(a)\\n        c=0\\n        if len(nums) > 0 :\\n            nums.remove(b)\\n        for i in nums :\\n            if i<a and i>b :\\n                c+=1\\n        return c\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        a=max(nums)\\n        b=min(nums)\\n        nums.remove(a)\\n        c=0\\n        if len(nums) > 0 :\\n            nums.remove(b)\\n        for i in nums :\\n            if i<a and i>b :\\n                c+=1\\n        return c\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815085,
                "title": "easy-solution-beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        \\n       \\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int element: nums)\\n        {\\n            max = Math.max(max,element);\\n            min = Math.min(min,element);\\n        }\\n        int count =0;\\n\\n\\n        for(int element : nums)\\n        {\\n            if(element<max && element>min)\\n            count++;\\n        }\\n\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        \\n       \\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int element: nums)\\n        {\\n            max = Math.max(max,element);\\n            min = Math.min(min,element);\\n        }\\n        int count =0;\\n\\n\\n        for(int element : nums)\\n        {\\n            if(element<max && element>min)\\n            count++;\\n        }\\n\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806015,
                "title": "simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int min=nums[0];\\n        int maxi=nums[n-1];\\n        int cnt=0;\\n        for(int i=1;i<n-1;i++){\\n            if(nums[i]>min && nums[i]<maxi){\\n                cnt++;\\n            }\\n        }\\n          return cnt;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int min=nums[0];\\n        int maxi=nums[n-1];\\n        int cnt=0;\\n        for(int i=1;i<n-1;i++){\\n            if(nums[i]>min && nums[i]<maxi){\\n                cnt++;\\n            }\\n        }\\n          return cnt;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785122,
                "title": "simple-java-solution-in-a-single-iteration-without-sorting-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, minCount = 0, maxCount = 0; \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] < min) {\\n                min = nums[i];\\n                minCount = 1;\\n            }\\n            else if(nums[i] == min) minCount++;\\n            if(nums[i] > max) {\\n                max = nums[i];\\n                maxCount = 1;\\n            }\\n            else if(nums[i] == max) maxCount++;\\n        }\\n        int cnt = nums.length - (maxCount + minCount);\\n        return cnt < 0 ? 0 : cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, minCount = 0, maxCount = 0; \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] < min) {\\n                min = nums[i];\\n                minCount = 1;\\n            }\\n            else if(nums[i] == min) minCount++;\\n            if(nums[i] > max) {\\n                max = nums[i];\\n                maxCount = 1;\\n            }\\n            else if(nums[i] == max) maxCount++;\\n        }\\n        int cnt = nums.length - (maxCount + minCount);\\n        return cnt < 0 ? 0 : cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781171,
                "title": "easy-python-solution-45-ms-beats-97-88",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        if len(Counter(nums))<=1:\\n            return 0\\n        nums=sorted(nums)\\n        return len(nums)-nums.count(nums[0])-nums.count(nums[-1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        if len(Counter(nums))<=1:\\n            return 0\\n        nums=sorted(nums)\\n        return len(nums)-nums.count(nums[0])-nums.count(nums[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774366,
                "title": "easy-and-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\n        int count = 0;\\n\\n        int minEl = *min_element(nums.begin(), nums.end());\\n        int maxEl = *max_element(nums.begin(), nums.end());\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] > minEl && nums[i] < maxEl){\\n                count++;\\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\n        int count = 0;\\n\\n        int minEl = *min_element(nums.begin(), nums.end());\\n        int maxEl = *max_element(nums.begin(), nums.end());\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] > minEl && nums[i] < maxEl){\\n                count++;\\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772225,
                "title": "c-o-n-time-o-1-space-easy",
                "content": "\\n- **Find the max and min element of vector, store in h and l variables**\\n- **Compare each element with Min and Max and count while iterating** \\n**through array in O(N) time**\\n- **Return the count as result.**\\n- **Space Complexity:**     O(1)\\n- **Time Complexity:** O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& n) {\\n        int res=0;\\n    \\n        int h = *max_element(n.begin(), n.end());\\n        int l =  *min_element(n.begin(), n.end() );\\n        for(int i=0; i<n.size(); i++)\\n        {\\n            if(l < n[i] && n[i] < h)\\n            res++;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& n) {\\n        int res=0;\\n    \\n        int h = *max_element(n.begin(), n.end());\\n        int l =  *min_element(n.begin(), n.end() );\\n        for(int i=0; i<n.size(); i++)\\n        {\\n            if(l < n[i] && n[i] < h)\\n            res++;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771753,
                "title": "easy-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>&n){\\n        map<int,int>mp;\\n        for(auto i:n){\\n            mp[i]++;\\n        }\\n        if(mp.size()<=1){\\n            return 0;\\n        }\\n        int sum=0;\\n        for(auto i:mp){\\n            sum+=i.second;\\n        }\\n        for(auto i:mp){\\n            sum-=i.second;\\n            break;\\n        }\\n        int l=0;\\n        for(auto i:mp){\\n            l=i.second;\\n        }\\n        return sum-l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>&n){\\n        map<int,int>mp;\\n        for(auto i:n){\\n            mp[i]++;\\n        }\\n        if(mp.size()<=1){\\n            return 0;\\n        }\\n        int sum=0;\\n        for(auto i:mp){\\n            sum+=i.second;\\n        }\\n        for(auto i:mp){\\n            sum-=i.second;\\n            break;\\n        }\\n        int l=0;\\n        for(auto i:mp){\\n            l=i.second;\\n        }\\n        return sum-l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767246,
                "title": "o-n-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n       if(nums.size() <= 2)\\n        return 0;\\n        int mxValue = INT_MIN, mnValue = INT_MAX, ans = 0, n = nums.size();\\n        for(int i = 0; i < nums.size(); i++){\\n           mxValue = max(mxValue, nums[i]);\\n           mnValue = min(mnValue, nums[i]);\\n        }\\n\\n        for(auto x: nums){\\n            if(x < mxValue && x > mnValue)\\n                ans++;\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n       if(nums.size() <= 2)\\n        return 0;\\n        int mxValue = INT_MIN, mnValue = INT_MAX, ans = 0, n = nums.size();\\n        for(int i = 0; i < nums.size(); i++){\\n           mxValue = max(mxValue, nums[i]);\\n           mnValue = min(mnValue, nums[i]);\\n        }\\n\\n        for(auto x: nums){\\n            if(x < mxValue && x > mnValue)\\n                ans++;\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755574,
                "title": "cpp-best-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        int count=0;\\n\\n      for(int i=0; i<n; i++){\\n          if(nums[i]>nums[0] && nums[i]<nums[n-1]){\\n              count++;\\n          }\\n      }\\n      return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        int count=0;\\n\\n      for(int i=0; i<n; i++){\\n          if(nums[i]>nums[0] && nums[i]<nums[n-1]){\\n              count++;\\n          }\\n      }\\n      return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754988,
                "title": "count-values-and-find-answer",
                "content": "# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        min_val = nums[0]\\n        max_val = nums[0]\\n        counter = {}\\n        \\n        for i in nums:\\n            min_val = min(min_val, i)\\n            max_val = max(max_val, i)\\n            counter[i] = counter.get(i, 0) + 1\\n        \\n        if len(counter) == 1:\\n            return 0\\n        counter[min_val] = 0\\n        counter[max_val] = 0\\n        return sum(counter.values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        min_val = nums[0]\\n        max_val = nums[0]\\n        counter = {}\\n        \\n        for i in nums:\\n            min_val = min(min_val, i)\\n            max_val = max(max_val, i)\\n            counter[i] = counter.get(i, 0) + 1\\n        \\n        if len(counter) == 1:\\n            return 0\\n        counter[min_val] = 0\\n        counter[max_val] = 0\\n        return sum(counter.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722814,
                "title": "easiest-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n      int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int min=nums[i],max=nums[i];\\n            for(int j=0;j<nums.length;j++){\\n            if(nums[j]>max)max=nums[j];\\n            if(nums[j]<min)min=nums[j];\\n            }\\n            if(max!=nums[i] && min!=nums[i])count++;\\n        }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n      int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int min=nums[i],max=nums[i];\\n            for(int j=0;j<nums.length;j++){\\n            if(nums[j]>max)max=nums[j];\\n            if(nums[j]<min)min=nums[j];\\n            }\\n            if(max!=nums[i] && min!=nums[i])count++;\\n        }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721335,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n       Arrays.sort(nums);\\n\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if ( nums[i] > nums[0] && nums[i] < nums[nums.length-1] ){\\n                count++;\\n            }\\n        }\\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countElements(int[] nums) {\\n       Arrays.sort(nums);\\n\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if ( nums[i] > nums[0] && nums[i] < nums[nums.length-1] ){\\n                count++;\\n            }\\n        }\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718507,
                "title": "easy-solution-in-python-sorting-nlogn",
                "content": "# Intuition\\nIf we look the given test cases and statement of problem, we can identify that we only want those numbers which have to satisfy condition of strictly greater and strictly smaller element in given list.\\n\\nSimple to break the given problem statement that --\\nWe have to find each element referenced minimum and maximum element and to check they shouldn\\'t be equal to minimum and maximum element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSupporting Test case to support my statement.\\nnums = [11,7,2,15]\\n\\nApproch to sort given list.\\nnums = [2,7,11,15]\\nmin_element = 2 , max_element = 15\\n\\nonly 7 and 11 can satisfy condition:\\n(7 != min_element and 7 > min_element) and (7 != max_element and 7 < max_element)\\n\\n(11 != min_element and 11 > min_element) and (11 != max_element and 11 < max_element)\\n\\ntherfore the ans is 2.\\n\\n\\n# Complexity\\n- Time complexity:\\nSince I have sorted the given list.\\nso sorting calculates the complexity of (nlogn) and \\nrunning and loop to find no of element to statisfy condition calculates the complexity of (n)\\n\\nTime complexity:(nlogn) + n = Big O(nlogn).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince i m not using extra space to store and value other the min_element and max_element,therefore \\nSpace complexity = Big O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_element = nums[-1]\\n        min_element = nums[0]\\n        no_of_elements = 0\\n\\n        for i in range(1,len(nums)-1):\\n            if nums[i] != max_element and nums[i] < max_element and nums[i] != min_element and nums[i] > min_element:\\n                no_of_elements +=1\\n        return no_of_elements\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_element = nums[-1]\\n        min_element = nums[0]\\n        no_of_elements = 0\\n\\n        for i in range(1,len(nums)-1):\\n            if nums[i] != max_element and nums[i] < max_element and nums[i] != min_element and nums[i] > min_element:\\n                no_of_elements +=1\\n        return no_of_elements\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715918,
                "title": "python-simple-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        dict={}\\n        uniq=[]\\n        for i in range(len(nums)):\\n            if nums[i] in uniq:\\n                dict[nums[i]]=dict.get(nums[i])+1\\n                continue\\n            uniq.append(nums[i])\\n            dict[nums[i]]=1\\n        count=0\\n        uniq.sort()\\n        #print(nums)\\n        #print(uniq)\\n        \\n        for i in range(1,len(uniq)-1):\\n            count+=dict.get(uniq[i])\\n        return count\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countElements(self, nums: List[int]) -> int:\\n        dict={}\\n        uniq=[]\\n        for i in range(len(nums)):\\n            if nums[i] in uniq:\\n                dict[nums[i]]=dict.get(nums[i])+1\\n                continue\\n            uniq.append(nums[i])\\n            dict[nums[i]]=1\\n        count=0\\n        uniq.sort()\\n        #print(nums)\\n        #print(uniq)\\n        \\n        for i in range(1,len(uniq)-1):\\n            count+=dict.get(uniq[i])\\n        return count\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694070,
                "title": "c-easy-and-readable-solution-less-than-92",
                "content": "![image.png](https://assets.leetcode.com/users/images/156077c5-1ebe-478f-bbf9-ada946219b7b_1687976628.402728.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int CountElements(int[] nums) {\\n        if (nums.Length < 3)\\n            return 0;\\n        int min = nums.Min();\\n        int max = nums.Max();\\n        int counter = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n            if (max > nums[i] && nums[i] > min)\\n                counter++;\\n        return counter;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountElements(int[] nums) {\\n        if (nums.Length < 3)\\n            return 0;\\n        int min = nums.Min();\\n        int max = nums.Max();\\n        int counter = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n            if (max > nums[i] && nums[i] > min)\\n                counter++;\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1941377,
                "content": [
                    {
                        "username": "Harshhk",
                        "content": "Testcase 1:\\ninput=[-3,3,3,90]\\noutput=2\\n\\nTestcase 2:\\ninput=[-71,-71,93,-71,40]\\noutput=1\\n\\nIsn\\'t it contradicting itself?\\nIf Testcase 2 is correct then someone explain me testcase 1.."
                    },
                    {
                        "username": "yush_2001",
                        "content": "both testcases are correct. as in secnd testcase only 40 is greater than minimum and less than maximum."
                    },
                    {
                        "username": "a4abhiram125",
                        "content": "[11,7,2,15]\\nfor the above case there is also strict small and great for 2 according to the test case description but the expectation is 2 how is this possible can anyone explain"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "Sort the Array\n``` Arrays.sort(nums);   // array would be -  2 7 11 15```\nNow you can see : \n> * The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\n> * Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\n\ncount will be 2 for this."
                    },
                    {
                        "username": "mpalaourg",
                        "content": "The testcase refers to 7 and 11. \\n7 has 2 and 11, where 11 has 7 and 15"
                    },
                    {
                        "username": "pappukr034",
                        "content": "good"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Any Binary search approach ?\\n\\n"
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@azuregcp](/azuregcp)  Thank you\\n"
                    },
                    {
                        "username": "azuregcp",
                        "content": "I think by semi-sorted you mean Partially sorted?\\n\\nAnyways, binary search can be applied only on one type of unsorted array and that is if it\\'s a rotated array. Other than that, you cannot apply binary search on an unsorted array. \\n\\nSo, O(n) is the best time for this problem."
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@JackChen890311](/JackChen890311)  idk the array looks like semi sorted  so just a random thought of bs"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Why do you need binary search?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one "
                    },
                    {
                        "username": "thangtv611",
                        "content": "With input: [-71,-71,93,-71,40], idk why the expectation is 1?"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Loot at  the last element  40   . It has  93 which is strictly greater and -71 which is strictly lesser \\n"
                    },
                    {
                        "username": "DarkPrinceDK",
                        "content": "1 is correct there is only one number(40) such that it has atleast one number(-71) less and greater(93) than that number "
                    }
                ]
            },
            {
                "id": 1878914,
                "content": [
                    {
                        "username": "Harshhk",
                        "content": "Testcase 1:\\ninput=[-3,3,3,90]\\noutput=2\\n\\nTestcase 2:\\ninput=[-71,-71,93,-71,40]\\noutput=1\\n\\nIsn\\'t it contradicting itself?\\nIf Testcase 2 is correct then someone explain me testcase 1.."
                    },
                    {
                        "username": "yush_2001",
                        "content": "both testcases are correct. as in secnd testcase only 40 is greater than minimum and less than maximum."
                    },
                    {
                        "username": "a4abhiram125",
                        "content": "[11,7,2,15]\\nfor the above case there is also strict small and great for 2 according to the test case description but the expectation is 2 how is this possible can anyone explain"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "Sort the Array\n``` Arrays.sort(nums);   // array would be -  2 7 11 15```\nNow you can see : \n> * The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\n> * Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\n\ncount will be 2 for this."
                    },
                    {
                        "username": "mpalaourg",
                        "content": "The testcase refers to 7 and 11. \\n7 has 2 and 11, where 11 has 7 and 15"
                    },
                    {
                        "username": "pappukr034",
                        "content": "good"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Any Binary search approach ?\\n\\n"
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@azuregcp](/azuregcp)  Thank you\\n"
                    },
                    {
                        "username": "azuregcp",
                        "content": "I think by semi-sorted you mean Partially sorted?\\n\\nAnyways, binary search can be applied only on one type of unsorted array and that is if it\\'s a rotated array. Other than that, you cannot apply binary search on an unsorted array. \\n\\nSo, O(n) is the best time for this problem."
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@JackChen890311](/JackChen890311)  idk the array looks like semi sorted  so just a random thought of bs"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Why do you need binary search?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one "
                    },
                    {
                        "username": "thangtv611",
                        "content": "With input: [-71,-71,93,-71,40], idk why the expectation is 1?"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Loot at  the last element  40   . It has  93 which is strictly greater and -71 which is strictly lesser \\n"
                    },
                    {
                        "username": "DarkPrinceDK",
                        "content": "1 is correct there is only one number(40) such that it has atleast one number(-71) less and greater(93) than that number "
                    }
                ]
            },
            {
                "id": 1707623,
                "content": [
                    {
                        "username": "Harshhk",
                        "content": "Testcase 1:\\ninput=[-3,3,3,90]\\noutput=2\\n\\nTestcase 2:\\ninput=[-71,-71,93,-71,40]\\noutput=1\\n\\nIsn\\'t it contradicting itself?\\nIf Testcase 2 is correct then someone explain me testcase 1.."
                    },
                    {
                        "username": "yush_2001",
                        "content": "both testcases are correct. as in secnd testcase only 40 is greater than minimum and less than maximum."
                    },
                    {
                        "username": "a4abhiram125",
                        "content": "[11,7,2,15]\\nfor the above case there is also strict small and great for 2 according to the test case description but the expectation is 2 how is this possible can anyone explain"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "Sort the Array\n``` Arrays.sort(nums);   // array would be -  2 7 11 15```\nNow you can see : \n> * The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\n> * Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\n\ncount will be 2 for this."
                    },
                    {
                        "username": "mpalaourg",
                        "content": "The testcase refers to 7 and 11. \\n7 has 2 and 11, where 11 has 7 and 15"
                    },
                    {
                        "username": "pappukr034",
                        "content": "good"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Any Binary search approach ?\\n\\n"
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@azuregcp](/azuregcp)  Thank you\\n"
                    },
                    {
                        "username": "azuregcp",
                        "content": "I think by semi-sorted you mean Partially sorted?\\n\\nAnyways, binary search can be applied only on one type of unsorted array and that is if it\\'s a rotated array. Other than that, you cannot apply binary search on an unsorted array. \\n\\nSo, O(n) is the best time for this problem."
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@JackChen890311](/JackChen890311)  idk the array looks like semi sorted  so just a random thought of bs"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Why do you need binary search?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one "
                    },
                    {
                        "username": "thangtv611",
                        "content": "With input: [-71,-71,93,-71,40], idk why the expectation is 1?"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Loot at  the last element  40   . It has  93 which is strictly greater and -71 which is strictly lesser \\n"
                    },
                    {
                        "username": "DarkPrinceDK",
                        "content": "1 is correct there is only one number(40) such that it has atleast one number(-71) less and greater(93) than that number "
                    }
                ]
            },
            {
                "id": 1903129,
                "content": [
                    {
                        "username": "Harshhk",
                        "content": "Testcase 1:\\ninput=[-3,3,3,90]\\noutput=2\\n\\nTestcase 2:\\ninput=[-71,-71,93,-71,40]\\noutput=1\\n\\nIsn\\'t it contradicting itself?\\nIf Testcase 2 is correct then someone explain me testcase 1.."
                    },
                    {
                        "username": "yush_2001",
                        "content": "both testcases are correct. as in secnd testcase only 40 is greater than minimum and less than maximum."
                    },
                    {
                        "username": "a4abhiram125",
                        "content": "[11,7,2,15]\\nfor the above case there is also strict small and great for 2 according to the test case description but the expectation is 2 how is this possible can anyone explain"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "Sort the Array\n``` Arrays.sort(nums);   // array would be -  2 7 11 15```\nNow you can see : \n> * The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\n> * Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\n\ncount will be 2 for this."
                    },
                    {
                        "username": "mpalaourg",
                        "content": "The testcase refers to 7 and 11. \\n7 has 2 and 11, where 11 has 7 and 15"
                    },
                    {
                        "username": "pappukr034",
                        "content": "good"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Any Binary search approach ?\\n\\n"
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@azuregcp](/azuregcp)  Thank you\\n"
                    },
                    {
                        "username": "azuregcp",
                        "content": "I think by semi-sorted you mean Partially sorted?\\n\\nAnyways, binary search can be applied only on one type of unsorted array and that is if it\\'s a rotated array. Other than that, you cannot apply binary search on an unsorted array. \\n\\nSo, O(n) is the best time for this problem."
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@JackChen890311](/JackChen890311)  idk the array looks like semi sorted  so just a random thought of bs"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Why do you need binary search?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one "
                    },
                    {
                        "username": "thangtv611",
                        "content": "With input: [-71,-71,93,-71,40], idk why the expectation is 1?"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Loot at  the last element  40   . It has  93 which is strictly greater and -71 which is strictly lesser \\n"
                    },
                    {
                        "username": "DarkPrinceDK",
                        "content": "1 is correct there is only one number(40) such that it has atleast one number(-71) less and greater(93) than that number "
                    }
                ]
            },
            {
                "id": 1854985,
                "content": [
                    {
                        "username": "Harshhk",
                        "content": "Testcase 1:\\ninput=[-3,3,3,90]\\noutput=2\\n\\nTestcase 2:\\ninput=[-71,-71,93,-71,40]\\noutput=1\\n\\nIsn\\'t it contradicting itself?\\nIf Testcase 2 is correct then someone explain me testcase 1.."
                    },
                    {
                        "username": "yush_2001",
                        "content": "both testcases are correct. as in secnd testcase only 40 is greater than minimum and less than maximum."
                    },
                    {
                        "username": "a4abhiram125",
                        "content": "[11,7,2,15]\\nfor the above case there is also strict small and great for 2 according to the test case description but the expectation is 2 how is this possible can anyone explain"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "Sort the Array\n``` Arrays.sort(nums);   // array would be -  2 7 11 15```\nNow you can see : \n> * The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\n> * Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\n\ncount will be 2 for this."
                    },
                    {
                        "username": "mpalaourg",
                        "content": "The testcase refers to 7 and 11. \\n7 has 2 and 11, where 11 has 7 and 15"
                    },
                    {
                        "username": "pappukr034",
                        "content": "good"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Any Binary search approach ?\\n\\n"
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@azuregcp](/azuregcp)  Thank you\\n"
                    },
                    {
                        "username": "azuregcp",
                        "content": "I think by semi-sorted you mean Partially sorted?\\n\\nAnyways, binary search can be applied only on one type of unsorted array and that is if it\\'s a rotated array. Other than that, you cannot apply binary search on an unsorted array. \\n\\nSo, O(n) is the best time for this problem."
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@JackChen890311](/JackChen890311)  idk the array looks like semi sorted  so just a random thought of bs"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Why do you need binary search?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one "
                    },
                    {
                        "username": "thangtv611",
                        "content": "With input: [-71,-71,93,-71,40], idk why the expectation is 1?"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Loot at  the last element  40   . It has  93 which is strictly greater and -71 which is strictly lesser \\n"
                    },
                    {
                        "username": "DarkPrinceDK",
                        "content": "1 is correct there is only one number(40) such that it has atleast one number(-71) less and greater(93) than that number "
                    }
                ]
            },
            {
                "id": 1854100,
                "content": [
                    {
                        "username": "Harshhk",
                        "content": "Testcase 1:\\ninput=[-3,3,3,90]\\noutput=2\\n\\nTestcase 2:\\ninput=[-71,-71,93,-71,40]\\noutput=1\\n\\nIsn\\'t it contradicting itself?\\nIf Testcase 2 is correct then someone explain me testcase 1.."
                    },
                    {
                        "username": "yush_2001",
                        "content": "both testcases are correct. as in secnd testcase only 40 is greater than minimum and less than maximum."
                    },
                    {
                        "username": "a4abhiram125",
                        "content": "[11,7,2,15]\\nfor the above case there is also strict small and great for 2 according to the test case description but the expectation is 2 how is this possible can anyone explain"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "Sort the Array\n``` Arrays.sort(nums);   // array would be -  2 7 11 15```\nNow you can see : \n> * The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\n> * Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\n\ncount will be 2 for this."
                    },
                    {
                        "username": "mpalaourg",
                        "content": "The testcase refers to 7 and 11. \\n7 has 2 and 11, where 11 has 7 and 15"
                    },
                    {
                        "username": "pappukr034",
                        "content": "good"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Any Binary search approach ?\\n\\n"
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@azuregcp](/azuregcp)  Thank you\\n"
                    },
                    {
                        "username": "azuregcp",
                        "content": "I think by semi-sorted you mean Partially sorted?\\n\\nAnyways, binary search can be applied only on one type of unsorted array and that is if it\\'s a rotated array. Other than that, you cannot apply binary search on an unsorted array. \\n\\nSo, O(n) is the best time for this problem."
                    },
                    {
                        "username": "IronMan_",
                        "content": "[@JackChen890311](/JackChen890311)  idk the array looks like semi sorted  so just a random thought of bs"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Why do you need binary search?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one "
                    },
                    {
                        "username": "thangtv611",
                        "content": "With input: [-71,-71,93,-71,40], idk why the expectation is 1?"
                    },
                    {
                        "username": "IronMan_",
                        "content": "Loot at  the last element  40   . It has  93 which is strictly greater and -71 which is strictly lesser \\n"
                    },
                    {
                        "username": "DarkPrinceDK",
                        "content": "1 is correct there is only one number(40) such that it has atleast one number(-71) less and greater(93) than that number "
                    }
                ]
            }
        ]
    }
]