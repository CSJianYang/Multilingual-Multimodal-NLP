[
    {
        "title": "Remove Duplicates from Sorted List",
        "question_content": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\n&nbsp;\nExample 1:\n\nInput: head = [1,1,2]\nOutput: [1,2]\n\nExample 2:\n\nInput: head = [1,1,2,3,3]\nOutput: [1,2,3]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 300].\n\t-100 <= Node.val <= 100\n\tThe list is guaranteed to be sorted in ascending order.",
        "solutions": [
            {
                "id": 28625,
                "title": "3-line-java-recursive-solution",
                "content": "This solution is inspired by renzid https://leetcode.com/discuss/33043/3-line-recursive-solution\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n            if(head == null || head.next == null)return head;\\n            head.next = deleteDuplicates(head.next);\\n            return head.val == head.next.val ? head.next : head;\\n    }\\n\\nEnjoy!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "This solution is inspired by renzid https://leetcode.com/discuss/33043/3-line-recursive-solution\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n            if(head == null || head.next == null)return head;\\n            head.next = deleteDuplicates(head.next);\\n            return head.val == head.next.val ? head.next : head;\\n    }\\n\\nEnjoy!",
                "codeTag": "Unknown"
            },
            {
                "id": 28614,
                "title": "my-pretty-solution-java",
                "content": "    public class Solution {\\n        public ListNode deleteDuplicates(ListNode head) {\\n            ListNode list = head;\\n             \\n             while(list != null) {\\n            \\t if (list.next == null) {\\n            \\t\\t break;\\n            \\t }\\n            \\t if (list.val == list.next.val) {\\n            \\t\\t list.next = list.next.next;\\n            \\t } else {\\n            \\t\\t list = list.next;\\n            \\t }\\n             }\\n             \\n             return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode deleteDuplicates(ListNode head) {\\n            ListNode list = head;\\n             \\n             while(list != null) {\\n            \\t if (list.next == null) {\\n            \\t\\t break;\\n            \\t }",
                "codeTag": "Java"
            },
            {
                "id": 28621,
                "title": "simple-iterative-python-6-lines-60-ms",
                "content": "    def deleteDuplicates(self, head):\\n        cur = head\\n        while cur:\\n            while cur.next and cur.next.val == cur.val:\\n                cur.next = cur.next.next     # skip duplicated node\\n            cur = cur.next     # not duplicate of current node, move to next node\\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def deleteDuplicates(self, head):\\n        cur = head\\n        while cur:\\n            while cur.next and cur.next.val == cur.val:\\n                cur.next = cur.next.next     # skip duplicated node\\n            cur = cur.next     # not duplicate of current node, move to next node\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 28663,
                "title": "easy-to-understand-c-solution",
                "content": "no need to initialize a new node\\n\\n    ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* cur = head;\\n            while(cur) {\\n            \\twhile(cur->next && cur->val == cur->next->val) {\\n            \\t\\tcur->next = cur->next->next;\\n            \\t}\\n            \\tcur = cur->next;\\n            }\\n            return head;\\n        }",
                "solutionTags": [],
                "code": "no need to initialize a new node\\n\\n    ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* cur = head;\\n            while(cur) {\\n            \\twhile(cur->next && cur->val == cur->next->val) {\\n            \\t\\tcur->next = cur->next->next;\\n            \\t}\\n            \\tcur = cur->next;\\n            }\\n            return head;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3257316,
                "title": "c-python-c-java-easiest-solution-o-n-time",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        while (temp&&temp->next)\\n        {\\n            if (temp->next->val==temp->val)\\n            {\\n                temp->next=temp->next->next;\\n                continue;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        temp = head\\n        while (temp and temp.next):\\n            if (temp.next.val == temp.val):\\n                temp.next = temp.next.next\\n                continue\\n            temp = temp.next\\n        return head\\n        \\n```\\n\\n# C\\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    struct ListNode* temp=head;\\n    while (temp&&temp->next)\\n    {\\n        if (temp->next->val==temp->val)\\n        {\\n            temp->next=temp->next->next;\\n            continue;\\n        }\\n        temp=temp->next;\\n    }\\n    return head;\\n}\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while (temp != null && temp.next != null)\\n        {\\n            if (temp.next.val==temp.val)\\n            {\\n                temp.next=temp.next.next;\\n                continue;\\n            }\\n            temp=temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\nUpvote if this helps please \\uD83D\\uDE42\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        while (temp&&temp->next)\\n        {\\n            if (temp->next->val==temp->val)\\n            {\\n                temp->next=temp->next->next;\\n                continue;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        temp = head\\n        while (temp and temp.next):\\n            if (temp.next.val == temp.val):\\n                temp.next = temp.next.next\\n                continue\\n            temp = temp.next\\n        return head\\n        \\n```\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    struct ListNode* temp=head;\\n    while (temp&&temp->next)\\n    {\\n        if (temp->next->val==temp->val)\\n        {\\n            temp->next=temp->next->next;\\n            continue;\\n        }\\n        temp=temp->next;\\n    }\\n    return head;\\n}\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while (temp != null && temp.next != null)\\n        {\\n            if (temp.next.val==temp.val)\\n            {\\n                temp.next=temp.next.next;\\n                continue;\\n            }\\n            temp=temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28730,
                "title": "concise-solution-and-memory-freeing",
                "content": "I noticed that the solutions posted here are too long and complicated. They use unnecessary variables and/or checks etc.\\nThe solution can be much more concise. Here is my solution:\\n\\n    class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode* cur = head;\\n            while (cur) {\\n                while (cur->next && cur->val == cur->next->val)\\n                    cur->next = cur->next->next;\\n                cur = cur->next;\\n            }\\n            return head;\\n        }\\n    };\\n\\n**Note about freeing memory**. We need to free memory when we delete a node. But don't use `delete node;` construct on an interview without discussing it with the interviewer. A list node can be allocated in many different ways and we can use `delete node;` only if we are sure that the nodes were allocated with `new TreeNode(...);`.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode* cur = head;\\n            while (cur) {\\n                while (cur->next && cur->val == cur->next->val)\\n                    cur->next = cur->next->next;\\n                cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 943403,
                "title": "python-simple-solution",
                "content": "**Solution 1:**\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur=head\\n        while cur:\\n            while cur.next and cur.next.val==cur.val:\\n                cur.next=cur.next.next\\n            cur=cur.next\\n        return head\\n        \\n```\\n\\n**Solution 2:**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur=head\\n        while cur:\\n            if cur.next and cur.next.val==cur.val:\\n                cur.next=cur.next.next\\n            else:\\n                cur=cur.next\\n        return head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur=head\\n        while cur:\\n            while cur.next and cur.next.val==cur.val:\\n                cur.next=cur.next.next\\n            cur=cur.next\\n        return head\\n        \\n```\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur=head\\n        while cur:\\n            if cur.next and cur.next.val==cur.val:\\n                cur.next=cur.next.next\\n            else:\\n                cur=cur.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28722,
                "title": "javascript-solution",
                "content": "I didn't see many JS solutions, so I thought I'd share\\n\\n<pre>\\nvar deleteDuplicates = function(head) {\\n    var current = head;\\n    \\n    while(current) {\\n        if(current.next !== null && current.val == current.next.val) {\\n            current.next = current.next.next;\\n        } else {\\n            current = current.next;\\n        }\\n    }\\n    \\n    return head;\\n};\\n</pre>",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "I didn't see many JS solutions, so I thought I'd share\\n\\n<pre>\\nvar deleteDuplicates = function(head) {\\n    var current = head;\\n    \\n    while(current) {\\n        if(current.next !== null && current.val == current.next.val) {\\n            current.next = current.next.next;\\n        } else {\\n            current = current.next;\\n        }\\n    }\\n    \\n    return head;\\n};\\n</pre>",
                "codeTag": "Unknown"
            },
            {
                "id": 314650,
                "title": "c-code-8-ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892275,
                "title": "python3-o-n-beats-95-80-41-ms-simple-with-explanation",
                "content": "# Approach\\n- We first deal with edge case of head being `None` rather than a `ListNode`\\n- Next we create a new variable `curr` to point at our current node, starting with the `head` node\\n- If `curr.next` is another node, we compare `curr.val` and `curr.next.val`\\n    - If the values are the same, we must remove one from the linked list\\n        - We keep the first node and remove the second by updating the first\\'s .next (`curr.next`) to the next node\\'s `.next` (`curr.next.next`)\\n    - If the values differ, we move point `curr` to the next node\\n- We repeat the previous process until the current node does not point to another node, at which point we return `head`, the de-duplicated linked list\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return None\\n\\n        curr = head\\n\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n\\n        return head\\n\\n```\\n\\n## Please upvote if you find this helpful! :D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return None\\n\\n        curr = head\\n\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765793,
                "title": "easy-java-solution-beats-100-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n\\n    ListNode temp = head;\\n        if (head == null)\\n        {\\n            return head;\\n        }\\n        \\n        while (temp.next !=null)\\n        {\\n            if (temp.val != temp.next.val) {\\n                temp = temp.next;\\n            }\\n            else temp.next = temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/c78d9c13-efe2-4e13-a6e9-c5c7c4f16a18_1689361724.747828.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n\\n    ListNode temp = head;\\n        if (head == null)\\n        {\\n            return head;\\n        }\\n        \\n        while (temp.next !=null)\\n        {\\n            if (temp.val != temp.next.val) {\\n                temp = temp.next;\\n            }\\n            else temp.next = temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414474,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 1 ms, faster than 92.17% of Java online submissions for Remove Duplicates from Sorted List.\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if(head == null || head.next == null)\\n            return head;\\n        // Initialize a pointer curr with the address of head node...\\n        ListNode curr = head;\\n        // Traverse all element through a while loop if curr node and the next node of curr node are present...\\n        while( curr != null && curr.next != null){\\n            // If the value of curr is equal to the value of prev...\\n            // It means the value is present in the linked list...\\n            if(curr.val == curr.next.val){\\n                // Hence we do not need to include curr again in the linked list...\\n                // So we increment the value of curr...\\n                curr.next = curr.next.next;\\n            }\\n            // Otherwise, we increment the curr pointer...\\n            else{\\n                curr = curr.next; \\n            }\\n        }\\n        return head;        // Return the sorted linked list without any duplicate element...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 4 ms, faster than 81.52% of C++ online submissions for Remove Duplicates from Sorted List.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // Special case...\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        // Initialize two pointers tmp(slow) and curr(fast)...\\n        ListNode* tmp = head;\\n        ListNode* curr = head->next;\\n        // Traverse all element through a while loop if curr node is not null...\\n        while(curr!=NULL) {\\n            // If the value of curr is equal to the value of tmp...\\n            // It means the value is present in the linked list...\\n            if(tmp->val == curr->val) {\\n                // Hence we do not need to include curr again in the linked list...\\n                // So we increment the value of curr...\\n                curr=curr->next;\\n            }\\n            // Otherwise, we increment both the pointers.\\n            else {\\n                tmp->next = curr;\\n                tmp = curr;\\n                curr = tmp->next;\\n            }\\n        }\\n        tmp->next = NULL;\\n        return head;        // Return the sorted linked list without any duplicate element...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 36 ms, faster than 79.68% of Python online submissions for Remove Duplicates from Sorted List.\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        # Handle special case that the list is empty\\n        if head == None:\\n            return head\\n        # Initialize curr with the address of head node...\\n        curr = head\\n        # Travel the list until the second last node\\n        while curr.next != None:\\n            # If the value of curr is equal to the value of prev...\\n            # It means the value is present in the linked list...\\n            if curr.val == curr.next.val:\\n                # Hence we do not need to include curr again in the linked list...\\n                # So we increment the value of curr...\\n                tmp = curr.next\\n                curr.next = curr.next.next\\n                del tmp\\n            # Otherwise, we increment the curr pointer...\\n            else:\\n                curr = curr.next\\n        return head         # Return the sorted linked list without any duplicate element...\\n```\\n                    \\n# **JavaScript Solution:**\\nRuntime: 82 ms, faster than 84.86% of JavaScript online submissions for Remove Duplicates from Sorted List.\\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if(head == null || head.next == null)\\n        return head;\\n    // Initialize a pointer curr with the address of head node...\\n    let curr = head;\\n    // Traverse all element through a while loop if curr node and the next node of curr node are present...\\n    while( curr != null && curr.next != null){\\n        // If the value of curr is equal to the value of prev...\\n        // It means the value is present in the linked list...\\n        if(curr.val == curr.next.val){\\n            // Hence we do not need to include curr again in the linked list...\\n            // So we increment the value of curr...\\n            curr.next = curr.next.next;\\n        }\\n        // Otherwise, we increment the curr pointer...\\n        else{\\n            curr = curr.next; \\n        }\\n    }\\n    return head;        // Return the sorted linked list without any duplicate element...\\n};\\n```\\n\\n# **C Language:**\\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // Special case...\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    // Initialize two pointers tmp(slow) and curr(fast)...\\n    struct ListNode* tmp = head;\\n    struct ListNode* curr = head->next;\\n    // Traverse all element through a while loop if curr node is not null...\\n    while(curr!=NULL) {\\n        // If the value of curr is equal to the value of tmp...\\n        // It means the value is present in the linked list...\\n        if(tmp->val == curr->val) {\\n            // Hence we do not need to include curr again in the linked list...\\n            // So we increment the value of curr...\\n            curr=curr->next;\\n        }\\n        // Otherwise, we increment both the pointers.\\n        else {\\n            tmp->next = curr;\\n            tmp = curr;\\n            curr = tmp->next;\\n        }\\n    }\\n    tmp->next = NULL;\\n    return head;        // Return the sorted linked list without any duplicate element...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Handle special case that the list is empty\\n        if head == None:\\n            return head\\n        # Initialize curr with the address of head node...\\n        curr = head\\n        # Travel the list until the second last node\\n        while curr.next != None:\\n            # If the value of curr is equal to the value of prev...\\n            # It means the value is present in the linked list...\\n            if curr.val == curr.next.val:\\n                # Hence we do not need to include curr again in the linked list...\\n                # So we increment the value of curr...\\n                tmp = curr.next\\n                curr.next = curr.next.next\\n                del tmp\\n            # Otherwise, we increment the curr pointer...\\n            else:\\n                curr = curr.next\\n        return head         # Return the sorted linked list without any duplicate element...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if(head == null || head.next == null)\\n            return head;\\n        // Initialize a pointer curr with the address of head node...\\n        ListNode curr = head;\\n        // Traverse all element through a while loop if curr node and the next node of curr node are present...\\n        while( curr != null && curr.next != null){\\n            // If the value of curr is equal to the value of prev...\\n            // It means the value is present in the linked list...\\n            if(curr.val == curr.next.val){\\n                // Hence we do not need to include curr again in the linked list...\\n                // So we increment the value of curr...\\n                curr.next = curr.next.next;\\n            }\\n            // Otherwise, we increment the curr pointer...\\n            else{\\n                curr = curr.next; \\n            }\\n        }\\n        return head;        // Return the sorted linked list without any duplicate element...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // Special case...\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        // Initialize two pointers tmp(slow) and curr(fast)...\\n        ListNode* tmp = head;\\n        ListNode* curr = head->next;\\n        // Traverse all element through a while loop if curr node is not null...\\n        while(curr!=NULL) {\\n            // If the value of curr is equal to the value of tmp...\\n            // It means the value is present in the linked list...\\n            if(tmp->val == curr->val) {\\n                // Hence we do not need to include curr again in the linked list...\\n                // So we increment the value of curr...\\n                curr=curr->next;\\n            }\\n            // Otherwise, we increment both the pointers.\\n            else {\\n                tmp->next = curr;\\n                tmp = curr;\\n                curr = tmp->next;\\n            }\\n        }\\n        tmp->next = NULL;\\n        return head;        // Return the sorted linked list without any duplicate element...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        # Handle special case that the list is empty\\n        if head == None:\\n            return head\\n        # Initialize curr with the address of head node...\\n        curr = head\\n        # Travel the list until the second last node\\n        while curr.next != None:\\n            # If the value of curr is equal to the value of prev...\\n            # It means the value is present in the linked list...\\n            if curr.val == curr.next.val:\\n                # Hence we do not need to include curr again in the linked list...\\n                # So we increment the value of curr...\\n                tmp = curr.next\\n                curr.next = curr.next.next\\n                del tmp\\n            # Otherwise, we increment the curr pointer...\\n            else:\\n                curr = curr.next\\n        return head         # Return the sorted linked list without any duplicate element...\\n```\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if(head == null || head.next == null)\\n        return head;\\n    // Initialize a pointer curr with the address of head node...\\n    let curr = head;\\n    // Traverse all element through a while loop if curr node and the next node of curr node are present...\\n    while( curr != null && curr.next != null){\\n        // If the value of curr is equal to the value of prev...\\n        // It means the value is present in the linked list...\\n        if(curr.val == curr.next.val){\\n            // Hence we do not need to include curr again in the linked list...\\n            // So we increment the value of curr...\\n            curr.next = curr.next.next;\\n        }\\n        // Otherwise, we increment the curr pointer...\\n        else{\\n            curr = curr.next; \\n        }\\n    }\\n    return head;        // Return the sorted linked list without any duplicate element...\\n};\\n```\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // Special case...\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    // Initialize two pointers tmp(slow) and curr(fast)...\\n    struct ListNode* tmp = head;\\n    struct ListNode* curr = head->next;\\n    // Traverse all element through a while loop if curr node is not null...\\n    while(curr!=NULL) {\\n        // If the value of curr is equal to the value of tmp...\\n        // It means the value is present in the linked list...\\n        if(tmp->val == curr->val) {\\n            // Hence we do not need to include curr again in the linked list...\\n            // So we increment the value of curr...\\n            curr=curr->next;\\n        }\\n        // Otherwise, we increment both the pointers.\\n        else {\\n            tmp->next = curr;\\n            tmp = curr;\\n            curr = tmp->next;\\n        }\\n    }\\n    tmp->next = NULL;\\n    return head;        // Return the sorted linked list without any duplicate element...\\n}\\n```\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Handle special case that the list is empty\\n        if head == None:\\n            return head\\n        # Initialize curr with the address of head node...\\n        curr = head\\n        # Travel the list until the second last node\\n        while curr.next != None:\\n            # If the value of curr is equal to the value of prev...\\n            # It means the value is present in the linked list...\\n            if curr.val == curr.next.val:\\n                # Hence we do not need to include curr again in the linked list...\\n                # So we increment the value of curr...\\n                tmp = curr.next\\n                curr.next = curr.next.next\\n                del tmp\\n            # Otherwise, we increment the curr pointer...\\n            else:\\n                curr = curr.next\\n        return head         # Return the sorted linked list without any duplicate element...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28699,
                "title": "clear-python-code-beat-90",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        first, second = head, head.next if head else None\\n        while second:\\n            if first.val == second.val:\\n                second = second.next\\n                first.next = second\\n            else:\\n                first = second\\n                second = second.next\\n                \\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        first, second = head, head.next if head else None\\n        while second:\\n            if first.val == second.val:\\n                second = second.next\\n                first.next = second\\n            else:\\n                first = second\\n                second = second.next\\n                \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023588,
                "title": "java-runtime-0ms-beats-100-00",
                "content": "# Intuition\\nThe problem requires removing duplicates from a sorted singly-linked list. The approach involves iterating through the list and removing duplicates while maintaining the sorted order.\\n\\n# Approach\\n- Initialize a pointer `current` to the head of the linked list to traverse the list.\\n- Start a while loop that continues until `current` reaches the end of the list or `current.next` reaches null.\\n- Inside the loop, compare the value of the current node `current.val` with the value of the next node `current.next.val`.\\n- If the values are equal, it indicates a duplicate node. In this case, update the `next` pointer of the current node `current.next` to skip the next node (remove the duplicate).\\n- If the values are not equal, move the `current` pointer to the next node, continuing the traversal.\\n- Repeat the loop until the end of the list is reached, ensuring that all duplicates are removed while maintaining the sorted order of the remaining nodes.\\n- After the loop, return the modified linked list, which contains no duplicates.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the linked list once, where n is the number of nodes in the list. Each node is examined once to identify and remove duplicates.\\n\\n- Space complexity: O(1)\\n  The algorithm uses a constant amount of additional memory space for variables, regardless of the size of the input linked list, making its space complexity constant.\\n\\n# Code\\n```java\\nclass Solution {\\n   public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n\\n        while (current != null && current.next != null) {\\n            if (current.val == current.next.val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/03822e25-72a1-4bde-a0fe-7a31db27fa1f_1694283728.4735084.webp)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n   public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n\\n        while (current != null && current.next != null) {\\n            if (current.val == current.next.val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455325,
                "title": "python-whithot-other-space",
                "content": "use cur to skip node which value are equal, and then return head\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur = head\\n        while(cur):\\n            if(cur.next and cur.next.val==cur.val):\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return head\\n```\\n\\nRuntime: 36 ms, faster than 94.20% of Python3 online submissions for Remove Duplicates from Sorted List.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Remove Duplicates from Sorted List.\\n\\n**If it helps you , Please give me a vote star\\nThanks**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur = head\\n        while(cur):\\n            if(cur.next and cur.next.val==cur.val):\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28636,
                "title": "clean-java-solution",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null) return head;\\n        ListNode dummy=head;\\n        while(dummy.next!=null){\\n            if(dummy.next.val==dummy.val){\\n                dummy.next=dummy.next.next;\\n            }else dummy=dummy.next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null) return head;\\n        ListNode dummy=head;\\n        while(dummy.next!=null){\\n            if(dummy.next.val==dummy.val){\\n                dummy.next=dummy.next.next;\\n            }else dummy=dummy.next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 344741,
                "title": "my-idiomatic-solution-rust",
                "content": "```\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut h = head;\\n        let mut p1 = h.as_mut().unwrap();\\n        while let Some(p2) = p1.next.as_mut() {\\n            if p1.val == p2.val {\\n                p1.next = p2.next.take();\\n            } else {\\n                p1 = p1.next.as_mut().unwrap();\\n            }\\n        }\\n        h\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut h = head;\\n        let mut p1 = h.as_mut().unwrap();\\n        while let Some(p2) = p1.next.as_mut() {\\n            if p1.val == p2.val {\\n                p1.next = p2.next.take();\\n            } else {\\n                p1 = p1.next.as_mut().unwrap();\\n            }\\n        }\\n        h\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506294,
                "title": "c-and-python-simple-solution",
                "content": "**C++ :**\\n\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\tif(!head) return head;\\n\\tListNode* tmp = head;\\n\\n\\twhile(tmp && tmp -> next)\\n\\t{\\n\\t\\tif(tmp -> val == tmp -> next -> val)\\n\\t\\t\\ttmp -> next = tmp -> next -> next;\\n\\t\\telse\\n\\t\\t\\ttmp = tmp -> next; \\n\\t}\\n\\n\\treturn head;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\ttemp = head\\n\\twhile temp and temp.next:\\n\\t\\tif temp.val == temp.next.val:\\n\\t\\t\\ttemp.next = temp.next.next\\n\\t\\telse:\\n\\t\\t\\ttemp = temp.next\\n\\n\\treturn head\\n```\\n\\n**Like it ? please upvote**\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\tif(!head) return head;\\n\\tListNode* tmp = head;\\n\\n\\twhile(tmp && tmp -> next)\\n\\t{\\n\\t\\tif(tmp -> val == tmp -> next -> val)\\n\\t\\t\\ttmp -> next = tmp -> next -> next;\\n\\t\\telse\\n\\t\\t\\ttmp = tmp -> next; \\n\\t}\\n\\n\\treturn head;\\n}\\n```\n```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\ttemp = head\\n\\twhile temp and temp.next:\\n\\t\\tif temp.val == temp.next.val:\\n\\t\\t\\ttemp.next = temp.next.next\\n\\t\\telse:\\n\\t\\t\\ttemp = temp.next\\n\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 28765,
                "title": "c-concise-solution",
                "content": "        \\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *cur = head;\\n        while (cur && cur->next) {\\n            if (cur->val == cur->next->val)\\n                cur->next = cur->next->next;\\n            else\\n                cur = cur->next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *cur = head;\\n        while (cur && cur->next) {\\n            if (cur->val == cur->next->val)\\n                cur->next = cur->next->next;\\n            else\\n                cur = cur->next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 801992,
                "title": "javascript-solution-83",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n    if(!head) return head\\n    var cur = head\\n    \\n    while(cur!=null && cur.next != null) {\\n        if(cur.next.val === cur.val) {\\n            cur.next = cur.next.next\\n        }else {\\n            cur = cur.next\\n        }\\n    }\\n    return head\\n}\\n```\\n\\n**Runtime: 76 ms, faster than 94.64% of JavaScript online submissions for Remove Duplicates from Sorted List.**\\n\\n**Memory Usage: 38.6 MB, less than 44.03% of JavaScript online submissions for Remove Duplicates from Sorted List.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    if(!head) return head\\n    var cur = head\\n    \\n    while(cur!=null && cur.next != null) {\\n        if(cur.next.val === cur.val) {\\n            cur.next = cur.next.next\\n        }else {\\n            cur = cur.next\\n        }\\n    }\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557910,
                "title": "rust-simple-concise-iterative-0ms-100",
                "content": "This would be a simple thing in C/C++, but with Rust\\'s super strict borrow checking and the general usage model for `Option` wrapping `Box` it\\'s challenging to find a solution that looks concise and is efficient. But I think I have it here. Any \"crustaceans\" who see a better way and want to offer advice, please let me know.\\n\\n```rust\\nimpl Solution {\\n    \\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> \\n    {\\n        let mut curr_opt = head.as_mut();\\n        \\n        while let Some(curr) = curr_opt {\\n            let mut next_opt = curr.next.take();\\n            \\n            while let Some(next) = next_opt.as_mut() {    \\n                if next.val == curr.val \\n                     { next_opt  = next.next.take(); }\\n                else { curr.next = next_opt;  break; }\\n            }\\n            curr_opt = curr.next.as_mut();\\n        }\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Linked List"
                ],
                "code": "```rust\\nimpl Solution {\\n    \\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> \\n    {\\n        let mut curr_opt = head.as_mut();\\n        \\n        while let Some(curr) = curr_opt {\\n            let mut next_opt = curr.next.take();\\n            \\n            while let Some(next) = next_opt.as_mut() {    \\n                if next.val == curr.val \\n                     { next_opt  = next.next.take(); }\\n                else { curr.next = next_opt;  break; }\\n            }\\n            curr_opt = curr.next.as_mut();\\n        }\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28745,
                "title": "easy-understand-java-solution",
                "content": " public ListNode deleteDuplicates(ListNode head) {\\n\\n        ListNode temp = head;\\n\\n        while(temp!=null&&temp.next!=null){\\n\\n            if(temp.val == temp.next.val){\\n\\n                temp.next = temp.next.next;\\n            }\\n            else\\n                temp = temp.next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [],
                "code": " public ListNode deleteDuplicates(ListNode head) {\\n\\n        ListNode temp = head;\\n\\n        while(temp!=null&&temp.next!=null){\\n\\n            if(temp.val == temp.next.val){\\n\\n                temp.next = temp.next.next;\\n            }\\n            else\\n                temp = temp.next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28828,
                "title": "one-liner-in-ruby",
                "content": "Recursively remove duplicates from the rest of the list, then possibly drop the head (if it's a duplicate of the value after it).\\n\\nRuby:\\n\\n    def delete_duplicates(h)\\n        h && (h.next = delete_duplicates(h.next)) && h.next.val == h.val ? h.next : h\\n    end\\n\\n---\\n\\nBad C++ versions:\\n\\n    return h && (h->next = deleteDuplicates(h->next)) && h->next->val == h->val ? h->next : h;\\n\\nAs @shawnyi pointed out, that leaks memory. So `delete`:\\n\\n    if (h && (h->next = deleteDuplicates(h->next)) && h->next->val == h->val) delete h, h = h->next; return h;\\n\\nAs @drbombe pointed out, I shouldn't access `h->next` after deleting `h`. Not sure what I was thinking. I certainly knew that. I guess I just focused on the algorithm and didn't care as long as it gets accepted (which it does).\\n\\nFor a proper version, see @drbombe's solution below.",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "Recursively remove duplicates from the rest of the list, then possibly drop the head (if it's a duplicate of the value after it).\\n\\nRuby:\\n\\n    def delete_duplicates(h)\\n        h && (h.next = delete_duplicates(h.next)) && h.next.val == h.val ? h.next : h\\n    end\\n\\n---\\n\\nBad C++ versions:\\n\\n    return h && (h->next = deleteDuplicates(h->next)) && h->next->val == h->val ? h->next : h;\\n\\nAs @shawnyi pointed out, that leaks memory. So `delete`:\\n\\n    if (h && (h->next = deleteDuplicates(h->next)) && h->next->val == h->val) delete h, h = h->next; return h;\\n\\nAs @drbombe pointed out, I shouldn't access `h->next` after deleting `h`. Not sure what I was thinking. I certainly knew that. I guess I just focused on the algorithm and didn't care as long as it gets accepted (which it does).\\n\\nFor a proper version, see @drbombe's solution below.",
                "codeTag": "Python3"
            },
            {
                "id": 2676904,
                "title": "easy-to-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        /* if head = NULL */\\n        if(!head) return head;\\n        /* setting the curr at head */\\n        ListNode *curr = head;\\n        while(curr->next){\\n            /* if curr value == curr next value the we have to delete next value */\\n            if(curr->val == curr->next->val){\\n                /* stroing next address for deleting further */\\n                ListNode *temp = curr->next;\\n                \\n                /* changing curr pointer to next of next */\\n                curr->next = curr->next->next;\\n                delete temp;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        /* if head = NULL */\\n        if(!head) return head;\\n        /* setting the curr at head */\\n        ListNode *curr = head;\\n        while(curr->next){\\n            /* if curr value == curr next value the we have to delete next value */\\n            if(curr->val == curr->next->val){\\n                /* stroing next address for deleting further */\\n                ListNode *temp = curr->next;\\n                \\n                /* changing curr pointer to next of next */\\n                curr->next = curr->next->next;\\n                delete temp;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335394,
                "title": "swift-remove-duplicates-from-sorted-list-test-cases",
                "content": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var node = head\\n        while let next = node?.next {\\n            node!.val == next.val ? (node!.next = next.next) : (node = next)\\n        }\\n        return head\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.027 (0.029) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.deleteDuplicates(.init([1,1,2]))\\n        let expected = ListNode([1,2])\\n        XCTAssertEqual(res?.val, expected?.val)\\n    }\\n    func test1() {\\n        let res = s.deleteDuplicates(.init([1,1,2,3,3]))\\n        let expected = ListNode([1,2,3])\\n        XCTAssertEqual(res?.val, expected?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var node = head\\n        while let next = node?.next {\\n            node!.val == next.val ? (node!.next = next.next) : (node = next)\\n        }\\n        return head\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.027 (0.029) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.deleteDuplicates(.init([1,1,2]))\\n        let expected = ListNode([1,2])\\n        XCTAssertEqual(res?.val, expected?.val)\\n    }\\n    func test1() {\\n        let res = s.deleteDuplicates(.init([1,1,2,3,3]))\\n        let expected = ListNode([1,2,3])\\n        XCTAssertEqual(res?.val, expected?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935684,
                "title": "very-understandable-javascript-two-pointer-solution-o-n-time-o-1-space",
                "content": "Let p = prev, n = next. Now walk through the code using p and n\\n```\\n1->1->2->3->3->4\\np  n\\n\\n1->   2->3->3->4\\np     n\\n\\n1->2->3->3->4\\np  n\\n\\n1->2->3->3->4\\n   p  n\\n\\n1->2->3->3->4\\n      p  n\\n\\t  \\n1->2->3   ->4\\n\\t  p  n\\n\\t  \\n1->2->3->4\\n\\t  p  n\\n\\n1->2->3->4\\n\\t     p  n\\n```\\n\\nCode: \\n```\\nvar deleteDuplicates = function(head) {\\n  if (!head) return null;\\n  // Init prev as 1st node, next as 2nd node\\n  let prev = head, next = head.next;\\n\\n  // Iterate until next is null, which is end of list\\n  while (next) {\\n    if (prev.val === next.val) {\\n\\t  // If next is a duplicate, skip over it by pointing its prev to its next\\n      prev.next = next.next;\\n    } else {\\n\\t  // Else, just move prev forward to continue through the list\\n      prev = prev.next;\\n    }\\n\\t// Always move next forward, it moves along with prev\\n    next = next.next;\\n  }\\n\\n  return head;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n1->1->2->3->3->4\\np  n\\n\\n1->   2->3->3->4\\np     n\\n\\n1->2->3->3->4\\np  n\\n\\n1->2->3->3->4\\n   p  n\\n\\n1->2->3->3->4\\n      p  n\\n\\t  \\n1->2->3   ->4\\n\\t  p  n\\n\\t  \\n1->2->3->4\\n\\t  p  n\\n\\n1->2->3->4\\n\\t     p  n\\n```\n```\\nvar deleteDuplicates = function(head) {\\n  if (!head) return null;\\n  // Init prev as 1st node, next as 2nd node\\n  let prev = head, next = head.next;\\n\\n  // Iterate until next is null, which is end of list\\n  while (next) {\\n    if (prev.val === next.val) {\\n\\t  // If next is a duplicate, skip over it by pointing its prev to its next\\n      prev.next = next.next;\\n    } else {\\n\\t  // Else, just move prev forward to continue through the list\\n      prev = prev.next;\\n    }\\n\\t// Always move next forward, it moves along with prev\\n    next = next.next;\\n  }\\n\\n  return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28743,
                "title": "remove-duplicates-from-sorted-unsorted-list-in-java",
                "content": "Remove duplicates from sorted linked list : \\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode fakeHead = head;\\n        while(fakeHead != null && fakeHead.next != null){\\n            if(fakeHead.val == fakeHead.next.val){\\n                fakeHead.next = fakeHead.next.next;\\n            } else{\\n                fakeHead = fakeHead.next;\\n            }\\n        }\\n        return head;\\n    }\\n\\n\\n\\nRemove duplicates from unsorted linked list (works on sorted list as well) : \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        Set<Integer> set = new HashSet<>();\\n        ListNode pre = null;\\n        ListNode fakeHead = head;\\n        while(fakeHead != null){\\n            if(!set.add(fakeHead.val)){\\n                pre.next = fakeHead.next;\\n            } else{\\n                pre = fakeHead;\\n            }\\n            fakeHead = fakeHead.next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Remove duplicates from sorted linked list : \\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode fakeHead = head;\\n        while(fakeHead != null && fakeHead.next != null){\\n            if(fakeHead.val == fakeHead.next.val){\\n                fakeHead.next = fakeHead.next.next;\\n            } else{\\n                fakeHead = fakeHead.next;\\n            }\\n        }\\n        return head;\\n    }\\n\\n\\n\\nRemove duplicates from unsorted linked list (works on sorted list as well) : \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        Set<Integer> set = new HashSet<>();\\n        ListNode pre = null;\\n        ListNode fakeHead = head;\\n        while(fakeHead != null){\\n            if(!set.add(fakeHead.val)){\\n                pre.next = fakeHead.next;\\n            } else{\\n                pre = fakeHead;\\n            }\\n            fakeHead = fakeHead.next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3154174,
                "title": "simple-java-c-100-readable-easy-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n public class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode temp = head;\\n    while (temp != null) {\\n        while(temp.next != null && temp.next.val == temp.val) {\\n           temp.next = temp.next.next;\\n        }\\n        temp = temp.next;\\n    }\\n    return head;\\n}\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n public class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode temp = head;\\n    while (temp != null) {\\n        while(temp.next != null && temp.next.val == temp.val) {\\n           temp.next = temp.next.next;\\n        }\\n        temp = temp.next;\\n    }\\n    return head;\\n}\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921891,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var current = head\\n        var last: ListNode?\\n        \\n        while current != nil {\\n            if last != nil && current!.val == last!.val {\\n                last?.next = current?.next\\n            \\n            } else {\\n                last = current\\n            }\\n            \\n            current = current?.next\\n        }\\n        \\n        return head\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var current = head\\n        var last: ListNode?\\n        \\n        while current != nil {\\n            if last != nil && current!.val == last!.val {\\n                last?.next = current?.next\\n            \\n            } else {\\n                last = current\\n            }\\n            \\n            current = current?.next\\n        }\\n        \\n        return head\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308429,
                "title": "simple-python-solution",
                "content": "```\\n\\t\\tif not head:\\n            return None\\n        curr = head\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr=curr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tif not head:\\n            return None\\n        curr = head\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr=curr.next\\n        return head\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3026270,
                "title": "javascript-easy-solution-with-explanation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe purpose of this code is to remove duplicate nodes from a linked list. It does this by iterating through the linked list and comparing the values stored in each node to the values stored in the nodes that come after it. If it finds two nodes with the same value, it deletes the second of the two nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function begins by checking if the head argument is null, in which case it returns null. This check handles the case of an empty linked list.\\n2. The function then declares a local variable curr and initializes it to head. This variable will be used to iterate through the linked list and delete any duplicate nodes.\\n3. The function then enters a while loop that continues as long as curr.next is not null. This loop will iterate through the entire linked list.\\n4. Within the loop, the function checks if the value stored in the current node (curr.val) is equal to the value stored in the next node (curr.next.val). If these values are equal, then the current node and the next node are duplicates, and the next node needs to be deleted.\\n5. To delete the next node, the function first stores a reference to the node after the next node (next_next). This is necessary because after the next node is deleted, we will need to update curr.next to skip over the deleted node and point to the node after the next node.\\n6. The function then declares a local variable nodeToDelete and initializes it to curr.next, which is the node that needs to be deleted.\\n7. The function then calls the built-in delete function and passes it nodeToDelete, which deletes the node from the linked list.\\n8. Finally, the function updates curr.next to point to the node after the next node (next_next), effectively skipping over the deleted node.\\n9. If the values stored in curr.val and curr.next.val are not equal, then the current node and the next node are not duplicates, and the loop simply advances curr to the next node by updating curr to curr.next.\\n10. After the loop completes, the function returns head, which is the reference to the head node of the linked list with the duplicates removed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the number of nodes in the linked list. This is because the function iterates through the entire linked list once, performing a constant amount of work on each iteration.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1), because the function only uses a constant amount of space regardless of the size of the input. The only variables that are allocated are \"curr\",\" next_next\", and \"nodeToDelete\", which are all fixed-size variables that do not depend on the size of the input.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    //empty list\\n    if(head == null)\\n    return null;\\n\\n   let curr = head;\\n    while(curr.next != null){\\n    \\n        if(curr.val == curr.next.val){\\n          let next_next = curr.next.next;\\n          let nodeToDelete = curr.next;\\n          delete(nodeToDelete);\\n          curr.next = next_next;\\n        }\\n        else//not equal\\n        { \\n          curr = curr.next;\\n        }\\n       \\n    }\\nreturn head;\\n};\\n**<!-- Please upvote if you like this solution -->**\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    //empty list\\n    if(head == null)\\n    return null;\\n\\n   let curr = head;\\n    while(curr.next != null){\\n    \\n        if(curr.val == curr.next.val){\\n          let next_next = curr.next.next;\\n          let nodeToDelete = curr.next;\\n          delete(nodeToDelete);\\n          curr.next = next_next;\\n        }\\n        else//not equal\\n        { \\n          curr = curr.next;\\n        }\\n       \\n    }\\nreturn head;\\n};\\n**<!-- Please upvote if you like this solution -->**\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1258359,
                "title": "simplest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode* pointer = head;\\n        while(pointer != NULL && pointer->next != NULL)\\n        {\\n            if(pointer->val == pointer->next->val)\\n            {\\n                pointer->next = pointer->next->next; //if the val of current node is equals to the val of next node then skip the node\\n            }\\n            else\\n            {\\n                pointer = pointer->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n**Like the solution? Please upvote.....**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode* pointer = head;\\n        while(pointer != NULL && pointer->next != NULL)\\n        {\\n            if(pointer->val == pointer->next->val)\\n            {\\n                pointer->next = pointer->next->next; //if the val of current node is equals to the val of next node then skip the node\\n            }\\n            else\\n            {\\n                pointer = pointer->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28750,
                "title": "4-ms-c-solution",
                "content": "    if (head) {\\n        struct ListNode *p = head;\\n        while (p->next) {\\n            if (p->val != p->next->val) {\\n                p = p->next;\\n            }\\n            else {\\n                struct ListNode *tmp = p->next;\\n                p->next = p->next->next;\\n                free(tmp);\\n            }\\n        }\\n    }\\n    \\n    return head;",
                "solutionTags": [],
                "code": "    if (head) {\\n        struct ListNode *p = head;\\n        while (p->next) {\\n            if (p->val != p->next->val) {\\n                p = p->next;\\n            }\\n            else {\\n                struct ListNode *tmp = p->next;\\n                p->next = p->next->next;\\n                free(tmp);\\n            }\\n        }\\n    }\\n    \\n    return head;",
                "codeTag": "Unknown"
            },
            {
                "id": 3333593,
                "title": "6-lines-code-in-python3",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr=head\\n        while curr:\\n            while curr.next and curr.next.val==curr.val:\\n                curr.next=curr.next.next\\n            curr=curr.next\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr=head\\n        while curr:\\n            while curr.next and curr.next.val==curr.val:\\n                curr.next=curr.next.next\\n            curr=curr.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333386,
                "title": "awesome-trick-with-7-lines-of-code",
                "content": "\\n# One Pointers Approach--->Time:O(N)\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current=head\\n        while current and current.next:\\n            if current.val==current.next.val:\\n                current.next=current.next.next\\n            else:\\n                current=current.next\\n        return head\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current=head\\n        while current and current.next:\\n            if current.val==current.next.val:\\n                current.next=current.next.next\\n            else:\\n                current=current.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662393,
                "title": "simple-python-solution-faster-than-97-36",
                "content": "**O(N) Time & O(1) Space Solution**\\n```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tfront = head #points to the front of the linked list\\n\\twhile head and head.next: #while we aren\\'t at the end of the list\\n\\t\\tif head.val == head.next.val: #if the next node has the same value\\n\\t\\t\\thead.next = head.next.next #skip it\\n\\t\\telse: #not a duplicate\\n\\t\\t\\thead = head.next #otherwise move forward\\n\\treturn front #return the front of the linked list\\n```\\nIn this solution, we use ```front``` to keep track of the front of the linkedlist. Then, we go through the list up until the end and check to see if the value of the current node is equal to the value of the next node. If it is, then we skip the duplicate node by setting ```head.next = head.next.next```. If we just removed a duplicate, we don\\'t know if the next node is also a duplicate, so we should not move forward with ```head = head.next``` like we do when we do not find a duplicate.\\nThis solution only needs to look at every node once, giving ```O(N)``` time complexity. Since it requires a constant amount of additional space, the memory complexity is ```O(1)```.\\n\\nP.S. ```while head and head.next``` is the same as ```while head is not None and head.next is not None``` \\u2013\\u2013 it just checks that neither of them are ```None```.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tfront = head #points to the front of the linked list\\n\\twhile head and head.next: #while we aren\\'t at the end of the list\\n\\t\\tif head.val == head.next.val: #if the next node has the same value\\n\\t\\t\\thead.next = head.next.next #skip it\\n\\t\\telse: #not a duplicate\\n\\t\\t\\thead = head.next #otherwise move forward\\n\\treturn front #return the front of the linked list\\n```\n```front```\n```head.next = head.next.next```\n```head = head.next```\n```O(N)```\n```O(1)```\n```while head and head.next```\n```while head is not None and head.next is not None```\n```None```",
                "codeTag": "Python3"
            },
            {
                "id": 1570266,
                "title": "java-faster-than-100",
                "content": "\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode curr = head;\\n        if(head == null) return null;\\n\\t\\t\\n\\t\\t// if the head.next == null it means that the list contains only one node (head) \\n\\t\\t//so there is no duplicates  we will simply return the head of the list\\n\\t\\t\\n        if(head.next == null) return head;\\n        else{\\n            while(curr.next != null){\\n\\t\\t\\t//we compare the data of the current node with the next node if they are equal\\n\\t\\t\\t//we remove the next node \\n                if(curr.val == curr.next.val) \\n                    curr.next = curr.next.next;\\n                else\\n\\t\\t\\t\\t//if they are not equal we simply move forward\\n                    curr=curr.next;\\n            }\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode curr = head;\\n        if(head == null) return null;\\n\\t\\t\\n\\t\\t// if the head.next == null it means that the list contains only one node (head) \\n\\t\\t//so there is no duplicates  we will simply return the head of the list\\n\\t\\t\\n        if(head.next == null) return head;\\n        else{\\n            while(curr.next != null){\\n\\t\\t\\t//we compare the data of the current node with the next node if they are equal\\n\\t\\t\\t//we remove the next node \\n                if(curr.val == curr.next.val) \\n                    curr.next = curr.next.next;\\n                else\\n\\t\\t\\t\\t//if they are not equal we simply move forward\\n                    curr=curr.next;\\n            }\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1342775,
                "title": "short-c-solution-using-recursion",
                "content": "Base case is head==NULL or head->next==NULL hence, we already have an empty list or list with a single element (no duplicates)\\nDecide what will be the next of the current head by recursively calling the function deleteDupliactes.\\nWhy this will work?\\nBecause as soon as we hit the base case, we will get an unique value for the tail. Now that unique value is passed as a next element for the previous element. If the value is same as previous elements value (compared during returning of function),  we will return the unique value itself, if the value is different, return the previous element which will have next element as this unique value.\\nExample:\\nA->B->C, going deep into recursion, first we get C, we compare with B, if(B!=C) we get A->next = B\\ni.e. A->B->C but if (B==C) we get A->next = C, hence A->C. This will also checked for values between A and C and so on.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next ==NULL)\\n            return head;\\n        head->next = deleteDuplicates(head->next);\\n        return head->val==head->next->val ? head->next : head;\\n    }\\n};\\n```\\nTime complexity = O(N)\\nSpace complexity = O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next ==NULL)\\n            return head;\\n        head->next = deleteDuplicates(head->next);\\n        return head->val==head->next->val ? head->next : head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28790,
                "title": "python-109ms-why-my-solution-is-fast-than-others",
                "content": "I just use a while loop to find duplicates. And my runtime is 109ms.\\n\\nA common runtime in python is 200ms ~ 400ms.\\n\\n    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a ListNode\\n        def deleteDuplicates(self, head):\\n            if head == None:\\n                return head\\n                \\n            node = head\\n            \\n            while node.next:\\n                if node.val == node.next.val:\\n                    node.next = node.next.next\\n                else:\\n                    node = node.next\\n                    \\n            return head",
                "solutionTags": [],
                "code": "I just use a while loop to find duplicates. And my runtime is 109ms.\\n\\nA common runtime in python is 200ms ~ 400ms.\\n\\n    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a ListNode\\n        def deleteDuplicates(self, head):\\n            if head == None:\\n                return head\\n                \\n            node = head\\n            \\n            while node.next:\\n                if node.val == node.next.val:\\n                    node.next = node.next.next\\n                else:\\n                    node = node.next\\n                    \\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 28620,
                "title": "share-a-recursive-solution-in-python",
                "content": "There is straight forward iterative solution, but it turns out recursive is quite few lines and not too hard to understand.\\n\\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a ListNode\\n        def deleteDuplicates(self, head):\\n            if head and head.next and head.val != head.next.val:\\n                head.next = self.deleteDuplicates(head.next)\\n            elif head and head.next:\\n                head = self.deleteDuplicates(head.next)\\n            return head",
                "solutionTags": [],
                "code": "There is straight forward iterative solution, but it turns out recursive is quite few lines and not too hard to understand.\\n\\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a ListNode\\n        def deleteDuplicates(self, head):\\n            if head and head.next and head.val != head.next.val:\\n                head.next = self.deleteDuplicates(head.next)\\n            elif head and head.next:\\n                head = self.deleteDuplicates(head.next)\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 2290759,
                "title": "python-beats-94-explained-with-diagrams",
                "content": "**Runtime: 42 ms, faster than 94.70% of Python3 online submissions for Remove Duplicates from Sorted List.**\\n**Memory Usage: 13.8 MB, less than 70.70% of Python3 online submissions for Remove Duplicates from Sorted List.**\\n\\nThe theme to solve this question is just like how we solve regular linked list problems. \\n\\nWe go with initializing two variables start and node with head then we move node to start.next\\n\\nLike in this example:-\\n![image](https://assets.leetcode.com/users/images/3c2f7589-5374-43a1-9c56-c0e8f203a2f6_1657981559.5628524.png)\\n now `start` is 1 and `node` is 1(2nd one)\\n we loop through the list and check if `start==node` and if that is true like in this case, what we need to do is set `start.next=node.next` now since the First `1` in the above diagram now points to `2` and the next thing we need to take care of is that we need to change this as I have illustated in the following pictures:-\\n \\n ![image](https://assets.leetcode.com/users/images/ecaeab50-b851-4dfa-94c7-7614a0402709_1658518230.7136285.jpeg)\\n ![image](https://assets.leetcode.com/users/images/94b27264-6072-4f8a-b1a3-705ac89a2012_1658518253.6033578.jpeg)\\n ![image](https://assets.leetcode.com/users/images/54f6551d-388c-43f3-9d1a-561c08359025_1658518264.8918567.jpeg)\\n\\n \\nFrom here it\\'s cake walk, you need to continue the loop and that\\'s it. The Probelm is Solved!!\\n\\n**Code**\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head \\n        start=node=head\\n        node=head.next\\n        while start and node:\\n            if start.val==node.val:\\n                start.next=node.next\\n                node.next=None\\n                node=start.next\\n            else:\\n                start=start.next\\n                node=node.next\\n        return head\\n```\\n\\n\\n_______________________________________________________________________________________________\\n_________________________________________________________________________________________________\\nEdit 1:\\nthe line `node.next=None` can be omitted as we wont ever reach that node\\n_________________________________________________________________________________________________\\n_________________________________________________________________________________________________\\n\\n\\nIf you liked my efforts then pls pls **UPVOTE** the post, it will encourage me to do more of this stuff!\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head \\n        start=node=head\\n        node=head.next\\n        while start and node:\\n            if start.val==node.val:\\n                start.next=node.next\\n                node.next=None\\n                node=start.next\\n            else:\\n                start=start.next\\n                node=node.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914980,
                "title": "easy-solution-one-pointer-two-while-loops",
                "content": "The outer `while` loops over distinct values, the inner `while` skips duplicates.\\n```csharp\\npublic class Solution\\n{\\n    public ListNode DeleteDuplicates(ListNode head)\\n    {\\n        ListNode n = head;\\n\\n        while (n is not null)\\n        {\\n            while (n.val == n.next?.val)\\n            {\\n                n.next = n.next.next;\\n            }\\n            n = n.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public ListNode DeleteDuplicates(ListNode head)\\n    {\\n        ListNode n = head;\\n\\n        while (n is not null)\\n        {\\n            while (n.val == n.next?.val)\\n            {\\n                n.next = n.next.next;\\n            }\\n            n = n.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28785,
                "title": "clear-java-solution",
                "content": "    public class Solution {\\n        public ListNode deleteDuplicates(ListNode head) {\\n            if(head == null) return null;\\n            ListNode pre = head;\\n            ListNode cur = head.next;\\n            while(cur != null){\\n                if(cur.val == pre.val){\\n                    pre.next = cur.next;\\n                    cur = cur.next;\\n                }\\n                else{\\n                    pre = pre.next;\\n                    cur = pre.next;\\n                }\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode deleteDuplicates(ListNode head) {\\n            if(head == null) return null;\\n            ListNode pre = head;\\n            ListNode cur = head.next;\\n            while(cur != null){\\n                if(cur.val == pre.val){\\n                    pre.next = cur.next;\\n                    cur = cur.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28800,
                "title": "python-recursive-and-iterative-solutions",
                "content": "```\\ndef deleteDuplicates(self, head):\\n\\tif not head or not head.next:\\n\\t\\treturn head\\n\\th = self.deleteDuplicates(head.next)\\n\\thead.next = h if head.val != h.val else h.next\\n\\treturn head\\n```\\n\\t\\t\\n\\tdef deleteDuplicates1(self, head):\\n        node = head\\n        while node and node.next:\\n            if node.val == node.next.val:\\n                node.next = node.next.next\\n            else:\\n                node = node.next\\n        return head\\n        \\n    def deleteDuplicates(self, head):\\n        dic = {}\\n        node = head\\n        while node:\\n            dic[node.val] = dic.get(node.val, 0) + 1\\n            node = node.next\\n        node = head\\n        while node:\\n            tmp = node\\n            for _ in xrange(dic[node.val]):\\n                tmp = tmp.next\\n            node.next = tmp\\n            node = node.next\\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef deleteDuplicates(self, head):\\n\\tif not head or not head.next:\\n\\t\\treturn head\\n\\th = self.deleteDuplicates(head.next)\\n\\thead.next = h if head.val != h.val else h.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2693121,
                "title": "java-solution-diagram",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        head.next = deleteDuplicates(head.next);\\n        return head.val == head.next.val ? head.next : head;\\n}\\n    }\\n```\\n\\n\\n**![image](https://assets.leetcode.com/users/images/1f497680-383f-44c3-b9a5-7087f7d1c43e_1665552943.6387627.png)**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        head.next = deleteDuplicates(head.next);\\n        return head.val == head.next.val ? head.next : head;\\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149146,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode*temp = head;\\n        \\n        if(!head) return head;\\n        \\n        while(head->next) {\\n            if(head->val == head->next->val) {\\n                head->next = head->next->next;\\n            }\\n            else{\\n                head = head->next;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode*temp = head;\\n        \\n        if(!head) return head;\\n        \\n        while(head->next) {\\n            if(head->val == head->next->val) {\\n                head->next = head->next->next;\\n            }\\n            else{\\n                head = head->next;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746631,
                "title": "simple-and-easy-beats-100",
                "content": "# upvote if you feel it easy\\uD83D\\uDE0A\\u2764\\n# Code\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while(temp!=null && temp.next != null) {\\n            if(temp.val == temp.next.val) {\\n                temp.next = temp.next.next;\\n            }else{\\n                temp = temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while(temp!=null && temp.next != null) {\\n            if(temp.val == temp.next.val) {\\n                temp.next = temp.next.next;\\n            }else{\\n                temp = temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475241,
                "title": "python-c-with-clear-explanation",
                "content": "## Below you will find the code implementation for both C and Python.\\n\\n# Approach:\\n1. In order to eliminate the duplicate nodes, we have to iterate over the linked list and compare for the duplicate values.\\n2. Create a **tem**porary **ref**erence (`curr`) to the **hea**d **nod**e.\\n3. **Ite**rate until you reach **NULL**.\\n`while(curr != NULL && curr->next != NULL)`\\n4. Check if the **cur**rent **nod**e **val**ue **is equal** to the **nex**t **nod**e **val**ue.\\n`if(curr->val == curr->next->val)`\\n5. If **$yes$**, **ski**p the **nex**t **nod**e by **poi**nting the **nex**t of the **cur**rent **nod**e to the **nex**t of the **nex**t **nod**e.\\n`curr->next = curr->next->next;`\\n6. If **$no$**, then we have a **new** **val**ue, so **mov**e the **poi**nter to the **nex**t of the **cur**rent **nod**e.\\n`curr = curr->next;`\\n7. **Ret**urn `head` since we are using the same linked list.\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n\\n```C []\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* curr = head;\\n\\n    while(curr != NULL && curr->next != NULL){\\n        if(curr->val == curr->next->val)\\n            curr->next = curr->next->next;\\n        else\\n            curr = curr->next;\\n    }\\n\\n    return head;\\n}\\n```\\n```python []\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n                \\n```\\n\\n### Please consider upvoting if you liked it or comment if you have an alternative approach! Thank you!",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* curr = head;\\n\\n    while(curr != NULL && curr->next != NULL){\\n        if(curr->val == curr->next->val)\\n            curr->next = curr->next->next;\\n        else\\n            curr = curr->next;\\n    }\\n\\n    return head;\\n}\\n```\n```python []\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393864,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* new_list = head;\\n    struct ListNode* temp = head;\\n    while (temp != NULL && temp->next != NULL) {\\n        if (temp->val == temp->next->val) {\\n            temp->next = temp->next->next;\\n        } else {\\n            temp = temp->next;\\n        }\\n    }\\n    return new_list;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* new_list = head;\\n    struct ListNode* temp = head;\\n    while (temp != NULL && temp->next != NULL) {\\n        if (temp->val == temp->next->val) {\\n            temp->next = temp->next->next;\\n        } else {\\n            temp = temp->next;\\n        }\\n    }\\n    return new_list;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101800,
                "title": "easy-simple-code-in-c-with-100-testcase-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a node temp which is equal to head \\nrun a loop until the temp!=NULL temp->next!=NUll which means until tail appears .\\nif(temp->val == temp->next->val)//i.e if temp and next node is equal then make temp->next equal to temp->next->next\\ntemp->next=temp->next->next;\\nelse\\ntemp=temp->next;  //itterate the node to next.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp = head;\\n        while(temp !=NULL && temp->next!=NULL){\\n            if(temp->val == temp->next->val){\\n                temp->next=temp->next->next;\\n               \\n            }\\n            else{\\n                temp=temp->next;\\n            }\\n        } \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp = head;\\n        while(temp !=NULL && temp->next!=NULL){\\n            if(temp->val == temp->next->val){\\n                temp->next=temp->next->next;\\n               \\n            }\\n            else{\\n                temp=temp->next;\\n            }\\n        } \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078821,
                "title": "javascript-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar deleteDuplicates = function(head) {\\n    var current = head;\\n\\n    while(current) {\\n        if(current.next!==null && current.val==current.next.val) {\\n            current.next = current.next.next;\\n        }\\n        else {\\n            current = current.next;\\n        }\\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    var current = head;\\n\\n    while(current) {\\n        if(current.next!==null && current.val==current.next.val) {\\n            current.next = current.next.next;\\n        }\\n        else {\\n            current = current.next;\\n        }\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2821993,
                "title": "python-98-89-faster-6-lines-o-n-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        while temp:\\n            while temp.next!=None and temp.val == temp.next.val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        while temp:\\n            while temp.next!=None and temp.val == temp.next.val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595755,
                "title": "python-solution-easy-explained-faster-than-89-79",
                "content": "If you like the solution, your upvote is appreciated! \\uD83E\\uDD1D\\n\\nExplanation:\\n\\nIn the first while loop, we continue as long as the current node and the next node exist.\\n\\nIn the second while loop, we continue to replace the next value, if it is the same as the current value. In a sense, we skip the next value if it is the same.\\n\\nWhen we reach the end of the linked list, and current node or next node is None, we can return the linked list from the beginning (head).\\n\\nAnd that is it!\\n\\nIf you did not yet, upvote to make my day \\uD83C\\uDF1E\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        current = head\\n        \\n    \\n        while current != None and current.next != None:\\n              while current.val == current.next.val:\\n                    current.next = current.next.next\\n                    if current.next == None:\\n                        break\\n              current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        current = head\\n        \\n    \\n        while current != None and current.next != None:\\n              while current.val == current.next.val:\\n                    current.next = current.next.next\\n                    if current.next == None:\\n                        break\\n              current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177026,
                "title": "c-java-explained-w-visual",
                "content": "Runtime Complexity: **`O(n)`**\\nSpace Complexity: **`O(1)`** (in-place)\\n\\n**There are two main actions to know:**\\n\\n#### (1) Traversal with a pointer: ```ptr = ptr.next;```\\n#### (2) Deletion of a target node: ```prev.next = target.next;``` or ```prev.next = prev.next.next;```\\n\\nWe will iterate through the list with a pointer `ListNode` `ptr` to accomplish our task. To check if a duplicate for `ptr.val` exists, we simply have to see if `ptr.next.val` is equal to `ptr.val`, because the array is sorted and duplicates are contiguous.\\n\\nThe following code is identical for both C# and Java:\\n```\\nif(head == null){return null;} //Don\\'t forget this edge case\\nListNode ptr = head; //Helps for returning at the end\\n\\nwhile(ptr.next != null){ //Terminates if there is no next node(end of list)\\n\\tif(ptr.next.val == ptr.val){ //Check for duplicate next node\\n\\t\\tptr.next = ptr.next.next; //Delete next node\\n\\t}\\n\\telse{\\n\\t\\tptr = ptr.next; //Advance if no duplicate is found\\n\\t}\\n}\\nreturn head; //Return the original start of list\\n```\\n\\nThe effect of our code is as such:\\n![image](https://assets.leetcode.com/users/images/081e8010-3642-4eff-bcba-68c30d95c893_1655785996.077856.png)\\n\\n\\n> Please upvote if this helps in any way!",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```ptr = ptr.next;```\n```prev.next = target.next;```\n```prev.next = prev.next.next;```\n```\\nif(head == null){return null;} //Don\\'t forget this edge case\\nListNode ptr = head; //Helps for returning at the end\\n\\nwhile(ptr.next != null){ //Terminates if there is no next node(end of list)\\n\\tif(ptr.next.val == ptr.val){ //Check for duplicate next node\\n\\t\\tptr.next = ptr.next.next; //Delete next node\\n\\t}\\n\\telse{\\n\\t\\tptr = ptr.next; //Advance if no duplicate is found\\n\\t}\\n}\\nreturn head; //Return the original start of list\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2142759,
                "title": "java-0ms-recursive-best-solution",
                "content": "# Please Upvote If You Find This Helpful\\n![image](https://assets.leetcode.com/users/images/84fe7943-54b9-442c-be63-2b148540f196_1655030408.0951629.png)\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        while (head.next != null && head.val == head.next.val) head.next = head.next.next;\\n        head.next = deleteDuplicates(head.next);\\n        return head;\\n    }\\n}\\n```\\n# Please Upvote If You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        while (head.next != null && head.val == head.next.val) head.next = head.next.next;\\n        head.next = deleteDuplicates(head.next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122525,
                "title": "js-simple-cutting",
                "content": "Overwrite `next` with `next.next` to cut next node when `current.next` exist, and `current.val` equals `current.next.val`.\\nIf not, continue normal traverse: `current = current.next;`\\n\\n![image](https://assets.leetcode.com/users/images/679e51b1-f16f-4b7f-8081-b7c097254645_1654615175.1876688.jpeg)\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n  let current = head;\\n  \\n  while (current) {\\n    if (current.next && current.val === current.next.val) {\\n      current.next = current.next.next;\\n    } else {\\n      current = current.next;\\n    }\\n  }\\n  \\n  return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n  let current = head;\\n  \\n  while (current) {\\n    if (current.next && current.val === current.next.val) {\\n      current.next = current.next.next;\\n    } else {\\n      current = current.next;\\n    }\\n  }\\n  \\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792789,
                "title": "python-java-simple-implementation",
                "content": "**Python 3**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t\\t# current element\\n        e = head\\n        while e:\\n\\t\\t\\t# loop until current element\\'s value is different to it\\'s next element\\'s value\\n            while e.next and e.next.val == e.val:\\n                e.next = e.next.next\\n            e = e.next\\n                \\n        return head\\t\\t\\n```\\n**Java**\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode e = head;\\n        while (e != null){\\n            while (e.next != null && e.next.val == e.val){\\n                e.next = e.next.next;\\n            }\\n            e = e.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\\n* Time complexity: O(n)\\n* Space complexity: O(1)",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t\\t# current element\\n        e = head\\n        while e:\\n\\t\\t\\t# loop until current element\\'s value is different to it\\'s next element\\'s value\\n            while e.next and e.next.val == e.val:\\n                e.next = e.next.next\\n            e = e.next\\n                \\n        return head\\t\\t\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode e = head;\\n        while (e != null){\\n            while (e.next != null && e.next.val == e.val){\\n                e.next = e.next.next;\\n            }\\n            e = e.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736671,
                "title": "c-easy-implementation",
                "content": "**please upvote if you like my solution**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    if(head==NULL)return NULL;\\n    struct ListNode* temp=head,*nextnode;\\n    while(temp->next!=0){\\n        if(temp->val==temp->next->val){\\n            nextnode=temp->next->next;\\n            free(temp->next);\\n            temp->next=nextnode;\\n        }\\n        else\\n        temp=temp->next;\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    if(head==NULL)return NULL;\\n    struct ListNode* temp=head,*nextnode;\\n    while(temp->next!=0){\\n        if(temp->val==temp->next->val){\\n            nextnode=temp->next->next;\\n            free(temp->next);\\n            temp->next=nextnode;\\n        }\\n        else\\n        temp=temp->next;\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646445,
                "title": "concise-explanation-with-c-code",
                "content": "Suppose the Linked List is  \\n1 -> 2 -> 2 -> 3 -> 3\\n\\nWe first take a temporary pointer and point to the Head of the List, then we traverse the List. \\nIf at any moment we find the value of the next of the temporary pointer with itself is same, we simply delete the next of the temporary pointer and go on traversing our list.\\n\\n# Code:-\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL) return head;\\n        ListNode *temp = head;\\n        while(temp->next) {\\n            if(temp->val == temp->next->val) {\\n                ListNode *link = temp->next;\\n                temp->next = temp->next->next; \\n                delete link;\\n            }\\n            else {\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nRead below for more clarification:-\\nfor list:- **1 -> 2 -> 2 -> 3 -> 3**\\n# Step 1:-\\ntemp = 1\\ntemp->next = 2,\\nhere both are different hence we go in the else part.\\nThe List Now becomes:-\\n**1->2->2->3->3**\\n\\n# Step 2:-\\ntemp = 2\\ntemp->next = 2\\nhere as both are same, we store the temp->next in **link** node(so that we can free memory later) and disrupt the connection of temp(2) with temp->next(2) and make temp with temp->next->next(3).\\nAfter this step, we need to free the memory of the deleted Node.\\nThe List Now becomes:-\\n**1->2->3->3**\\n\\n# Step 3:-\\ntemp = 2\\ntemp->next = 3,\\nhere both are different hence we go in the else part.\\nThe List Now becomes:-\\n**1->2->3->3**\\n\\n# Step 4:-\\ntemp = 3\\ntemp->next = 3\\nHere, again as both are same, we just follow the same procedure in **Step2**.\\nThe List Now becomes:-\\n**1->2->3**\\n\\n# Step 5:-\\ntemp=3\\ntemp->next = NULL\\nNow our while condition becomes false, hence we move out of the loop.\\n\\n\\n# \\uD83D\\uDC80DANGER\\uD83D\\uDC80:-\\nWe must provide a check condition at the beginning of our code, to handle the case of **[]**, else we are bound the get a Run Time Error.\\n\\nAt the end, we return the Head with the modified Linked List.\\n\\nHappy Coding, \\nsayak04.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL) return head;\\n        ListNode *temp = head;\\n        while(temp->next) {\\n            if(temp->val == temp->next->val) {\\n                ListNode *link = temp->next;\\n                temp->next = temp->next->next; \\n                delete link;\\n            }\\n            else {\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636022,
                "title": "c-4-lines-of-most-simple-iterative-and-recurrsive-solution",
                "content": "I added both iterative and simple recursive solution in simplest manner.\\nOnly one line difference in both soluton\\n1. Iterative Solution (faster)\\n```\\n        ListNode* curr = head;\\n        while(curr != NULL && curr -> next != NULL) {\\n            if(curr -> val == curr -> next -> val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        return head;\\n```\\n2. Recursive Solution (2 times slower than iterative)\\n```\\nListNode* curr = head;\\nif(curr != NULL && curr -> next != NULL) {\\n                if(curr -> val == curr -> next -> val) {\\n                        curr -> next = curr -> next -> next;\\n                } else {\\n                    curr = curr -> next;\\n                }\\n                deleteDuplicates(curr);\\n            }\\n        return head;\\n```\\n**Upvote if this helped!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        ListNode* curr = head;\\n        while(curr != NULL && curr -> next != NULL) {\\n            if(curr -> val == curr -> next -> val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        return head;\\n```\n```\\nListNode* curr = head;\\nif(curr != NULL && curr -> next != NULL) {\\n                if(curr -> val == curr -> next -> val) {\\n                        curr -> next = curr -> next -> next;\\n                } else {\\n                    curr = curr -> next;\\n                }\\n                deleteDuplicates(curr);\\n            }\\n        return head;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1356619,
                "title": "go-simple-solution-with-recursion-0-ms",
                "content": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t} else if head.Val == head.Next.Val {\\n\\t\\thead = deleteDuplicates(head.Next)\\n\\t\\treturn head\\n\\t} else {\\n\\t\\thead.Next = deleteDuplicates(head.Next)\\n\\t\\treturn head\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t} else if head.Val == head.Next.Val {\\n\\t\\thead = deleteDuplicates(head.Next)\\n\\t\\treturn head\\n\\t} else {\\n\\t\\thead.Next = deleteDuplicates(head.Next)\\n\\t\\treturn head\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346260,
                "title": "python-straight-forward-methods",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        current = head\\n        while current!=None and current.next!=None:\\n            if current.val==current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        current = head\\n        while current!=None and current.next!=None:\\n            if current.val==current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293968,
                "title": "c-straightforward-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        var root = head;\\n        while (head != null) {\\n            var pre = head;\\n            while (head != null && head.val == pre.val)\\n                head= head.next;\\n            pre.next = head;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        var root = head;\\n        while (head != null) {\\n            var pre = head;\\n            while (head != null && head.val == pre.val)\\n                head= head.next;\\n            pre.next = head;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917809,
                "title": "remove-duplicates-from-the-linked-list-runtime-beats-85-11-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the values are ``sorted``, we can just compare the current value with the next value to check for ``duplicates``. Traversing through the linked list and checking for this condition in each node will solve the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start with assigning the current node to the head of the linked list\\n- Traverse through the link list and ``compare`` the ``current`` node value with the ``next`` node value. If the values are same then ``current.next`` should point to ``current.next.next``. This will skip the next node\\n- While traversal we should also check if  ``current.next`` exists. If not then terminate the loop\\n- After succesful traversal the derived link list will contain no duplicates\\n- Return the ``head``\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        while current and current.next:\\n            if current.val == current.next.val: current.next = current.next.next\\n            else: current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        while current and current.next:\\n            if current.val == current.next.val: current.next = current.next.next\\n            else: current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283672,
                "title": "easy-solution-in-c-o-n-time",
                "content": "# Intuition\\nWe can solve this problem by traversing the linked list and keeping track of the current node and the next node. If the value of the current node is equal to the value of the next node, we know that the next node is a duplicate and we need to remove it. We can remove the next node by changing the next pointer of the current node to point to the node after the next node. We continue this process until we reach the end of the linked list.\\n\\n# Approach\\n- Start at the head of the linked list.\\n- While the current node and the next node are not null:\\n    a. If the value of the current node is equal to the value of the next node, remove the next node by changing the next pointer of the current node to point to the node after the next node.\\n    b. If the values are not equal, move on to the next pair of nodes.\\n- Return the head of the modified linked list.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n            if(head==NULL){\\n            return NULL;\\n        }\\n       ListNode* curr = head;\\n       while(curr != NULL){\\n           if(curr->next != NULL && curr->val == curr->next->val ){\\n               ListNode* temp = curr->next;\\n               curr->next = curr->next->next;\\n               delete temp;\\n           }\\n           else{\\n           curr = curr->next;\\n           }\\n       } \\n       return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n            if(head==NULL){\\n            return NULL;\\n        }\\n       ListNode* curr = head;\\n       while(curr != NULL){\\n           if(curr->next != NULL && curr->val == curr->next->val ){\\n               ListNode* temp = curr->next;\\n               curr->next = curr->next->next;\\n               delete temp;\\n           }\\n           else{\\n           curr = curr->next;\\n           }\\n       } \\n       return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185214,
                "title": "beats-94-95-83-remove-duplicates-from-sorted-list-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n94.95%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Check if the linked list is empty\\n        if not head:\\n            return None\\n        \\n        # Initialize two pointers: current and previous\\n        prev = head\\n        current = head.next\\n        \\n        while current:\\n            # If the current node\\'s value is equal to the previous node\\'s value, delete the current node\\n            if current.val == prev.val:\\n                prev.next = current.next\\n                current = current.next\\n            # If the current node\\'s value is different, move the pointers to the next node\\n            else:\\n                prev = current\\n                current = current.next\\n        \\n        return head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Check if the linked list is empty\\n        if not head:\\n            return None\\n        \\n        # Initialize two pointers: current and previous\\n        prev = head\\n        current = head.next\\n        \\n        while current:\\n            # If the current node\\'s value is equal to the previous node\\'s value, delete the current node\\n            if current.val == prev.val:\\n                prev.next = current.next\\n                current = current.next\\n            # If the current node\\'s value is different, move the pointers to the next node\\n            else:\\n                prev = current\\n                current = current.next\\n        \\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115484,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        \\n        if(head == null)\\n            return null;\\n\\n        if(head.next == null)\\n            return head;\\n\\n        ListNode prevNode = head;\\n        for(ListNode node = head.next; node != null; node = node.next)\\n        {\\n            if(node.val == prevNode.val)\\n            {\\n                prevNode.next = node.next;\\n            }\\n            else \\n            {\\n                prevNode = node;\\n            }\\n        }\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        \\n        if(head == null)\\n            return null;\\n\\n        if(head.next == null)\\n            return head;\\n\\n        ListNode prevNode = head;\\n        for(ListNode node = head.next; node != null; node = node.next)\\n        {\\n            if(node.val == prevNode.val)\\n            {\\n                prevNode.next = node.next;\\n            }\\n            else \\n            {\\n                prevNode = node;\\n            }\\n        }\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086107,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* c=head;\\n        ListNode* p=new ListNode(1);\\n        ListNode* k=p;\\n        while(c)\\n        {\\n            while(c->next && c->val==c->next->val)\\n            c=c->next;\\n            // cout<<\"f\";\\n            p->next=c;\\n            p=p->next;\\n            c=c->next;\\n        }\\n        p->next=NULL;\\n        return k->next;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* c=head;\\n        ListNode* p=new ListNode(1);\\n        ListNode* k=p;\\n        while(c)\\n        {\\n            while(c->next && c->val==c->next->val)\\n            c=c->next;\\n            // cout<<\"f\";\\n            p->next=c;\\n            p=p->next;\\n            c=c->next;\\n        }\\n        p->next=NULL;\\n        return k->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3070363,
                "title": "o-n-o-1-python-solution-explained",
                "content": "Hello **Tenno Leetcoders**,\\n\\nFor this problem, we want to remove nodes with duplicated values and return a new sorted linked list\\n\\n### Iterative Step\\n\\n\\t1) One of the edge cases, we need to watch out for is when our `head` is `None`  then we simply return `None`\\n\\n\\t2) Our first node will become our current head \\n\\n\\t3) We will only perform removal process if current.next has a node and check for the following:\\n\\t\\n\\t\\t- if current head value equals to next node value, then remove the duplicated node by setting next node \\n\\t\\tto the node after the duplicated node \\n\\t\\t\\n\\t\\t-  If not equal, we will check the next node \\n\\t\\n\\t4) We will then return the de-duped linked list by returning the head\\n\\n### Code\\n```\\n   def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        if not head: return None\\n        \\n        current = head\\n        print(current)\\n         \\n        while current.next:\\n            \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next   \\n                \\n        return head\\n```\\n\\n\\n#### Time Complexity: O(n)\\n\\n#### Space Complexity: O(1)\\n\\n\\n ***Upvote if this tenno\\'s discussion helped you in some type of way***\\n  \\n***Warframe\\'s short clip of the day***\\n![image](https://assets.leetcode.com/users/images/1175511c-ddd4-40cd-a397-ea689aec52bd_1674066252.4141765.gif)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n   def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        if not head: return None\\n        \\n        current = head\\n        print(current)\\n         \\n        while current.next:\\n            \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next   \\n                \\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2332700,
                "title": "java-best-and-easy-solution-1-ms",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode list = head;\\n         \\n         while(list != null) {\\n        \\t if (list.next == null) {\\n        \\t\\t break;\\n        \\t }\\n        \\t if (list.val == list.next.val) {\\n        \\t\\t list.next = list.next.next;\\n        \\t }\\n           else {\\n        \\t\\t list = list.next;\\n        \\t }\\n         }\\n         \\n         return head;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode list = head;\\n         \\n         while(list != null) {\\n        \\t if (list.next == null) {\\n        \\t\\t break;\\n        \\t }\\n        \\t if (list.val == list.next.val) {\\n        \\t\\t list.next = list.next.next;\\n        \\t }\\n           else {\\n        \\t\\t list = list.next;\\n        \\t }\\n         }\\n         \\n         return head;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893349,
                "title": "100-fastest-typescript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) return null\\n  if (!head.next) return head\\n\\n  let prev = head\\n  let curr = head.next\\n\\n  while (curr) {\\n    while (curr && curr.val === prev.val) { curr = curr.next as ListNode }\\n\\n    prev.next = curr\\n    prev = curr\\n\\n    if (curr) { curr = curr.next as ListNode }\\n  }\\n\\n  return head\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) return null\\n  if (!head.next) return head\\n\\n  let prev = head\\n  let curr = head.next\\n\\n  while (curr) {\\n    while (curr && curr.val === prev.val) { curr = curr.next as ListNode }\\n\\n    prev.next = curr\\n    prev = curr\\n\\n    if (curr) { curr = curr.next as ListNode }\\n  }\\n\\n  return head\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797468,
                "title": "python-simple-python-solution-using-iterative-approach",
                "content": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tnode = head\\n\\n\\t\\t\\twhile node!= None and node.next != None:\\n\\n\\t\\t\\t\\tif node.val == node.next.val:\\n\\n\\t\\t\\t\\t\\tnode.next=node.next.next\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tnode=node.next\\n\\n\\t\\t\\treturn head",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tnode = head\\n\\n\\t\\t\\twhile node!= None and node.next != None:\\n\\n\\t\\t\\t\\tif node.val == node.next.val:\\n\\n\\t\\t\\t\\t\\tnode.next=node.next.next\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tnode=node.next\\n\\n\\t\\t\\treturn head",
                "codeTag": "Java"
            },
            {
                "id": 1448498,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut result_list = ListNode::new(0);\\n        let mut result_list_iterator = &mut result_list;\\n        let mut input_list_iterator = head.as_ref();\\n        let mut previous_val = i32::MIN;\\n        \\n        while let Some(node) = input_list_iterator {\\n            if node.val != previous_val {\\n                result_list_iterator.next = Some(Box::new(ListNode::new(node.val)));\\n                result_list_iterator = result_list_iterator.next.as_mut().unwrap();\\n                previous_val = node.val;\\n            }\\n            input_list_iterator = node.next.as_ref();\\n        }\\n        \\n        result_list.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut result_list = ListNode::new(0);\\n        let mut result_list_iterator = &mut result_list;\\n        let mut input_list_iterator = head.as_ref();\\n        let mut previous_val = i32::MIN;\\n        \\n        while let Some(node) = input_list_iterator {\\n            if node.val != previous_val {\\n                result_list_iterator.next = Some(Box::new(ListNode::new(node.val)));\\n                result_list_iterator = result_list_iterator.next.as_mut().unwrap();\\n                previous_val = node.val;\\n            }\\n            input_list_iterator = node.next.as_ref();\\n        }\\n        \\n        result_list.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445853,
                "title": "recursive-c",
                "content": "...\\nListNode* deleteDuplicate(ListNode* head)\\n{\\n\\n       if(head==NULL || head->next==NULL)          \\n        {                                           \\n         return head;                               \\n        }\\n        \\n        head->next  =  deleteDuplicates(head->next);\\n        if(head->val==head->next->val)\\n        {\\n          return head->next;\\n        }\\n        \\n        return head; \\n}\\n\\n...\\n",
                "solutionTags": [],
                "code": "...\\nListNode* deleteDuplicate(ListNode* head)\\n{\\n\\n       if(head==NULL || head->next==NULL)          \\n        {                                           \\n         return head;                               \\n        }\\n        \\n        head->next  =  deleteDuplicates(head->next);\\n        if(head->val==head->next->val)\\n        {\\n          return head->next;\\n        }\\n        \\n        return head; \\n}\\n\\n...\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1223275,
                "title": "good-code-without-memory-leak-c-ez-to-understnad",
                "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        \\n        ListNode *curr=head;\\n        \\n        while(curr!=NULL){\\n            \\n            if(curr->next!=NULL && curr->val==curr->next->val){\\n                \\n                ListNode *temp=curr->next;\\n                curr->next = curr->next->next;\\n                \\n                delete temp;\\n                \\n                \\n            }\\n            \\n            else{\\n                curr=curr->next;\\n            }\\n            \\n            \\n            \\n            \\n        }\\n        return head;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1078121,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        ListNode node1 = head,\\n                 node2 = head.next;\\n        \\n        while (node2 != null)\\n            if (node1.val == node2.val)\\n            {\\n                node1.next = node2.next;\\n                node2.next = null;\\n                node2 = node1.next;\\n            }\\n            else\\n            {\\n                node1 = node2;\\n                node2 = node2?.next;\\n            }\\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        ListNode node1 = head,\\n                 node2 = head.next;\\n        \\n        while (node2 != null)\\n            if (node1.val == node2.val)\\n            {\\n                node1.next = node2.next;\\n                node2.next = null;\\n                node2 = node1.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 680569,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        var temp =head;\\n        while(head != null && head.next != null)\\n        {\\n            if(head.val == head.next.val){\\n                head.next = head.next.next;\\n            }\\n            else{\\n                head = head.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        var temp =head;\\n        while(head != null && head.next != null)\\n        {\\n            if(head.val == head.next.val){\\n                head.next = head.next.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 386405,
                "title": "4ms-c-solution",
                "content": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* cur = head;\\n    while (cur && cur->next) {\\n        if(cur->val == cur->next->val)\\n            cur->next = cur->next->next;\\n        else\\n            cur = cur->next;\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* cur = head;\\n    while (cur && cur->next) {\\n        if(cur->val == cur->next->val)\\n            cur->next = cur->next->next;\\n        else\\n            cur = cur->next;\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189606,
                "title": "4-simple-solutions-javascript",
                "content": "**Solution #1**\\nThis solution **CAN NOT** be used if the array is not sorted.\\n\\nO(1) Space\\nO(n) Time\\n\\n```\\nvar deleteDuplicates = function(head) {\\n    let cur = head;\\n    \\n    while (cur && cur.next) {\\n        if (cur.val === cur.next.val) {\\n            // skip duplicates\\t\\t\\t\\t\\n            cur.next = cur.next.next;\\n        } else {\\n            cur = cur.next;\\n        }\\n    }\\n    \\n    return head;\\n}\\n```\\n\\n**Solution #2**\\n\\nfast and slow\\nO(1) Space\\nO(n) Time\\n\\n ```\\n\\n var deleteDuplicates = function(head) {\\n\\t let preHead = new ListNode();\\n\\t preHead.next = head;\\n\\n\\t let cur = preHead.next;\\n\\t let prev = preHead;\\n\\n\\t while (cur) {\\n\\t\\t\\t // when dups are found don\\'t move prev.\\n\\t\\t\\t if (cur.val === prev.val) {\\n\\t\\t\\t\\t\\t prev.next = cur.next;\\n\\t\\t\\t } else {\\n\\t\\t\\t\\t\\t prev = prev.next;\\n\\t\\t\\t }\\n\\t\\t\\t cur = cur.next;\\n\\t }\\n\\n\\t return preHead.next;\\n }\\n ```\\n\\n**Solution #3**\\nthis solution can be used even if the array is not sorted.\\n\\nO(1) Space\\nO(n2) Time\\n\\n```\\n\\n var deleteDuplicates = function(head) {\\n    \\n    let current = head;\\n    \\n    while (current) {\\n        let runner = current;\\n        \\n        // remove dups after the current node \\n        while (runner.next) {\\n            if (runner.val === runner.next.val) {\\n                // skip Dups\\n                runner.next = runner.next.next;\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        current = current.next;   \\n    }\\n    \\n    return head;\\n}\\n```\\n\\n\\n**Solution #4**\\nUsing Hash Table\\n\\nthis solution can be used even if the array is not sorted.\\n\\nO(n) Space\\nO(n) Time\\n\\n```\\nvar deleteDuplicates = function(head) {\\n    const dups = {};\\n    let cur = head;\\n    let prev;\\n    while (cur) {\\n        if (!dups[cur.val]) {\\n            dups[cur.val] = true;\\n            prev = cur;\\n        } else {\\n            prev.next = cur.next;\\n        }\\n        cur = cur.next;\\n    }\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    let cur = head;\\n    \\n    while (cur && cur.next) {\\n        if (cur.val === cur.next.val) {\\n            // skip duplicates\\t\\t\\t\\t\\n            cur.next = cur.next.next;\\n        } else {\\n            cur = cur.next;\\n        }\\n    }\\n    \\n    return head;\\n}\\n```\n```\\n\\n var deleteDuplicates = function(head) {\\n\\t let preHead = new ListNode();\\n\\t preHead.next = head;\\n\\n\\t let cur = preHead.next;\\n\\t let prev = preHead;\\n\\n\\t while (cur) {\\n\\t\\t\\t // when dups are found don\\'t move prev.\\n\\t\\t\\t if (cur.val === prev.val) {\\n\\t\\t\\t\\t\\t prev.next = cur.next;\\n\\t\\t\\t } else {\\n\\t\\t\\t\\t\\t prev = prev.next;\\n\\t\\t\\t }\\n\\t\\t\\t cur = cur.next;\\n\\t }\\n\\n\\t return preHead.next;\\n }\\n ```\n```\\n\\n var deleteDuplicates = function(head) {\\n    \\n    let current = head;\\n    \\n    while (current) {\\n        let runner = current;\\n        \\n        // remove dups after the current node \\n        while (runner.next) {\\n            if (runner.val === runner.next.val) {\\n                // skip Dups\\n                runner.next = runner.next.next;\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        current = current.next;   \\n    }\\n    \\n    return head;\\n}\\n```\n```\\nvar deleteDuplicates = function(head) {\\n    const dups = {};\\n    let cur = head;\\n    let prev;\\n    while (cur) {\\n        if (!dups[cur.val]) {\\n            dups[cur.val] = true;\\n            prev = cur;\\n        } else {\\n            prev.next = cur.next;\\n        }\\n        cur = cur.next;\\n    }\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28812,
                "title": "c-c-simple-solution",
                "content": "C++ version\\n\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* node = head;\\n        while(node != NULL){\\n           if((node->next != NULL) && (node->next->val == node->val))\\n           {\\n               ListNode* oldNext = node->next;\\n               node->next = node->next->next;\\n               delete oldNext;\\n           }\\n           else\\n               node = node->next;\\n       } \\n       return head;\\n    }\\n\\t\\nC# version\\n\\n    public ListNode DeleteDuplicates(ListNode head) {\\n         ListNode node = head;\\n        while(node != null){\\n           if((node.next != null) && (node.next.val == node.val))\\n               node.next = node.next.next;\\n           else\\n               node = node.next;\\n       } \\n       return head;       \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "C++ version\\n\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* node = head;\\n        while(node != NULL){\\n           if((node->next != NULL) && (node->next->val == node->val))\\n           {\\n               ListNode* oldNext = node->next;\\n               node->next = node->next->next;\\n               delete oldNext;\\n           }\\n           else\\n               node = node->next;\\n       } \\n       return head;\\n    }\\n\\t\\nC# version\\n\\n    public ListNode DeleteDuplicates(ListNode head) {\\n         ListNode node = head;\\n        while(node != null){\\n           if((node.next != null) && (node.next.val == node.val))\\n               node.next = node.next.next;\\n           else\\n               node = node.next;\\n       } \\n       return head;       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28773,
                "title": "two-pointers-java-solution",
                "content": "        public ListNode deleteDuplicates(ListNode head) {\\n    \\t\\tif(head==null || head.next==null) return head;\\n    \\t\\tListNode p = head;\\n    \\t\\tListNode curr = p.next;\\n    \\t\\twhile(curr!=null) {\\n    \\t\\t\\tif(curr.val!=p.val) {\\n    \\t\\t\\t\\tp.next=curr;\\n    \\t\\t\\t\\tp=curr;\\n    \\t\\t\\t}\\n    \\t\\t\\tcurr=curr.next;\\n    \\t\\t}\\n    \\t\\tp.next=curr;\\n    \\t\\treturn head;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "        public ListNode deleteDuplicates(ListNode head) {\\n    \\t\\tif(head==null || head.next==null) return head;\\n    \\t\\tListNode p = head;\\n    \\t\\tListNode curr = p.next;\\n    \\t\\twhile(curr!=null) {\\n    \\t\\t\\tif(curr.val!=p.val) {\\n    \\t\\t\\t\\tp.next=curr;\\n    \\t\\t\\t\\tp=curr;\\n    \\t\\t\\t}\\n    \\t\\t\\tcurr=curr.next;\\n    \\t\\t}\\n    \\t\\tp.next=curr;\\n    \\t\\treturn head;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3558535,
                "title": "simple-java-solution-beats-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode list = head;         \\n        while(list != null) {\\n            if (list.next == null) break; \\n            if (list.val == list.next.val) list.next = list.next.next;\\n            else list = list.next;\\n        }         \\n        return head;\\n    }\\n}\\n```\\n**Please upvote if you like the solution.\\nHappy Coding!** \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode list = head;         \\n        while(list != null) {\\n            if (list.next == null) break; \\n            if (list.val == list.next.val) list.next = list.next.next;\\n            else list = list.next;\\n        }         \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506654,
                "title": "fast-ts-js-solution-beats-97-19",
                "content": "![image.png](https://assets.leetcode.com/users/images/320f510c-a43a-4577-93ae-4bc05025084a_1683684477.138928.png)\\n\\nAs it is sorted we know that the next val can be similar. \\n\\nHence, we check for that and shift the pointer `->` `next`.\\n\\n# Code\\n```tsx\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    let node = head\\n\\n    while(node !== null){\\n        if(node.next !== null){\\n            if(node.val === node.next.val){\\n                node.next = node.next.next\\n                continue\\n            }\\n        }\\n\\n        node = node.next\\n    }\\n\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```tsx\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    let node = head\\n\\n    while(node !== null){\\n        if(node.next !== null){\\n            if(node.val === node.next.val){\\n                node.next = node.next.next\\n                continue\\n            }\\n        }\\n\\n        node = node.next\\n    }\\n\\n    return head\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451851,
                "title": "easy-solution",
                "content": "# Approach\\n![image.png](https://assets.leetcode.com/users/images/feca6847-02cc-4730-911b-6254abae6b57_1682368667.526796.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode current = head;\\n\\n        while (current != null && current.next != null) {\\n            if (current.val == current.next.val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n\\n        return head;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode current = head;\\n\\n        while (current != null && current.next != null) {\\n            if (current.val == current.next.val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n\\n        return head;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998601,
                "title": "simple-fast-and-efficient-c-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the next value is same, then simply connect the current node to the next-to-next node and repeat this process until you reach the end which is NULL\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, I am handling the edge case where the first node is empty because not only that is a good practice but leetcode always has such test cases too : )\\n# Complexity\\n- Time complexity: O(n) (Worst Case) (Since we have to go through the entire list)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) (Since we are not creating new nodes)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // Handling the Edge Case of empty list\\n        if(head == NULL) \\n            return head;\\n        ListNode* temp = head;\\n        // This is our temporary variable \\n        // We will use it to iterate through the list\\n        // While the head pointer remains intact\\n\\n        while(temp->next != NULL){\\n            // Since we have to compare the next node\\'s value\\n            // Our main condition is whether next node is NULL\\n            if(temp->next->val == temp->val){\\n                temp->next = temp->next->next;\\n                // Skip over the node connecting to next one\\n            }\\n            else{\\n                temp = temp->next; // Simply move through the list\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // Handling the Edge Case of empty list\\n        if(head == NULL) \\n            return head;\\n        ListNode* temp = head;\\n        // This is our temporary variable \\n        // We will use it to iterate through the list\\n        // While the head pointer remains intact\\n\\n        while(temp->next != NULL){\\n            // Since we have to compare the next node\\'s value\\n            // Our main condition is whether next node is NULL\\n            if(temp->next->val == temp->val){\\n                temp->next = temp->next->next;\\n                // Skip over the node connecting to next one\\n            }\\n            else{\\n                temp = temp->next; // Simply move through the list\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884254,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        current = head\\n        while current and current.next: \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        current = head\\n        while current and current.next: \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863725,
                "title": "javascript-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\n\\nvar deleteDuplicates = function(head) {\\n    if(head===null) return head;\\n    let node  = head;\\n    while(node && node.next) {\\n        if(node.next.val === node.val) {\\n            node.next = node.next.next\\n        }else {\\n            node = node.next\\n        }\\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\n\\nvar deleteDuplicates = function(head) {\\n    if(head===null) return head;\\n    let node  = head;\\n    while(node && node.next) {\\n        if(node.next.val === node.val) {\\n            node.next = node.next.next\\n        }else {\\n            node = node.next\\n        }\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2862948,
                "title": "easy-to-understand-cpp-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* prev=head;\\n        ListNode* nnext=head;\\n        while(nnext!=NULL && prev->next!=NULL){\\n            nnext=prev->next;\\n            if(nnext->val==prev->val){\\n                prev->next=prev->next->next;\\n                delete nnext;\\n                nnext=prev->next;\\n                continue;\\n            }\\n            prev=nnext;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* prev=head;\\n        ListNode* nnext=head;\\n        while(nnext!=NULL && prev->next!=NULL){\\n            nnext=prev->next;\\n            if(nnext->val==prev->val){\\n                prev->next=prev->next->next;\\n                delete nnext;\\n                nnext=prev->next;\\n                continue;\\n            }\\n            prev=nnext;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754975,
                "title": "java-runtime-0ms-faster-than-100-memory-usage-less-than-95-98",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode sentinel = new ListNode(0, head);\\n        ListNode pred = sentinel;\\n\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                pred.next = head.next;\\n            } else {\\n                pred = pred.next;\\n            }\\n            head = head.next;\\n        }\\n        return sentinel.next;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/986282c2-03ac-4cbb-9bbf-4b52311cd57e_1667028644.6378608.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode sentinel = new ListNode(0, head);\\n        ListNode pred = sentinel;\\n\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                pred.next = head.next;\\n            } else {\\n                pred = pred.next;\\n            }\\n            head = head.next;\\n        }\\n        return sentinel.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732826,
                "title": "c-java-0-ms-100-00-faster-4-lines-code",
                "content": "````\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *ans = head;\\n        while(ans && ans->next){\\n            if(ans->val == ans->next->val) ans->next = ans->next->next;\\n            else ans = ans->next;\\n        }\\n        return head;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Linked List"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *ans = head;\\n        while(ans && ans->next){\\n            if(ans->val == ans->next->val) ans->next = ans->next->next;\\n            else ans = ans->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460238,
                "title": "java-most-decisive-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)\\n            return head;\\n \\n        ListNode j = head;\\n \\n        while( j!= null && j.next != null){\\n            if(j.val == j.next.val){\\n                j.next = j.next.next;\\n            }else{\\n                j = j.next; \\n            }\\n        }\\n \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)\\n            return head;\\n \\n        ListNode j = head;\\n \\n        while( j!= null && j.next != null){\\n            if(j.val == j.next.val){\\n                j.next = j.next.next;\\n            }else{\\n                j = j.next; \\n            }\\n        }\\n \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184653,
                "title": "python-easy-solution-explained-beginners",
                "content": "**Try to read explaination, mainly in the note, you will get very clear understanding how to do these kind of problems.**\\n* Since given linked list is in sorted manner, it is guaranteed that duplicates will be together.\\n* So, we check the current node value with the next node\\'s value\\n\\t* if it is True:\\n\\t\\t* we simply point current node\\'s next with next node\\'s next \\n\\t* else:\\n\\t\\t* we simply move our pointer to next node.\\n\\n**NOTE** -\\n* we are not moving our currrent pointer to next after finding duplicate and changing current\\'s next to next node\\'s next. we are doing it only if we donot find any duplicates. **why**?\\n\\t* it will work for every case, but it will fail for the case if we have duplicates at the end.\\n\\t* let\\'s take an example of [1, 1, 2, 3, 3]\\n\\t* while head.next:\\n\\t\\t* head.val == head.next.val; simply point head.next = head.next.next \\n\\t\\t* and if we move head pointer to head.next, that is fine currpointer is at 2. head.val != head.next.val, move head pointer to next\\n\\t\\t* head.val == head.next.val, simply point head.next = head.next.next. and if we move head pointer to head.next, now current head is at None and our LL is 1->2->3. and when we are checking while loop we get an error that None doesn\\'t have next.\\n\\t\\t* so if we donot move our pointer to next if we find the duplicate then we will be able to cover all the cases.\\n* Now, you can get doubt what if we have while condition as while head:\\n\\t* that\\'s completely normal, here we are comparing current\\'s value with it\\'s next value. so at first we have to check whether curr.next is present or not.\\n* after every thing is done simply return the head that we stored in a temp, since we are moving our head pointer.\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return\\n        temp = head\\n        while head.next:\\n            if head.val == head.next.val:\\n                head.next = head.next.next\\n            else:\\n                head = head.next\\n        return temp\\n```\\n**Kindly Upvote if it helps :)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return\\n        temp = head\\n        while head.next:\\n            if head.val == head.next.val:\\n                head.next = head.next.next\\n            else:\\n                head = head.next\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119715,
                "title": "javascript-efficient-solution-meme",
                "content": "The key idea is traverse through list, and compare next node value with current, but step to the next node only if value is different\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    if (!head) return head;\\n    \\n    const headPointer = head;\\n    \\n    while (head !== null) {\\n        if (head.next !== null && head.val === head.next.val) {\\n            head.next = head.next.next;\\n        } else {\\n            head = head.next;\\n        }\\n    }\\n    \\n    return headPointer;\\n};\\n```\\n\\n**If you like solution or meme, upvote for motivate me**\\n\\nMeme#13 *see my other solutions for more memes!\\n\\n![image](https://assets.leetcode.com/users/images/acb34c8e-1feb-46e6-bf1b-63f75af2b4a9_1654544828.9435894.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    if (!head) return head;\\n    \\n    const headPointer = head;\\n    \\n    while (head !== null) {\\n        if (head.next !== null && head.val === head.next.val) {\\n            head.next = head.next.next;\\n        } else {\\n            head = head.next;\\n        }\\n    }\\n    \\n    return headPointer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106100,
                "title": "c-simple-solution",
                "content": "**upvote if you liked the solution(^ _^)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL) return head;\\n        ListNode* temp= head;\\n        while(temp->next!=NULL){\\n            if(temp->val!= temp->next->val) temp = temp->next;\\n            else\\n                temp->next= temp->next->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL) return head;\\n        ListNode* temp= head;\\n        while(temp->next!=NULL){\\n            if(temp->val!= temp->next->val) temp = temp->next;\\n            else\\n                temp->next= temp->next->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704166,
                "title": "python-3-30ms-faster-than-98-iterative-5-lines-solution-easy-approach",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        cur=head\\n        while cur and cur.next:\\n            if cur.val==cur.next.val:\\n                cur.next=cur.next.next\\n                continue\\n            cur=cur.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        cur=head\\n        while cur and cur.next:\\n            if cur.val==cur.next.val:\\n                cur.next=cur.next.next\\n                continue\\n            cur=cur.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631411,
                "title": "iterative-simple-and-easy-c",
                "content": "Implementation\\n\\n**Iterative Approach\\nTime Complexity = O(N), Space Complexity = O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur = head;\\n        while(cur){            \\n            if(cur->next && cur->next->val == cur->val) cur->next = cur->next->next;\\n            else cur = cur->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur = head;\\n        while(cur){            \\n            if(cur->next && cur->next->val == cur->val) cur->next = cur->next->next;\\n            else cur = cur->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570831,
                "title": "scala-solution",
                "content": "```\\nobject Solution {\\n def deleteDuplicates(head: ListNode): ListNode = {\\n    head match {\\n      case h if h == null => h\\n      case h if h.next == null => h\\n      case h if h.next.x == h.x => deleteDuplicates(h.next)\\n      case h => new ListNode(h.x, deleteDuplicates(h.next))\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n def deleteDuplicates(head: ListNode): ListNode = {\\n    head match {\\n      case h if h == null => h\\n      case h if h.next == null => h\\n      case h if h.next.x == h.x => deleteDuplicates(h.next)\\n      case h => new ListNode(h.x, deleteDuplicates(h.next))\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1511046,
                "title": "python-simplest-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        tempHead = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                head.next = head.next.next\\n            else:\\n                head = head.next\\n        return tempHead\\n            \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        tempHead = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                head.next = head.next.next\\n            else:\\n                head = head.next\\n        return tempHead\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354556,
                "title": "python-solution-for-remove-duplicates-from-sorted-list",
                "content": "**Method 1**\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        l1 = head\\n        values = set()\\n        while l1:\\n            values.add(l1.val)\\n            l1 = l1.next\\n            \\n        dummy = current = ListNode(0)\\n        values = sorted(values)\\n        for i in values:\\n            current.next = ListNode(val=int(i))\\n            current = current.next\\n                  \\n        current.next = None\\n        return dummy.next\\n```\\n\\n**Method 2**\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n        \\n        curr = head\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr=curr.next\\n        return head\\n```\\n\\t \\nIf you like it, please **UPVOTE** it motivates me to write more of these posts !!\\nHappy Coding :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        l1 = head\\n        values = set()\\n        while l1:\\n            values.add(l1.val)\\n            l1 = l1.next\\n            \\n        dummy = current = ListNode(0)\\n        values = sorted(values)\\n        for i in values:\\n            current.next = ListNode(val=int(i))\\n            current = current.next\\n                  \\n        current.next = None\\n        return dummy.next\\n```\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n        \\n        curr = head\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr=curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117432,
                "title": "faster-than-100-c-short-solution-without-memory-leak",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *temp=head;\\n        while(temp)\\n        {\\n            int element=temp->val;\\n            while(temp->next && element==temp->next->val) //checks if node after temp is its duplicate\\n\\t\\t\\t//since nodes are deleted U don\\'t need to move temp (temp=temp->next) \\n            {\\n                ListNode* m=temp->next;\\n                temp->next=m->next;\\n                delete m;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *temp=head;\\n        while(temp)\\n        {\\n            int element=temp->val;\\n            while(temp->next && element==temp->next->val) //checks if node after temp is its duplicate\\n\\t\\t\\t//since nodes are deleted U don\\'t need to move temp (temp=temp->next) \\n            {\\n                ListNode* m=temp->next;\\n                temp->next=m->next;\\n                delete m;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 972872,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        curr = head\\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        curr = head\\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869704,
                "title": "easy-python-beats-98-explained-with-comments",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head: return\\n\\t\\t# We\\'ll track the prev and current nodes.\\n        prev = head\\n        cur = head.next\\n\\t\\t# Set the prev.next to None (we update this when we find the next != node)\\n        prev.next = None\\n        while cur:\\n\\t\\t    # If the vals of the two nodes are the same advance cur.\\n            if cur.val == prev.val:\\n                cur = cur.next\\n\\t\\t\\t# Otherwise we know they are different vals.\\n            else:\\n\\t\\t\\t    # We set our prevs next to the current node.\\n                prev.next = cur\\n\\t\\t\\t\\t# We advance cur.\\n                cur = cur.next\\n\\t\\t\\t\\t# We advance prev.\\n                prev = prev.next\\n\\t\\t\\t\\t# Then set prev.next to None until we find another node.\\n                prev.next = None\\n                \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head: return\\n\\t\\t# We\\'ll track the prev and current nodes.\\n        prev = head\\n        cur = head.next\\n\\t\\t# Set the prev.next to None (we update this when we find the next != node)\\n        prev.next = None\\n        while cur:\\n\\t\\t    # If the vals of the two nodes are the same advance cur.\\n            if cur.val == prev.val:\\n                cur = cur.next\\n\\t\\t\\t# Otherwise we know they are different vals.\\n            else:\\n\\t\\t\\t    # We set our prevs next to the current node.\\n                prev.next = cur\\n\\t\\t\\t\\t# We advance cur.\\n                cur = cur.next\\n\\t\\t\\t\\t# We advance prev.\\n                prev = prev.next\\n\\t\\t\\t\\t# Then set prev.next to None until we find another node.\\n                prev.next = None\\n                \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738168,
                "title": "c-simplest-solution-beats-98",
                "content": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *temp=head;\\n        while(temp) {\\n        \\twhile(temp->next && temp->val==temp->next->val) {\\n                ListNode *t=temp->next->next;\\n                delete temp->next;\\n        \\t\\ttemp->next=t;\\n        \\t}\\n        \\ttemp=temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *temp=head;\\n        while(temp) {\\n        \\twhile(temp->next && temp->val==temp->next->val) {\\n                ListNode *t=temp->next->next;\\n                delete temp->next;\\n        \\t\\ttemp->next=t;\\n        \\t}\\n        \\ttemp=temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502590,
                "title": "recursive-solution-for-concept-building",
                "content": "class Solution:\\n    \\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        \\n            if head is None:\\n                return\\n    \\n            if head.next is not None:\\n        \\n                if head.val == head.next.val:\\n            \\n                    temp = head.next.next\\n                    head.next = None\\n                    head.next = temp\\n                    self.deleteDuplicates(head)\\n                else:\\n            \\n                    self.deleteDuplicates(head.next)\\n            \\n            return head\\n                                      \\n        \\n            \\n            \\n        \\n        \\n        \\n            \\n            \\n        \\n        \\n\\t\\t\\n#steps:\\n#1) check if head is None > \\n#2) check if head.next is not None> \\n#above two condition helps not to call on None type object\\n#3) compare 1st element of LL to 2nd(head.val == head.val.next)\\n#4) if they are same store the next.next element of LL in temp\\n#5) break the LL by assigning head.next = None\\n#6) now assign head.next to temp \\n#7) now call on self.deleteDuplicates(head) \\n#you wont choose head.next because it fails for  1->1->1->NONE\\n#8) WHEN next element is not same : more forward >self.deleteDuplicates(head.next)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "class Solution:\\n    \\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        \\n            if head is None:\\n                return\\n    \\n            if head.next is not None:\\n        \\n                if head.val == head.next.val:\\n            \\n                    temp = head.next.next\\n                    head.next = None\\n                    head.next = temp\\n                    self.deleteDuplicates(head)\\n                else:\\n            \\n                    self.deleteDuplicates(head.next)\\n            \\n            return head\\n                                      \\n        \\n            \\n            \\n        \\n        \\n        \\n            \\n            \\n        \\n        \\n\\t\\t\\n#steps:\\n#1) check if head is None > \\n#2) check if head.next is not None> \\n#above two condition helps not to call on None type object\\n#3) compare 1st element of LL to 2nd(head.val == head.val.next)\\n#4) if they are same store the next.next element of LL in temp\\n#5) break the LL by assigning head.next = None\\n#6) now assign head.next to temp \\n#7) now call on self.deleteDuplicates(head) \\n#you wont choose head.next because it fails for  1->1->1->NONE\\n#8) WHEN next element is not same : more forward >self.deleteDuplicates(head.next)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 275378,
                "title": "javascript-solution-simple",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    if (!head) return head;\\n    \\n    let curr = head;\\n    \\n    while(curr.next) {\\n        if (curr.val === curr.next.val) {\\n            curr.next = curr.next.next;\\n        } else {\\n            curr = curr.next;\\n        }\\n    }\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    if (!head) return head;\\n    \\n    let curr = head;\\n    \\n    while(curr.next) {\\n        if (curr.val === curr.next.val) {\\n            curr.next = curr.next.next;\\n        } else {\\n            curr = curr.next;\\n        }\\n    }\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 241787,
                "title": "python-3-pointer-listnode-100-96",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        now = head\\n        while head and now.next:\\n            if now.val == now.next.val:\\n                now.next = now.next.next\\n            else:\\n                now = now.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        now = head\\n        while head and now.next:\\n            if now.val == now.next.val:\\n                now.next = now.next.next\\n            else:\\n                now = now.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28618,
                "title": "iterative-python-solution-beats-99-8",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        current = head\\n        while current and current.next: \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        current = head\\n        while current and current.next: \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 28623,
                "title": "recursive-solution-in-swift-and-my-illustration",
                "content": "Here is my swift code and my illustration for someone who can hardly understand recursive as me ... :)\\n\\n```\\nfunc deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n    if head == nil || head?.next == nil { return head }\\n    head!.next = deleteDuplicates(head!.next)\\n    return head!.val == head!.next?.val ? head!.next : head\\n}\\n```\\n![](https://windsuzu.github.io/leetcode-83/remove_nodes.gif)",
                "solutionTags": [],
                "code": "```\\nfunc deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n    if head == nil || head?.next == nil { return head }\\n    head!.next = deleteDuplicates(head!.next)\\n    return head!.val == head!.next?.val ? head!.next : head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969975,
                "title": "100-faster-java-c-short-and-easy-for-understanding",
                "content": "\\n\\n# Approach\\n- Create ListNode Current for point nodes\\n- Initialy Current point to head\\n\\n- Iterate while loop until last Node\\n- if next node value is erqual to current node value than skip next node and jump to next node of next node.\\n  else next node value are different than current node value than make current node = next node\\n- Example 1:\\n  1 -> 1 -> 2\\n  initialy current node is first 1\\n  next node of current node is second 1\\n  both have same values so we update current.next for skip next element\\n current.next(second 1)=current.next.next(2) \\n 1 -> 2 \\n\\n# Complexity\\n- Time complexity: O(n);\\n\\n- Space complexity: O(1);\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        ListNode* Current=head;\\n\\n        while(Current!=NULL && Current->next!=NULL)\\n        {\\n            // if next node value is silmilar to current node\\n            // skip next node and update current.next\\n\\n            if(Current->val==Current->next->val)\\n            {\\n                Current->next=Current->next->next;\\n            }\\n            else\\n            {\\n                Current=Current->next;\\n            }\\n        }\\n        return head;  \\n    }\\n};\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) \\n    {\\n        ListNode Current=head;\\n\\n        while(Current!=null && Current.next!=null)\\n        {\\n            // if next node value is silmilar to current node\\n            // skip next node and update current.next\\n            if(Current.val==Current.next.val)\\n            {\\n                Current.next=Current.next.next;\\n            }\\n            else\\n            {\\n                Current=Current.next;\\n            }\\n        }\\n        return head;    \\n    }\\n}\\n```\\n\\nUpvote if code is usefull for you.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        ListNode* Current=head;\\n\\n        while(Current!=NULL && Current->next!=NULL)\\n        {\\n            // if next node value is silmilar to current node\\n            // skip next node and update current.next\\n\\n            if(Current->val==Current->next->val)\\n            {\\n                Current->next=Current->next->next;\\n            }\\n            else\\n            {\\n                Current=Current->next;\\n            }\\n        }\\n        return head;  \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) \\n    {\\n        ListNode Current=head;\\n\\n        while(Current!=null && Current.next!=null)\\n        {\\n            // if next node value is silmilar to current node\\n            // skip next node and update current.next\\n            if(Current.val==Current.next.val)\\n            {\\n                Current.next=Current.next.next;\\n            }\\n            else\\n            {\\n                Current=Current.next;\\n            }\\n        }\\n        return head;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917726,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916584,
                "title": "python3-beats-90-efficient-removal-of-duplicates-from-a-sorted-linked-list",
                "content": "# Intuition\\nOur goal is to remove duplicate nodes while maintaining the order. Since the list is sorted, duplicate nodes will be adjacent to each other. We just need to skip them.\\n\\n# Approach\\n1. We start with a pointer called `curr` that initially points to the `head` of the linked list.\\n1. We use a while loop to iterate through the linked list as long as `curr` is not None and `curr.next` is not None. This loop will help us traverse the linked list and examine each pair of adjacent nodes.\\n1. Inside the loop, we compare the value of the current node `curr `with the value of the next node `curr.next`.\\n1. If the values are equal, it means we\\'ve found a duplicate node. In this case, we **update the next pointer of the current node** `curr` **to skip the next node and directly point to the node after the duplicate.** This effectively removes the duplicate node from the linked list.\\n1. If the values are not equal i.e. not duplicates, we move the `curr` **pointer** **one step forward** to examine the next pair of nodes.\\n1. The loop continues until we reach the end of the linked list or until we\\'ve checked all pairs of adjacent nodes.\\n1. Finally, we return the head of the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\nThe algorithm iterates through the entire linked list once. Thus, the time complexity is $$O(n)$$, where n is the number of nodes in the linked list.\\n\\n- Space complexity:\\nWe are using only a constant amount of extra space to store the curr pointer. No additional data structures are used, so the space complexity is $$O(1)$$.\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Sort"
                ],
                "code": "```\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789177,
                "title": "c-solution-o-1-space-optimized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL  ||  head->next==NULL) return head;\\n\\n        ListNode*prev=NULL;\\n        ListNode*temp=NULL;\\n        ListNode*curr=head;\\n\\n        while(curr!=NULL){\\n            if(prev==NULL){\\n                prev=curr;\\n                temp=prev;\\n                curr=curr->next;\\n                continue;\\n            }\\n            if(curr->val == prev->val){\\n                curr=curr->next;\\n                if(curr==NULL) prev->next=NULL;\\n            }\\n            else{\\n                prev->next=curr;\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL  ||  head->next==NULL) return head;\\n\\n        ListNode*prev=NULL;\\n        ListNode*temp=NULL;\\n        ListNode*curr=head;\\n\\n        while(curr!=NULL){\\n            if(prev==NULL){\\n                prev=curr;\\n                temp=prev;\\n                curr=curr->next;\\n                continue;\\n            }\\n            if(curr->val == prev->val){\\n                curr=curr->next;\\n                if(curr==NULL) prev->next=NULL;\\n            }\\n            else{\\n                prev->next=curr;\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761114,
                "title": "siimple-linked-list-solution-easy-to-understand-simple-logic",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL or head->next==NULL)return head;\\n        ListNode* p=head;\\n        while(p!=NULL and p->next!=NULL){\\n            if(p->val==p->next->val){\\n                p->next=p->next->next;\\n            }\\n            else{\\n                p=p->next;\\n            }\\n        }\\n        return head;\\n      }\\n    };",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL or head->next==NULL)return head;\\n        ListNode* p=head;\\n        while(p!=NULL and p->next!=NULL){\\n            if(p->val==p->next->val){\\n                p->next=p->next->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3459803,
                "title": "100-simple-and-easy-code-for-removing-duplicates",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n        while(current != null && current.next != null) {\\n            if(current.val == current.next.val) {\\n                current.next = current.next.next;\\n            }\\n            else {\\n                current = current.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n        while(current != null && current.next != null) {\\n            if(current.val == current.next.val) {\\n                current.next = current.next.next;\\n            }\\n            else {\\n                current = current.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446457,
                "title": "two-pointer-approach-with-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove the duplicates from the linked list !!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, prev and curr, with the first and the second nodes of the linked list, respectively.\\n2. While curr is not NULL, compare the value of curr and prev nodes.\\n3. If they have the same value, update prev->next to curr->next and move curr to the next node.\\n4. If they have different values, move both prev and curr to their next nodes.\\n5. Return the head of the modified linked list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL)\\n        {\\n            return head;\\n        }\\n\\n        ListNode* curr = head->next;\\n        ListNode* prev = head;\\n\\n        if(curr == NULL || prev == NULL)\\n        {\\n            return head;\\n        }\\n\\n        while(curr != NULL)\\n        {\\n            if(curr->val == prev->val)\\n            {\\n                curr = curr->next;\\n                prev->next = curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL)\\n        {\\n            return head;\\n        }\\n\\n        ListNode* curr = head->next;\\n        ListNode* prev = head;\\n\\n        if(curr == NULL || prev == NULL)\\n        {\\n            return head;\\n        }\\n\\n        while(curr != NULL)\\n        {\\n            if(curr->val == prev->val)\\n            {\\n                curr = curr->next;\\n                prev->next = curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436205,
                "title": "easy-python3-solution-with-explanation",
                "content": "# Explanation \\n\\n- Set curr to the head and iterate till `curr` and `curr.next` is not None\\n- if `curr` node and `curr.next` have same value then just skip that node and set `curr.next = curr.next.next` else `curr = curr.next` and just return the `head`\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334014,
                "title": "easiest-solution-ever-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while (temp != null) {\\n            while(temp.next != null && temp.next.val == temp.val) \\n                temp.next = temp.next.next;\\n            temp = temp.next;\\n        } return head;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while (temp != null) {\\n            while(temp.next != null && temp.next.val == temp.val) \\n                temp.next = temp.next.next;\\n            temp = temp.next;\\n        } return head;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332247,
                "title": "different-solutions-using-map-and-iterative-way",
                "content": "**1. Using Hasmap to store the occurence of all nodes values(i.e. frequency) , and then again traverse to find frequency>1 , if yes remove that node.**\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode *deleteDuplicates(ListNode *head) {\\n    \\n    if(head == NULL || head->next == NULL) return head;   // if head is null or head ka next is null (i.e only one element ) then return head .\\n\\n    ListNode* temp = head;\\n\\n    map<int,int> m;\\n\\n    while(temp != nullptr){\\n        m[temp->val]++;\\n        temp = temp->next;\\n    }\\n    temp = head;\\n    while(temp != nullptr){\\n        \\n        if(m[temp->val]>1){              // If frquency is greater than 1 , then remove that node and decrease the frequency\\n            m[temp->val]--;\\n            ListNode* del = temp->next;\\n            temp->next = del->next;    // remove the connection of temp node using a new node del which is pointing to temp ka next.\\n            delete del;\\n        }else{\\n            temp = temp->next;\\n        }\\n        \\n        \\n\\n    }\\n    \\n    return head;\\n\\n}\\n};\\n```\\n2. Iterative Approach .\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode *deleteDuplicates(ListNode *head) {\\n\\n    ListNode* temp = head;\\n\\n    \\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }\\n\\n    while(temp->next != nullptr){\\n\\n        if(temp->val == temp->next->val){\\n            ListNode* del = temp->next;\\n            temp->next = del->next;\\n            delete del;\\n        }else{\\n            temp = temp->next;\\n        }\\n\\n        \\n    }\\n\\nreturn head;\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode *deleteDuplicates(ListNode *head) {\\n    \\n    if(head == NULL || head->next == NULL) return head;   // if head is null or head ka next is null (i.e only one element ) then return head .\\n\\n    ListNode* temp = head;\\n\\n    map<int,int> m;\\n\\n    while(temp != nullptr){\\n        m[temp->val]++;\\n        temp = temp->next;\\n    }\\n    temp = head;\\n    while(temp != nullptr){\\n        \\n        if(m[temp->val]>1){              // If frquency is greater than 1 , then remove that node and decrease the frequency\\n            m[temp->val]--;\\n            ListNode* del = temp->next;\\n            temp->next = del->next;    // remove the connection of temp node using a new node del which is pointing to temp ka next.\\n            delete del;\\n        }else{\\n            temp = temp->next;\\n        }\\n        \\n        \\n\\n    }\\n    \\n    return head;\\n\\n}\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode *deleteDuplicates(ListNode *head) {\\n\\n    ListNode* temp = head;\\n\\n    \\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }\\n\\n    while(temp->next != nullptr){\\n\\n        if(temp->val == temp->next->val){\\n            ListNode* del = temp->next;\\n            temp->next = del->next;\\n            delete del;\\n        }else{\\n            temp = temp->next;\\n        }\\n\\n        \\n    }\\n\\nreturn head;\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142463,
                "title": "easy-c-solution-linked-list-best-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approache by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n \\n /*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        while(curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                curr->next = curr->next->next;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n \\n /*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        while(curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                curr->next = curr->next->next;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030179,
                "title": "updated-step-wise-java-beats-100-runtime-100-space-easy-to-understand",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe list is already sorted so we only need to check the consecutive ListNode values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n    1. Check the base condition.\\n    2. Traverse the list to access the element.\\n    3. Compare the consecutive node values. \\n    4. Remove the duplicate elements.\\n    5. Finally, return the head node.\\nFollow the code below to understand the solution.\\n\\n              **If this solution helped you, give it an up-vote to help others** \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n\\n        //Step: 1\\n        //if the list is empty, return null.\\n        if(head == null) return head;\\n        \\n        //initialize preNode from head.\\n        ListNode preNode = head;\\n\\n        //initialize curNode from head.next.\\n        ListNode preNode = head.next;\\n\\n\\n        //Step: 2\\n        //Traverse till the last node.\\n        while(curNode != null)\\n        {\\n            //Step: 3\\n            //if the consecutive nodes have duplicate value.\\n            if(preNode.val==curNode.val)\\n            {\\n                //Step: 4\\n                //change the pointers to delete curNode.\\n                preNode.next=curNode.next;\\n            }\\n            //if the values are not duplicate.\\n            else\\n            {\\n                //Simply, update the preNode to curNode.\\n                preNode=curNode;\\n            }\\n            //curNode reference will get updated in both cases.\\n            //So, write it out of if-else block.\\n            curNode=curNode.next;\\n        }\\n\\n        //Step: 5\\n        //Finally, return the head node.\\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n\\n        //Step: 1\\n        //if the list is empty, return null.\\n        if(head == null) return head;\\n        \\n        //initialize preNode from head.\\n        ListNode preNode = head;\\n\\n        //initialize curNode from head.next.\\n        ListNode preNode = head.next;\\n\\n\\n        //Step: 2\\n        //Traverse till the last node.\\n        while(curNode != null)\\n        {\\n            //Step: 3\\n            //if the consecutive nodes have duplicate value.\\n            if(preNode.val==curNode.val)\\n            {\\n                //Step: 4\\n                //change the pointers to delete curNode.\\n                preNode.next=curNode.next;\\n            }\\n            //if the values are not duplicate.\\n            else\\n            {\\n                //Simply, update the preNode to curNode.\\n                preNode=curNode;\\n            }\\n            //curNode reference will get updated in both cases.\\n            //So, write it out of if-else block.\\n            curNode=curNode.next;\\n        }\\n\\n        //Step: 5\\n        //Finally, return the head node.\\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005436,
                "title": "easy-java-solution-beats-100",
                "content": "Hope this helps.\\nDo Upvote if you like it !!\\n\\nThanks :)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode node) {\\n        if(node==null){\\n            return node;\\n        }\\n        ListNode head=node;\\n        while(node.next!=null){\\n            if(node.val==node.next.val){\\n                node.next=node.next .next;\\n            }\\n            else{\\n                node=node.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode node) {\\n        if(node==null){\\n            return node;\\n        }\\n        ListNode head=node;\\n        while(node.next!=null){\\n            if(node.val==node.next.val){\\n                node.next=node.next .next;\\n            }\\n            else{\\n                node=node.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974847,
                "title": "c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* ans = deleteDuplicates(head->next);\\n        if(head->val == ans->val)\\n            head->next = ans->next;\\n        return head;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* ans = deleteDuplicates(head->next);\\n        if(head->val == ans->val)\\n            head->next = ans->next;\\n        return head;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954526,
                "title": "my-first-easy-solution-0ms-100-java",
                "content": "- 166/166 cases passed (0 ms)\\n- Your runtime beats 100 % of java submissions\\n- Your memory usage beats 83.92 % of java submissions (42 MB)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        ListNode out=new ListNode(),t=out;\\n\\n        while(head!=null){\\n            while(head.next!=null && head.val==head.next.val)\\n                head=head.next;\\n            t.next=new ListNode(head.val);\\n            t=t.next;\\n            head=head.next;    \\n        }\\n        return out.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        ListNode out=new ListNode(),t=out;\\n\\n        while(head!=null){\\n            while(head.next!=null && head.val==head.next.val)\\n                head=head.next;\\n            t.next=new ListNode(head.val);\\n            t=t.next;\\n            head=head.next;    \\n        }\\n        return out.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809763,
                "title": "java-easy-solution-with-explanation",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        //First we check if the head is null or not \\n        // if the head is null we simply return the head \\n        if(head == null) return head;\\n        ListNode node = head; \\n        //Here we perform a while loop until the node value is null \\n        while(node.next != null){\\n            //Through a if else condition we check if the value of the current node is equal to the value of the next node \\n            //if the value of the current node is same as the next one we simply skip the next node by \"node.next = node.next.next\"\\n            if(node.val == node.next.val) node.next = node.next.next;\\n            else node = node.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        //First we check if the head is null or not \\n        // if the head is null we simply return the head \\n        if(head == null) return head;\\n        ListNode node = head; \\n        //Here we perform a while loop until the node value is null \\n        while(node.next != null){\\n            //Through a if else condition we check if the value of the current node is equal to the value of the next node \\n            //if the value of the current node is same as the next one we simply skip the next node by \"node.next = node.next.next\"\\n            if(node.val == node.next.val) node.next = node.next.next;\\n            else node = node.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805997,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode listNode = head;\\n\\n        while (listNode != null && listNode.next != null) {\\n            if (listNode.val == listNode.next.val)  {\\n                listNode.next = listNode.next.next;\\n            } else {\\n                listNode = listNode.next;\\n            }\\n        }\\n        return head;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode listNode = head;\\n\\n        while (listNode != null && listNode.next != null) {\\n            if (listNode.val == listNode.next.val)  {\\n                listNode.next = listNode.next.next;\\n            } else {\\n                listNode = listNode.next;\\n            }\\n        }\\n        return head;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790045,
                "title": "easy-solution-faster-than-97-of-solution",
                "content": "# Intuition\\nWe will link node to the next element which is not the duplicate\\n\\n# Approach\\nTake two pointer q and p , p will move faster and q will remain at head only. p will move until q->val==p->val;\\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\nNone\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        struct ListNode *p=head;\\n        struct ListNode *q=head;\\n       while(p){\\n       while( p && q && p->val==q->val){\\n           p=p->next;\\n       }\\n       q->next=p;\\n       q=p;\\n       if(p){\\n       p=p->next;\\n       }\\n       }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        struct ListNode *p=head;\\n        struct ListNode *q=head;\\n       while(p){\\n       while( p && q && p->val==q->val){\\n           p=p->next;\\n       }\\n       q->next=p;\\n       q=p;\\n       if(p){\\n       p=p->next;\\n       }\\n       }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728818,
                "title": "c-easy-solution",
                "content": "class Solution\\n{\\n    public:\\n        ListNode* deleteDuplicates(ListNode *head)\\n        {\\n            if (head == NULL)\\n                return head;\\n\\n            ListNode *curr = head;\\n            while (curr->next != NULL)\\n            {\\n                if (curr->val == curr->next->val)\\n                {\\n                    ListNode *temp = curr->next;\\n                    curr->next = curr->next->next;\\n                    delete temp;\\n                }\\n                else\\n                    curr = curr->next;\\n            }\\n            return head;\\n        }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution\\n{\\n    public:\\n        ListNode* deleteDuplicates(ListNode *head)\\n        {\\n            if (head == NULL)\\n                return head;\\n\\n            ListNode *curr = head;\\n            while (curr->next != NULL)\\n            {\\n                if (curr->val == curr->next->val)\\n                {\\n                    ListNode *temp = curr->next;\\n                    curr->next = curr->next->next;\\n                    delete temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2721853,
                "title": "linear-python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        pt=head\\n        prev=pt\\n        pt=pt.next\\n        while pt:\\n            if pt.val==prev.val:\\n                prev.next=pt.next\\n                pt=pt.next\\n            else:\\n                prev=pt\\n                pt=pt.next\\n        return head\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        pt=head\\n        prev=pt\\n        pt=pt.next\\n        while pt:\\n            if pt.val==prev.val:\\n                prev.next=pt.next\\n                pt=pt.next\\n            else:\\n                prev=pt\\n                pt=pt.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663946,
                "title": "simple-and-efficient-approach-in-python",
                "content": "Hi Leets! I have solved it using a simple and efficient way. The algorithm I thought is that we will traverse through the linked list and if our current node is equal to the next node then we will just skip the next node and go to the next node of next. Through this we will be skipping the same nodes.\\n```\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        current = head\\n        nxt = head.next\\n        while nxt is not None:\\n            if current.val == nxt.val:\\n                current.next = nxt.next\\n                nxt = current  # If there are more than two same elements we will check them again\\n            current = nxt\\n            nxt = nxt.next\\n        return head\\n```\\nIf any queries feel free to ask :)",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        current = head\\n        nxt = head.next\\n        while nxt is not None:\\n            if current.val == nxt.val:\\n                current.next = nxt.next\\n                nxt = current  # If there are more than two same elements we will check them again\\n            current = nxt\\n            nxt = nxt.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637753,
                "title": "o-n-100-faster-iterative",
                "content": "***Approach : i will traverse over the list if i find value of current node equal to value of next node i will jump to curr->next->node (equals to deleting the curr->next node ).***\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head==nullptr)\\n            return head;\\n        \\n        ListNode *temp=head;\\n        \\n        while(temp){\\n            \\n                if(temp->next != nullptr and temp->val == temp->next->val){\\n                    temp->next = temp->next->next;\\n                }\\n                else{\\n                    temp=temp->next;\\n                }    \\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head==nullptr)\\n            return head;\\n        \\n        ListNode *temp=head;\\n        \\n        while(temp){\\n            \\n                if(temp->next != nullptr and temp->val == temp->next->val){\\n                    temp->next = temp->next->next;\\n                }\\n                else{\\n                    temp=temp->next;\\n                }    \\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637683,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head \\n        while curr :\\n            while curr.next and curr.next.val == curr.val:\\n                curr.next = curr.next.next\\n            curr = curr.next\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head \\n        while curr :\\n            while curr.next and curr.next.val == curr.val:\\n                curr.next = curr.next.next\\n            curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508423,
                "title": "simple-and-easy-java-solution-100-faster",
                "content": "```\\n\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n        while (current != null && current.next != null) {\\n            if (current.next.val == current.val) current.next = current.next.next;\\n            else current = current.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n        while (current != null && current.next != null) {\\n            if (current.next.val == current.val) current.next = current.next.next;\\n            else current = current.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248548,
                "title": "python-solution-explained-time-o-n-space-o-1",
                "content": "# Explaination:\\nThis problem is asking us to delete all duplicate nodes, so after we visit a node, if there are any other nodes with the same value, delete them and only keep the first instance of that node.\\n**Example:** 1->1->2->3\\nAs you can see `1` appears twice, we want to remove the duplicate, that would be the second `1`. \\nAfter removing it the result should look like: 1->2->3\\n\\n**Solution Breakdown:**\\n1. We create a variable `current` and initialize it to be the `head` of our linked list input\\n2. We setup our `while` loop to keep iterating while `current` and `current.next` are **NOT** `None`. The reason we do this is because we want to check the `current` node and one node after the `current` node and we want to compare their values to see if they are the same.\\n3. If the `current` node value is the same as the `current.next` value, we found a duplicate, so we change the pointer to skip the `.next` node and point to the node AFTER `current.next`. The reason why we do this is because we want to get rid of duplicates. So 1->1->2->3, the first `1` in that list will now skip the second `1` and point to the `2` like 1->2->3.\\n4. Notice how we don\\'t update `current`, we only update `current.next`, this is because there can be more duplicates. Imagine our input was 1->1->1->2->3. After updating `current.next` it would become 1->1->2->3, we deleted the second `1` in the list and pointed the first `1` to the third `1`. But if we update our current to be `current.next.next` we will end up not deleting the third `1` which is also a duplicate. `current` would point to that `1` and the next node after would be `2`, then our `if` statement would not catch the duplicate. Since we didn\\'t update the `current` we are still at the first `1` so `current.val` will be `1` and `current.next.val` will be `1` now we can delete that last one to make the list 1->2->3.\\n5. If `current` and `current.next` do not have the same values, we just update `current` like normal and set it to `current.next`\\n6. We return `head` after we finish.\\n\\n**Time O(N) | Space O(1):**\\nTime is O(N) because at most we are just going through the entire linked list once\\nSpace is O(1) because we don\\'t have anything saved in memory which is scaling with our input. We only have a variable which we use to update pointers.\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        \\n        while current and current.next:\\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        \\n        while current and current.next:\\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078592,
                "title": "my-sweet-o-n-solution-c",
                "content": "we have to traverse the linkedlist and have to ignore the duplicates by changing the link\\nby accessing the `prev` and `ptr->next` pointer which are neighbours of duplicate elements ,those pointer will help to remove the duplicate .\\n\\n\\n```\\n    ListNode *deleteDuplicates(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        ListNode *prev = ptr;\\n        if (!head)\\n        {\\n            return NULL;\\n        }\\n        while (ptr->next)\\n        {\\n            if (ptr->val == ptr->next->val)\\n            {\\n                ptr = ptr->next;\\n            }\\n            else\\n            {\\n                prev->next = ptr->next;\\n                ptr = ptr->next;\\n                prev = ptr;\\n            }\\n        }\\n        prev->next = NULL;\\n        return h;\\n    }\\n```\\n##### Feel free to ask any **doubts** in the comment section.\\n##### If you like this solution, do **UPVOTE**.\\n##### Happy Coding :)",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n    ListNode *deleteDuplicates(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        ListNode *prev = ptr;\\n        if (!head)\\n        {\\n            return NULL;\\n        }\\n        while (ptr->next)\\n        {\\n            if (ptr->val == ptr->next->val)\\n            {\\n                ptr = ptr->next;\\n            }\\n            else\\n            {\\n                prev->next = ptr->next;\\n                ptr = ptr->next;\\n                prev = ptr;\\n            }\\n        }\\n        prev->next = NULL;\\n        return h;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2077456,
                "title": "rust-typescript",
                "content": "Runtime: 3 ms, faster than 55.95% of Rust online submissions for Remove Duplicates from Sorted List.\\nMemory Usage: 2.1 MB, less than 72.62% of Rust online submissions for Remove Duplicates from Sorted List.\\n\\n```\\ntype Node = Option<Box<ListNode>>;\\nimpl Solution {\\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        \\n        if head.is_none() { return None }        \\n        let mut curr_node = head.as_mut().unwrap();\\n        \\n        while let Some(node) = curr_node.next.as_mut() { \\n            if curr_node.val == node.val { \\n                curr_node.next = node.next.take()\\n            } else  { \\n                curr_node = curr_node.next.as_mut().unwrap()\\n            }\\n        }\\n        head \\n    }\\n}\\n```\\n\\n#### TypeScript \\nRuntime: 121 ms, faster than 31.50% of TypeScript online submissions for Remove Duplicates from Sorted List.\\nMemory Usage: 45 MB, less than 67.89% of TypeScript online submissions for Remove Duplicates from Sorted List.\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    if (!head) { return null; }\\n    \\n    let curr_node: ListNode = head;\\n    while (curr_node.next) { \\n        if (curr_node.val === curr_node.next.val) { \\n            curr_node.next = curr_node.next.next\\n        } else { \\n            curr_node = curr_node.next\\n        }\\n    }\\n    return head \\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ntype Node = Option<Box<ListNode>>;\\nimpl Solution {\\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        \\n        if head.is_none() { return None }        \\n        let mut curr_node = head.as_mut().unwrap();\\n        \\n        while let Some(node) = curr_node.next.as_mut() { \\n            if curr_node.val == node.val { \\n                curr_node.next = node.next.take()\\n            } else  { \\n                curr_node = curr_node.next.as_mut().unwrap()\\n            }\\n        }\\n        head \\n    }\\n}\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    if (!head) { return null; }\\n    \\n    let curr_node: ListNode = head;\\n    while (curr_node.next) { \\n        if (curr_node.val === curr_node.next.val) { \\n            curr_node.next = curr_node.next.next\\n        } else { \\n            curr_node = curr_node.next\\n        }\\n    }\\n    return head \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877373,
                "title": "simple-typescript-o-n-with-one-pointer",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    let p = head;\\n    while(p && p.next) {\\n        if(p.val === p.next.val) {\\n            p.next = p.next.next;\\n        } else {\\n            p = p.next;\\n        }\\n    } \\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    let p = head;\\n    while(p && p.next) {\\n        if(p.val === p.next.val) {\\n            p.next = p.next.next;\\n        } else {\\n            p = p.next;\\n        }\\n    } \\n    return head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837194,
                "title": "java-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n\\t\\n\\twhile(current != null && current.next != null){\\n\\t  if(current.val == current.next.val){\\n\\t      current.next = current.next.next;\\n\\t  }else{\\n\\t      current = current.next;\\n\\t  }\\n\\t}\\n\\treturn head;\\n    }\\n}\\n```\\nPerform a dry run for better understanding .\\nHappy coding,\\nUpvote if helped !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n\\t\\n\\twhile(current != null && current.next != null){\\n\\t  if(current.val == current.next.val){\\n\\t      current.next = current.next.next;\\n\\t  }else{\\n\\t      current = current.next;\\n\\t  }\\n\\t}\\n\\treturn head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807742,
                "title": "python-3-faster-than-98-o-n",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None:\\n            return head\\n        ptr = head\\n        while(ptr.next!=None):\\n            if ptr.val==ptr.next.val:\\n                ptr.next = ptr.next.next\\n            else:\\n                ptr = ptr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None:\\n            return head\\n        ptr = head\\n        while(ptr.next!=None):\\n            if ptr.val==ptr.next.val:\\n                ptr.next = ptr.next.next\\n            else:\\n                ptr = ptr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779974,
                "title": "python-simple-and-efficient",
                "content": "```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        itr = head\\n        \\n        if itr is None:\\n            return itr\\n        \\n        while itr.next:\\n            if itr.val == itr.next.val:\\n                itr.next = itr.next.next\\n            else:\\n                itr = itr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        itr = head\\n        \\n        if itr is None:\\n            return itr\\n        \\n        while itr.next:\\n            if itr.val == itr.next.val:\\n                itr.next = itr.next.next\\n            else:\\n                itr = itr.next\\n        \\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1769910,
                "title": "o-n-tc-and-o-1-space-algorithm-iterative",
                "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* temp=head;\\n        \\n        while(temp!=NULL && temp->next!=NULL){\\n            if(temp->next->val==temp->val){\\n                temp->next=temp->next->next;\\n                continue;\\n            }\\n            temp=temp->next;            \\n        }\\n        \\n        return head;\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* temp=head;\\n        \\n        while(temp!=NULL && temp->next!=NULL){\\n            if(temp->next->val==temp->val){\\n                temp->next=temp->next->next;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1759668,
                "title": "java-solution-with-dry-run",
                "content": "```\\n/*\\n curr\\n  1 --------> 2---------> 3 ----------> 3 ------->null\\n  \\n  curr.val = 1 , curr.next.val =2   1!=2 so move curr to it\\'s next \\n\\n\\n\\n            curr\\n  1 --------> 2---------> 3 ----------> 3 ------->null\\n\\ncurr.val = 2 , curr.next.val =3   2!=3 so move curr to it\\'s next \\n\\n\\n                        curr\\n  1 --------> 2---------> 3     3 ------->null\\n                          |________________|\\n  curr.val = 3 , curr.next.val =3   3==3 so move curr.next to it\\'s next\\'s next\\n  As we found the duplicate element hence breaking the link of duplicate elements\\n\\n\\nNow curr.next is pointing to null it means , we have removed all duplicate elements till curr and now we can return head of list\\n\\nFinal List\\n\\nhead\\n  1----------->2---------->3------>null\\n\\n*/\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null) return null;\\n        \\n        ListNode curr = head;\\n        \\n        while(curr.next != null)\\n        {\\n            if(curr.val == curr.next.val)\\n            {\\n                curr.next = curr.next.next;\\n            }\\n            else\\n                curr = curr.next;\\n        }\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null) return null;\\n        \\n        ListNode curr = head;\\n        \\n        while(curr.next != null)\\n        {\\n            if(curr.val == curr.next.val)\\n            {\\n                curr.next = curr.next.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1664584,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val==curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val==curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626515,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null){\\n            return head;\\n        }\\n        ListNode temp=head;\\n        while(temp.next!=null){\\n            if(temp.val==temp.next.val){\\n                temp.next=temp.next.next;\\n            }else{\\n                temp=temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1584417,
                "title": "javascript-o-n-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    let curr = head;\\n    while(curr&&curr.next){\\n        if(curr.val === curr.next.val){\\n            curr.next = curr.next.next;\\n        }else{\\n            curr=curr.next;   \\n        }        \\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    let curr = head;\\n    while(curr&&curr.next){\\n        if(curr.val === curr.next.val){\\n            curr.next = curr.next.next;\\n        }else{\\n            curr=curr.next;   \\n        }        \\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1495686,
                "title": "c-solution-o-n-t-c",
                "content": "Upvote if you like the solution ->\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        while(temp!=NULL &&temp->next!=NULL){\\n            if(temp->val==temp->next->val){\\n                temp->next=temp->next->next;\\n            }else{\\n                temp=temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        while(temp!=NULL &&temp->next!=NULL){\\n            if(temp->val==temp->next->val){\\n                temp->next=temp->next->next;\\n            }else{\\n                temp=temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494834,
                "title": "short-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        if(head.val==head.next.val) head=deleteDuplicates(head.next);\\n        head.next =deleteDuplicates(head.next);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        if(head.val==head.next.val) head=deleteDuplicates(head.next);\\n        head.next =deleteDuplicates(head.next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450058,
                "title": "c-iterative-and-recursive-solutions",
                "content": "#### Iterative Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t\\tListNode* curr = head;\\n\\t\\t\\tListNode* temp = NULL;\\n\\t\\t\\twhile(curr && curr -> next){\\n\\t\\t\\t\\tif(curr -> val == curr -> next -> val){\\n\\t\\t\\t\\t\\ttemp = curr -> next;\\n\\t\\t\\t\\t\\tcurr -> next = curr -> next -> next;\\n\\t\\t\\t\\t\\tdelete temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tcurr = curr -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t};\\n#### Recursive Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t\\tif(!head || !(head -> next)){\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\t}\\n\\t\\t\\tif(head -> val == head -> next -> val){\\n\\t\\t\\t\\tListNode* temp = head -> next;\\n\\t\\t\\t\\thead -> next = head -> next -> next;\\n\\t\\t\\t\\tdelete temp;\\n\\t\\t\\t\\tdeleteDuplicates(head);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tdeleteDuplicates(head -> next);\\n\\t\\t\\t}\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t\\tListNode* curr = head;\\n\\t\\t\\tListNode* temp = NULL;\\n\\t\\t\\twhile(curr && curr -> next){\\n\\t\\t\\t\\tif(curr -> val == curr -> next -> val){\\n\\t\\t\\t\\t\\ttemp = curr -> next;\\n\\t\\t\\t\\t\\tcurr -> next = curr -> next -> next;\\n\\t\\t\\t\\t\\tdelete temp;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1435205,
                "title": "elixir-304-ms-50-9-mb-recursion-pattern-matching",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec delete_duplicates(head :: ListNode.t | nil) :: ListNode.t | nil\\n  def delete_duplicates(nil), do: nil\\n  def delete_duplicates(%ListNode{val: _, next: nil} = current_node), do: current_node\\n                               \\n  def delete_duplicates(%ListNode{val: val, next: %ListNode{val: val, next: _} = next_node} = _current_node) do \\n    delete_duplicates(next_node)                      \\n  end\\n      \\n  def delete_duplicates(%ListNode{val: _, next: next_node} = current_node) do\\n    %ListNode{current_node | next: delete_duplicates(next_node)}\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec delete_duplicates(head :: ListNode.t | nil) :: ListNode.t | nil\\n  def delete_duplicates(nil), do: nil\\n  def delete_duplicates(%ListNode{val: _, next: nil} = current_node), do: current_node\\n                               \\n  def delete_duplicates(%ListNode{val: val, next: %ListNode{val: val, next: _} = next_node} = _current_node) do \\n    delete_duplicates(next_node)                      \\n  end\\n      \\n  def delete_duplicates(%ListNode{val: _, next: next_node} = current_node) do\\n    %ListNode{current_node | next: delete_duplicates(next_node)}\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1348034,
                "title": "c-code",
                "content": "Runtime: 4 ms, faster than 94.60% of C online submissions for Remove Duplicates from Sorted List.\\nMemory Usage: 6.5 MB, less than 66.03% of C online submissions for Remove Duplicates from Sorted List.\\n\\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    if(head==NULL || head->next == NULL)return head;\\n    struct ListNode *temp=head->next,*lastValidElement=head;\\n    while(temp!=NULL){\\n        if(temp->val != lastValidElement->val){\\n            lastValidElement->next=temp;\\n            lastValidElement=temp;\\n        }\\n        temp=temp->next;\\n    }\\n    lastValidElement->next=temp;\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    if(head==NULL || head->next == NULL)return head;\\n    struct ListNode *temp=head->next,*lastValidElement=head;\\n    while(temp!=NULL){\\n        if(temp->val != lastValidElement->val){\\n            lastValidElement->next=temp;\\n            lastValidElement=temp;\\n        }\\n        temp=temp->next;\\n    }\\n    lastValidElement->next=temp;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113182,
                "title": "c-83-remove-duplicates-from-sorted-list",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* node = head; \\n        while (node) \\n            if (node->next && node->val == node->next->val) node->next = node->next->next; \\n            else node = node->next; \\n        return head; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* node = head; \\n        while (node) \\n            if (node->next && node->val == node->next->val) node->next = node->next->next; \\n            else node = node->next; \\n        return head; \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568765,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1572757,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1669069,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1571190,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1805936,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1571189,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2059381,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2051834,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2047974,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2046475,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1568765,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1572757,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1669069,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1571190,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1805936,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1571189,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2059381,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2051834,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2047974,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2046475,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2018890,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 2009520,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1996312,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1996151,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1994408,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1991819,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1933403,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1930282,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1914738,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1895135,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1891177,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1884913,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1806864,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1805944,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1804752,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1800759,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1792814,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1779291,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1771755,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1761387,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1760992,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1757025,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1751092,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1743305,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1742504,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1735792,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1735520,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1735051,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1734963,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1734960,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1734831,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1728794,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1725799,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1717545,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1716382,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1710022,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1700982,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1694676,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1692816,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1686376,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            }
        ]
    }
]