[
    {
        "title": "Validate Binary Search Tree",
        "question_content": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\n\n\tThe left subtree of a node contains only nodes with keys less than the node's key.\n\tThe right subtree of a node contains only nodes with keys greater than the node's key.\n\tBoth the left and right subtrees must also be binary search trees.\n\n&nbsp;\nExample 1:\n\nInput: root = [2,1,3]\nOutput: true\n\nExample 2:\n\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 104].\n\t-231 <= Node.val <= 231 - 1",
        "solutions": [
            {
                "id": 32112,
                "title": "learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution",
                "content": "I will show you all how to tackle various tree questions using iterative inorder traversal. First one is the standard iterative inorder traversal using stack. Hope everyone agrees with this solution. \\n\\nQuestion : [Binary Tree Inorder Traversal][1]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n            \\n        }\\n        return list;\\n    }\\n\\nNow, we can use this structure to find the Kth smallest element in BST.\\n\\nQuestion : [Kth Smallest Element in a BST][2]\\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<>();\\n         while(root != null || !stack.isEmpty()) {\\n             while(root != null) {\\n                 stack.push(root);    \\n                 root = root.left;   \\n             } \\n             root = stack.pop();\\n             if(--k == 0) break;\\n             root = root.right;\\n         }\\n         return root.val;\\n     }\\n\\nWe can also use this structure to solve BST validation question. \\n\\nQuestion : [Validate Binary Search Tree][3]\\n\\n    public boolean isValidBST(TreeNode root) {\\n       if (root == null) return true;\\n       Stack<TreeNode> stack = new Stack<>();\\n       TreeNode pre = null;\\n       while (root != null || !stack.isEmpty()) {\\n          while (root != null) {\\n             stack.push(root);\\n             root = root.left;\\n          }\\n          root = stack.pop();\\n          if(pre != null && root.val <= pre.val) return false;\\n          pre = root;\\n          root = root.right;\\n       }\\n       return true;\\n    }\\n\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n  [2]: https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\n  [3]: https://leetcode.com/problems/validate-binary-search-tree/",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "I will show you all how to tackle various tree questions using iterative inorder traversal. First one is the standard iterative inorder traversal using stack. Hope everyone agrees with this solution. \\n\\nQuestion : [Binary Tree Inorder Traversal][1]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n            \\n        }\\n        return list;\\n    }\\n\\nNow, we can use this structure to find the Kth smallest element in BST.\\n\\nQuestion : [Kth Smallest Element in a BST][2]\\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<>();\\n         while(root != null || !stack.isEmpty()) {\\n             while(root != null) {\\n                 stack.push(root);    \\n                 root = root.left;   \\n             } \\n             root = stack.pop();\\n             if(--k == 0) break;\\n             root = root.right;\\n         }\\n         return root.val;\\n     }\\n\\nWe can also use this structure to solve BST validation question. \\n\\nQuestion : [Validate Binary Search Tree][3]\\n\\n    public boolean isValidBST(TreeNode root) {\\n       if (root == null) return true;\\n       Stack<TreeNode> stack = new Stack<>();\\n       TreeNode pre = null;\\n       while (root != null || !stack.isEmpty()) {\\n          while (root != null) {\\n             stack.push(root);\\n             root = root.left;\\n          }\\n          root = stack.pop();\\n          if(pre != null && root.val <= pre.val) return false;\\n          pre = root;\\n          root = root.right;\\n       }\\n       return true;\\n    }\\n\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n  [2]: https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\n  [3]: https://leetcode.com/problems/validate-binary-search-tree/",
                "codeTag": "Unknown"
            },
            {
                "id": 32109,
                "title": "my-simple-java-solution-in-3-lines",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }\\n        \\n        public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\\n            if (root == null) return true;\\n            if (root.val >= maxVal || root.val <= minVal) return false;\\n            return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\\n        }\\n    }\\n\\nBasically what I am doing is recursively iterating over the tree while defining interval `<minVal, maxVal>` for each node which value must fit in.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32104,
                "title": "c-in-order-traversal-and-please-do-not-rely-on-buggy-int-max-int-min-solutions-any-more",
                "content": "    class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            TreeNode* prev = NULL;\\n            return validate(root, prev);\\n        }\\n        bool validate(TreeNode* node, TreeNode* &prev) {\\n            if (node == NULL) return true;\\n            if (!validate(node->left, prev)) return false;\\n            if (prev != NULL && prev->val >= node->val) return false;\\n            prev = node;\\n            return validate(node->right, prev);\\n        }\\n    };\\n\\n> Update:\\n> \\n> If we use in-order traversal to serialize a binary search tree, we can\\n> get a list of values in ascending order. It can be proved with the\\n> definition of BST. And here I use the reference of TreeNode\\n> pointer `prev` as a global variable to mark the address of previous node in the\\n> list.\\n> \\n> \\u201cIn-order Traversal\\u201d:\\n> [https://en.wikipedia.org/wiki/Tree_traversal#In-order]()\\n\\nIf you know what `INT_MAX` or `INT_MIN` is, then it is no excuse for your carelessness.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            TreeNode* prev = NULL;\\n            return validate(root, prev);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32141,
                "title": "c-simple-recursive-solution",
                "content": "    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, NULL, NULL);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n        if(!root) return true;\\n        if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n            return false;\\n        return isValidBST(root->left, minNode, root) && isValidBST(root->right, root, maxNode);\\n    }",
                "solutionTags": [],
                "code": "    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, NULL, NULL);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n        if(!root) return true;\\n        if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n            return false;\\n        return isValidBST(root->left, minNode, root) && isValidBST(root->right, root, maxNode);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3169560,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n\\nbool isPossible(TreeNode* root, long long l, long long r){\\n    if(root == nullptr)  return true;\\n    if(root->val < r and root->val > l)\\n        return isPossible(root->left, l, root->val) and \\n                                isPossible(root->right, root->val, r);\\n    else return false;\\n}\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long long int min = -1000000000000, max = 1000000000000;\\n        return isPossible(root, min, max);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        prev = float(\\'-inf\\')\\n        def inorder(node):\\n            nonlocal prev\\n            if not node:\\n                return True\\n            if not (inorder(node.left) and prev < node.val):\\n                return False\\n            prev = node.val\\n            return inorder(node.right)\\n        return inorder(root)\\n```\\n\\n```Java []\\nclass Solution {\\n    private long minVal = Long.MIN_VALUE;\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true; \\n        if (!isValidBST(root.left)) return false;\\n        \\n        if (minVal >= root.val) return false; \\n\\n        minVal = root.val;\\n\\n        if (!isValidBST(root.right)) return false;\\n\\n        return true;\\n    } \\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n\\nbool isPossible(TreeNode* root, long long l, long long r){\\n    if(root == nullptr)  return true;\\n    if(root->val < r and root->val > l)\\n        return isPossible(root->left, l, root->val) and \\n                                isPossible(root->right, root->val, r);\\n    else return false;\\n}\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long long int min = -1000000000000, max = 1000000000000;\\n        return isPossible(root, min, max);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        prev = float(\\'-inf\\')\\n        def inorder(node):\\n            nonlocal prev\\n            if not node:\\n                return True\\n            if not (inorder(node.left) and prev < node.val):\\n                return False\\n            prev = node.val\\n            return inorder(node.right)\\n        return inorder(root)\\n```\n```Java []\\nclass Solution {\\n    private long minVal = Long.MIN_VALUE;\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true; \\n        if (!isValidBST(root.left)) return false;\\n        \\n        if (minVal >= root.val) return false; \\n\\n        minVal = root.val;\\n\\n        if (!isValidBST(root.right)) return false;\\n\\n        return true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786520,
                "title": "general-tree-traversal-problems-interview-prep",
                "content": "Please feel free to suggest similar problems in the comment section.\\n\\nThere are three types of Tree traversal: Inorder, Preorder and Postorder\\n\\n* **Inorder:** left, root, right\\n* **Preorder:** root, left child, right child **OR**  root, right child, left child\\t\\t\\t\\n* **Postorder:** left child, right child, root **OR** right child, left child, root\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\n**INORDER TRAVERSAL**\\n\\n**98. Validate Binary Search Tree**\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        output =[]\\n        self.inorder(root, output)\\n        \\n        for i in range(1, len(output)):\\n\\t\\t\\tif output[i-1]>= output[i]:\\n\\t\\t\\t\\treturn False\\n        \\n        return True\\n    \\n    # Time complexity of inorder traversal is O(n)\\n    # Fun fact: Inorder traversal leads to a sorted array if it is \\n    # a Valid Binary Search. Tree.\\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n        \\n```\\n**94. Binary Tree Inorder Traversal**\\n\\n\\n```\\n# Recursive: runtime-16ms\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.inorder(root, output)\\n        return output\\n        \\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n\\n\\n# Iterative Runtime: 20 ms, faster than 70.13%\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack=[]\\n        \\n        while stack or root:\\n            \\n            if root:\\n                stack.append(root)\\n                root =root.left\\n                \\n            else:\\n                temp =stack.pop()\\n                output.append(temp.val)\\n                root= temp.right\\n           \\n        return output\\n```\\n\\n**PREORDER TRAVERSAL**\\n\\n**589. N-ary Tree Preorder Traversal**\\n\\n\\n```\\n## Recursive Solution: Runtime: 36 ms, faster than 97.16%\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output =[]\\n        \\n        # perform dfs on the root and get the output stack\\n        self.dfs(root, output)\\n        \\n        # return the output of all the nodes.\\n        return output\\n    \\n    def dfs(self, root, output):\\n        \\n        # If root is none return \\n        if root is None:\\n            return\\n        \\n        # for preorder we first add the root val\\n        output.append(root.val)\\n        \\n        # Then add all the children to the output\\n        for child in root.children:\\n            self.dfs(child, output)\\n       \\n\\t   \\n\\t   \\n# Iterative Solution- Runtime: 40 ms, faster than 91.86% \\n\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n        \\n        # Till there is element in stack the loop runs.\\n        while stack:\\n            \\n            #pop the last element from the stack and store it into temp.\\n            temp = stack.pop()\\n            \\n            # append. the value of temp to output\\n            output.append(temp.val)\\n            \\n            #add the children of the temp into the stack in reverse order.\\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\\n            # This continues till the stack is empty.\\n            stack.extend(temp.children[::-1])\\n        \\n        #return the output\\n        return output\\n        \\n```\\n\\n\\n\\n**144. Binary Tree Preorder Traversal**\\n\\n\\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        \\n        output.append(root.val)\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output)\\n       \\n\\t   \\n# Iterative Solution- Runtime: 12 ms, faster than 97.82%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            temp=stack.pop()\\n            if temp:\\n                output.append(temp.val)\\n                stack.append(temp.right)\\n                stack.append(temp.left)\\n        \\n        return output\\n```\\n**257. Binary Tree Paths** : Runtime: 16 ms, faster than 93.92% of Python \\nhttps://leetcode.com/problems/binary-tree-paths/\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[str]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        result = []\\n        self.dfs(root, \"\", result)\\n        return result\\n\\n    def dfs(self, root, path, result):\\n        if not root.left and not root.right:\\n            result.append(path + str(root.val))\\n        \\n        if root.left:\\n            self.dfs(root.left, path + str(root.val) + \"->\" , result)\\n        if root.right:\\n            self.dfs(root.right, path + str(root.val) + \"->\", result)\\n        \\n```\\n\\n\\n**POSTORDER TRAVERSAL**\\n\\n**590. N-ary Tree Postorder Traversal**\\n```\\n# Recursive : Runtime: 40 ms, faster than 89.79% \\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        for child in root.children:\\n            self.dfs(child, output)\\n        \\n        output.append(root.val)\\n \\n \\n # Iterative Solution: Runtime: 48 ms, faster than 62.81%\\n \\n `\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                output.append(root.val)\\n                stack += root.children\\n                \\n        return output[::-1]`\\n        \\n```\\n\\n**145. Binary Tree Postorder Traversal**\\n\\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output) \\n        output.append(root.val)\\n\\t\\t\\n\\t\\t\\n# Iterative solution: Runtime: 12 ms, faster than 98.10%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack =[root]\\n        \\n        if not root:\\n            return None\\n        \\n        # iterate only when there is elements inside the stack.\\n        while stack:\\n            \\n            # pop the element from stack and stored it into temp\\n            temp=stack.pop()\\n            \\n            #append the value of temp to output\\n            output.append(temp.val)\\n            \\n            #Now traverse through left node and add the node to stack\\n            if temp.left:\\n                stack.append(temp.left)\\n                \\n            #else traverse through right node and add to stack\\n            if temp.right:\\n                stack.append(temp.right)\\n         \\n        # After iterating through the stack,  print the result in reverse order.  \\n        return output[::-1]\\n    \\n    \\n# Example: Iteration 1 : #stack=[1] - first iteration, temp =1, \\n                #output[1]\\n                #temp.left is Null\\n                #temp.right is [2]\\n                # stack =[2]\\n\\n```\\n\\n**LEVEL ORDER TRAVERSAL**\\n\\n**102. Binary Tree Level Order Traversal**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        \\n        if not root:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)    \\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\\n\\n**107. Binary Tree Level Order Traversal II**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrderBottom(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, 0, output)\\n        return output[::-1]\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n             return\\n            \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n```\\n\\n**429. N-ary Tree Level Order Traversal**\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level ,output):\\n        if root is None:\\n            return\\n        if len(output)< level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        for child in root.children:\\n            self.dfs(child, level+1, output)\\n      \\n```\\n\\n**103. Binary Tree Zigzag Level Order Traversal**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        \\n        for i in range(len(output)):\\n            if i % 2 !=0:\\n                output[i].reverse()\\n            else:\\n                continue\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\\n\\n\\n**BINARY TREE CONSTRUCTION**\\n\\n\\n**105. Construct Binary Tree from Preorder and Inorder Traversal**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not inorder or not preorder:\\n            return None\\n        \\n        #pattern is preorder=[root, left, right]\\n        #inorder = [left, root, right],  so find index and value using root.\\n        \\n        root = TreeNode(preorder[0])\\n        \\n        root_index= 0\\n        \\n        #iterate through inorder list and find the list index of the root.\\n        for i in range(len(inorder)):\\n            if inorder[i]== root.val:\\n                root_index = i\\n            else:\\n                continue\\n                \\n        #slice the inorder list into left and right.     \\n        left_inorder = inorder[:root_index]\\n        right_inorder = inorder[root_index+1:]\\n        \\n        #slice the preorder list into left and right.\\n        left_preorder = preorder[1:len(left_inorder)+1]\\n        right_preorder = preorder[len(left_preorder)+1:]\\n        \\n        #append by updating preorder and inorder lists\\n        root.left = self.buildTree(left_preorder, left_inorder)\\n        root.right = self.buildTree(right_preorder, right_inorder)\\n        \\n        return root\\n```\\n\\n**106. Construct Binary Tree from Inorder and Postorder Traversal**\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        # PATTERN\\n        # inorder: l, root, right\\n        # postorder: l,r,root\\n        # the last element of postorder is root\\n        \\n        if not inorder or not postorder:\\n            return None\\n        \\n        root_index=0\\n        \\n        # Build the data structure based on root value\\n        root = TreeNode(postorder.pop())\\n        \\n        for i in range(len(inorder)):\\n            if inorder[i]==root.val:\\n                root_index=i\\n            else:\\n                continue\\n        \\n        left_in=inorder[:root_index]\\n        right_in = inorder[root_index+1:]\\n        \\n        root.right = self.buildTree(right_in, postorder)\\n        root.left = self.buildTree(left_in,  postorder)\\n\\n        return root\\n   \\n```\\n\\n**889. Construct Binary Tree from Preorder and Postorder Traversal:** \\nRuntime: 40 ms, faster than 80.14%\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre:\\n            return None\\n        \\n        root = TreeNode(post.pop())\\n        \\n        if len(pre) == 1:\\n            return root\\n        \\n        # Find the index of the root value from pre\\n        for i in range(len(pre)):\\n            if pre[i]==post[-1]:\\n                root_index= i\\n            else:\\n                continue\\n        \\n        root.right = self.constructFromPrePost(pre[root_index:], post) \\n        root.left = self.constructFromPrePost(pre[1:root_index],post) \\n        \\n        return root \\n   \\n# Explanation:   root=1, root_index = 0, root.right=(pre(1,2,3,4,5,6,7))  [1, 2,3,4,5,6,7]                           vii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 3, root_index= 4, root.right=(pre(3,6,7))  [3,4,5,6,7]                               v\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root=7, root_index=2, root.right= pre(7), now len(pre) == 1, return 7 ---[7]        i\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =6, root_index=1, root.left= pre(6), now len(pre)==1, return 6 -----[6,7]      ii \\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =2, root_index= 1, root.right= pre(2,4,5)   [2,3,4,5,6,7]                               vi \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 5, root_index=2, root.right= pre(5)  now len(pre)==1, return 5 ----[5,6,7]   iii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 4, root_index=1, root.right= pre(4)  now len(pre)==1, return 4-----[4,5,6,7]  iv\\n\\n```\\n=========================================================\\nHope you\\'ve found the solutions useful. Please do UPVOTE, it only motivates me to write more such posts. Thanks!",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        output =[]\\n        self.inorder(root, output)\\n        \\n        for i in range(1, len(output)):\\n\\t\\t\\tif output[i-1]>= output[i]:\\n\\t\\t\\t\\treturn False\\n        \\n        return True\\n    \\n    # Time complexity of inorder traversal is O(n)\\n    # Fun fact: Inorder traversal leads to a sorted array if it is \\n    # a Valid Binary Search. Tree.\\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n        \\n```\n```\\n# Recursive: runtime-16ms\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.inorder(root, output)\\n        return output\\n        \\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n\\n\\n# Iterative Runtime: 20 ms, faster than 70.13%\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack=[]\\n        \\n        while stack or root:\\n            \\n            if root:\\n                stack.append(root)\\n                root =root.left\\n                \\n            else:\\n                temp =stack.pop()\\n                output.append(temp.val)\\n                root= temp.right\\n           \\n        return output\\n```\n```\\n## Recursive Solution: Runtime: 36 ms, faster than 97.16%\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output =[]\\n        \\n        # perform dfs on the root and get the output stack\\n        self.dfs(root, output)\\n        \\n        # return the output of all the nodes.\\n        return output\\n    \\n    def dfs(self, root, output):\\n        \\n        # If root is none return \\n        if root is None:\\n            return\\n        \\n        # for preorder we first add the root val\\n        output.append(root.val)\\n        \\n        # Then add all the children to the output\\n        for child in root.children:\\n            self.dfs(child, output)\\n       \\n\\t   \\n\\t   \\n# Iterative Solution- Runtime: 40 ms, faster than 91.86% \\n\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n        \\n        # Till there is element in stack the loop runs.\\n        while stack:\\n            \\n            #pop the last element from the stack and store it into temp.\\n            temp = stack.pop()\\n            \\n            # append. the value of temp to output\\n            output.append(temp.val)\\n            \\n            #add the children of the temp into the stack in reverse order.\\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\\n            # This continues till the stack is empty.\\n            stack.extend(temp.children[::-1])\\n        \\n        #return the output\\n        return output\\n        \\n```\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        \\n        output.append(root.val)\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output)\\n       \\n\\t   \\n# Iterative Solution- Runtime: 12 ms, faster than 97.82%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            temp=stack.pop()\\n            if temp:\\n                output.append(temp.val)\\n                stack.append(temp.right)\\n                stack.append(temp.left)\\n        \\n        return output\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[str]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        result = []\\n        self.dfs(root, \"\", result)\\n        return result\\n\\n    def dfs(self, root, path, result):\\n        if not root.left and not root.right:\\n            result.append(path + str(root.val))\\n        \\n        if root.left:\\n            self.dfs(root.left, path + str(root.val) + \"->\" , result)\\n        if root.right:\\n            self.dfs(root.right, path + str(root.val) + \"->\", result)\\n        \\n```\n```\\n# Recursive : Runtime: 40 ms, faster than 89.79% \\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        for child in root.children:\\n            self.dfs(child, output)\\n        \\n        output.append(root.val)\\n \\n \\n # Iterative Solution: Runtime: 48 ms, faster than 62.81%\\n \\n `\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                output.append(root.val)\\n                stack += root.children\\n                \\n        return output[::-1]`\\n        \\n```\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output) \\n        output.append(root.val)\\n\\t\\t\\n\\t\\t\\n# Iterative solution: Runtime: 12 ms, faster than 98.10%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack =[root]\\n        \\n        if not root:\\n            return None\\n        \\n        # iterate only when there is elements inside the stack.\\n        while stack:\\n            \\n            # pop the element from stack and stored it into temp\\n            temp=stack.pop()\\n            \\n            #append the value of temp to output\\n            output.append(temp.val)\\n            \\n            #Now traverse through left node and add the node to stack\\n            if temp.left:\\n                stack.append(temp.left)\\n                \\n            #else traverse through right node and add to stack\\n            if temp.right:\\n                stack.append(temp.right)\\n         \\n        # After iterating through the stack,  print the result in reverse order.  \\n        return output[::-1]\\n    \\n    \\n# Example: Iteration 1 : #stack=[1] - first iteration, temp =1, \\n                #output[1]\\n                #temp.left is Null\\n                #temp.right is [2]\\n                # stack =[2]\\n\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        \\n        if not root:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)    \\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrderBottom(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, 0, output)\\n        return output[::-1]\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n             return\\n            \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level ,output):\\n        if root is None:\\n            return\\n        if len(output)< level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        for child in root.children:\\n            self.dfs(child, level+1, output)\\n      \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        \\n        for i in range(len(output)):\\n            if i % 2 !=0:\\n                output[i].reverse()\\n            else:\\n                continue\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not inorder or not preorder:\\n            return None\\n        \\n        #pattern is preorder=[root, left, right]\\n        #inorder = [left, root, right],  so find index and value using root.\\n        \\n        root = TreeNode(preorder[0])\\n        \\n        root_index= 0\\n        \\n        #iterate through inorder list and find the list index of the root.\\n        for i in range(len(inorder)):\\n            if inorder[i]== root.val:\\n                root_index = i\\n            else:\\n                continue\\n                \\n        #slice the inorder list into left and right.     \\n        left_inorder = inorder[:root_index]\\n        right_inorder = inorder[root_index+1:]\\n        \\n        #slice the preorder list into left and right.\\n        left_preorder = preorder[1:len(left_inorder)+1]\\n        right_preorder = preorder[len(left_preorder)+1:]\\n        \\n        #append by updating preorder and inorder lists\\n        root.left = self.buildTree(left_preorder, left_inorder)\\n        root.right = self.buildTree(right_preorder, right_inorder)\\n        \\n        return root\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        # PATTERN\\n        # inorder: l, root, right\\n        # postorder: l,r,root\\n        # the last element of postorder is root\\n        \\n        if not inorder or not postorder:\\n            return None\\n        \\n        root_index=0\\n        \\n        # Build the data structure based on root value\\n        root = TreeNode(postorder.pop())\\n        \\n        for i in range(len(inorder)):\\n            if inorder[i]==root.val:\\n                root_index=i\\n            else:\\n                continue\\n        \\n        left_in=inorder[:root_index]\\n        right_in = inorder[root_index+1:]\\n        \\n        root.right = self.buildTree(right_in, postorder)\\n        root.left = self.buildTree(left_in,  postorder)\\n\\n        return root\\n   \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre:\\n            return None\\n        \\n        root = TreeNode(post.pop())\\n        \\n        if len(pre) == 1:\\n            return root\\n        \\n        # Find the index of the root value from pre\\n        for i in range(len(pre)):\\n            if pre[i]==post[-1]:\\n                root_index= i\\n            else:\\n                continue\\n        \\n        root.right = self.constructFromPrePost(pre[root_index:], post) \\n        root.left = self.constructFromPrePost(pre[1:root_index],post) \\n        \\n        return root \\n   \\n# Explanation:   root=1, root_index = 0, root.right=(pre(1,2,3,4,5,6,7))  [1, 2,3,4,5,6,7]                           vii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 3, root_index= 4, root.right=(pre(3,6,7))  [3,4,5,6,7]                               v\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root=7, root_index=2, root.right= pre(7), now len(pre) == 1, return 7 ---[7]        i\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =6, root_index=1, root.left= pre(6), now len(pre)==1, return 6 -----[6,7]      ii \\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =2, root_index= 1, root.right= pre(2,4,5)   [2,3,4,5,6,7]                               vi \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 5, root_index=2, root.right= pre(5)  now len(pre)==1, return 5 ----[5,6,7]   iii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 4, root_index=1, root.right= pre(4)  now len(pre)==1, return 4-----[4,5,6,7]  iv\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32178,
                "title": "clean-python-solution",
                "content": "Use recursion. Pass down two parameters: `lessThan` (which means that all nodes in the the current subtree must be smaller than this value) and `largerThan` (all must be larger than it). Compare root of the current subtree with these two values. Then, recursively check the left and right subtree of the current one. Take care of the values passed down.\\n\\n\\n    class Solution(object):\\n        def isValidBST(self, root, lessThan = float('inf'), largerThan = float('-inf')):\\n            if not root:\\n                return True\\n            if root.val <= largerThan or root.val >= lessThan:\\n                return False\\n            return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and \\\\\\n                   self.isValidBST(root.right, lessThan, max(root.val, largerThan))",
                "solutionTags": [],
                "code": "Use recursion. Pass down two parameters: `lessThan` (which means that all nodes in the the current subtree must be smaller than this value) and `largerThan` (all must be larger than it). Compare root of the current subtree with these two values. Then, recursively check the left and right subtree of the current one. Take care of the values passed down.\\n\\n\\n    class Solution(object):\\n        def isValidBST(self, root, lessThan = float('inf'), largerThan = float('-inf')):\\n            if not root:\\n                return True\\n            if root.val <= largerThan or root.val >= lessThan:\\n                return False\\n            return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and \\\\\\n                   self.isValidBST(root.right, lessThan, max(root.val, largerThan))",
                "codeTag": "Java"
            },
            {
                "id": 32138,
                "title": "another-passed-java-solution",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return helper(root, null, null);\\n        }\\n        \\n        boolean helper(TreeNode root, Integer min, Integer max) {\\n            if (root == null)\\n                return true;\\n            \\n            if ((min != null && root.val <= min) || (max != null && root.val >= max))\\n                return false;\\n            \\n            return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n        }\\n    }\\n\\nMy original solution was calling helper(root, Integer.MIN_VALUE, Integer.MAX_VALUE), but it failed when a tree node is either Integer.MIN_VALUE or Integer.MAX_VALUE. The correct solution is don't check with them.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return helper(root, null, null);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 974511,
                "title": "c-the-simplest-o-n-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\nprivate:\\n    vector<int> tree;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\nprivate:\\n    vector<int> tree;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32153,
                "title": "python-version-based-on-inorder-traversal",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @return a boolean\\n        # 7:38\\n        def isValidBST(self, root):\\n            output = []\\n            self.inOrder(root, output)\\n            \\n            for i in range(1, len(output)):\\n                if output[i-1] >= output[i]:\\n                    return False\\n    \\n            return True\\n    \\n        def inOrder(self, root, output):\\n            if root is None:\\n                return\\n            \\n            self.inOrder(root.left, output)\\n            output.append(root.val)\\n            self.inOrder(root.right, output)",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @return a boolean\\n        # 7:38\\n        def isValidBST(self, root):\\n            output = []\\n            self.inOrder(root, output)\\n            \\n            for i in range(1, len(output)):\\n                if output[i-1] >= output[i]:\\n                    return False\\n    \\n            return True\\n    \\n        def inOrder(self, root, output):\\n            if root is None:\\n                return\\n            \\n            self.inOrder(root.left, output)\\n            output.append(root.val)\\n            self.inOrder(root.right, output)",
                "codeTag": "Java"
            },
            {
                "id": 234410,
                "title": "c-recursive-and-iterative",
                "content": "For the recursive solution, we set a lower bound and a upper bound for the tree. When we recurse on the left subtree, the upper bound becomes the value of its root. When we recurse on the right subtree, the lower bound becomes the value of its root.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return valid(root, LONG_MIN, LONG_MAX);\\n    }\\nprivate:\\n    bool valid(TreeNode* root, long min, long max) {\\n        if (!root) {\\n            return true;\\n        }\\n        if (root -> val <= min || root -> val >= max) {\\n            return false;\\n        }\\n        return valid(root -> left, min, root -> val) && valid(root -> right, root -> val, max);\\n    }\\n};\\n```\\n\\nNote we use `LONG_MIN` and `LONG_MAX` to handle edge cases like `[INT_MAX]`.\\n\\nThe iterative idea is to apply iterative inorder traversal to the tree and check whether the current value is always larger than the previous one.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long pre = LONG_MIN;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            if (root -> val <= pre) {\\n                return false;\\n            }\\n            pre = root -> val;\\n            root = root -> right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return valid(root, LONG_MIN, LONG_MAX);\\n    }\\nprivate:\\n    bool valid(TreeNode* root, long min, long max) {\\n        if (!root) {\\n            return true;\\n        }\\n        if (root -> val <= min || root -> val >= max) {\\n            return false;\\n        }\\n        return valid(root -> left, min, root -> val) && valid(root -> right, root -> val, max);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long pre = LONG_MIN;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            if (root -> val <= pre) {\\n                return false;\\n            }\\n            pre = root -> val;\\n            root = root -> right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974147,
                "title": "python-js-java-go-c-o-n-by-dfs-and-rule-w-hint",
                "content": "O( n ) sol. by divide-and-conquer.\\n\\n[\\u672C\\u984C\\u5C0D\\u61C9\\u7684\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/650988e9fd897800019a383f)\\n\\n---\\n\\n**Hint**:\\n\\nThink of BST rule:\\n**Left sub-tree** nodes\\' value **< current** node value\\n**Right sub-tree** nodes\\' value **> current** node value\\n\\n---\\n\\n**Algorithm**:\\n\\nStep_#1:\\nSet upper bound as maximum integer, and lower bound as minimum integer in run-time environment.\\n\\nStep_#2:\\nStart DFS traversal from root node, and check whether each level follow BST rules or not.\\nUpdate lower bound and upper bound before going down to next level.\\n\\nStep_#3:\\nOnce we find the violation, reject and early return False.\\nOtherwise, accept and return True if all tree nodes follow BST rule.\\n\\n---\\n\\nPython\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        \\n        # Use maximal system integer to represent infinity\\n        INF = sys.maxsize\\n        \\n        def helper(node, lower, upper):\\n            \\n            if not node:\\n\\t\\t\\t\\t# empty node or empty tree\\n                return True\\n            \\n            if lower < node.val < upper:\\n\\t\\t\\t\\t# check if all tree nodes follow BST rule\\n                return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\\n            \\n            else:\\n\\t\\t\\t\\t# early reject when we find violation\\n                return False\\n            \\n        # ----------------------------------\\n        \\n        return helper( node=root, lower=-INF, upper=INF )\\n```\\n\\n---\\n\\nJava\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        \\n        return checker( -INF, INF, root);\\n    }\\n    \\n    private boolean checker( long lower, long upper, TreeNode node ){\\n        \\n        if( node == null ){\\n            return true;\\n        }\\n        \\n        if( (lower < node.val) && ( node.val < upper ) ){\\n            return checker(lower, node.val, node.left) && checker(node.val, upper, node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private long INF = Long.MAX_VALUE;\\n\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nC++\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidBST(TreeNode* root) {\\n\\n\\t\\t\\treturn validate(root, std::numeric_limits<long>::min(), std::numeric_limits<long>::max() );\\n\\t\\t}\\n\\n\\tprivate:\\n\\t\\tbool validate(TreeNode* node, long lower, long upper){\\n\\n\\t\\t\\tif( node == NULL ){\\n\\n\\t\\t\\t\\t// empty node or empty tree is valid always\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif( (lower < node->val) && (node->val < upper) ){\\n\\n\\t\\t\\t\\t// check if all tree nodes follow BST rule\\n\\t\\t\\t\\treturn validate(node->left, lower, node->val) && validate(node->right, node->val, upper);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// early reject when we find violation\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n\\t};\\n```\\n\\n</details>\\n\\n,or\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        prev = NULL;\\n        \\n        return validate(root );\\n    }\\n    \\nprivate:\\n    TreeNode *prev;\\n    bool validate(TreeNode* node){\\n        \\n        if( node == NULL ){\\n            \\n            // empty node or empty tree is valid always\\n            return true;\\n        }\\n        \\n        \\n        if( !validate(node->left ) ){\\n            return false;\\n        }\\n        \\n        if( prev != NULL && (node->val <= prev -> val) ){\\n            return false;\\n        }\\n        prev = node;\\n        \\n        return validate(node->right);\\n        \\n    }\\n};\\n```\\n\\n</details>\\n\\n\\n\\n---\\nGo\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\nfunc isValidBST(root *TreeNode) bool {\\n    \\n    return validate( root, math.MinInt, math.MaxInt)\\n}\\n\\nfunc validate(node *TreeNode, lower int, upper int)bool{\\n    \\n    if node == nil{\\n        \\n        //empty node or empty tree is always valid\\n        return true\\n    }\\n    \\n    if( (lower < node.Val) && (node.Val < upper) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.Left, lower, node.Val ) && validate( node.Right, node.Val, upper )\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false\\n    }\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\nJavascript\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\nvar isValidBST = function(root) {\\n    \\n    return validate(root, -Infinity, Infinity);\\n};\\n\\n\\nvar validate = function(node, lower,upper){\\n    \\n    if ( node == null ){\\n        \\n        // empty node or empty tree\\n        return true;\\n    }\\n    \\n    if( (lower < node.val) && ( node.val < upper ) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.left, lower, node.val) && validate( node.right, node.val, upper);\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false;\\n    }\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\nShare anotehr implementation with well-ordered property of BST\\'s inorder traversal\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def checker(node):\\n            \\n            if not node:\\n\\t\\t\\t\\t## Base case\\n                # empty node or empty tree\\n                yield True\\n                \\n            else:\\n                ## General cases:\\n\\n                yield from checker(node.left)\\n\\n                if checker.prev and (checker.prev.val >= node.val):\\n                    # previous node should be smaller then current node\\n                    # find violation\\n                    yield False\\n\\n                checker.prev = node\\n\\n                yield from checker(node.right)\\n                \\n            return\\n        # ---------------------------------------\\n        \\n        # use the property that inorder traversla of BST outputs sorted ascending sequence naturally\\n        checker.prev = None\\n        return all( checker(root) )\\n```\\n\\n---\\n\\nRelative leetcode challenge\\n\\n[Leetcode #99 Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)\\n\\n[Leetcode #700 Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        \\n        # Use maximal system integer to represent infinity\\n        INF = sys.maxsize\\n        \\n        def helper(node, lower, upper):\\n            \\n            if not node:\\n\\t\\t\\t\\t# empty node or empty tree\\n                return True\\n            \\n            if lower < node.val < upper:\\n\\t\\t\\t\\t# check if all tree nodes follow BST rule\\n                return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\\n            \\n            else:\\n\\t\\t\\t\\t# early reject when we find violation\\n                return False\\n            \\n        # ----------------------------------\\n        \\n        return helper( node=root, lower=-INF, upper=INF )\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        \\n        return checker( -INF, INF, root);\\n    }\\n    \\n    private boolean checker( long lower, long upper, TreeNode node ){\\n        \\n        if( node == null ){\\n            return true;\\n        }\\n        \\n        if( (lower < node.val) && ( node.val < upper ) ){\\n            return checker(lower, node.val, node.left) && checker(node.val, upper, node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private long INF = Long.MAX_VALUE;\\n\\n}\\n```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidBST(TreeNode* root) {\\n\\n\\t\\t\\treturn validate(root, std::numeric_limits<long>::min(), std::numeric_limits<long>::max() );\\n\\t\\t}\\n\\n\\tprivate:\\n\\t\\tbool validate(TreeNode* node, long lower, long upper){\\n\\n\\t\\t\\tif( node == NULL ){\\n\\n\\t\\t\\t\\t// empty node or empty tree is valid always\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif( (lower < node->val) && (node->val < upper) ){\\n\\n\\t\\t\\t\\t// check if all tree nodes follow BST rule\\n\\t\\t\\t\\treturn validate(node->left, lower, node->val) && validate(node->right, node->val, upper);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// early reject when we find violation\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n\\t};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        prev = NULL;\\n        \\n        return validate(root );\\n    }\\n    \\nprivate:\\n    TreeNode *prev;\\n    bool validate(TreeNode* node){\\n        \\n        if( node == NULL ){\\n            \\n            // empty node or empty tree is valid always\\n            return true;\\n        }\\n        \\n        \\n        if( !validate(node->left ) ){\\n            return false;\\n        }\\n        \\n        if( prev != NULL && (node->val <= prev -> val) ){\\n            return false;\\n        }\\n        prev = node;\\n        \\n        return validate(node->right);\\n        \\n    }\\n};\\n```\n```\\nfunc isValidBST(root *TreeNode) bool {\\n    \\n    return validate( root, math.MinInt, math.MaxInt)\\n}\\n\\nfunc validate(node *TreeNode, lower int, upper int)bool{\\n    \\n    if node == nil{\\n        \\n        //empty node or empty tree is always valid\\n        return true\\n    }\\n    \\n    if( (lower < node.Val) && (node.Val < upper) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.Left, lower, node.Val ) && validate( node.Right, node.Val, upper )\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false\\n    }\\n    \\n}\\n```\n```\\nvar isValidBST = function(root) {\\n    \\n    return validate(root, -Infinity, Infinity);\\n};\\n\\n\\nvar validate = function(node, lower,upper){\\n    \\n    if ( node == null ){\\n        \\n        // empty node or empty tree\\n        return true;\\n    }\\n    \\n    if( (lower < node.val) && ( node.val < upper ) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.left, lower, node.val) && validate( node.right, node.val, upper);\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false;\\n    }\\n    \\n}\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def checker(node):\\n            \\n            if not node:\\n\\t\\t\\t\\t## Base case\\n                # empty node or empty tree\\n                yield True\\n                \\n            else:\\n                ## General cases:\\n\\n                yield from checker(node.left)\\n\\n                if checker.prev and (checker.prev.val >= node.val):\\n                    # previous node should be smaller then current node\\n                    # find violation\\n                    yield False\\n\\n                checker.prev = node\\n\\n                yield from checker(node.right)\\n                \\n            return\\n        # ---------------------------------------\\n        \\n        # use the property that inorder traversla of BST outputs sorted ascending sequence naturally\\n        checker.prev = None\\n        return all( checker(root) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32101,
                "title": "my-java-inorder-iteration-solution",
                "content": "the idea is to do a inorder Traversal and keep the value of the\\n\\n    public boolean isValidBST (TreeNode root){\\n    \\t\\t   Stack<TreeNode> stack = new Stack<TreeNode> ();\\n    \\t\\t   TreeNode cur = root ;\\n    \\t\\t   TreeNode pre = null ;\\t\\t   \\n    \\t\\t   while (!stack.isEmpty() || cur != null) {\\t\\t\\t   \\n    \\t\\t\\t   if (cur != null) {\\n    \\t\\t\\t\\t   stack.push(cur);\\n    \\t\\t\\t\\t   cur = cur.left ;\\n    \\t\\t\\t   } else {\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   TreeNode p = stack.pop() ;\\n    \\t\\t\\t\\t   if (pre != null && p.val <= pre.val) {\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t\\t   return false ;\\n    \\t\\t\\t\\t   }\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   pre = p ;\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   cur = p.right ;\\n    \\t\\t\\t   }\\n    \\t\\t   }\\n    \\t\\t   return true ; \\n    \\t   }",
                "solutionTags": [],
                "code": "the idea is to do a inorder Traversal and keep the value of the\\n\\n    public boolean isValidBST (TreeNode root){\\n    \\t\\t   Stack<TreeNode> stack = new Stack<TreeNode> ();\\n    \\t\\t   TreeNode cur = root ;\\n    \\t\\t   TreeNode pre = null ;\\t\\t   \\n    \\t\\t   while (!stack.isEmpty() || cur != null) {\\t\\t\\t   \\n    \\t\\t\\t   if (cur != null) {\\n    \\t\\t\\t\\t   stack.push(cur);\\n    \\t\\t\\t\\t   cur = cur.left ;\\n    \\t\\t\\t   } else {\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   TreeNode p = stack.pop() ;\\n    \\t\\t\\t\\t   if (pre != null && p.val <= pre.val) {\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t\\t   return false ;\\n    \\t\\t\\t\\t   }\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   pre = p ;\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   cur = p.right ;\\n    \\t\\t\\t   }\\n    \\t\\t   }\\n    \\t\\t   return true ; \\n    \\t   }",
                "codeTag": "Unknown"
            },
            {
                "id": 146601,
                "title": "python3-100-using-easy-recursion",
                "content": "If you just want a solution scroll down, otherwise here\\'s an explanation.\\n\\nLet\\'s start with a simple definition of the nodes of a binary search tree!\\nA parent node is greater than its left child but smaller than its right.\\n```\\n    2\\n   / \\\\\\n  1   3 // valid tree!\\n```\\n\\n```\\n    5\\n   / \\\\\\n  1   4  // not valid here!\\n     / \\\\\\n    3   6\\n```\\n\\nOne solution would be to check every parent as we work down the tree but it creates a lot of complicated logic. So why don\\'t we check every child on the way up! All we have to do is keep track of the mininum and maximum valid values on the way down.\\n\\nTo prevent some extra checks let\\'s start with -infinity and infinity.\\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n```\\n\\nSo let\\'s walk it out!\\n```\\n    2 \\n   / \\\\\\n  1   3 \\n\\t\\n1 // -inf < 1 < 2, so it\\'s still valid\\n3 //  2 < 3 < inf, so it\\'s still a valid tree\\n2 // -inf < 2 < inf, so it\\'s a valid tree!\\n```\\n\\nAnd what about an invalid tree?\\n\\n```\\n    5 \\n   / \\\\\\n  1   4 \\n\\t\\n1 // -inf < 1 < 5, so it\\'s still a valid tree\\n4 // 5 > 4 < inf, this tree is not a valid binary tree!\\t\\n```\\n\\nSo here\\'s one way we could implement this logic!\\n\\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n\\t\\ndef check_bst(self, node, left, right):\\n    if not node:\\n        return True\\n\\n    if not left < node.val < right:\\n        return False\\n\\n    return (check_bst(node.left, left, node.val)\\n            and check_bst(node.right, node.val, right))\\n```",
                "solutionTags": [],
                "code": "```\\n    2\\n   / \\\\\\n  1   3 // valid tree!\\n```\n```\\n    5\\n   / \\\\\\n  1   4  // not valid here!\\n     / \\\\\\n    3   6\\n```\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n```\n```\\n    2 \\n   / \\\\\\n  1   3 \\n\\t\\n1 // -inf < 1 < 2, so it\\'s still valid\\n3 //  2 < 3 < inf, so it\\'s still a valid tree\\n2 // -inf < 2 < inf, so it\\'s a valid tree!\\n```\n```\\n    5 \\n   / \\\\\\n  1   4 \\n\\t\\n1 // -inf < 1 < 5, so it\\'s still a valid tree\\n4 // 5 > 4 < inf, this tree is not a valid binary tree!\\t\\n```\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n\\t\\ndef check_bst(self, node, left, right):\\n    if not node:\\n        return True\\n\\n    if not left < node.val < right:\\n        return False\\n\\n    return (check_bst(node.left, left, node.val)\\n            and check_bst(node.right, node.val, right))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2409071,
                "title": "python-one-liner-96-6-with-detailed-explantion-recursion-simple",
                "content": "There are two steps:\\n1. set a range (at first we set it to (-infinity, infinity)\\n2. see if every node is in their own range\\n![image](https://assets.leetcode.com/users/images/864f8660-dcc9-4ae5-82a6-4edbf8190755_1660181425.0985472.png)\\nHere\\'s the one line code:\\n```\\nclass Solution:\\n    def isValidBST(self, node: Optional[TreeNode],low=-inf, high=inf) -> bool:\\n            return (not node) or ((low < node.val < high) and self.isValidBST(node.left, low, node.val)  and self.isValidBST(node.right, node.val, high))\\n```\\n\\nHere\\'s the code for better understand:\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def helper(node, low, high):\\n            if not node:\\n                return True\\n            if not (low < node.val < high):\\n                return False\\n            return helper(node.left, low, node.val) and helper(node.right, node.val, high)\\n        \\n        return helper(root, -inf, inf)\\n```\\n**Please UPVOTE if you LIKE!!**\\n![image](https://assets.leetcode.com/users/images/6be7315b-0f00-463e-b813-977d576b9e0b_1660180800.7504048.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, node: Optional[TreeNode],low=-inf, high=inf) -> bool:\\n            return (not node) or ((low < node.val < high) and self.isValidBST(node.left, low, node.val)  and self.isValidBST(node.right, node.val, high))\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def helper(node, low, high):\\n            if not node:\\n                return True\\n            if not (low < node.val < high):\\n                return False\\n            return helper(node.left, low, node.val) and helper(node.right, node.val, high)\\n        \\n        return helper(root, -inf, inf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32193,
                "title": "1-ms-java-solution-using-recursion",
                "content": "    public class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, null, null);\\n    }\\n    \\n    public boolean isValid(TreeNode root, Integer min, Integer max) {\\n        if(root == null) return true;\\n        if(min != null && root.val <= min) return false;\\n        if(max != null && root.val >= max) return false;\\n        \\n        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, null, null);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 258511,
                "title": "easy-java-0ms-solution",
                "content": "The trick is to do an inorder traversal of the tree and check that the value of each node visited is greater than the value of the previous node.\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    TreeNode prev = null;\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        \\n        if(isValidBST(root.left) && (prev == null || root.val > prev.val)) {\\n            prev = root;\\n            return isValidBST(root.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    TreeNode prev = null;\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        \\n        if(isValidBST(root.left) && (prev == null || root.val > prev.val)) {\\n            prev = root;\\n            return isValidBST(root.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959657,
                "title": "c-recursive-solution-passing-all-test-cases",
                "content": "### Keep in Mind\\n * Passing `NULL` to `int` will cast `NULL` to `0` in integer. \\n * So, It will give wrong result for [0, null, -1].\\n * If someone will pass `INT_MIN` as default value, then It\\'ll fail for case - [-2147483648] and vice-versa.\\n *  That\\'s why pointers are used here.\\n *  One can use **TreeNode** addresses as pointers.\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValid(root, NULL, NULL);\\n    }\\n    \\n    bool isValid(TreeNode* root, int* lower, int* upper){\\n        if(!root)\\n            return true;\\n\\n        if(upper && root -> val >= *upper)\\n            return false;\\n        if(lower && root -> val <= *lower)\\n            return false;\\n        \\n        return isValid(root -> left, lower, &(root -> val)) && isValid(root -> right, &(root -> val), upper);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValid(root, NULL, NULL);\\n    }\\n    \\n    bool isValid(TreeNode* root, int* lower, int* upper){\\n        if(!root)\\n            return true;\\n\\n        if(upper && root -> val >= *upper)\\n            return false;\\n        if(lower && root -> val <= *lower)\\n            return false;\\n        \\n        return isValid(root -> left, lower, &(root -> val)) && isValid(root -> right, &(root -> val), upper);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410354,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.***\\n**Also you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\nhttps://www.youtube.com/watch?v=geBeUvcMMwo\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529937,
                "title": "javascript-97-faster-simple-recursion",
                "content": "```\\nvar isValidBST = function(root, min=null, max=null) {\\n    if (!root) return true;\\n    if (min && root.val <= min.val) return false;\\n    if (max && root.val >= max.val) return false;\\n    return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar isValidBST = function(root, min=null, max=null) {\\n    if (!root) return true;\\n    if (min && root.val <= min.val) return false;\\n    if (max && root.val >= max.val) return false;\\n    return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1282793,
                "title": "faster-than-100-cpp-solution-don-t-repeat-my-mistake-int-min-int-max",
                "content": "You might be doing the same mistake that I did, using **INT_MAX**, **INT_MIN**.\\nMy first solution : \\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, INT_MAX, INT_MIN);\\n    }\\n    \\n    bool fun(TreeNode* root, int max, int min){\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val > min && root->val < max){\\n\\t\\t\\t//checking recursively the left and right-subtree, are they BST??\\n\\t\\t\\t// if both subtree are BST, then Parent tree is also BST\\n            return fun(root->left, root->val, min) && fun(root->right, max, root->val);\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nBut I did a silly mistake here, The constraint given is from -2^31 to 2^31-1, and INT_MAX = 2^31-1 and INT_MIN = -2^31.\\nIn this case, it will fail.\\n\\nBetter approach is, that will never fail at any constartint is using the reference for minNode, and maxNode. Actually this is the basic concept here to be used, first one is dependent on the constraint.\\nFollowing this approach, we came up to this solution:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, NULL, NULL);\\n    }\\n    \\n    bool fun(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t// Using the same above logic\\n\\t\\t//Just check if max or min-node is NULL, then follow it as true\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return fun(root->left, root, min) && fun(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, INT_MAX, INT_MIN);\\n    }\\n    \\n    bool fun(TreeNode* root, int max, int min){\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val > min && root->val < max){\\n\\t\\t\\t//checking recursively the left and right-subtree, are they BST??\\n\\t\\t\\t// if both subtree are BST, then Parent tree is also BST\\n            return fun(root->left, root->val, min) && fun(root->right, max, root->val);\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, NULL, NULL);\\n    }\\n    \\n    bool fun(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t// Using the same above logic\\n\\t\\t//Just check if max or min-node is NULL, then follow it as true\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return fun(root->left, root, min) && fun(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724888,
                "title": "java-dfs-recursion-clean-0-ms",
                "content": "### **Please Upvote** :D\\n``` java []\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValid(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (root.val >= max || root.val <= min) {\\n            return false;\\n        }\\n        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValid(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (root.val >= max || root.val <= min) {\\n            return false;\\n        }\\n        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974185,
                "title": "python-simple-dfs-explained",
                "content": "We need to check that some property holds for every node of our tree, so as usual any recursion method should work here. Let us use function `dfs(node, low, high)`, where:\\n1. `node` is node we are currently in\\n2. `low` and `high` are bounds we expect to value of this node be in.\\n\\nNow, let us go to the main algorithm:\\n1. If we have `None` node, we are happy: empty tree is BST\\n2. Next we check if `low < node.val < high` and if it is not true, we can immedietly return `False`.\\n3. Finally, we check conditions for left children: its value should be in `(low, node.val)` and for right children: `(node.val, high)`. If one of this `dfs` return False, we need to return False.\\n\\n**Complexity**: time complexity is `O(n)` to traverse every node of our tree. Space complexity is `O(h)`, where `h` is height of our tree.\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root):\\n        def dfs(node, low, high):\\n            if not node: return True\\n            if not low < node.val < high: return False\\n            return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)\\n        \\n        return dfs(root, -float(\"inf\"), float(\"inf\"))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root):\\n        def dfs(node, low, high):\\n            if not node: return True\\n            if not low < node.val < high: return False\\n            return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)\\n        \\n        return dfs(root, -float(\"inf\"), float(\"inf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32117,
                "title": "my-javascript-solution",
                "content": "This is a very classic BST problem, we just need to scan every single node in the tree and see if the node's value matches the BST rules, that is all the values in node's left subtree are less than the value in node, and all the values in node's right subtree are greater than the value in node, if we found a node that doesn't satisfy the rules, simply return false from the recursion.\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isValidBST = function(root) {\\n    if (!root) {\\n        return true; // Sanity check for passing test case '[]'\\n    }\\n\\n    function helper(root, min, max) {\\n        if (!root) {\\n            return true; // We hit the end of the path\\n        }\\n        \\n        if ((min !== null && root.val <= min) || (max !== null && root.val >= max)) {\\n            return false; // current node's val doesn't satisfy the BST rules\\n        }\\n        \\n        // Continue to scan left and right\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n    \\n    return helper(root, null, null);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isValidBST = function(root) {\\n    if (!root) {\\n        return true; // Sanity check for passing test case '[]'\\n    }\\n\\n    function helper(root, min, max) {\\n        if (!root) {\\n            return true; // We hit the end of the path\\n        }\\n        \\n        if ((min !== null && root.val <= min) || (max !== null && root.val >= max)) {\\n            return false; // current node's val doesn't satisfy the BST rules\\n        }\\n        \\n        // Continue to scan left and right\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n    \\n    return helper(root, null, null);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32347,
                "title": "c-easy-to-read-in-order-traversal-solution",
                "content": "Ensure that every next node of in-order traversal is larger than previous one. Using boolean flag to start with the left most node.\\n\\n    class Solution {\\n        bool first = true;\\n        int prev = 0;\\n    public:\\n        bool isValidBST(TreeNode *root) {\\n            if(root == NULL) return true;\\n            \\n            return (\\n                isValidBST(root->left)\\n                && check(root->val)\\n                && isValidBST(root->right));\\n        }\\n        \\n        bool check(int val)\\n        {\\n            if(first)\\n            {\\n                first = false;\\n                prev = val;\\n                return true;\\n            }\\n            \\n            if(prev >= val) return false;\\n            \\n            prev = val;\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        bool first = true;\\n        int prev = 0;\\n    public:\\n        bool isValidBST(TreeNode *root) {\\n            if(root == NULL) return true;\\n            \\n            return (\\n                isValidBST(root->left)\\n                && check(root->val)\\n                && isValidBST(root->right));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3053617,
                "title": "c-inorder-ascending-order",
                "content": "# Intuition\\nThe inorder traversal of BST is in ascending order.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStore the elements of inorder traversal of BST in an array. If it doesn\\'t follow strictly increasing order, return false.\\nReturn true otherwise. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> numbers;//declare it globally, it contains the inorder traversal of BST\\n\\nvoid inorderpush(TreeNode* root){\\n    if(root==nullptr){\\n        return;\\n    }\\n    inorderpush(root->left);\\n    numbers.push_back(root->val);//inserts the element in array\\n    inorderpush(root->right);\\n}\\n\\nbool isValidBST(TreeNode* root) {\\n    inorderpush(root);\\n\\n    for(int i=0;i<numbers.size()-1;i++){\\n        if(numbers[i+1]<=numbers[i]){\\n            return false;//if array is not strictly increasing\\n        }\\n    }\\n    return true; //if array is strictly increasing   \\n    }\\n};\\n```\\n**Please upvote if it helps. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> numbers;//declare it globally, it contains the inorder traversal of BST\\n\\nvoid inorderpush(TreeNode* root){\\n    if(root==nullptr){\\n        return;\\n    }\\n    inorderpush(root->left);\\n    numbers.push_back(root->val);//inserts the element in array\\n    inorderpush(root->right);\\n}\\n\\nbool isValidBST(TreeNode* root) {\\n    inorderpush(root);\\n\\n    for(int i=0;i<numbers.size()-1;i++){\\n        if(numbers[i+1]<=numbers[i]){\\n            return false;//if array is not strictly increasing\\n        }\\n    }\\n    return true; //if array is strictly increasing   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642757,
                "title": "2-solutions-easy-to-understand-simple-recursive-iterative-python-solution",
                "content": "```\\n    def iterative(self, root):\\n        if not root: return True\\n        stack = [(root, -float(\\'inf\\'), float(\\'inf\\'))]\\n        while len(stack):\\n            node, left, right = stack.pop()\\n            if node.val <= left or node.val >= right: return False\\n            if node.left: stack.append((node.left, left, node.val))\\n            if node.right: stack.append((node.right, node.val, right))\\n        return True\\n        \\n        \\n        \\n        \\n    def recursive(self, root): \\n        def rec(node, left, right):\\n            if node:\\n                if node.val <= left or node.val >= right: return False\\n                return rec(node.left, left, node.val) and rec(node.right, node.val, right)\\n            return True\\n        return rec(root, -float(\\'inf\\'), float(\\'inf\\') )\\n        \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def iterative(self, root):\\n        if not root: return True\\n        stack = [(root, -float(\\'inf\\'), float(\\'inf\\'))]\\n        while len(stack):\\n            node, left, right = stack.pop()\\n            if node.val <= left or node.val >= right: return False\\n            if node.left: stack.append((node.left, left, node.val))\\n            if node.right: stack.append((node.right, node.val, right))\\n        return True\\n        \\n        \\n        \\n        \\n    def recursive(self, root): \\n        def rec(node, left, right):\\n            if node:\\n                if node.val <= left or node.val >= right: return False\\n                return rec(node.left, left, node.val) and rec(node.right, node.val, right)\\n            return True\\n        return rec(root, -float(\\'inf\\'), float(\\'inf\\') )\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1278481,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isBST(TreeNode root,long min,long max)\\n    {\\n        if(root == null)\\n            return true;\\n        \\n        //System.out.println(root.val + \" \"+min + \" \"+max);\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        \\n        boolean left = isBST(root.left,min,root.val);\\n        boolean right = isBST(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isBST(TreeNode root,long min,long max)\\n    {\\n        if(root == null)\\n            return true;\\n        \\n        //System.out.println(root.val + \" \"+min + \" \"+max);\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        \\n        boolean left = isBST(root.left,min,root.val);\\n        boolean right = isBST(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114459,
                "title": "3-python-solutions-clamping-window-in-order-traversal",
                "content": "*Solution 1:\\n\\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.isValidNode(root,float('-inf'), float('inf'))\\n    \\n    def isValidNode(self, root, l, r):\\n        if not root:\\n            return True\\n        return l<root.val<r and self.isValidNode(root.left, l, root.val) and self.isValidNode(root.right, root.val, r)\\n```\\n\\n\\n\\n\\n*Solution 2:\\n\\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        self.inorderT(root, order)\\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n    \\n    def inorderT(self, root, order):\\n        if root is None:\\n            return\\n        self.inorderT(root.left, order)\\n        order.append(root.val)\\n        self.inorderT(root.right, order)\\n```\\n\\n\\n\\n*Solution 3:\\n\\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        stack = []\\n        cur = root\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            cur = stack.pop()\\n            order.append(cur.val)\\n            cur = cur.right\\n        print(order)\\n        \\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.isValidNode(root,float('-inf'), float('inf'))\\n    \\n    def isValidNode(self, root, l, r):\\n        if not root:\\n            return True\\n        return l<root.val<r and self.isValidNode(root.left, l, root.val) and self.isValidNode(root.right, root.val, r)\\n```\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        self.inorderT(root, order)\\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n    \\n    def inorderT(self, root, order):\\n        if root is None:\\n            return\\n        self.inorderT(root.left, order)\\n        order.append(root.val)\\n        self.inorderT(root.right, order)\\n```\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        stack = []\\n        cur = root\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            cur = stack.pop()\\n            order.append(cur.val)\\n            cur = cur.right\\n        print(order)\\n        \\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440997,
                "title": "easy-to-understand-concise-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621513,
                "title": "javascript-intuitive-solution-using-inorder-traversal",
                "content": "```javascript\\nvar isValidBST = function(root) {\\n    \\n    function inOrder(node) {\\n        if(!node) return [];\\n        return [...inOrder(node.left), node.val, ...inOrder(node.right)]\\n    }\\n    \\n    const sortedArr = inOrder(root);\\n    \\n    for(let i = 0; i < sortedArr.length; i++) {\\n        if(sortedArr[i+1] <= sortedArr[i]) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isValidBST = function(root) {\\n    \\n    function inOrder(node) {\\n        if(!node) return [];\\n        return [...inOrder(node.left), node.val, ...inOrder(node.right)]\\n    }\\n    \\n    const sortedArr = inOrder(root);\\n    \\n    for(let i = 0; i < sortedArr.length; i++) {\\n        if(sortedArr[i+1] <= sortedArr[i]) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2409583,
                "title": "python-easily-understood-faster-than-96-recursion",
                "content": "Method: `recursion`\\n```\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(root, lower, upper):\\n\\t\\tif not root:\\n\\t\\t\\treturn True\\n\\t\\tif lower >= root.val or upper <= root.val:\\n\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\treturn check_validate(root.left, lower, root.val) and check_validate(\\n\\t\\t\\t\\troot.right, root.val, upper\\n\\t\\t\\t)\\n\\n\\treturn check_validate(root, -math.inf, math.inf)\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n<br/>\\nUsing `in-order`, much more easy-understanding\\n```\\nlast = -math.inf\\nended = False\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(cur):\\n\\t\\tif self.ended:\\n\\t\\t\\treturn \\n\\t\\tif cur.left:\\n\\t\\t\\tcheck_validate(cur.left)\\n\\n\\t\\tif not(cur.val > self.last):\\n\\t\\t\\tself.ended = True\\n\\t\\t\\treturn\\n\\n\\t\\tself.last = cur.val\\n\\t\\tif cur.right:\\n\\t\\t\\tcheck_validate(cur.right)\\n\\tcheck_validate(root)\\n\\treturn not self.ended\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n<br/>\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(root, lower, upper):\\n\\t\\tif not root:\\n\\t\\t\\treturn True\\n\\t\\tif lower >= root.val or upper <= root.val:\\n\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\treturn check_validate(root.left, lower, root.val) and check_validate(\\n\\t\\t\\t\\troot.right, root.val, upper\\n\\t\\t\\t)\\n\\n\\treturn check_validate(root, -math.inf, math.inf)\\n```\n```\\nlast = -math.inf\\nended = False\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(cur):\\n\\t\\tif self.ended:\\n\\t\\t\\treturn \\n\\t\\tif cur.left:\\n\\t\\t\\tcheck_validate(cur.left)\\n\\n\\t\\tif not(cur.val > self.last):\\n\\t\\t\\tself.ended = True\\n\\t\\t\\treturn\\n\\n\\t\\tself.last = cur.val\\n\\t\\tif cur.right:\\n\\t\\t\\tcheck_validate(cur.right)\\n\\tcheck_validate(root)\\n\\treturn not self.ended\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1047111,
                "title": "simple-js-dfs",
                "content": "```\\nvar isValidBST = function(root, min = -Infinity, max = Infinity) {\\n    if(root === null)\\n        return true;\\n    if(root.val <= min || root.val >= max)\\n        return false;\\n    return isValidBST(root.right, root.val, max) && isValidBST(root.left, min, root.val)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidBST = function(root, min = -Infinity, max = Infinity) {\\n    if(root === null)\\n        return true;\\n    if(root.val <= min || root.val >= max)\\n        return false;\\n    return isValidBST(root.right, root.val, max) && isValidBST(root.left, min, root.val)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970452,
                "title": "c-dfs-recursion-time-o-n-space-o-n",
                "content": "**DFS Recusive Approach**\\nThe reason why we update min and max at every step is because:\\n1. For every left node, the max value it can have it less than its parent\\'s and the min value it can have is the left most node for that particular subtree.\\n2. For every right node, the max value it can have it less than the right most node of that particular subtree  and the min value it can have is the root value.\\n\\nTime Complexity: O (n)\\nSpace Complexity: O (n) (For the recursion Stack)\\n```\\nclass Solution {\\npublic:\\n    bool isValidBSTHelper (TreeNode* currentNode, TreeNode* min, TreeNode* max) {\\n        if (currentNode==NULL) return true;               \\n        if (min && currentNode->val <= min->val) return false;\\n        if (max && currentNode->val >= max->val) return false;\\n\\n        return isValidBSTHelper (currentNode->left, min, currentNode) && isValidBSTHelper (currentNode->right, currentNode, max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTHelper (root, NULL, NULL);\\n    }\\n};\\n```\\nThis is a [nice intuitive solution](https://leetcode.com/problems/validate-binary-search-tree/discuss/990894/C%2B%2B-faster-than-90.55-of-C%2B%2B-and-less-than-87.48-of-C%2B%2B)\\n\\n**Iterative Inorder Stack Solution**\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack <TreeNode*> s;        \\n        TreeNode* pre=NULL;\\n        \\n        while (root || !s.empty()) {\\n            while (root) {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(), s.pop();\\n            \\n            if (pre!=NULL && root->val<=pre->val) return false;\\n            pre=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\\nVery nice article https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBSTHelper (TreeNode* currentNode, TreeNode* min, TreeNode* max) {\\n        if (currentNode==NULL) return true;               \\n        if (min && currentNode->val <= min->val) return false;\\n        if (max && currentNode->val >= max->val) return false;\\n\\n        return isValidBSTHelper (currentNode->left, min, currentNode) && isValidBSTHelper (currentNode->right, currentNode, max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTHelper (root, NULL, NULL);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack <TreeNode*> s;        \\n        TreeNode* pre=NULL;\\n        \\n        while (root || !s.empty()) {\\n            while (root) {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(), s.pop();\\n            \\n            if (pre!=NULL && root->val<=pre->val) return false;\\n            pre=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574931,
                "title": "beats-100-only-3-lines-code-diagram-image-best-explaination-c-python-java",
                "content": "# Diagram Data Flow\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![code2flow_4fd67K (1).png](https://assets.leetcode.com/users/images/c309b924-df01-4309-a316-8c0e521925f5_1685354802.071912.png)\\n\\n# Approach\\n**Before we start properties to verify BST are:**\\n- Top root node should have range -infinity to +infinity\\n- When we move to left of BST its value must be in -infinity and\\nthe value of its parent root !\\n- When move to right its value lies in more the parent root value and + infinity .\\n- We just checked this condition recursively and DONE ! \\n- Let -infinity and + infinity to given constaints in questions.\\n- Done\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode*root,long long int lb,long long int ub)\\n    {\\n        if(root==nullptr)return true;\\n        if((root->val<ub&&root->val>lb)&&(solve(root->left,lb,root->val))&&(solve(root->right,root->val,ub))) return true;\\n        else return false;\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        long long int lb=-2147483649;\\n        long long int ub=2147483648;\\n        bool ans =solve(root,lb,ub);\\n        return ans;\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/3c08567f-214c-420d-9996-ba6ba915f4cf_1685355329.144175.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode*root,long long int lb,long long int ub)\\n    {\\n        if(root==nullptr)return true;\\n        if((root->val<ub&&root->val>lb)&&(solve(root->left,lb,root->val))&&(solve(root->right,root->val,ub))) return true;\\n        else return false;\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        long long int lb=-2147483649;\\n        long long int ub=2147483648;\\n        bool ans =solve(root,lb,ub);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206020,
                "title": "c-solution-using-long-max-and-long-min",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidBSTHelper(TreeNode* root, long min, long max) {\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}   \\n\\t\\t\\tif(root->val > min && root->val < max) {\\n\\t\\t\\t\\treturn isValidBSTHelper(root->left, min, root->val) && isValidBSTHelper(root->right, root->val, max);\\n\\t\\t\\t}    \\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tbool isValidBST(TreeNode* root) {\\n\\t\\t\\treturn isValidBSTHelper(root, LONG_MIN, LONG_MAX);\\n\\t\\t} \\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isValidBSTHelper(TreeNode* root, long min, long max) {\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 32382,
                "title": "accepted-java-solution",
                "content": "import java.util.Stack;\\n\\npublic class Solution {\\n\\nStack<Integer> stack = new Stack<Integer>();\\n\\npublic void inOrder(TreeNode root){\\n\\n    if(root != null){\\n        inOrder(root.left);\\n        stack.push(root.val);\\n        inOrder(root.right);\\n    }\\n}\\npublic boolean isValidBST(TreeNode root){\\n\\n    if(root == null){\\n        return true;\\n    }\\n\\n    inOrder(root);\\n    int i = stack.pop();\\n\\n    while(!stack.isEmpty()){\\n        int j = stack.pop();\\n        if(i <= j){\\n            return false;\\n        }\\n        i = j;\\n    }\\n\\n    return true;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\nStack<Integer> stack = new Stack<Integer>();\\n\\npublic void inOrder(TreeNode root){\\n\\n    if(root != null){\\n        inOrder(root.left);\\n        stack.push(root.val);\\n        inOrder(root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32196,
                "title": "1ms-java-solution-o-n-time-and-o-1-space-using-integer-object-and-null-pointer",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBSTHelper(root, null, null);\\n        }\\n    \\n        private boolean isValidBSTHelper(TreeNode root, Integer leftBound, Integer rightBound) {\\n            // recursively pass left and right bounds from higher level to lower level\\n            if (root == null) {\\n                return true;\\n            }\\n            if (leftBound != null && root.val <= leftBound || rightBound != null && root.val >= rightBound) {\\n                return false;\\n            }\\n            return isValidBSTHelper(root.left, leftBound, root.val) && isValidBSTHelper(root.right, root.val, rightBound);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBSTHelper(root, null, null);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32378,
                "title": "python-easy-to-understand-iterative-and-recursive-solutions",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        return self.valid(root, -sys.maxsize, sys.maxsize)\\n    \\n    def valid(self, root, l, r):\\n        if not root:\\n            return True\\n        if not (l < root.val < r):\\n            return False\\n        return self.valid(root.left, l, root.val) and self.valid(root.right, root.val, r)\\n        \\n    def isValidBST3(self, root):\\n        pre, stack = None, []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return True\\n            node = stack.pop()\\n            if pre and pre.val >= node.val:\\n                return False\\n            pre = node\\n            root = node.right\\n        \\n    def isValidBST2(self, root):\\n        ret, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            ret.append(node.val)\\n            root = node.right\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n                \\n    def isValidBST1(self, root):\\n        ret = []\\n        self.dfs(root, ret)\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n             \\n    def dfs(self, root, ret):\\n        if root:\\n            self.dfs(root.left, ret)\\n            ret.append(root.val)\\n            self.dfs(root.right, ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        return self.valid(root, -sys.maxsize, sys.maxsize)\\n    \\n    def valid(self, root, l, r):\\n        if not root:\\n            return True\\n        if not (l < root.val < r):\\n            return False\\n        return self.valid(root.left, l, root.val) and self.valid(root.right, root.val, r)\\n        \\n    def isValidBST3(self, root):\\n        pre, stack = None, []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return True\\n            node = stack.pop()\\n            if pre and pre.val >= node.val:\\n                return False\\n            pre = node\\n            root = node.right\\n        \\n    def isValidBST2(self, root):\\n        ret, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            ret.append(node.val)\\n            root = node.right\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n                \\n    def isValidBST1(self, root):\\n        ret = []\\n        self.dfs(root, ret)\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n             \\n    def dfs(self, root, ret):\\n        if root:\\n            self.dfs(root.left, ret)\\n            ret.append(root.val)\\n            self.dfs(root.right, ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704624,
                "title": "simple-python-solution-to-validate-binary-search-tree-using-recursion",
                "content": "**IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def valid(node, left, right):\\n            if not node:\\n                return True\\n            if not (node.val<right and node.val>left):\\n                return False\\n            \\n            return (valid(node.left, left, node.val) and \\n                    valid(node.right, node.val, right))\\n        \\n        return valid(root, float(-inf), float(inf))\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def valid(node, left, right):\\n            if not node:\\n                return True\\n            if not (node.val<right and node.val>left):\\n                return False\\n            \\n            return (valid(node.left, left, node.val) and \\n                    valid(node.right, node.val, right))\\n        \\n        return valid(root, float(-inf), float(inf))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409238,
                "title": "java-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    private boolean flag=true;\\n    TreeNode prev=null;\\n    public boolean isValidBST(TreeNode root) {\\n        inorder(root);\\n        return flag;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(prev!=null && root.val<=prev.val){\\n            flag=false;\\n            return;\\n        }\\n        prev=root;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean flag=true;\\n    TreeNode prev=null;\\n    public boolean isValidBST(TreeNode root) {\\n        inorder(root);\\n        return flag;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(prev!=null && root.val<=prev.val){\\n            flag=false;\\n            return;\\n        }\\n        prev=root;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504455,
                "title": "easy-0-ms-100-fully-explained-java-c-python-js-c-python3-dfs",
                "content": "# **Java Solution:**\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree.\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);   \\n    } \\n    public boolean isValidBST(TreeNode root, double minimum, double maximum){\\n        // Base case: root is null...\\n        if(root == null) return true;\\n        // If the value of root is less or equal to minimum...\\n        // Or If the value of root is greater or equal to maximum...\\n        if(root.val <= minimum || root.val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // Base case...\\n        if(root == NULL) return true;\\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool check(TreeNode* root, long minimum, long maximum){\\n        // If root is NULl...\\n        if(root == NULL) return true;\\n        // If the value of root is less or equal to minimum \\n        // Or If the value of root is greater or equal to maximum\\n        if(root->val <= minimum || root->val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def isValidBST(self, root, maximum = float(\\'-inf\\'), minimum = float(\\'inf\\')):\\n        # Base case: root is null...\\n        if not root: return True\\n        # If the value of root is less thsn minimum Or greater than maximum...\\n        if not maximum < root.val < minimum: return False\\n        # Recursively call the function for the left and right subtree...\\n        return self.isValidBST(root.left, maximum, root.val) and self.isValidBST(root.right, root.val, minimum)\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar isValidBST = function(root, minimum, maximum) {\\n    // Base case: root is null...\\n    if(root == null) return true;\\n    // If the value of root is less or equal to minimum...\\n    // Or If the value of root is greater or equal to maximum...\\n    if(root.val <= minimum || root.val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool check(struct TreeNode* root, long minimum, long maximum){\\n    // If root is NULl...\\n    if(root == NULL) return true;\\n    // If the value of root is less or equal to minimum \\n    // Or If the value of root is greater or equal to maximum\\n    if(root->val <= minimum || root->val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n}\\nbool isValidBST(struct TreeNode* root){\\n    // Base case...\\n    if(root == NULL) return true;\\n    return check(root, LONG_MIN, LONG_MAX);\\n}\\n```\\n\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree.\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);   \\n    } \\n    public boolean isValidBST(TreeNode root, double minimum, double maximum){\\n        // Base case: root is null...\\n        if(root == null) return true;\\n        // If the value of root is less or equal to minimum...\\n        // Or If the value of root is greater or equal to maximum...\\n        if(root.val <= minimum || root.val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // Base case...\\n        if(root == NULL) return true;\\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool check(TreeNode* root, long minimum, long maximum){\\n        // If root is NULl...\\n        if(root == NULL) return true;\\n        // If the value of root is less or equal to minimum \\n        // Or If the value of root is greater or equal to maximum\\n        if(root->val <= minimum || root->val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isValidBST(self, root, maximum = float(\\'-inf\\'), minimum = float(\\'inf\\')):\\n        # Base case: root is null...\\n        if not root: return True\\n        # If the value of root is less thsn minimum Or greater than maximum...\\n        if not maximum < root.val < minimum: return False\\n        # Recursively call the function for the left and right subtree...\\n        return self.isValidBST(root.left, maximum, root.val) and self.isValidBST(root.right, root.val, minimum)\\n```\n```\\nvar isValidBST = function(root, minimum, maximum) {\\n    // Base case: root is null...\\n    if(root == null) return true;\\n    // If the value of root is less or equal to minimum...\\n    // Or If the value of root is greater or equal to maximum...\\n    if(root.val <= minimum || root.val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n};\\n```\n```\\nbool check(struct TreeNode* root, long minimum, long maximum){\\n    // If root is NULl...\\n    if(root == NULL) return true;\\n    // If the value of root is less or equal to minimum \\n    // Or If the value of root is greater or equal to maximum\\n    if(root->val <= minimum || root->val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n}\\nbool isValidBST(struct TreeNode* root){\\n    // Base case...\\n    if(root == NULL) return true;\\n    return check(root, LONG_MIN, LONG_MAX);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409094,
                "title": "java-0ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\n```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValid(TreeNode node, long l, long h) {\\n        if (node == null) { // Base Case\\n            return true;\\n        }\\n\\t\\t// intially head can be anything between -inf to +inf\\n\\t\\t//after head left node should be l to previous head node value and right node should be head node value to h\\n        return node.val > l && node.val < h && isValid(node.left, l, node.val) && isValid(node.right, node.val, h);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValid(TreeNode node, long l, long h) {\\n        if (node == null) { // Base Case\\n            return true;\\n        }\\n\\t\\t// intially head can be anything between -inf to +inf\\n\\t\\t//after head left node should be l to previous head node value and right node should be head node value to h\\n        return node.val > l && node.val < h && isValid(node.left, l, node.val) && isValid(node.right, node.val, h);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783930,
                "title": "easy-to-understand-2-lines-solution-o-n-with-examples-and-explanation-javascript",
                "content": "Short and sweet:\\n\\n```ts\\nfunction isValidBST(root: TreeNode|null, min = -Infinity, max = Infinity): boolean {\\n  if(!root) return true;\\n  return !(root.val <= min || root.val >= max) && isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n};\\n```\\n\\nHow it works?\\n- If the root is `null`, then is a valid BST.\\n- If the root is NOT null, then we check for the following:\\n  - check if the current node\\'s value is within boundaries (min/max). The intial boundaries are -/+ Infinity so any value would be valid.\\n  - However, for the children we start restricting the boundaries. If we go to the left subtree, then we set the current node as the `max` boundary. Similarly, if we go the right subtree, then we set the current node\\'s value as the `min`.\\n\\nLet\\'s do some examples:\\n\\n**Example 1**:\\n\\n`[20,10,30,null,18,null,null,9,19]`\\n\\n![image](https://assets.leetcode.com/users/images/c25f0c88-4a57-40ba-8bea-06f02a0cf64c_1597065536.6765602.png)\\n\\nThe recursion call will be the following:\\n\\n- isValidBST(root: 20, min = -Infinity, max = Infinity)\\n\\t- isValidBST(root: 10, min = -Infinity, max = 20)\\n\\t\\t- isValidBST(root: 18, min = 10, max = 20)\\n\\t\\t\\t- isValidBST(root: 9, min = 10, max = 18): `false`, though `9 < 18 < 19`, 9 is lower than the `min=10`, so it will return false.\\n\\n\\n**Example 2**:\\n\\n`[20,10,30,null,18,null,null,17,19]`\\n\\n![image](https://assets.leetcode.com/users/images/6d31c54b-a7c0-4269-a727-b211fccc14bc_1597065014.7532413.png)\\n\\nThe recursion call will be the following:\\n- isValidBST(root: 20, min: -Infinity, max: Infinity): `true`\\n\\t- isValidBST(root: 10, min = -Infinity, max = 20): `true`\\n\\t\\t- isValidBST(root: 18, min = 10, max = 20): `true`\\n\\t\\t\\t- isValidBST(root: 17, min = 10, max = 18): `true`\\n\\t\\t\\t- isValidBST(root: 19, min = 18, max = 20): `true`\\n\\t- isValidBST(root: 30, min = 20, max = Infinity): `true`\\n\\nEach one returns true so it\\'s a valid BST.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction isValidBST(root: TreeNode|null, min = -Infinity, max = Infinity): boolean {\\n  if(!root) return true;\\n  return !(root.val <= min || root.val >= max) && isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 509816,
                "title": "go-4ms",
                "content": "```\\nfunc isValidBST(root *TreeNode) bool {\\n    return RecValidate(root, nil, nil)\\n}\\n\\nfunc RecValidate(n, min, max *TreeNode) bool {\\n    if n == nil {\\n        return true\\n    }\\n    if min != nil && n.Val <= min.Val {\\n        return false\\n    }\\n    if max != nil && n.Val >= max.Val {\\n        return false\\n    }\\n    return RecValidate(n.Left, min, n) && RecValidate(n.Right, n, max)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidBST(root *TreeNode) bool {\\n    return RecValidate(root, nil, nil)\\n}\\n\\nfunc RecValidate(n, min, max *TreeNode) bool {\\n    if n == nil {\\n        return true\\n    }\\n    if min != nil && n.Val <= min.Val {\\n        return false\\n    }\\n    if max != nil && n.Val >= max.Val {\\n        return false\\n    }\\n    return RecValidate(n.Left, min, n) && RecValidate(n.Right, n, max)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32356,
                "title": "4-line-c-simple-solution-easy-understanding",
                "content": "     bool isValidBST(TreeNode* root) {\\n        return dfs_valid(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool dfs_valid(TreeNode *root, long low, long high) {\\n        if (!root) return true;\\n        return low < root->val && root->val < high && dfs_valid(root->left, low, root->val)\\n                && dfs_valid(root->right, root->val, high);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     bool isValidBST(TreeNode* root) {\\n        return dfs_valid(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool dfs_valid(TreeNode *root, long low, long high) {\\n        if (!root) return true;\\n        return low < root->val && root->val < high && dfs_valid(root->left, low, root->val)\\n                && dfs_valid(root->right, root->val, high);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3213726,
                "title": "python-inorder-traversal-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        arr = []\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        inorder(root)\\n        return True if arr == list(sorted(set(arr))) else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        arr = []\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        inorder(root)\\n        return True if arr == list(sorted(set(arr))) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508434,
                "title": "c-python-simple-o-n-solution",
                "content": "**C++ :**\\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root -> left);\\n        bTree.push_back(root -> val);\\n        inorder(root -> right);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        // An empty tree\\n        if(!root)\\n            return true;\\n        \\n        // A leaf\\n        if(!root -> right && !root -> left)\\n            return true;\\n        \\n        // Inorder traversal to get the tree\\'s values sorted\\n        inorder(root);\\n        \\n        for(int i = 0; i < bTree.size() - 1; ++i)\\n            if(bTree[i] >= bTree[i + 1])\\n                return false;\\n        return true;\\n        \\n    }\\n    \\n    private:\\n        vector<int> bTree;\\n};\\n```\\n\\n**Python :**\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.tree = []\\n     \\n    def inorder(self, root: Optional[TreeNode]) -> None:\\n        if not root:\\n            return\\n        \\n        self.inorder(root.left);\\n        self.tree.append(root.val);\\n        self.inorder(root.right);\\n        \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        if not root.right and not root.left:\\n            return True\\n        \\n        self.inorder(root)\\n        \\n        for i in range(len(self.tree) - 1):\\n            if self.tree[i] >= self.tree[i + 1]:\\n                return False\\n        return True;\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root -> left);\\n        bTree.push_back(root -> val);\\n        inorder(root -> right);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        // An empty tree\\n        if(!root)\\n            return true;\\n        \\n        // A leaf\\n        if(!root -> right && !root -> left)\\n            return true;\\n        \\n        // Inorder traversal to get the tree\\'s values sorted\\n        inorder(root);\\n        \\n        for(int i = 0; i < bTree.size() - 1; ++i)\\n            if(bTree[i] >= bTree[i + 1])\\n                return false;\\n        return true;\\n        \\n    }\\n    \\n    private:\\n        vector<int> bTree;\\n};\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.tree = []\\n     \\n    def inorder(self, root: Optional[TreeNode]) -> None:\\n        if not root:\\n            return\\n        \\n        self.inorder(root.left);\\n        self.tree.append(root.val);\\n        self.inorder(root.right);\\n        \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        if not root.right and not root.left:\\n            return True\\n        \\n        self.inorder(root)\\n        \\n        for i in range(len(self.tree) - 1):\\n            if self.tree[i] >= self.tree[i + 1]:\\n                return False\\n        return True;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32136,
                "title": "three-solutions-in-c",
                "content": "**Solution 1.** \\n\\nBF, O(n^2).\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(!root) return true;\\n        if(!isValid(root->left, root->val, true) || !isValid(root->right, root->val, false)) return false;\\n        return isValidBST(root->left) && isValidBST(root->right);\\n    }\\n    \\n    bool isValid(TreeNode* root, int bound, bool isLeft){\\n        return !root || (isLeft ? root->val < bound : root->val > bound ) && isValid(root->left, bound, isLeft) && isValid(root->right, bound, isLeft);\\n    }\\n};\\n```\\n***\\n**Solution 2.** \\n\\nIn-order, recursive, O(n), refered from [here](https://discuss.leetcode.com/topic/4659/c-in-order-traversal-and-please-do-not-rely-on-buggy-int_max-int_min-solutions-any-more).\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* pre = NULL;\\n        return isValid(root, pre);\\n    }\\n    \\n    bool isValid(TreeNode* root, TreeNode* &pre){\\n        if(!root) return true;\\n        if(!isValid(root->left, pre)) return false;\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        return isValid(root->right, pre);\\n    }\\n};\\n```\\n***\\n**Solution 3.** \\n\\nIn-order, iterative, O(n), refered from [here](https://discuss.leetcode.com/topic/46016/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution).\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*>s;\\n        TreeNode* pre = NULL;\\n        while(root || !s.empty()){\\n            while(root){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre && root->val <= pre->val) return false;\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(!root) return true;\\n        if(!isValid(root->left, root->val, true) || !isValid(root->right, root->val, false)) return false;\\n        return isValidBST(root->left) && isValidBST(root->right);\\n    }\\n    \\n    bool isValid(TreeNode* root, int bound, bool isLeft){\\n        return !root || (isLeft ? root->val < bound : root->val > bound ) && isValid(root->left, bound, isLeft) && isValid(root->right, bound, isLeft);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* pre = NULL;\\n        return isValid(root, pre);\\n    }\\n    \\n    bool isValid(TreeNode* root, TreeNode* &pre){\\n        if(!root) return true;\\n        if(!isValid(root->left, pre)) return false;\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        return isValid(root->right, pre);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*>s;\\n        TreeNode* pre = NULL;\\n        while(root || !s.empty()){\\n            while(root){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre && root->val <= pre->val) return false;\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247077,
                "title": "java-recursive-solution-0ms-without-using-long-max-value-and-long-min-value",
                "content": "# Approach\\nFor this problem, we need to choose one biggest value > `Integer.MAX_VALUE`\\nand one smallest value < `Integer.MIN_VALUE` as the maximum and minimum, respectively. They could not be equal, otherwise cases like\\n```\\nroot = [2147483647]\\nroot = [2147483647, 2147483647]\\n```\\nwill be failed.\\n\\n`Long.MAX_VALUE` and `Long.MIN_VALUE` are luckily the two that meet our needs. However, if unluckily in the future the LeetCode admin adds them into the test cases, cases like\\n```\\nroot = [9223372036854775807]\\nroot = [9223372036854775807, 9223372036854775807]\\n```\\nwill be failed again.\\n\\nTherefore, it is better to avoid using them. We can simply replace the `int` or `long` with `TreeNode`, and set them to `null` when calling the helper function, as shown in the code below.\\n\\n# Reference\\nhttps://algs4.cs.princeton.edu/32bst/BST.java.html\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n\\n    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (min != null && root.val <= min.val) {\\n            return false;\\n        }\\n\\n        if (max != null && root.val >= max.val) {\\n            return false;\\n        }\\n        return isValidBST(root.left, min, root) \\n                && isValidBST(root.right, root, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nroot = [2147483647]\\nroot = [2147483647, 2147483647]\\n```\n```\\nroot = [9223372036854775807]\\nroot = [9223372036854775807, 9223372036854775807]\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n\\n    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (min != null && root.val <= min.val) {\\n            return false;\\n        }\\n\\n        if (max != null && root.val >= max.val) {\\n            return false;\\n        }\\n        return isValidBST(root.left, min, root) \\n                && isValidBST(root.right, root, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736338,
                "title": "easy-c-solution-dfs-recursion",
                "content": "# Solution via in-order traversal [we need to check whether that returned elements are in ascending order]\\n\\n```\\nclass Solution {\\npublic:\\n    long int num = LONG_MIN;\\n\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n        \\n        bool ans = isValidBST(root->left);\\n        \\n        if (root->val > num) {\\n            num = root->val;\\n        } else return false;\\n\\n        return ans && isValidBST(root->right);\\n    }\\n};\\n```\\n\\n# Solution via recursion\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, long int min = LONG_MIN, long int max = LONG_MAX) {\\n        if (!root) return true;\\n\\n        if (root->val > min && root->val < max) {\\n            return true && isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n\\n\\n*If the above approaches helped you, then please upvote the solution!*\\n\\n## My GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long int num = LONG_MIN;\\n\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n        \\n        bool ans = isValidBST(root->left);\\n        \\n        if (root->val > num) {\\n            num = root->val;\\n        } else return false;\\n\\n        return ans && isValidBST(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, long int min = LONG_MIN, long int max = LONG_MAX) {\\n        if (!root) return true;\\n\\n        if (root->val > min && root->val < max) {\\n            return true && isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847783,
                "title": "dfs-solution-easy-to-understand",
                "content": "```\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        self.answer = True\\n        \\n        def dfs(root, left, right):\\n            if root:\\n                if left >= root.val or root.val >= right:\\n                    self.answer = False\\n                    return\\n                dfs(root.left, left, root.val)\\n                dfs(root.right, root.val, right)\\n        dfs(root, float(\"-inf\"), float(\\'inf\\'))\\n        return self.answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        self.answer = True\\n        \\n        def dfs(root, left, right):\\n            if root:\\n                if left >= root.val or root.val >= right:\\n                    self.answer = False\\n                    return\\n                dfs(root.left, left, root.val)\\n                dfs(root.right, root.val, right)\\n        dfs(root, float(\"-inf\"), float(\\'inf\\'))\\n        return self.answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 286092,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return DFS(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool DFS(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (min < root.val && root.val < max) {\\n            var leftResult = DFS(root.left, min, root.val);\\n            var rightResult = DFS(root.right, root.val, max);\\n\\n            if (leftResult && rightResult) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return DFS(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool DFS(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (min < root.val && root.val < max) {\\n            var leftResult = DFS(root.left, min, root.val);\\n            var rightResult = DFS(root.right, root.val, max);\\n\\n            if (leftResult && rightResult) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232839,
                "title": "swift",
                "content": "```swift\\nfunc isValidBST(_ root: TreeNode?) -> Bool {\\n   return isBst(root, min: Int.min, max: Int.max)\\n}\\n    \\nprivate func isBst(_ node: TreeNode?, min: Int, max: Int) -> Bool {\\n\\tif node == nil { return true }\\n\\tif node!.val <= min || node!.val >= max { return false }\\n\\treturn isBst(node?.left, min: min, max: node!.val) &&\\n\\t\\t   isBst(node?.right, min: node!.val, max: max)\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc isValidBST(_ root: TreeNode?) -> Bool {\\n   return isBst(root, min: Int.min, max: Int.max)\\n}\\n    \\nprivate func isBst(_ node: TreeNode?, min: Int, max: Int) -> Bool {\\n\\tif node == nil { return true }\\n\\tif node!.val <= min || node!.val >= max { return false }\\n\\treturn isBst(node?.left, min: min, max: node!.val) &&\\n\\t\\t   isBst(node?.right, min: node!.val, max: max)\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207438,
                "title": "javascript",
                "content": "```\\nvar isValidBST = function(root) {\\n    if(!root) \\n        return true\\n    return dfs(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)\\n    \\n    function dfs(root, min, max){\\n        if(!root) \\n            return true\\n        if(root.val <= min || root.val >= max)\\n            return false\\n        return dfs(root.left, min, root.val) && dfs(root.right, root.val, max)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidBST = function(root) {\\n    if(!root) \\n        return true\\n    return dfs(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)\\n    \\n    function dfs(root, min, max){\\n        if(!root) \\n            return true\\n        if(root.val <= min || root.val >= max)\\n            return false\\n        return dfs(root.left, min, root.val) && dfs(root.right, root.val, max)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32306,
                "title": "1-ms-java-solution",
                "content": "    public class Solution {\\n        private TreeNode prev = null;\\n        \\n        public boolean isValidBST(TreeNode root) {\\n            if(root == null){\\n                return true;\\n            }\\n            if(!isValidBST(root.left)) return false;\\n            if(prev != null && root.val <= prev.val) return false;\\n            prev = root;\\n            return isValidBST(root.right);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        private TreeNode prev = null;\\n        \\n        public boolean isValidBST(TreeNode root) {\\n            if(root == null){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32370,
                "title": "python-inorder-non-recursive-solution-using-stack",
                "content": "    class Solution(object):\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            # using inorder - binary search tree will be ascending order\\n            stack = []\\n            cur = root\\n            pre = None\\n            while len(stack) or cur:\\n                if cur:\\n                    stack.append(cur)\\n                    cur = cur.left\\n                else:\\n                    p = stack.pop()\\n                    if pre and p.val <= pre.val:\\n                        return False\\n                    pre = p\\n                    cur = p.right\\n            return True",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    class Solution(object):\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            # using inorder - binary search tree will be ascending order\\n            stack = []\\n            cur = root\\n            pre = None\\n            while len(stack) or cur:\\n                if cur:\\n                    stack.append(cur)\\n                    cur = cur.left\\n                else:\\n                    p = stack.pop()\\n                    if pre and p.val <= pre.val:\\n                        return False\\n                    pre = p\\n                    cur = p.right\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 32502,
                "title": "test-cases-missing",
                "content": "There should be a test case where some nodes have values equal to Integer.MIN_VALUE and Integer.MAX_VALUE;\\n\\nThis solution is accepted and shouldn't be:\\n\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        return isValidBST(root.left,Integer.MIN_VALUE, root.val) \\n               && isValidBST(root.right,root.val,Integer.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, int smallest, int largest) {\\n        if (root == null) return true;\\n        if (root.val > smallest && root.val < largest)\\n            return isValidBST(root.left,smallest, root.val) \\n                   && isValidBST(root.right,root.val,largest);\\n        else\\n            return false;\\n    }",
                "solutionTags": [],
                "code": "There should be a test case where some nodes have values equal to Integer.MIN_VALUE and Integer.MAX_VALUE;\\n\\nThis solution is accepted and shouldn't be:\\n\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        return isValidBST(root.left,Integer.MIN_VALUE, root.val) \\n               && isValidBST(root.right,root.val,Integer.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, int smallest, int largest) {\\n        if (root == null) return true;\\n        if (root.val > smallest && root.val < largest)\\n            return isValidBST(root.left,smallest, root.val) \\n                   && isValidBST(root.right,root.val,largest);\\n        else\\n            return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3770870,
                "title": "superb-lgic-bst",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def BST(root,mx,mi):\\n            if not root:\\n                return True\\n            elif root.val>=mx or root.val<=mi:\\n                return False\\n            else:\\n                return BST(root.left,root.val,mi) and BST(root.right,mx,root.val)\\n        return BST(root,float(\\'inf\\'),float(\\'-inf\\'))\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def BST(root,mx,mi):\\n            if not root:\\n                return True\\n            elif root.val>=mx or root.val<=mi:\\n                return False\\n            else:\\n                return BST(root.left,root.val,mi) and BST(root.right,mx,root.val)\\n        return BST(root,float(\\'inf\\'),float(\\'-inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390380,
                "title": "intuitive-c-solution-inorder-traversal",
                "content": "##### Let\\'s connect on Linkedin https://www.linkedin.com/in/arthur-asanaliev/\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251741,
                "title": "simple-brute-force-solution-o-n-time-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you clearly understand the question, it states that you just need to check whether the BST is valid or not, and when we traverse a BST using INORDER, the output stream will be a sorted list.\\n\\n# Simple Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can traverse the BST using Inorder and store each output element in a list, and check whether the list is sorted or not.\\n\\n**FOR EXAMPLE:**\\nIf the BST looks something like this:\\n![djanj.png](https://assets.leetcode.com/users/images/4435e6a0-5248-45a0-97bf-a83d668f8569_1677843929.3729975.png)\\n\\nThe **INORDER** traversal will be - [1, 3, 4, 6, 7, 8, 10, 13, 14]\\nAnd if a tree is a BST the inorder will be sorted;\\n\\nThe above tree is a valid BST, and we can check that using the above inorder list.\\n\\n\\n# Complexity\\n- Time complexity: O(N) for traversing tree and O(N) for checking if resultant list is sorted or not,  N = Number of Nodes in a tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) in worst case if tree is skewed, and O(N) space for storing each element in a list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Travserse entire tree using inorder, and store each element inside the res.\\n    void inorder(TreeNode* root, vector<int>&res) {\\n        if(!root) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> res;\\n        inorder(root, res);\\n        for(int i=1; i<res.size(); ++i) {\\n            // Checking if res[i-1] >= res[i] then return false;\\n            // That means the input tree is not a valid BST;\\n            if(res[i-1]>=res[i]) return false;\\n        }\\n        return true;\\n        // Follow up: solve this without using any extra space.\\n        // Hint: You can use ranges, for each element.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Travserse entire tree using inorder, and store each element inside the res.\\n    void inorder(TreeNode* root, vector<int>&res) {\\n        if(!root) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> res;\\n        inorder(root, res);\\n        for(int i=1; i<res.size(); ++i) {\\n            // Checking if res[i-1] >= res[i] then return false;\\n            // That means the input tree is not a valid BST;\\n            if(res[i-1]>=res[i]) return false;\\n        }\\n        return true;\\n        // Follow up: solve this without using any extra space.\\n        // Hint: You can use ranges, for each element.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926224,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n \\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n\\n    private var prev: Int?\\n    \\n    func isValidBST(_ root: TreeNode?) -> Bool {\\n        inorder(root)\\n    }\\n    \\n    private func inorder(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return true }\\n        \\n        guard inorder(root.left) else { return false }\\n        \\n        if let prev = prev, root.val <= prev { return false }\\n        \\n        prev = root.val\\n        return inorder(root.right)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n \\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n\\n    private var prev: Int?\\n    \\n    func isValidBST(_ root: TreeNode?) -> Bool {\\n        inorder(root)\\n    }\\n    \\n    private func inorder(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return true }\\n        \\n        guard inorder(root.left) else { return false }\\n        \\n        if let prev = prev, root.val <= prev { return false }\\n        \\n        prev = root.val\\n        return inorder(root.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682393,
                "title": "easy-c-inorder-traversal-o-n",
                "content": "The inorder traversal of a BST is always sorted.\\nAlgortihm\\n1) Obtain the Inorder traversal of Binary Tree\\n2) Check if Inorder traversal is sorted\\n3) If sorted then return TRUE\\n4) If  NOT sorted then return FALSE\\n\\nInorder Traversal Explained\\n![image](https://assets.leetcode.com/users/images/6bf52f7d-5b1f-4bc1-bdab-c88511f090c6_1641889707.5851665.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void check(TreeNode* root, vector <int>& res){\\n        if(root == NULL) return;\\n        \\n        check(root->left,res);\\n        res.push_back(root->val);\\n        check(root->right,res);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector <int> res;\\n        check(root,res);\\n        for(int i = 1; i <res.size(); i++){\\n            if(res[i] <= res[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nUpvote if you understood.\\nThank you!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(TreeNode* root, vector <int>& res){\\n        if(root == NULL) return;\\n        \\n        check(root->left,res);\\n        res.push_back(root->val);\\n        check(root->right,res);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector <int> res;\\n        check(root,res);\\n        for(int i = 1; i <res.size(); i++){\\n            if(res[i] <= res[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150778,
                "title": "java-solution-both-recursive-and-non-recursive-good-way-to-build-concept-on-tree",
                "content": "I found this to be a good problem to improve concepts on tree, especially BST.\\nApproach 1: Employ BST property and iterative inorder traversal.\\nWe remember that in BST, an iterative inorder traversal is basically an ascending sorted list. Now, we also know that no two elements in the tree are equal.\\n\\nHence the simple logic that at any given point of time, the previous element should not be greater than or equal to the current element. For the first element, previous element is just \"null\".\\n\\nFor boundary conditions, we need to understand that Integer.MAX_VALUE and Integer.MIN_VALUE are all valid values, so cannot be used as sentinel markers. \\n\\nCode below:\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode prev = null;\\n        TreeNode curr = root;\\n        \\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Inorder visit of node\\n            curr = stack.pop();\\n\\t\\t\\t// Checking BST property\\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        // At this stage, all nodes have been visited, and we know the tree is BST\\n        return true;\\n        \\n    }\\n}\\n```\\n\\nNow the interviewer can ask for any alternative approach to solve this problem, like a recursive approach without any global/member variable. In this case, we need to think about invariant here are the bounds of each node.\\nIf a node is a left child in a BST, it\\'s max value is bound by its parent. Similarly, if it right child, then its min value is bound by its parent.\\n\\nOne trick here is how do we intuitively pass unbounded limits since MIN and MAX values are already taken? In Java, Integer object comes to the rescue, and the value \"null\" indicates unbounded value.\\n\\nRest of the code is pretty intuitive:\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, null, null);\\n    }\\n    \\n    private boolean helper(TreeNode node, Integer minVal, Integer maxVal) {\\n        if (node == null) {\\n            return true;\\n        }\\n        \\n        // Preorder traversal: check if the current node respects the bounds\\n        if (minVal != null && node.val <= minVal) {\\n            return false;\\n        }\\n        \\n        if (maxVal != null && node.val >= maxVal) {\\n            return false;\\n        }\\n        \\n        // Traverse left and right children, note that current node applies to min and max bounds based on which\\n        // child we select\\n        boolean left = helper(node.left, minVal, node.val);\\n        boolean right = helper(node.right, node.val, maxVal);\\n        return left == true && right == true;\\n    }\\n}\\n```\\n\\nBoth the algorithms take O(n) time complexity since they intend to visit all nodes to ensure the tree is BST, and O(h) space which signifies the stack size (explicit stack or recursion stack). Skewed tree with only left/right child will take worst case space of (n) following basic tree property.\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode prev = null;\\n        TreeNode curr = root;\\n        \\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Inorder visit of node\\n            curr = stack.pop();\\n\\t\\t\\t// Checking BST property\\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        // At this stage, all nodes have been visited, and we know the tree is BST\\n        return true;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, null, null);\\n    }\\n    \\n    private boolean helper(TreeNode node, Integer minVal, Integer maxVal) {\\n        if (node == null) {\\n            return true;\\n        }\\n        \\n        // Preorder traversal: check if the current node respects the bounds\\n        if (minVal != null && node.val <= minVal) {\\n            return false;\\n        }\\n        \\n        if (maxVal != null && node.val >= maxVal) {\\n            return false;\\n        }\\n        \\n        // Traverse left and right children, note that current node applies to min and max bounds based on which\\n        // child we select\\n        boolean left = helper(node.left, minVal, node.val);\\n        boolean right = helper(node.right, node.val, maxVal);\\n        return left == true && right == true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594360,
                "title": "simple-readable-java-recursion-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root, Integer min, Integer max) {\\n        if (root == null) \\n            return true; \\n        if ((max != null && root.val >= max) || (min != null && root.val <= min)) \\n            return false; \\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root, Integer min, Integer max) {\\n        if (root == null) \\n            return true; \\n        if ((max != null && root.val >= max) || (min != null && root.val <= min)) \\n            return false; \\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32369,
                "title": "output-in-submit-and-run-code-are-different",
                "content": "I submit my code and got return as wrong answer since it does not pass case [0,-1]. It shows my output is false but it should be true. Then I run code by check customized case [0,-1]. It shows my output is true. Is there anything wrong?\\n\\n    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        global pre\\n        pre = None\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            global pre\\n            if (root == None):\\n                return True\\n            if ((not self.isValidBST(root.left)) or (pre != None and pre.val >= root.val)):\\n                return False\\n            pre = root\\n            if (not self.isValidBST(root.right)):\\n                return False\\n            return True",
                "solutionTags": [],
                "code": "I submit my code and got return as wrong answer since it does not pass case [0,-1]. It shows my output is false but it should be true. Then I run code by check customized case [0,-1]. It shows my output is true. Is there anything wrong?\\n\\n    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        global pre\\n        pre = None\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            global pre\\n            if (root == None):\\n                return True\\n            if ((not self.isValidBST(root.left)) or (pre != None and pre.val >= root.val)):\\n                return False\\n            pre = root\\n            if (not self.isValidBST(root.right)):\\n                return False\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 32300,
                "title": "morris-traversal-o-1-space-no-recursion-o-n-time-with-explanation-java",
                "content": "    // inorder traversal to see if the value is monotonically increased\\n    // use morris traversal to gain O(1) space, No recursion and O(n) time\\n    // main idea: the key part of tree traversal is how to go back to parent,\\n    //            one way is to use recursion and store parent in function stack,\\n    //            another way is to use explicit stack to store parent,\\n    //            morris traversal modify the original tree and \\n    //            let the right child of the predecessor of the root to point back to itself\\n    //            in order to go back to the root and then restore the pointer(set it to null again)\\n    //            the overall time complexity is still O(n), since the tree is traversed\\n    //            no more than twice(there is not overlap between the path of finding predecessor).\\n    public boolean isValidBST(TreeNode root) {\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        TreeNode pred = null; // predecessor\\n        \\n        while (curr != null) {\\n            if (curr.left == null) {\\n                if (prev != null) {\\n                    if (curr.val <= prev.val) {\\n                        return false;\\n                    }\\n                }\\n                prev = curr;\\n                curr = curr.right;\\n            } else {\\n                pred = curr.left;\\n                while (pred.right != null && pred.right != curr) { // find predecessor\\n                    pred = pred.right;\\n                }\\n                if (pred.right == curr) {\\n                    pred.right = null;\\n                    if (prev != null) {\\n                        if (curr.val <= prev.val) {\\n                            return false;\\n                        }\\n                    }\\n                    prev = curr;\\n                    curr = curr.right;\\n                } else {\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    // inorder traversal to see if the value is monotonically increased\\n    // use morris traversal to gain O(1) space, No recursion and O(n) time\\n    // main idea: the key part of tree traversal is how to go back to parent,\\n    //            one way is to use recursion and store parent in function stack,\\n    //            another way is to use explicit stack to store parent,\\n    //            morris traversal modify the original tree and \\n    //            let the right child of the predecessor of the root to point back to itself\\n    //            in order to go back to the root and then restore the pointer(set it to null again)\\n    //            the overall time complexity is still O(n), since the tree is traversed\\n    //            no more than twice(there is not overlap between the path of finding predecessor).\\n    public boolean isValidBST(TreeNode root) {\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        TreeNode pred = null; // predecessor\\n        \\n        while (curr != null) {\\n            if (curr.left == null) {\\n                if (prev != null) {\\n                    if (curr.val <= prev.val) {\\n                        return false;\\n                    }\\n                }\\n                prev = curr;\\n                curr = curr.right;\\n            } else {\\n                pred = curr.left;\\n                while (pred.right != null && pred.right != curr) { // find predecessor\\n                    pred = pred.right;\\n                }\\n                if (pred.right == curr) {\\n                    pred.right = null;\\n                    if (prev != null) {\\n                        if (curr.val <= prev.val) {\\n                            return false;\\n                        }\\n                    }\\n                    prev = curr;\\n                    curr = curr.right;\\n                } else {\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3272265,
                "title": "best-o-n-solution",
                "content": "# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (root->left == NULL && root->right == NULL)\\n            return true;        \\n        return checkBST(root, NULL, NULL); \\n    }\\n\\n    bool checkBST(TreeNode* root, TreeNode* min, TreeNode* max) {\\n        if (root == NULL)\\n            return true;\\n        if ((min != NULL && root->val <= min->val) || (max != NULL && root->val >= max->val))\\n            return false;\\n        return checkBST(root->left, min, root) &&\\n               checkBST(root->right, root, max);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (root->left == NULL && root->right == NULL)\\n            return true;        \\n        return checkBST(root, NULL, NULL); \\n    }\\n\\n    bool checkBST(TreeNode* root, TreeNode* min, TreeNode* max) {\\n        if (root == NULL)\\n            return true;\\n        if ((min != NULL && root->val <= min->val) || (max != NULL && root->val >= max->val))\\n            return false;\\n        return checkBST(root->left, min, root) &&\\n               checkBST(root->right, root, max);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568142,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.***\\n**Also you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\nhttps://www.youtube.com/watch?v=geBeUvcMMwo\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350343,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        return self.helper(root, float(\\'-inf\\'), float(\\'inf\\'))\\n    \\n    def helper(self, node, minVal, maxVal):\\n        if node == None:\\n            return True\\n        \\n        if node.val <= minVal or node.val >= maxVal:\\n            return False\\n        \\n        left = self.helper(node.left, minVal, node.val)\\n        right = self.helper(node.right, node.val, maxVal)\\n        \\n        return left and right         \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        return self.helper(root, float(\\'-inf\\'), float(\\'inf\\'))\\n    \\n    def helper(self, node, minVal, maxVal):\\n        if node == None:\\n            return True\\n        \\n        if node.val <= minVal or node.val >= maxVal:\\n            return False\\n        \\n        left = self.helper(node.left, minVal, node.val)\\n        right = self.helper(node.right, node.val, maxVal)\\n        \\n        return left and right         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110589,
                "title": "python-solution-with-linear-time-complexity-100-working",
                "content": "\\n        def dfs(lower,upper,node):\\n            if not node:\\n                return True\\n            elif node.val<=lower or node.val>=upper:\\n                return False\\n            else:\\n                return dfs(lower,node.val,node.left) and dfs(node.val,upper,node.right)\\n        return dfs(float(\\'-inf\\'),float(\\'inf\\'),root) \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n        def dfs(lower,upper,node):\\n            if not node:\\n                return True\\n            elif node.val<=lower or node.val>=upper:\\n                return False\\n            else:\\n                return dfs(lower,node.val,node.left) and dfs(node.val,upper,node.right)\\n        return dfs(float(\\'-inf\\'),float(\\'inf\\'),root) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2409055,
                "title": "c-long-long-man",
                "content": "1. if you go left, set bounds to min to root->val\\n2. if you go right, set boudns to root->val to max\\n3. use long long to get away from overflow and underflows\\n**4. check out the twitch channel.  Link in profile.**\\n```\\nclass Solution {  \\n    bool dfs(TreeNode* root, long long mn, long long mx) {\\n        if(!root) return true;\\n        \\n        if(root->val <= mn || root->val >= mx) return false;\\n        \\n        bool left = dfs(root->left, mn, root->val);\\n        bool right = dfs(root->right, root->val, mx);\\n        \\n        return left && right;\\n    }\\n    \\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return dfs(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\n    bool dfs(TreeNode* root, long long mn, long long mx) {\\n        if(!root) return true;\\n        \\n        if(root->val <= mn || root->val >= mx) return false;\\n        \\n        bool left = dfs(root->left, mn, root->val);\\n        bool right = dfs(root->right, root->val, mx);\\n        \\n        return left && right;\\n    }\\n    \\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return dfs(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366749,
                "title": "python-recursion-and-recursive-stack-space-o-1-space",
                "content": "Without using a list just use prev variable to store the previous node value and check if the Tree nodes are in ascending order during the inorder traversal. You dont have to create extra space for list.\\n    \\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        self.flag = True\\n        self.prev = float(\"-inf\")\\n        self.inorder(root)\\n        return self.flag\\n\\n        \\n    def inorder(self,root):\\n        #base condition\\n        if root==None:\\n            return\\n        \\n\\n        self.inorder(root.left)\\n        \\n        if root.val<=self.prev:\\n            self.flag = False            \\n        self.prev = root.val\\n        \\n        self.inorder(root.right)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Without using a list just use prev variable to store the previous node value and check if the Tree nodes are in ascending order during the inorder traversal. You dont have to create extra space for list.\\n    \\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        self.flag = True\\n        self.prev = float(\"-inf\")\\n        self.inorder(root)\\n        return self.flag\\n\\n        \\n    def inorder(self,root):\\n        #base condition\\n        if root==None:\\n            return\\n        \\n\\n        self.inorder(root.left)\\n        \\n        if root.val<=self.prev:\\n            self.flag = False            \\n        self.prev = root.val\\n        \\n        self.inorder(root.right)",
                "codeTag": "Python3"
            },
            {
                "id": 344672,
                "title": "c-clear-recursive-solution-without-using-longlong-double",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, TreeNode* nmin = nullptr, TreeNode* nmax = nullptr) {\\n        if(!root) \\n            return true;\\n        if(nmin && root->val <= nmin->val)\\n            return false;\\n        if(nmax && root->val >= nmax->val)\\n            return false;\\n        return isValidBST(root->left, nmin, root) && isValidBST(root->right, root, nmax);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, TreeNode* nmin = nullptr, TreeNode* nmax = nullptr) {\\n        if(!root) \\n            return true;\\n        if(nmin && root->val <= nmin->val)\\n            return false;\\n        if(nmax && root->val >= nmax->val)\\n            return false;\\n        return isValidBST(root->left, nmin, root) && isValidBST(root->right, root, nmax);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229282,
                "title": "neat-java-recursive-solution",
                "content": "``` java\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode x, TreeNode min, TreeNode max) {\\n        if (x == null) return true;\\n        if (max != null && x.val >= max.val) return false;\\n        if (min != null && x.val <= min.val) return false;\\n        return isValidBST(x.left, min, x) && isValidBST(x.right, x ,max);\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/jayomg/image_1548896395.png)\\n",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode x, TreeNode min, TreeNode max) {\\n        if (x == null) return true;\\n        if (max != null && x.val >= max.val) return false;\\n        if (min != null && x.val <= min.val) return false;\\n        return isValidBST(x.left, min, x) && isValidBST(x.right, x ,max);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32371,
                "title": "java-solution-after-adding-test-cases",
                "content": "Actually, not too much needs to be changed if you got AC code when extra test cases are not added. The only difference is add if-else condition for node's value equals INT_MAX and INT_MIN. \\n\\n    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            if (root == null) {\\n                return true;\\n            }\\n            if (root.left == null && root.right == null) {\\n                return true;\\n            }\\n            return check(root, Integer.MAX_VALUE, Integer.MIN_VALUE);\\n        }\\n        \\n        public boolean check(TreeNode node, int max, int min) {\\n            if (node == null) {\\n                return true;\\n            }\\n            if (node.val > max || node.val < min) {\\n                return false;\\n            }\\n    \\n            // if node's value is INT_MIN, it should not have left child any more\\n            if (node.val == Integer.MIN_VALUE && node.left != null) {\\n                return false;\\n            }\\n            \\n            // if node's value is INT_MAX, it should not have right child any more\\n            if (node.val == Integer.MAX_VALUE && node.right != null) {\\n                return false;\\n            }\\n    \\n            return check(node.left, node.val - 1, min) && check(node.right, max, node.val + 1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            if (root == null) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3972693,
                "title": "4-best-c-solutions-recursive-iterative-and-inorder-approach-beats-100",
                "content": "# Code\\n```\\n// Recursive solution - Using LONG_MIN anmd LONG_MAX\\nclass Solution {\\npublic: \\n    bool solve(TreeNode* root, long min, long max){\\n        if(root == NULL)   \\n            return true;\\n        \\n        if(root->val <= min || root->val >= max)  \\n            return false;\\n        \\n        return solve(root->left, min, root->val) && solve(root->right, root->val, max);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n\\n// Recursion solution - Using nodes\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, NULL, NULL);\\n    }\\n    \\n    bool solve(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return solve(root->left, root, min) && solve(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(root == NULL)\\n            return true;\\n        \\n        stack<TreeNode*> s;\\n        TreeNode *pre = NULL;\\n\\n        while(root != NULL || !s.empty()){\\n            while(root != NULL){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre != NULL && root->val <= pre->val){\\n                return false;\\n            }\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n\\n// Check if inorder is sorted\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        for(int i=1; i<ans.size(); i++){\\n            if(ans[i] <= ans[i-1])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution - Using LONG_MIN anmd LONG_MAX\\nclass Solution {\\npublic: \\n    bool solve(TreeNode* root, long min, long max){\\n        if(root == NULL)   \\n            return true;\\n        \\n        if(root->val <= min || root->val >= max)  \\n            return false;\\n        \\n        return solve(root->left, min, root->val) && solve(root->right, root->val, max);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n\\n// Recursion solution - Using nodes\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, NULL, NULL);\\n    }\\n    \\n    bool solve(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return solve(root->left, root, min) && solve(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(root == NULL)\\n            return true;\\n        \\n        stack<TreeNode*> s;\\n        TreeNode *pre = NULL;\\n\\n        while(root != NULL || !s.empty()){\\n            while(root != NULL){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre != NULL && root->val <= pre->val){\\n                return false;\\n            }\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n\\n// Check if inorder is sorted\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        for(int i=1; i<ans.size(); i++){\\n            if(ans[i] <= ans[i-1])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982339,
                "title": "optimized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n\\n    bool check(TreeNode* root, long minval, long maxval ){\\n\\n        if(root==NULL) return true;\\n\\n        if(root->val >= maxval || root->val <= minval) return false;\\n\\n        return check(root->left,minval, root->val) && check(root->right, root->val, maxval);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n\\n    bool check(TreeNode* root, long minval, long maxval ){\\n\\n        if(root==NULL) return true;\\n\\n        if(root->val >= maxval || root->val <= minval) return false;\\n\\n        return check(root->left,minval, root->val) && check(root->right, root->val, maxval);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410074,
                "title": "c-6-different-solutions-recursive-iteratively-in-order-traversal-check-previous",
                "content": "I came up with a few different approaches. Please let me know if you came up with another idea.\\n\\n**Solution 1: recursive with numeric limits**\\n\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, numeric_limits<long>::min(), numeric_limits<long>::max());\\n    }\\n    \\n    bool isValidBST(TreeNode* node, long min, long max) {\\n        if (!node) return true;\\n        \\n        return\\n            (min < node->val && node->val < max) &&\\n            isValidBST(node->left, min, node->val) &&\\n            isValidBST(node->right, node->val, max);\\n    }\\n```\\n\\n**Solution 2: recursive with lower bound and upper bound node**\\n\\nIn this version we don\\'t need to make any assumptions about ```TreeNode::val```, all we care about is that they are compareable. In the following solutions we always only compare values to each other and don\\'t make any futher assumptions about there type.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, nullptr, nullptr);\\n    }\\n    \\n    bool isValidBST(TreeNode* node, TreeNode* lb, TreeNode* ub) {\\n        if (!node) return true;\\n        \\n        if (lb && !(lb->val < node->val)) return false;\\n        if (ub && !(node->val < ub->val)) return false;\\n        \\n        return\\n            isValidBST(node->left, lb, node) &&\\n            isValidBST(node->right, node, ub);\\n    }\\n```\\n\\n**Solution 3: interative with lower bound and upper bound node**\\n\\nWe might as well do this iteratively. We could also use a ```stack``` instead of a ```queue```.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n\\n        queue<array<TreeNode*, 3>> q;\\n        q.push({root, nullptr, nullptr});\\n        \\n        while (!empty(q)) {\\n            auto [node, lb, ub] = q.front(); q.pop();\\n            \\n            if (lb && lb->val >= node->val) return false;\\n            if (ub && ub->val <= node->val) return false;\\n            \\n            if (node->left) q.push({node->left, lb, node});\\n            if (node->right) q.push({node->right, node, ub});\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n**Solution 4: inorder traversal w/ previous node recursively**\\n\\nA different approach is to compare a node with a previous node in an inorder traversal. The values need to be asceding.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(root, &prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode** prev) {\\n        if (!root) return true;\\n        \\n        if (root->left && !isValidBST(root->left, prev)) return false;\\n        \\n        // visit\\n        if (*prev && root->val <= (*prev)->val) return false;\\n        *prev = root;\\n     \\n        if (root->right && !isValidBST(root->right, prev)) return false;\\n        \\n        return true;\\n    }\\n```\\n\\n**Solution 5: inorder traversal w/ previous node iteratively**\\n\\nLike solution 4, but iteratively.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        \\n        TreeNode* prev = nullptr;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n            \\n            // Visit.\\n            if (prev && prev->val >= root->val) return false;\\n            prev = root;\\n            \\n            root = root->right;\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n**Solution 6: serialise the BST and check if sequence is monotonic increasing**\\n\\nNote that ```std::is_sorted``` can\\'t be used here. This uses extra memory for the serialised sequence, which feels a bit unnecassary, but oh well, sue me. :)\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> values;\\n        stack<TreeNode*> st;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n\\n            // Visit.\\n            values.push_back(root->val);\\n            \\n            root = root->right;\\n        }\\n\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(values), end(values), greater_equal<>()) == end(values);\\n    }\\n```\\n\\n**Bonus Solution: custom STL iterator**\\n\\nWe can turn this into a one liner:\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(root), end(root), greater_equal<>()) == end(root);\\n    }\\n```\\n\\n... if we implement a custom iterator for ```TreeNode```. This avoids the extra memory for the ```vector<int>``` from solution 6, but this iterator is quite a have object and expensive to copy. It would take more work to make this effiecient, but it works. So to make the above could work we need something like this:\\n\\n```\\n// TODO(heder): Can we turn this into a \"lean\" iterator? This one is quite \"fat\", as it has\\n// a stack<> member.\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    // TODO(heder): Keep the root pointer around so we know if the iterator is\\n    // from the same tree?\\n    Iterator(TreeNode* root) : curr_(root) {\\n        gotoLeftMost(curr_);\\n    }\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        if (curr_) {\\n            gotoLeftMost(curr_->right);\\n        }\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    stack<TreeNode*> st_;\\n    TreeNode* curr_;\\n    \\n    void gotoLeftMost(TreeNode* node) {\\n        while (node) {\\n            st_.push(node);\\n            node = node->left;\\n        }\\n        \\n        if (empty(st_)) {\\n            curr_ = nullptr;\\n        } else {\\n            curr_ = st_.top();\\n            st_.pop();\\n        }\\n    }\\n};\\n\\nstruct Iterator begin(TreeNode* root) {\\n    return Iterator(root);\\n}\\n\\nstruct Iterator end(TreeNode* root) {\\n    return Iterator(nullptr);\\n}\\n```\\n\\nComments on how to improve any of the solutions are welcome.",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, numeric_limits<long>::min(), numeric_limits<long>::max());\\n    }\\n    \\n    bool isValidBST(TreeNode* node, long min, long max) {\\n        if (!node) return true;\\n        \\n        return\\n            (min < node->val && node->val < max) &&\\n            isValidBST(node->left, min, node->val) &&\\n            isValidBST(node->right, node->val, max);\\n    }\\n```\n```TreeNode::val```\n```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, nullptr, nullptr);\\n    }\\n    \\n    bool isValidBST(TreeNode* node, TreeNode* lb, TreeNode* ub) {\\n        if (!node) return true;\\n        \\n        if (lb && !(lb->val < node->val)) return false;\\n        if (ub && !(node->val < ub->val)) return false;\\n        \\n        return\\n            isValidBST(node->left, lb, node) &&\\n            isValidBST(node->right, node, ub);\\n    }\\n```\n```stack```\n```queue```\n```\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n\\n        queue<array<TreeNode*, 3>> q;\\n        q.push({root, nullptr, nullptr});\\n        \\n        while (!empty(q)) {\\n            auto [node, lb, ub] = q.front(); q.pop();\\n            \\n            if (lb && lb->val >= node->val) return false;\\n            if (ub && ub->val <= node->val) return false;\\n            \\n            if (node->left) q.push({node->left, lb, node});\\n            if (node->right) q.push({node->right, node, ub});\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(root, &prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode** prev) {\\n        if (!root) return true;\\n        \\n        if (root->left && !isValidBST(root->left, prev)) return false;\\n        \\n        // visit\\n        if (*prev && root->val <= (*prev)->val) return false;\\n        *prev = root;\\n     \\n        if (root->right && !isValidBST(root->right, prev)) return false;\\n        \\n        return true;\\n    }\\n```\n```\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        \\n        TreeNode* prev = nullptr;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n            \\n            // Visit.\\n            if (prev && prev->val >= root->val) return false;\\n            prev = root;\\n            \\n            root = root->right;\\n        }\\n        \\n        return true;\\n    }\\n```\n```std::is_sorted```\n```\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> values;\\n        stack<TreeNode*> st;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n\\n            // Visit.\\n            values.push_back(root->val);\\n            \\n            root = root->right;\\n        }\\n\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(values), end(values), greater_equal<>()) == end(values);\\n    }\\n```\n```\\n    bool isValidBST(TreeNode* root) {\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(root), end(root), greater_equal<>()) == end(root);\\n    }\\n```\n```TreeNode```\n```vector<int>```\n```\\n// TODO(heder): Can we turn this into a \"lean\" iterator? This one is quite \"fat\", as it has\\n// a stack<> member.\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    // TODO(heder): Keep the root pointer around so we know if the iterator is\\n    // from the same tree?\\n    Iterator(TreeNode* root) : curr_(root) {\\n        gotoLeftMost(curr_);\\n    }\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        if (curr_) {\\n            gotoLeftMost(curr_->right);\\n        }\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    stack<TreeNode*> st_;\\n    TreeNode* curr_;\\n    \\n    void gotoLeftMost(TreeNode* node) {\\n        while (node) {\\n            st_.push(node);\\n            node = node->left;\\n        }\\n        \\n        if (empty(st_)) {\\n            curr_ = nullptr;\\n        } else {\\n            curr_ = st_.top();\\n            st_.pop();\\n        }\\n    }\\n};\\n\\nstruct Iterator begin(TreeNode* root) {\\n    return Iterator(root);\\n}\\n\\nstruct Iterator end(TreeNode* root) {\\n    return Iterator(nullptr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408926,
                "title": "daily-leetcoding-challenge-august-day-11",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/validate-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Traversal with Valid Range\n\n  \n**Approach 2:** Iterative Traversal with Valid Range\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/validate-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1573371,
                "title": "c-easy-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(TreeNode* root, long long int min,long long int max){\\n        if(!root)return true;\\n        \\n        if(root->val>=max || root->val<=min)return false;\\n        \\n        return solve(root->left,min,root->val) and solve(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(!root)return true;\\n        \\n        return solve(root,-1e18,1e18);\\n    }\\n};\\n```\\n\\nHope you like it.\\n\\nPlease upvote it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(TreeNode* root, long long int min,long long int max){\\n        if(!root)return true;\\n        \\n        if(root->val>=max || root->val<=min)return false;\\n        \\n        return solve(root->left,min,root->val) and solve(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(!root)return true;\\n        \\n        return solve(root,-1e18,1e18);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974349,
                "title": "validate-binary-search-tree-4-line-compressed-code",
                "content": "```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root,Long.MIN_VALUE,Long.MAX_VALUE);       \\n    }\\n    public boolean isValid(TreeNode root,long least,long max){\\n        if(root==null) return true;\\n        if(root.left!=null&&(root.left.val>=root.val||root.left.val<=least)) return false;\\n        if(root.right!=null&&(root.right.val<=root.val||root.right.val>=max)) return false;\\n        return isValid(root.left,least,root.val)&&isValid(root.right,root.val,max);\\n    }\\n```\\nfor video explanation leet code soln\\nhttps://leetcode.com/problems/validate-binary-search-tree/solution/\\n\\n**If you like it please upvote ,it inspires me **",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root,Long.MIN_VALUE,Long.MAX_VALUE);       \\n    }\\n    public boolean isValid(TreeNode root,long least,long max){\\n        if(root==null) return true;\\n        if(root.left!=null&&(root.left.val>=root.val||root.left.val<=least)) return false;\\n        if(root.right!=null&&(root.right.val<=root.val||root.right.val>=max)) return false;\\n        return isValid(root.left,least,root.val)&&isValid(root.right,root.val,max);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3221320,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\\n        if (root == null) return true;\\n        if (root.val >= maxVal || root.val <= minVal) return false;\\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\\n        if (root == null) return true;\\n        if (root.val >= maxVal || root.val <= minVal) return false;\\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413874,
                "title": "easiest-3-lines-recursive-solution",
                "content": "**Easiest 3 lines recursive solution using C++.\\nSelf Explanatory**\\n```\\n    bool isBST(TreeNode* root,long min, long max){\\n        if(root==NULL) return true;\\n        if(root->val <= min || root->val >= max) return false;\\n        return isBST(root->left,min,root->val) and isBST(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isBST(root, LONG_MIN, LONG_MAX);\\n     }\\n```\\n**Please UPVOTE if you like**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n    bool isBST(TreeNode* root,long min, long max){\\n        if(root==NULL) return true;\\n        if(root->val <= min || root->val >= max) return false;\\n        return isBST(root->left,min,root->val) and isBST(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isBST(root, LONG_MIN, LONG_MAX);\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2284839,
                "title": "c-easy-solution-inorder-approach-accepted",
                "content": "```\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n//function to get inorder traversal of the tree\\nvoid inorder(TreeNode* root, vector<int> &in){\\n\\tif(root){\\n\\t\\tinorder(root->left, in);\\n\\t\\tin.push_back(root->val);\\n\\t\\tinorder(root->right, in);\\n\\t}\\n}\\n\\n//once we get the inorder traversal, we\\'ll check if it\\'s strictly increasing or not \\nbool isValidBST(TreeNode* root) {\\n\\tvector<int> in;\\n\\tinorder(root, in);\\n\\tfor(int i=1; i<in.size(); i++)\\n\\t\\tif(in[i] <= in[i-1]) return false;        \\n\\n\\treturn true;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n//function to get inorder traversal of the tree\\nvoid inorder(TreeNode* root, vector<int> &in){\\n\\tif(root){\\n\\t\\tinorder(root->left, in);\\n\\t\\tin.push_back(root->val);\\n\\t\\tinorder(root->right, in);\\n\\t}\\n}\\n\\n//once we get the inorder traversal, we\\'ll check if it\\'s strictly increasing or not \\nbool isValidBST(TreeNode* root) {\\n\\tvector<int> in;\\n\\tinorder(root, in);\\n\\tfor(int i=1; i<in.size(); i++)\\n\\t\\tif(in[i] <= in[i-1]) return false;        \\n\\n\\treturn true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185300,
                "title": "python3-pre-order-recursive-shortest-code",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root, lessThan = float(\\'inf\\'), largerThan = float(\\'-inf\\')):\\n        if not root:\\n            return True\\n        if root.val <= largerThan or root.val >= lessThan:\\n            return False\\n        return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and self.isValidBST(root.right, lessThan, max(root.val, largerThan))\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root, lessThan = float(\\'inf\\'), largerThan = float(\\'-inf\\')):\\n        if not root:\\n            return True\\n        if root.val <= largerThan or root.val >= lessThan:\\n            return False\\n        return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and self.isValidBST(root.right, lessThan, max(root.val, largerThan))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136196,
                "title": "c-using-2-approaches-inorder-vs-lower-upper-bound",
                "content": "# Approach 1: Recursive Traversal with Valid Range\\nThe idea above could be implemented as a recursion. One compares the node value with its upper and lower limits if they are available. Then one repeats the same step recursively for left and right subtrees.\\n\\n![image](https://assets.leetcode.com/users/images/a0d82e09-5323-4657-973c-6683c032a638_1654891625.0223632.png)\\n![image](https://assets.leetcode.com/users/images/8e604d74-3b9f-4b0c-9d69-6f76a9f8c450_1654891642.1756604.png)\\n![image](https://assets.leetcode.com/users/images/ce2197cb-2fdc-4780-9b43-fb9c6dbbed7e_1654891653.190994.png)\\n![image](https://assets.leetcode.com/users/images/0b868fbe-193f-431a-b1bc-b86c633e6afa_1654891663.4470136.png)\\n```\\nclass Solution {\\npublic:\\n    bool validate(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        // Empty trees are valid BSTs.\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        // The current node\\'s value must be between low and high.\\n        if ((low != nullptr and root->val <= low->val) or\\n            (high != nullptr and root->val >= high->val)) {\\n            return false;\\n        }\\n\\n        // The left and right subtree must also be valid.\\n        return validate(root->right, root, high) and\\n               validate(root->left, low, root);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return validate(root, nullptr, nullptr);\\n    }\\n};\\n```\\n\\n# Complexity Analysis:-\\nTime complexity : O(N) since we visit each node exactly once.\\nSpace complexity : O(N) since we keep up to the entire tree.\\n\\n# Approach 2: Recursive Inorder Traversal\\n**Algorithm**\\nLet\\'s use the order of nodes in the inorder traversal Left -> Node -> Right.\\n![image](https://assets.leetcode.com/users/images/3e730632-50e2-41f7-8e4a-4156e66edaa5_1654891858.3544605.png)\\nHere the nodes are enumerated in the order you visit them, and you could follow 1-2-3-4-5 to compare different strategies.\\n\\nLeft -> Node -> Right order of inorder traversal means for BST that each element should be smaller than the next one.\\nHence the algorithm with O(N) time complexity and O(N) space complexity could be simple:\\nCompute inorder traversal list inorder.\\nCheck if each element in inorder is smaller than the next one.\\n![image](https://assets.leetcode.com/users/images/ca8fe881-77ad-4de0-bb88-3f52665e6637_1654891906.4635844.png)\\n# *Do we need to keep the whole inorder traversal list?*\\n***Actually, no. The last added inorder element is enough to ensure at each step that the tree is BST (or not). Hence one could merge both steps into one and reduce the used space.***\\n\\n```\\nclass Solution {\\nprivate:\\n    TreeNode* prev = nullptr;\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return inorder(root);\\n    }\\n\\n    bool inorder(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        if (!inorder(root->left)) {\\n            return false;\\n        }\\n        if (prev != nullptr && root->val <= prev->val) {\\n            return false;\\n        }\\n        prev = root;\\n        return inorder(root->right);\\n    }\\n};\\n```\\n# Complexity Analysis:-\\nTime complexity : O(N) in the worst case when the tree is a BST or the \"bad\" element is a rightmost leaf.\\nSpace complexity : O(N) for the space on the run-time stack.\\n\\n# Guys Please Don\\'t forget to upvote me.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validate(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        // Empty trees are valid BSTs.\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        // The current node\\'s value must be between low and high.\\n        if ((low != nullptr and root->val <= low->val) or\\n            (high != nullptr and root->val >= high->val)) {\\n            return false;\\n        }\\n\\n        // The left and right subtree must also be valid.\\n        return validate(root->right, root, high) and\\n               validate(root->left, low, root);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return validate(root, nullptr, nullptr);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    TreeNode* prev = nullptr;\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return inorder(root);\\n    }\\n\\n    bool inorder(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        if (!inorder(root->left)) {\\n            return false;\\n        }\\n        if (prev != nullptr && root->val <= prev->val) {\\n            return false;\\n        }\\n        prev = root;\\n        return inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633608,
                "title": "python-solution-easy-to-understand-inorder-traverse-explanation",
                "content": "Since the inorder traversal of a binary search tree is always in ascending order, it can be used to easily validate the BST.\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def inorder(root,arr):\\n            if not root:\\n                return\\n            inorder(root.left,arr)\\n            arr.append(root.val)\\n            inorder(root.right,arr)\\n        arr=[]\\n        inorder(root,arr)\\n        #checking whether all elements in the arr are present in ascending order\\n        #if not, then its not a valid BST\\n        for i in range(1, len(arr)): \\n            if arr[i]<=arr[i-1]:\\n                return False\\n        return True\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def inorder(root,arr):\\n            if not root:\\n                return\\n            inorder(root.left,arr)\\n            arr.append(root.val)\\n            inorder(root.right,arr)\\n        arr=[]\\n        inorder(root,arr)\\n        #checking whether all elements in the arr are present in ascending order\\n        #if not, then its not a valid BST\\n        for i in range(1, len(arr)): \\n            if arr[i]<=arr[i-1]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548797,
                "title": "inorder-must-be-sorted-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129042,
                "title": "python-morris-o-1-space-approach",
                "content": "For when the Interviewer asks for a space optimal i.e. O(1) BST traversal as a follow-up question.\\nThis is standard in-order morris traversal as a generator. The values yielded by Morris generator with BST should be strictly increasing in this problem.\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def morris(root):\\n            if not root: return None\\n            curr = root\\n            while curr:\\n                if not curr.left:\\n                    yield curr.val\\n                    curr = curr.right\\n                else:\\n                    prev = curr.left\\n                    while prev.right != None and prev.right != curr:\\n                        prev = prev.right\\n                    if prev.right == None:\\n                        prev.right = curr\\n                        curr = curr.left\\n                    elif prev.right == curr:\\n                        prev.right = None\\n                        yield curr.val\\n                        curr = curr.right\\n        prev = -math.inf\\n        for val in morris(root):\\n            if val <= prev: return False\\n            prev = val\\n        return True\\n```\\nNote: Morris traversal has an O(N) time complexity, since we visit every node in the worst case. It has a O(1) space complexity, since we merely modify (change and restore) pointers during traversal and do not make use of any stack memory.\\n---\\n<img src=\"https://assets.leetcode.com/users/images/46a0cb74-af6c-48ec-8d80-6b298cbe5e4f_1616909821.403881.png\" width=700>\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def morris(root):\\n            if not root: return None\\n            curr = root\\n            while curr:\\n                if not curr.left:\\n                    yield curr.val\\n                    curr = curr.right\\n                else:\\n                    prev = curr.left\\n                    while prev.right != None and prev.right != curr:\\n                        prev = prev.right\\n                    if prev.right == None:\\n                        prev.right = curr\\n                        curr = curr.left\\n                    elif prev.right == curr:\\n                        prev.right = None\\n                        yield curr.val\\n                        curr = curr.right\\n        prev = -math.inf\\n        for val in morris(root):\\n            if val <= prev: return False\\n            prev = val\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794511,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom)\\n    {\\n        if (!root)\\n            return true;\\n        if (root->val >= top)\\n            return false; \\n        if (root->val <= bottom)\\n            return false;\\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        if ((!root->left) && (!root->right))\\n            return true;\\n        return isBST(root, 2147483648, -2147483649);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom)\\n    {\\n        if (!root)\\n            return true;\\n        if (root->val >= top)\\n            return false; \\n        if (root->val <= bottom)\\n            return false;\\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        if ((!root->left) && (!root->right))\\n            return true;\\n        return isBST(root, 2147483648, -2147483649);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634809,
                "title": "beats-100-maintain-min-max-ranges-java",
                "content": "Make sure to use LONG for min max ranges since there are inputs in test cases having long values.\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isValidBSTUtil(TreeNode root,long min,long max){\\n        if(root == null)\\n            return true;\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        return isValidBSTUtil(root.left,min,root.val) &&\\n            isValidBSTUtil(root.right,root.val,max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isValidBSTUtil(TreeNode root,long min,long max){\\n        if(root == null)\\n            return true;\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        return isValidBSTUtil(root.left,min,root.val) &&\\n            isValidBSTUtil(root.right,root.val,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581741,
                "title": "c-shortest-solution",
                "content": "This solution uses min/max borders\\n```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) {\\n\\tif (root == null) return true;\\n\\tif (root.val <= min || root.val >= max) return false;\\n\\treturn IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n}\\n```\\n\\nThe same in one line\\n```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) => root == null || !(root.val <= min) && !(root.val >= max)\\n                                                   && IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n```\\n\\nAnother solution, doesn\\'t use borders, just a value of a previous node\\n\\n```\\npublic class Solution {\\n    int? previousNode;\\n    public bool IsValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        if (!IsValidBST(root.left) || root.val <= previousNode) return false;\\n        previousNode = root.val;\\n        return IsValidBST(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) {\\n\\tif (root == null) return true;\\n\\tif (root.val <= min || root.val >= max) return false;\\n\\treturn IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n}\\n```\n```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) => root == null || !(root.val <= min) && !(root.val >= max)\\n                                                   && IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n```\n```\\npublic class Solution {\\n    int? previousNode;\\n    public bool IsValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        if (!IsValidBST(root.left) || root.val <= previousNode) return false;\\n        previousNode = root.val;\\n        return IsValidBST(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32203,
                "title": "javascript-recursive-o-n",
                "content": "At each function call, we check if the current node value is contained between an upper and lower bounds.\\n\\nThe upper bound is reduced each time we dive in the left branch, and the lower bound is increased each time we dive in the right branch.\\n\\nindeed, all the nodes of the left branch must be lower than the current node (including the ones in right branches as long as they are deeper), and vice versa.\\n\\n```js\\nvar isValidBST = function(root, upperBound=Infinity, lowerBound=-Infinity) {\\n  if (!root) { return true; }\\n  if (root.val >= upperBound || root.val <= lowerBound) return false;\\n \\n  return isValidBST(root.left, Math.min(upperBound, root.val), lowerBound) &&\\n         isValidBST(root.right, upperBound, Math.max(lowerBound, root.val));\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar isValidBST = function(root, upperBound=Infinity, lowerBound=-Infinity) {\\n  if (!root) { return true; }\\n  if (root.val >= upperBound || root.val <= lowerBound) return false;\\n \\n  return isValidBST(root.left, Math.min(upperBound, root.val), lowerBound) &&\\n         isValidBST(root.right, upperBound, Math.max(lowerBound, root.val));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32234,
                "title": "python-simple-and-clean-recursive-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def valid(node, lower, upper):\\n            if not node:\\n                return True\\n            if lower is not None and node.val <= lower:\\n                return False\\n            if upper is not None and node.val >= upper:\\n                return False\\n            return valid(node.left, lower, node.val) and valid(node.right, node.val, upper)\\n        return valid(root, None, None)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def valid(node, lower, upper):\\n            if not node:\\n                return True\\n            if lower is not None and node.val <= lower:\\n                return False\\n            if upper is not None and node.val >= upper:\\n                return False\\n            return valid(node.left, lower, node.val) and valid(node.right, node.val, upper)\\n        return valid(root, None, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32295,
                "title": "java-solution-with-recursion",
                "content": "    public class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       return isValidBST(root,null,null);\\n       \\n    }\\n    private boolean isValidBST(TreeNode root, Integer max, Integer min){\\n           if(root==null)   return true;\\n           if(max!=null&&root.val>=max)\\n             return false;\\n           if(min!=null&&root.val<=min)\\n             return false;\\n           return isValidBST(root.left,root.val,min)&&isValidBST(root.right,max,root.val); \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       return isValidBST(root,null,null);\\n       \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32312,
                "title": "clean-small-c-code-3-line-implementation-16ms",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool val(TreeNode* root,long long int minrange,long long int maxrange)\\n        {\\n            if(root==NULL)return true;\\n            if(root->val>minrange&&root->val<maxrange&&val(root->left,minrange,root->val)&&val(root->right,root->val,maxrange))return true;\\n            return false;\\n        }\\n        bool isValidBST(TreeNode* root) {\\n            return val(root,-2147483650,2147483650);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool val(TreeNode* root,long long int minrange,long long int maxrange)\\n        {\\n            if(root==NULL)return true;\\n            if(root->val>minrange&&root->val<maxrange&&val(root->left,minrange,root->val)&&val(root->right,root->val,maxrange))return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32314,
                "title": "very-short-and-concise-java-solution-easy-to-understand",
                "content": "        public boolean isValidBST(TreeNode root) {\\n            return validateRange(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }\\n     \\n        private boolean validateRange(TreeNode root, long min, long max) {\\n            if (root == null) return true;\\n            if (!(root.val > min && root.val < max)) return false;\\n            return validateRange(root.left, min, (long) root.val) \\n            && validateRange(root.right, (long) root.val, max);\\n        }\\n\\nWe take advantages on the constraint of the range for the value in a BST.",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "        public boolean isValidBST(TreeNode root) {\\n            return validateRange(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }\\n     \\n        private boolean validateRange(TreeNode root, long min, long max) {\\n            if (root == null) return true;\\n            if (!(root.val > min && root.val < max)) return false;\\n            return validateRange(root.left, min, (long) root.val) \\n            && validateRange(root.right, (long) root.val, max);\\n        }\\n\\nWe take advantages on the constraint of the range for the value in a BST.",
                "codeTag": "Unknown"
            },
            {
                "id": 32426,
                "title": "simple-and-10-lines-c-recurive-solution",
                "content": "    class Solution {\\n        public:\\n            bool isValidBST(TreeNode *root) {\\n                long long min = LLONG_MIN, max = LLONG_MAX;\\n                return isValidBST(root, min, max);\\n            }\\n            bool isValidBST(TreeNode *node, long long min, long long max){\\n                if(node == NULL)\\n                    return true;\\n                if(node->val <= min || node->val >= max)\\n                    return false;\\n                if(!isValidBST(node->left, min, node->val) || !isValidBST(node->right, node->val, max))\\n                    return false;\\n                return true;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            bool isValidBST(TreeNode *root) {\\n                long long min = LLONG_MIN, max = LLONG_MAX;\\n                return isValidBST(root, min, max);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3487254,
                "title": "simple-dfs-solution-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince all the nodes in the left-sub-tree should be less than the current node, and all the nodes in the right-sub-tree should be greater than the current node, we can iterate down to check if each node satisfies the condition, that is it should be in a range (min, max) where max for nodes in left-sub-tree and min for right-sub-tree is the parent node vlaue.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - as we need to visit all nodes once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we do not use any extra space\\n**But**, if we consider the space occupied in the memory by the stacking-recursive function call (function-call stack), we can it is O(n)\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return Evaluate(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool Evaluate(TreeNode node, long min, long max)\\n    {\\n        if (node == null)\\n        {\\n            return true;\\n        }\\n\\n        return (\\n            node.val > min &&\\n            node.val < max &&\\n            Evaluate(node.left, min, node.val) &&\\n            Evaluate(node.right, node.val, max)\\n        );\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return Evaluate(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool Evaluate(TreeNode node, long min, long max)\\n    {\\n        if (node == null)\\n        {\\n            return true;\\n        }\\n\\n        return (\\n            node.val > min &&\\n            node.val < max &&\\n            Evaluate(node.left, min, node.val) &&\\n            Evaluate(node.right, node.val, max)\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356533,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static boolean isValid(TreeNode root,TreeNode min ,TreeNode max){\\n        if(root==null){\\n            return true;\\n        }\\n        if(min!=null && root.val<=min.val){\\n            return false;\\n        }\\n        if(max!=null && root.val>=max.val){\\n            return false;\\n        }\\n        return isValid(root.left,min,root)&&isValid(root.right,root,max);\\n\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n    if(isValid(root,null,null)){\\n          return true;\\n      }\\n      else{\\n           return false;\\n    \\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static boolean isValid(TreeNode root,TreeNode min ,TreeNode max){\\n        if(root==null){\\n            return true;\\n        }\\n        if(min!=null && root.val<=min.val){\\n            return false;\\n        }\\n        if(max!=null && root.val>=max.val){\\n            return false;\\n        }\\n        return isValid(root.left,min,root)&&isValid(root.right,root,max);\\n\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n    if(isValid(root,null,null)){\\n          return true;\\n      }\\n      else{\\n           return false;\\n    \\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249901,
                "title": "python3-simple-solution-uwu",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode], min_val=float(\\'-inf\\'), max_val=float(\\'inf\\')) -> bool:\\n        if not root:\\n            return True\\n\\n        if root.val <= min_val or root.val >= max_val:\\n            return False\\n\\n        left_valid = self.isValidBST(root.left, min_val, root.val)\\n        right_valid = self.isValidBST(root.right, root.val, max_val)\\n\\n        return left_valid and right_valid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode], min_val=float(\\'-inf\\'), max_val=float(\\'inf\\')) -> bool:\\n        if not root:\\n            return True\\n\\n        if root.val <= min_val or root.val >= max_val:\\n            return False\\n\\n        left_valid = self.isValidBST(root.left, min_val, root.val)\\n        right_valid = self.isValidBST(root.right, root.val, max_val)\\n\\n        return left_valid and right_valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020203,
                "title": "0ms-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode pre=null;\\n    public boolean isValidBST(TreeNode root) {\\n    \\n     if(root!=null){\\n         if(!isValidBST(root.left)) return false;\\n         if(pre!=null && root.val<=pre.val) return false;\\n         pre=root;\\n         return isValidBST(root.right);\\n     }   \\n     return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode pre=null;\\n    public boolean isValidBST(TreeNode root) {\\n    \\n     if(root!=null){\\n         if(!isValidBST(root.left)) return false;\\n         if(pre!=null && root.val<=pre.val) return false;\\n         pre=root;\\n         return isValidBST(root.right);\\n     }   \\n     return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708912,
                "title": "java-easy-solution-using-recursion",
                "content": "\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n      return checker(root, null, null);  \\n    }\\n    public boolean checker(TreeNode root, Integer min, Integer max) {\\n        if(root == null) return true;\\n\\n        if((min != null && root.val <= min) || (max != null && root.val >= max))\\n        return false;\\n\\n        return checker(root.left, min, root.val) && checker(root.right, root.val, max);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n      return checker(root, null, null);  \\n    }\\n    public boolean checker(TreeNode root, Integer min, Integer max) {\\n        if(root == null) return true;\\n\\n        if((min != null && root.val <= min) || (max != null && root.val >= max))\\n        return false;\\n\\n        return checker(root.left, min, root.val) && checker(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431031,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.***\\n**Also you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\nhttps://www.youtube.com/watch?v=geBeUvcMMwo\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409352,
                "title": "c-2-methods-inorder-and-recursion-better-than-96-27-comments",
                "content": "Method 1: using InOrder Traversal\\n```\\nprivate:\\n\\tvector<int> tree;\\npublic:\\n\\tvoid inOrder(TreeNode* root) {\\n\\t// if root value is null\\n\\t\\tif (!root)\\n\\t\\t\\treturn;\\n\\t\\tinOrder(root->left);\\n\\t\\ttree.push_back(root->val);\\n\\t\\tinOrder(root->right);\\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif (!root)\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t// getting the inorder traversal of the tree\\n\\t\\tinOrder(root);\\n\\t\\tfor (int i=1; i<tree.size(); i++)\\n\\t\\t\\tif (tree[i] <= tree[i-1])\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true; \\n\\t}\\n```\\n![image](https://assets.leetcode.com/users/images/245bf7a5-b24a-4d1e-96cf-bba40d32fb61_1660189798.6316102.png)\\n\\nMethod 2: using Recursion\\n```\\nbool helper(TreeNode* root, long long low, long long high){\\n\\t\\tif(!root)   return true;\\n\\t\\tif(root->val<=low || root->val>=high)   return false;\\n\\t\\treturn helper(root->left, low, root->val) && \\n\\t\\t\\t\\thelper(root->right, root->val, high);            \\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif(!root)   return true;\\n\\t\\t// used long long \\n\\t\\treturn helper(root, -21474836470, 21474836470);\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nprivate:\\n\\tvector<int> tree;\\npublic:\\n\\tvoid inOrder(TreeNode* root) {\\n\\t// if root value is null\\n\\t\\tif (!root)\\n\\t\\t\\treturn;\\n\\t\\tinOrder(root->left);\\n\\t\\ttree.push_back(root->val);\\n\\t\\tinOrder(root->right);\\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif (!root)\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t// getting the inorder traversal of the tree\\n\\t\\tinOrder(root);\\n\\t\\tfor (int i=1; i<tree.size(); i++)\\n\\t\\t\\tif (tree[i] <= tree[i-1])\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true; \\n\\t}\\n```\n```\\nbool helper(TreeNode* root, long long low, long long high){\\n\\t\\tif(!root)   return true;\\n\\t\\tif(root->val<=low || root->val>=high)   return false;\\n\\t\\treturn helper(root->left, low, root->val) && \\n\\t\\t\\t\\thelper(root->right, root->val, high);            \\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif(!root)   return true;\\n\\t\\t// used long long \\n\\t\\treturn helper(root, -21474836470, 21474836470);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045697,
                "title": "js-simple-explained-in-order-traversal",
                "content": "# 98. Validate Binary Search Tree\\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n## The Question\\nFor this article we will be covering Leetcode \\'[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\\' question. This question is rated as a **Medium** question.\\n\\nQuestion:\\n\\n> Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).\\n> \\n> **A valid BST** is defined as follows:\\n> - The left subtree of a node contains only nodes with keys **less than** the `node`\\'s key.\\n> - The right subtree of a node contains only nodes with keys **greater than** the `node`\\'s key.\\n> - Both the left and right subtrees must also be binary search trees.\\n\\n\\n![BST](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\\n\\nExample:\\n```\\nInput: root = [2,1,3]\\nOutput: true\\n\\n```\\n\\n## Explaining The Question\\nThis Question is rated **Medium**. Which I believe is accurate. This question is fantastic for learning about [Binary Search Trees](https://en.wikipedia.org/wiki/Binary_search_tree) and [In order Tree Traversal](https://en.wikipedia.org/wiki/Tree_traversal). \\n\\nWhat we\\'re being asked is to validate if the given Binary Search Tree is valid or not. Meaning it comply with the rules of a Binary Search Tree. Meaning all the lesser values are on the left and all the greater values are on the right.\\n \\nMany of the solutions to this questions has you focus on the `min` and `max` values throughout the tree. This is a very common approach to solving this problem. As it checks if a min or max value is violated anywhere in the tree. Now, while this is a great approach, I think their is a simpler and better way to solve it. \\n\\nThe solution I am going to explain will have transferable knowledge to lots of other issues.\\n1. [99. Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)\\n\\n##  Recommended Knowledge\\n1. [Binary Tree](https://en.wikipedia.org/wiki/Binary_tree)\\n2. [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search)\\n3. [In-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order)\\n4. [Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree)\\n\\n## What do we know?\\n1. We have been given a ***Binary Search Tree***. It could be valid or not.\\n2. We need to validate it. \\n3. Their is always going to be at least 2 nodes. \\n\\n## How we\\'re going to do it:\\n\\nBasically, what we\\'re going to do is to traverse the Binary Tree in ***In-Order***. What this mean\\'s is that the ***NEXT*** node we visit should always be ***greater*** than the previous node. If it isn\\'t, then we know the tree is instantly invalid.\\n\\n1. Set a `flag` to `true`, this flag will be used to let us know if the tree is valid or not. By default its always valid. Until we find a node that is less than the previous node.\\n2. We will declare a previous node pointer, as we\\'re going to be keeping track of our previous node in the in-order traversal of the tree. \\n3. We will perform the in-order traversal of the tree, asking at each point in the traversal, \\'Is the current node less than the previous node?\\' If it is, then we know the tree is invalid. So we set the `flag` to `false`.\\n4. If no bad nodes are found, then we know the tree is valid and the flag remains untouched. \\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is the number of nodes in our ***Binary Search Tree*** | As we\\'re going to traverse all of the nodes within the tree.\\n* Space Complexity: *O(**h**)* | Where ***h*** is the height of the ***Binary Search Tree*** | Because we\\'re going to store the height of the tree within the [Call Stack](https://en.wikipedia.org/wiki/Call_stack) due to the [in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order).\\n\\n\\'***Could this be improved?***\\' Yes! [Morris Traversal](https://en.wikipedia.org/wiki/Tree_traversal#Morris_traversal) could do this problem in ***O(1) space complexity***. But [Morris Traversal](https://en.wikipedia.org/wiki/Tree_traversal#Morris_traversal) is tricky and tough to read. For the sake of simplicity, I don\\'t use it here. \\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 67 ms, faster than ***94.56%*** of JavaScript online submissions for Validate Binary Search Tree\\n* Memory Usage: 46.8 MB, less than ***22.46%*** of JavaScript online submissions for Validate Binary Search Tree\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/700878043/)\\n\\n\\n***\\n\\n# The Solution\\n```\\nvar isValidBST = function (root) {\\n    // This is the flag that will be returned\\n    // In the event we find a node that violates the BST property, we inverted the flag.\\n    let is_bst_valid = true;\\n\\n    // We will also be tracking the previous node.\\n    // This will be used to check if the current node is greater than the previous node.\\n    // As a valid BST, the previous node must be less than the current node.\\n    let prev_node = new TreeNode(-Infinity, null, null);\\n\\n    // We will traverse the tree in-order.\\n    // As a BST traversed in-order would result in something akin to a sorted array.\\n    // [1,2,3,4,5,6,7,8,9]\\n    // In the event we see something like this:\\n    // [1,2,3,4,*99,6,7,8,9,10]\\n    // We know it\\'s not a valid BST.\\n    const in_order_traverse = (node) => {\\n        \\n        // Empty tree. Base case.\\n        if (!node || !is_bst_valid) {\\n            return;\\n        }\\n\\n        // Get my left nodes.\\n        in_order_traverse(node.left);\\n\\n        // The in order section\\n        // Check if the current node is greater than the previous node.\\n        // If not, it\\'s a invalid tree\\n        if (node.val <= prev_node.val) {\\n            is_bst_valid = false;\\n        }\\n\\n        // Update the previous node.\\n        prev_node = node;\\n        in_order_traverse(node.right);\\n    };\\n\\n    in_order_traverse(root);\\n\\n    // Return the flag\\n    return is_bst_valid;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nInput: root = [2,1,3]\\nOutput: true\\n\\n```\n```\\nvar isValidBST = function (root) {\\n    // This is the flag that will be returned\\n    // In the event we find a node that violates the BST property, we inverted the flag.\\n    let is_bst_valid = true;\\n\\n    // We will also be tracking the previous node.\\n    // This will be used to check if the current node is greater than the previous node.\\n    // As a valid BST, the previous node must be less than the current node.\\n    let prev_node = new TreeNode(-Infinity, null, null);\\n\\n    // We will traverse the tree in-order.\\n    // As a BST traversed in-order would result in something akin to a sorted array.\\n    // [1,2,3,4,5,6,7,8,9]\\n    // In the event we see something like this:\\n    // [1,2,3,4,*99,6,7,8,9,10]\\n    // We know it\\'s not a valid BST.\\n    const in_order_traverse = (node) => {\\n        \\n        // Empty tree. Base case.\\n        if (!node || !is_bst_valid) {\\n            return;\\n        }\\n\\n        // Get my left nodes.\\n        in_order_traverse(node.left);\\n\\n        // The in order section\\n        // Check if the current node is greater than the previous node.\\n        // If not, it\\'s a invalid tree\\n        if (node.val <= prev_node.val) {\\n            is_bst_valid = false;\\n        }\\n\\n        // Update the previous node.\\n        prev_node = node;\\n        in_order_traverse(node.right);\\n    };\\n\\n    in_order_traverse(root);\\n\\n    // Return the flag\\n    return is_bst_valid;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828680,
                "title": "java-recursive-approach-100-faster",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        //for every node, maintain upper bound and lowerbound\\n        //helper func(root, lower bound, upper bound) - for recursion\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    boolean helper(TreeNode root, long min, long max){\\n        if(root==null)\\n            return true;\\n        if(root.val<=min || root.val>=max)\\n            return false;\\n        //update the lower bound for right subtree and upper bound for left subtree\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```\\nPlease upvote if it helps!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        //for every node, maintain upper bound and lowerbound\\n        //helper func(root, lower bound, upper bound) - for recursion\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    boolean helper(TreeNode root, long min, long max){\\n        if(root==null)\\n            return true;\\n        if(root.val<=min || root.val>=max)\\n            return false;\\n        //update the lower bound for right subtree and upper bound for left subtree\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628160,
                "title": "java-solution-inorder-traversal",
                "content": "We have used here the concept that if it a BST then while traversing it in inoder we will get an increasing order array or list whatever you have used in inorder to collect.\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        helper(root,list);\\n        System.out.println(list);\\n        for(int i =0;i<list.size()-1;i++){\\n            if(list.get(i+1)<=list.get(i)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public List<Integer> helper(TreeNode root,ArrayList<Integer> list){\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        \\n       helper(root.left,list);\\n        \\n        list.add(root.val);\\n      helper(root.right,list);\\n        \\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        helper(root,list);\\n        System.out.println(list);\\n        for(int i =0;i<list.size()-1;i++){\\n            if(list.get(i+1)<=list.get(i)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public List<Integer> helper(TreeNode root,ArrayList<Integer> list){\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        \\n       helper(root.left,list);\\n        \\n        list.add(root.val);\\n      helper(root.right,list);\\n        \\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382524,
                "title": "c-fast-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res; // to store inorder order traversal\\n    void solve(TreeNode* root) {\\n        if(root == NULL) return; // Base Condition\\n        solve(root->left); // Left subtree\\n        res.push_back(root->val); // Keep pushing elements in in-order manner\\n        solve(root->right); // Right subtree\\n    }\\n    bool isValidBST(TreeNode* root) {   \\n        solve(root); // fill the vector in in-order manner\\n        for(int i=1; i<res.size(); i++) {\\n            if(res[i] <= res[i-1]) // If this occurs, BST condition violates\\n                return false; // Not a valid BST\\n        }\\n        return true; // All fine if u reached here, BST is valid\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res; // to store inorder order traversal\\n    void solve(TreeNode* root) {\\n        if(root == NULL) return; // Base Condition\\n        solve(root->left); // Left subtree\\n        res.push_back(root->val); // Keep pushing elements in in-order manner\\n        solve(root->right); // Right subtree\\n    }\\n    bool isValidBST(TreeNode* root) {   \\n        solve(root); // fill the vector in in-order manner\\n        for(int i=1; i<res.size(); i++) {\\n            if(res[i] <= res[i-1]) // If this occurs, BST condition violates\\n                return false; // Not a valid BST\\n        }\\n        return true; // All fine if u reached here, BST is valid\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218926,
                "title": "intuition-explained-dfs-solution",
                "content": "This is a good problem that is based on a fundamental tree principle, which is the inorder traversal. The important take away of the inorder traversal is that it returns the values of a valid binary tree in sorted order. Keeping that in mind if a binary tree is invalid then it\\'s inordere traversal will also be unsorted. \\nThat is what we are doing in the solution we first store the inorder values of the binary tree using the inorder traversal into the inorder vector and then check if the vector is sorted or not and based on that we return true or false.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> &inorder) {\\n        \\n        if(root == NULL) \\n            return;\\n        helper(root->left, inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right, inorder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        vector<int> inorder;\\n        helper(root, inorder);\\n        \\n        int n = inorder.size();\\n        \\n        for(int i=1;i<n;i++) {\\n            if(inorder[i-1]  >= inorder[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> &inorder) {\\n        \\n        if(root == NULL) \\n            return;\\n        helper(root->left, inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right, inorder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        vector<int> inorder;\\n        helper(root, inorder);\\n        \\n        int n = inorder.size();\\n        \\n        for(int i=1;i<n;i++) {\\n            if(inorder[i-1]  >= inorder[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045913,
                "title": "python-bfs",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        \\n        while queue:\\n            currNode, min, max = queue.popleft()\\n            \\n            if currNode.val <= min or currNode.val >= max:\\n                return False\\n            \\n            if currNode.left:\\n                queue.append((currNode.left, min, currNode.val))\\n            if currNode.right:\\n                queue.append((currNode.right, currNode.val, max))\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        \\n        while queue:\\n            currNode, min, max = queue.popleft()\\n            \\n            if currNode.val <= min or currNode.val >= max:\\n                return False\\n            \\n            if currNode.left:\\n                queue.append((currNode.left, min, currNode.val))\\n            if currNode.right:\\n                queue.append((currNode.right, currNode.val, max))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044174,
                "title": "python-3-inorder-traversal-increasing-order-check-91",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        q = []\\n        def dfs(node):\\n            if not node:\\n                return \\n            dfs(node.left)\\n            q.append(node.val)\\n            dfs(node.right)\\n        dfs(root)\\n        \\n        for i in range(1,len(q)):\\n            if q[i-1]>=q[i]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        q = []\\n        def dfs(node):\\n            if not node:\\n                return \\n            dfs(node.left)\\n            q.append(node.val)\\n            dfs(node.right)\\n        dfs(root)\\n        \\n        for i in range(1,len(q)):\\n            if q[i-1]>=q[i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976329,
                "title": "my-simple-recursive-approach-in-python",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def check(root, low_range=float(\\'-inf\\'), high_range=float(\\'inf\\')):\\n            if not root:\\n                return True\\n            elif not low_range < root.val < high_range:\\n                return False\\n            \\n            return check(root.left, low_range, root.val) and check(root.right, root.val, high_range)\\n        \\n        return check(root)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def check(root, low_range=float(\\'-inf\\'), high_range=float(\\'inf\\')):\\n            if not root:\\n                return True\\n            elif not low_range < root.val < high_range:\\n                return False\\n            \\n            return check(root.left, low_range, root.val) and check(root.right, root.val, high_range)\\n        \\n        return check(root)\\n",
                "codeTag": "Java"
            },
            {
                "id": 885601,
                "title": "easy-js-solution",
                "content": "```\\n\\n/*\\nUse DFS to traverse all nodes.\\nAt each node, we check if it is a valid BST tree.\\nFor a tree to be a valid BST, its left subtree and right subtree must be valid BSTs and\\nits node value should be less than some value and greater than some value. These \\'some\\' values are updated at every node and passed to the next node.\\n*/\\nvar isValidBST = function(root) {\\n    return isValidBSTHelper(root, -Infinity, Infinity);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst isValidBSTHelper = (root, low, high) => {\\n    if (!root) {\\n        return true;\\n    }\\n    return root.val > low && root.val < high &&\\n        isValidBSTHelper(root.left, low, root.val) &&\\n        isValidBSTHelper(root.right, root.val, high);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/*\\nUse DFS to traverse all nodes.\\nAt each node, we check if it is a valid BST tree.\\nFor a tree to be a valid BST, its left subtree and right subtree must be valid BSTs and\\nits node value should be less than some value and greater than some value. These \\'some\\' values are updated at every node and passed to the next node.\\n*/\\nvar isValidBST = function(root) {\\n    return isValidBSTHelper(root, -Infinity, Infinity);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst isValidBSTHelper = (root, low, high) => {\\n    if (!root) {\\n        return true;\\n    }\\n    return root.val > low && root.val < high &&\\n        isValidBSTHelper(root.left, low, root.val) &&\\n        isValidBSTHelper(root.right, root.val, high);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819530,
                "title": "c-upper-and-lower-bound",
                "content": "\\nCan\\'t use INT_MIN and INT_MAX because of one beautiful test case :(\\n```\\nclass Solution {\\npublic:\\n    \\n    bool traverse(TreeNode* root,long long int lowerb,long long int upperb){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val<=lowerb || root->val>=upperb){\\n            return false;\\n        }\\n        return traverse(root->left,lowerb,root->val) && traverse(root->right,root->val,upperb);\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return traverse(root,LLONG_MIN,LLONG_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool traverse(TreeNode* root,long long int lowerb,long long int upperb){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val<=lowerb || root->val>=upperb){\\n            return false;\\n        }\\n        return traverse(root->left,lowerb,root->val) && traverse(root->right,root->val,upperb);\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return traverse(root,LLONG_MIN,LLONG_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265189,
                "title": "inorder-preorder-and-postorder-solution",
                "content": "In interview, it\\'s possible to be asked to implement this question in all of three tree traversal methods. If you like my solution, please upvote!\\n\\nPreorder maintains a interval in the search function\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    private boolean helper(TreeNode root, long lo, long hi) {\\n        if (root == null) return true;\\n        if (root.val >= hi || root.val <= lo) return false;\\n        return helper(root.left, lo, root.val) && helper(root.right, root.val, hi);\\n    }\\n}\\n```\\n\\nInorder maintains a previous node to compare with the current node\\n```\\nclass Solution {\\n    private TreeNode prev;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root);\\n    }\\n    \\n    private boolean helper(TreeNode root) {\\n        if (root == null) return true;\\n        if (!helper(root.left)) return false;\\n        if (prev != null && prev.val >= root.val) return false;\\n        prev = root;\\n        return helper(root.right);\\n    }\\n}\\n```\\n\\nPostorder should return a interval which represents the lower and upper bound of the subtree\\n```\\nclass Solution {\\n    private boolean ans;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        ans = true;\\n        postorder(root);\\n        return ans;\\n    }\\n    \\n    private int[] postorder(TreeNode root) {\\n        if (root == null) return null;\\n        int[] left = postorder(root.left);\\n        int[] right = postorder(root.right);\\n        if (left != null && left[1] >= root.val) ans = false;\\n        if (right != null && right[0] <= root.val) ans = false; \\n        int[] tmp = new int[2];\\n        tmp[0] = left == null ? root.val : left[0];\\n        tmp[1] = right == null ? root.val : right[1];\\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    private boolean helper(TreeNode root, long lo, long hi) {\\n        if (root == null) return true;\\n        if (root.val >= hi || root.val <= lo) return false;\\n        return helper(root.left, lo, root.val) && helper(root.right, root.val, hi);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private TreeNode prev;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root);\\n    }\\n    \\n    private boolean helper(TreeNode root) {\\n        if (root == null) return true;\\n        if (!helper(root.left)) return false;\\n        if (prev != null && prev.val >= root.val) return false;\\n        prev = root;\\n        return helper(root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private boolean ans;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        ans = true;\\n        postorder(root);\\n        return ans;\\n    }\\n    \\n    private int[] postorder(TreeNode root) {\\n        if (root == null) return null;\\n        int[] left = postorder(root.left);\\n        int[] right = postorder(root.right);\\n        if (left != null && left[1] >= root.val) ans = false;\\n        if (right != null && right[0] <= root.val) ans = false; \\n        int[] tmp = new int[2];\\n        tmp[0] = left == null ? root.val : left[0];\\n        tmp[1] = right == null ? root.val : right[1];\\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32114,
                "title": "pyhton-beats-99-77-iterative",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        stack = [None]\\n        prev = -float(\"inf\")\\n        while stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            x = stack.pop()\\n            if x:\\n                if x.val <= prev:\\n                    return False\\n                prev = x.val\\n                root = x.right\\n                \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        stack = [None]\\n        prev = -float(\"inf\")\\n        while stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            x = stack.pop()\\n            if x:\\n                if x.val <= prev:\\n                    return False\\n                prev = x.val\\n                root = x.right\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32350,
                "title": "share-my-java-inorder-simple-solution",
                "content": "    public class Solution {\\n        long tmp =Long.MIN_VALUE;\\n        public boolean isValidBST(TreeNode root) {\\n            if(root != null){\\n                boolean left = isValidBST(root.left);\\n                if(root.val<=tmp)\\n                    return false;\\n                tmp = root.val;\\n                boolean right = isValidBST(root.right);\\n                if(!left || !right)\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        long tmp =Long.MIN_VALUE;\\n        public boolean isValidBST(TreeNode root) {\\n            if(root != null){\\n                boolean left = isValidBST(root.left);\\n                if(root.val<=tmp)\\n                    return false;\\n                tmp = root.val;\\n                boolean right = isValidBST(root.right);\\n                if(!left || !right)\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32421,
                "title": "simple-java-recursion-solution",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root,null,null); \\n            \\n        }\\n        public boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\\n            if(root==null) return true;\\n            if(min!=null && root.val<=min.val) return false;\\n            if(max!=null && root.val>=max.val) return false;\\n            if(!isValidBST(root.left, min, root)) return false;\\n            if(!isValidBST(root.right, root, max)) return false;\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root,null,null); \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3344154,
                "title": "beats-100-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBs(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n\\n        public boolean isValidBs(TreeNode root, long min, long max){\\n        if(root == null)return true;\\n        if(root.val<= min || root.val >= max) return false;\\n        boolean left= isValidBs(root.left,min,root.val);\\n        boolean right = isValidBs(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBs(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n\\n        public boolean isValidBs(TreeNode root, long min, long max){\\n        if(root == null)return true;\\n        if(root.val<= min || root.val >= max) return false;\\n        boolean left= isValidBs(root.left,min,root.val);\\n        boolean right = isValidBs(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168283,
                "title": "without-inorder-easy-solution-o-n",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\n    bool isbst(TreeNode* root, long min, long max){\\n        // Base Case\\n        if( root == NULL) return true;\\n        \\n        if(root->val > min && root->val < max){\\n            bool left = isbst(root->left,min,root->val);\\n            bool right = isbst(root->right, root->val, max);\\n\\n            return left && right;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        return isbst(root, LONG_MIN,LONG_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isbst(TreeNode* root, long min, long max){\\n        // Base Case\\n        if( root == NULL) return true;\\n        \\n        if(root->val > min && root->val < max){\\n            bool left = isbst(root->left,min,root->val);\\n            bool right = isbst(root->right, root->val, max);\\n\\n            return left && right;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        return isbst(root, LONG_MIN,LONG_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823221,
                "title": "best-solution-java",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean check(TreeNode root , TreeNode min , TreeNode max){\\n        if(root == null ) return true;\\n        \\n        if(min!= null  && root.val<=min.val) return false;\\n        else if(max!=null && root.val>=max.val) return false;\\n        \\n        return check(root.left,min,root ) && check(root.right , root,max);\\n        }\\n    \\n    public boolean isValidBST(TreeNode root) {\\n       return check(root,null,null);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean check(TreeNode root , TreeNode min , TreeNode max){\\n        if(root == null ) return true;\\n        \\n        if(min!= null  && root.val<=min.val) return false;\\n        else if(max!=null && root.val>=max.val) return false;\\n        \\n        return check(root.left,min,root ) && check(root.right , root,max);\\n        }\\n    \\n    public boolean isValidBST(TreeNode root) {\\n       return check(root,null,null);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803203,
                "title": "java-solution",
                "content": "The idea is to check every node for lower and upper bound\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    public boolean helper(TreeNode root, long l, long r){\\n        if(root==null)return true;\\n\\n        if(root.val<=l || root.val>=r)return false;\\n\\n        return helper(root.right,root.val,r) && helper(root.left,l,root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    public boolean helper(TreeNode root, long l, long r){\\n        if(root==null)return true;\\n\\n        if(root.val<=l || root.val>=r)return false;\\n\\n        return helper(root.right,root.val,r) && helper(root.left,l,root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410319,
                "title": "dfs-post-order-full-visual-explanation-with-image",
                "content": "Take the time to read the post, it explains the intuition fully. Practice makes perfect :)\\n\\nIf you found this post helpful, please upvote <3\\n\\n<hr />\\n\\n# Terminology\\nFirst, let\\'s recall what is a `binary search tree`.\\n\\nBinary search tree is simply a binary tree where all values to the **left are smaller** than the current node\\'s value, and all values to the **right are bigger** than the current node\\'s value.\\n\\nSome examples of BSTs:\\n\\n![image](https://assets.leetcode.com/users/images/7c25afb7-1d9f-4ef4-a557-d08c948e309e_1660204948.035542.png)\\n\\nNow with this understanding, let\\'s tackle the problem.\\n\\n# Intuition\\n\\nKnowing what is a BST, we need to think about the **local constraints** for each subtree.\\n\\nWhenever we are working with binary trees (or any recursive data structure) we should think how to \"validate\" a subtree (subproblem), and return that answer to the parent to recursively continue the process.\\n\\n\\nLet\\'s take the previous tree as an example:\\n\\n**EDIT:** the arrows may confuse some readers. The current value must be smaller than the green arrow, and bigger than blue arrow.\\n\\n![image](https://assets.leetcode.com/users/images/621eb95b-9e0a-48c6-9a09-6a7ad11fd986_1660205256.1745734.png)\\n\\n\\nWe know that the current subtree of value 4, must bigger than 3, but also smaller than the parent that branched left (because all values on the left are smaller), which is 5.\\n\\nLet\\'s call them `parent_minimum` and `parent_maximum` values.\\n\\nLet\\'s take the another example:\\n\\n![image](https://assets.leetcode.com/users/images/8e00a212-89e9-489c-ad28-4cdee52174b6_1660205364.6228054.png)\\n\\nWe know that the subtree with value 6 must be smaller than 7, because 7 is located to the right of that subtree. But also 6 must be greater than 5, because 5 is located to the left, hence the values is smaller.\\n\\nWith this idea we have everything to write the code\\n\\n# Algorithm\\nThe algorithm will run a post order DFS traversal, to first validate left and right subtrees.\\n\\nIf both subtrees are valid, we will check the constraints discussed above.\\n\\nWhenever we branch left, the current node value is the `parent_maximum`, because all values to the left must be smaller.\\n\\nWhenever we branch right, the current node value is the `parent_minimum`, because all values to the right must be greater.\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def is_valid_root(node, parent_maximum, parent_minimum):\\n            if not node: return True\\n            \\n            # Check left side\\n            if not is_valid_root(node.left, node.val, parent_minimum): return False\\n            \\n            # Check right side\\n            if not is_valid_root(node.right, parent_maximum ,node.val): return False\\n            \\n            # Check constraints with current node\\n            if node.val >= parent_maximum or node.val <= parent_minimum: return False\\n            \\n            # Otherwise we are good\\n            return True\\n            \\n        \\n        return is_valid_root(root, float(\\'inf\\'), float(\\'-inf\\'))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def is_valid_root(node, parent_maximum, parent_minimum):\\n            if not node: return True\\n            \\n            # Check left side\\n            if not is_valid_root(node.left, node.val, parent_minimum): return False\\n            \\n            # Check right side\\n            if not is_valid_root(node.right, parent_maximum ,node.val): return False\\n            \\n            # Check constraints with current node\\n            if node.val >= parent_maximum or node.val <= parent_minimum: return False\\n            \\n            # Otherwise we are good\\n            return True\\n            \\n        \\n        return is_valid_root(root, float(\\'inf\\'), float(\\'-inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410270,
                "title": "c-3-approach",
                "content": "In this question we are given an Binary Tree and we have to create a program that check given Binary Tree is Binary Search Tree or not \\nA valid BST mean:\\n* Value of root should be greater than all left nodes\\n* Value of root should be lesser than all right nodes\\n## Approach1:\\n1.  Get maximum from leftsubtree and store it in leftmax variable.\\n2.  Get minimum from rightsubtree and store it in rightmin variable \\n3. leftmax should be smaller than node value and rightmin should be greater than node value if it is then we made two recursive call to check left subtree and right subtree for that node.\\n4. if this won\\'t happen or condition is false then our BST isn\\'t valid BST. \\n5. The reason why we use long long and LONG_MAX or LONG_MIN because of its constraint -2^31 <= Node.val <= 2^31 - 1 at testcase no. 72 that is [2147483647] that why our INT_MIN and INT_MAX won\\'t work for that testcase so we use long long , LONG_MAX , LONG_MIN.\\n5. Reason why we create min,max function it can work only for int , if value is not in integer range so it won\\'t work .\\n```\\nclass Solution {\\npublic:\\n\\n  long long functionmin(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long functionmax(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    \\n    long long Minimum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MAX;\\n        }\\n        return functionmin(root->val,functionmin(Minimum(root->left),Minimum(root->right)));\\n        \\n    }\\n    long long Maximum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MIN;\\n        }\\n        return functionmax(root->val,functionmax(Maximum(root->left),Maximum(root->right)));\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        long long  leftmax=Maximum(root->left);\\n        long long  rightmin=Minimum(root->right);\\n       \\n        return (root->val>leftmax)&&(root->val<rightmin)&&isValidBST(root->left)&&isValidBST(root->right);\\n        \\n        \\n    }\\n};\\n\\n```\\n\\n## Approach2\\n\\n1. This is similar as first approach but its Time Complexity is lesser than first appraoch because in this appraoch we\\'ll not call minimum and maximum function at every recursive call.\\n2. We\\'re creating a class that hold minimum ,maximum and isBst of tree .\\n3. Leftoutput and rightoutput contain max,min,isbst for respective subtrees.\\n4. Leftoutput->isBst and Rightoutput->isBst should be true , Rightoutput.minimum value should be greater than root value and Leftoutput.maximum value should be lesse than root value whether it is true or false ,we store it in output.bst and we also calculate  minimum and maximum for output.\\n```\\nclass Solution {\\npublic:\\n      long long min(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long max(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    class CheckBst\\n    {\\n        public:\\n        long long maximum;\\n        long long minimum;\\n        bool isbst;\\n    };\\n    CheckBst Helper(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            CheckBst output;\\n            output.maximum=LONG_MIN;\\n            output.minimum=LONG_MAX;\\n            output.isbst=true;\\n            return output;\\n        }\\n        CheckBst leftoutput=Helper(root->left);\\n        CheckBst rightoutput=Helper(root->right);\\n        CheckBst output;\\n        output.isbst=(leftoutput.isbst)&&(rightoutput.isbst)&&(leftoutput.maximum<root->val)&&(rightoutput.minimum>root->val);\\n        output.maximum=max(root->val,max(leftoutput.maximum,rightoutput.maximum));\\n        output.minimum=min(root->val,min(leftoutput.minimum,rightoutput.minimum));\\n        return output;\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\nCheckBst ans=Helper(root);\\n        return ans.isbst;\\n    }\\n};\\n```\\n\\n## Approach3\\n![image](https://assets.leetcode.com/users/images/60971896-df7f-478d-bbaa-63eba83be334_1660201230.3960164.jpeg =250x)`\\ncheck  \\u261D\\uFE0F image to understand more\\n1. Range of value of left node is between -\\u221E to root value\\n2. Range of value of right node is between  root value to \\u221E\\n3. Root value should be within the range of maxi and mini if it\\'s value out of the  bound then we we return false \\n```\\n\\nclass Solution {\\npublic:\\n\\n  \\n    bool isValidBST(TreeNode* root,long long maxi=LONG_MAX,long long mini=LONG_MIN) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->val>=maxi||root->val<=mini)\\n        {\\n            return false;\\n        }\\n        \\n        return isValidBST(root->left,root->val,mini)&&(isValidBST(root->right,maxi,root->val));          \\n        \\n    }\\n};\\n\\n```\\n\\nIf it helpful for you then make sure you upvote it\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n  long long functionmin(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long functionmax(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    \\n    long long Minimum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MAX;\\n        }\\n        return functionmin(root->val,functionmin(Minimum(root->left),Minimum(root->right)));\\n        \\n    }\\n    long long Maximum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MIN;\\n        }\\n        return functionmax(root->val,functionmax(Maximum(root->left),Maximum(root->right)));\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        long long  leftmax=Maximum(root->left);\\n        long long  rightmin=Minimum(root->right);\\n       \\n        return (root->val>leftmax)&&(root->val<rightmin)&&isValidBST(root->left)&&isValidBST(root->right);\\n        \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n      long long min(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long max(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    class CheckBst\\n    {\\n        public:\\n        long long maximum;\\n        long long minimum;\\n        bool isbst;\\n    };\\n    CheckBst Helper(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            CheckBst output;\\n            output.maximum=LONG_MIN;\\n            output.minimum=LONG_MAX;\\n            output.isbst=true;\\n            return output;\\n        }\\n        CheckBst leftoutput=Helper(root->left);\\n        CheckBst rightoutput=Helper(root->right);\\n        CheckBst output;\\n        output.isbst=(leftoutput.isbst)&&(rightoutput.isbst)&&(leftoutput.maximum<root->val)&&(rightoutput.minimum>root->val);\\n        output.maximum=max(root->val,max(leftoutput.maximum,rightoutput.maximum));\\n        output.minimum=min(root->val,min(leftoutput.minimum,rightoutput.minimum));\\n        return output;\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\nCheckBst ans=Helper(root);\\n        return ans.isbst;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n\\n  \\n    bool isValidBST(TreeNode* root,long long maxi=LONG_MAX,long long mini=LONG_MIN) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->val>=maxi||root->val<=mini)\\n        {\\n            return false;\\n        }\\n        \\n        return isValidBST(root->left,root->val,mini)&&(isValidBST(root->right,maxi,root->val));          \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197682,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Recursive solution:\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, min_val=float(\"-inf\"), max_val=float(\"inf\")):\\n            if root is None:\\n                return True\\n            \\n            return (min_val < root.val < max_val and helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val))\\n        return helper(root)\\n```\\n\\nIterative Solution:\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        queue = deque()\\n        queue.append((root, float(\"-inf\"), float(\"inf\")))\\n        \\n        while queue:\\n            node, min_val, max_val = queue.popleft()\\n            if node:\\n                if min_val >= node.val or node.val >= max_val:\\n                    return False\\n                if node.left:\\n                    queue.append((node.left, min_val, node.val))\\n                \\n                if node.right:\\n                    queue.append((node.right, node.val, max_val))\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, min_val=float(\"-inf\"), max_val=float(\"inf\")):\\n            if root is None:\\n                return True\\n            \\n            return (min_val < root.val < max_val and helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val))\\n        return helper(root)\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        queue = deque()\\n        queue.append((root, float(\"-inf\"), float(\"inf\")))\\n        \\n        while queue:\\n            node, min_val, max_val = queue.popleft()\\n            if node:\\n                if min_val >= node.val or node.val >= max_val:\\n                    return False\\n                if node.left:\\n                    queue.append((node.left, min_val, node.val))\\n                \\n                if node.right:\\n                    queue.append((node.right, node.val, max_val))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965947,
                "title": "c-with-explanation-inordertravrsal-recursion-98-validate-binary-search-tree",
                "content": "If The **Inorder** **traversal** of the given **BST** gives values in **Sorted** **order** then the given **BST** **will** **be** **valid** else BST will be invalid  \\n\\n\\t class Solution {\\n\\t\\tpublic:\\n\\t\\t   void inorder(TreeNode*root,vector<int>&ans)\\n\\t\\t   {\\n\\t\\t\\t   if(!root) return;\\n\\t\\t\\t   inorder(root->left,ans);\\n\\t\\t\\t   ans.push_back(root->val);\\n\\t\\t\\t   inorder(root->right,ans);\\n\\t\\t   }\\n\\t\\t\\tbool isValidBST(TreeNode* root) {\\n\\t\\t\\t\\tvector<int>v;\\n\\t\\t\\t\\tinorder(root,v);\\n\\t\\t\\t\\tfor(int i=1;i<v.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(v[i]<=v[i-1]) // if not in order  \\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if we can be able to come out of loop it means all elements are in order  \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t   void inorder(TreeNode*root,vector<int>&ans)\\n\\t\\t   {\\n\\t\\t\\t   if(!root) return;\\n\\t\\t\\t   inorder(root->left,ans);\\n\\t\\t\\t   ans.push_back(root->val);\\n\\t\\t\\t   inorder(root->right,ans);\\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1570606,
                "title": "python-3-simple-recursion",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, low, high):\\n            if root is None:\\n                return True\\n            \\n            if root.val <= low or root.val >= high:\\n                return False\\n            \\n            return helper(root.left, low, root.val) and helper(root.right, root.val, high)\\n        \\n        return helper(root, -math.inf, math.inf)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, low, high):\\n            if root is None:\\n                return True\\n            \\n            if root.val <= low or root.val >= high:\\n                return False\\n            \\n            return helper(root.left, low, root.val) and helper(root.right, root.val, high)\\n        \\n        return helper(root, -math.inf, math.inf)",
                "codeTag": "Java"
            },
            {
                "id": 1548781,
                "title": "c-solution-inorder-vector-method",
                "content": "```\\n    void getOrder(TreeNode* root, vector<int> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root->val);\\n        getOrder(root->right, inOrder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> inOrder;\\n        getOrder(root, inOrder);\\n        if(inOrder.size() == 1) return true;\\n        for(int i = 1; i < inOrder.size(); i++) {\\n            if(inOrder[i] <= inOrder[i-1]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void getOrder(TreeNode* root, vector<int> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root->val);\\n        getOrder(root->right, inOrder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> inOrder;\\n        getOrder(root, inOrder);\\n        if(inOrder.size() == 1) return true;\\n        for(int i = 1; i < inOrder.size(); i++) {\\n            if(inOrder[i] <= inOrder[i-1]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519922,
                "title": "python-o-nlogn-o-n-multiple-simple-solutions",
                "content": "## Solution 1 - O(nlogn)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def inorderTraversal(self, root, inorder):\\n        if root:\\n            self.inorderTraversal(root.left, inorder)\\n            inorder.append(root.val)\\n            self.inorderTraversal(root.right, inorder)\\n            \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        inorder = []\\n        self.inorderTraversal(root, inorder)\\n        \"\"\"\\n            Since inorder traversal of BST gives a sorted array so if inorder traversal of given BST is not sorted then it is not a valid BST.\\n            To overcome duplicates we need to verify the length of inorder array and inorder hash set as BST can\\'t have duplicates.\\n        \"\"\"\\n        return inorder == sorted(inorder) and len(inorder) == len(set(inorder))\\n```\\n\\n## Solution 2 - O(n)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def isValidBST(self, root: Optional[TreeNode], left=-sys.maxsize, right=sys.maxsize) -> bool:\\n        if not root:\\n            return True\\n        if left >= root.val or right <= root.val:\\n            return False\\n        return self.isValidBST(root.left, left, root.val) and self.isValidBST(root.right, root.val, right)\\n```\\n\\n***If you liked the above solutions then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def inorderTraversal(self, root, inorder):\\n        if root:\\n            self.inorderTraversal(root.left, inorder)\\n            inorder.append(root.val)\\n            self.inorderTraversal(root.right, inorder)\\n            \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        inorder = []\\n        self.inorderTraversal(root, inorder)\\n        \"\"\"\\n            Since inorder traversal of BST gives a sorted array so if inorder traversal of given BST is not sorted then it is not a valid BST.\\n            To overcome duplicates we need to verify the length of inorder array and inorder hash set as BST can\\'t have duplicates.\\n        \"\"\"\\n        return inorder == sorted(inorder) and len(inorder) == len(set(inorder))\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def isValidBST(self, root: Optional[TreeNode], left=-sys.maxsize, right=sys.maxsize) -> bool:\\n        if not root:\\n            return True\\n        if left >= root.val or right <= root.val:\\n            return False\\n        return self.isValidBST(root.left, left, root.val) and self.isValidBST(root.right, root.val, right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505663,
                "title": "java-solution-easy-short-clean",
                "content": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    private boolean valid(TreeNode root, long min, long max){\\n        if(root == null)    return true;\\n        if(root.val>min && root.val<max)    \\n            return(valid(root.left, min, root.val) && valid(root.right, root.val, max));\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    private boolean valid(TreeNode root, long min, long max){\\n        if(root == null)    return true;\\n        if(root.val>min && root.val<max)    \\n            return(valid(root.left, min, root.val) && valid(root.right, root.val, max));\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346591,
                "title": "c-3-solutions-efficient-simple-easy-to-understand",
                "content": "**1st Approach: Direct Implementation of Definition of BST using Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidBSTUtil(TreeNode* root, long long int maximum, long long int minimum){\\n        if(root == NULL)\\n            return true;\\n        if(root->val >= maximum || root->val <= minimum)\\n            return false;\\n        if(isValidBSTUtil(root->left, root->val, minimum) \\n           && isValidBSTUtil(root->right, maximum, root->val)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTUtil(root, LONG_MAX, LONG_MIN);\\n    }\\n};\\n```\\n\\n**2nd Approach: Using Inorder Traversal and Extra Space**\\n\\n```\\nclass Solution {\\n    vector<int> tree;\\npublic:\\n   void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**3rd Approach: Similar to 2nd Approach without storing all values**\\n\\n```\\nclass Solution {\\npublic:\\n    bool validateBST(TreeNode* root, TreeNode* &prev){\\n        if(root == NULL) return true;\\n        if(!(validateBST(root->left, prev))) return false;\\n        if(prev != NULL && prev->val >= root->val) return false;\\n        prev = root;\\n        return validateBST(root->right, prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return validateBST(root, prev);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBSTUtil(TreeNode* root, long long int maximum, long long int minimum){\\n        if(root == NULL)\\n            return true;\\n        if(root->val >= maximum || root->val <= minimum)\\n            return false;\\n        if(isValidBSTUtil(root->left, root->val, minimum) \\n           && isValidBSTUtil(root->right, maximum, root->val)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTUtil(root, LONG_MAX, LONG_MIN);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> tree;\\npublic:\\n   void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool validateBST(TreeNode* root, TreeNode* &prev){\\n        if(root == NULL) return true;\\n        if(!(validateBST(root->left, prev))) return false;\\n        if(prev != NULL && prev->val >= root->val) return false;\\n        prev = root;\\n        return validateBST(root->right, prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return validateBST(root, prev);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187373,
                "title": "90-faster-inorder-traversal-c",
                "content": "***Do upvote if you found the solution helpful to keep me motivated*** \\u270C\\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root , vector<int> &v)\\n    {\\n        if(root == NULL)\\n            return;\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\t\\n    bool isValidBST(TreeNode* root) {\\n     vector<int> v;\\n     solve(root,v);\\n     for(int i=0 ; i<v.size()-1 ;i++)\\n     {\\n         if(v[i] >= v[i+1])\\n          return false;\\n     }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root , vector<int> &v)\\n    {\\n        if(root == NULL)\\n            return;\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\t\\n    bool isValidBST(TreeNode* root) {\\n     vector<int> v;\\n     solve(root,v);\\n     for(int i=0 ; i<v.size()-1 ;i++)\\n     {\\n         if(v[i] >= v[i+1])\\n          return false;\\n     }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151410,
                "title": "python-recursion-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def helper(root, min_val, max_val):\\n            if not root:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\\n        return helper(root, -float(\\'inf\\'), float(\\'inf\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def helper(root, min_val, max_val):\\n            if not root:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\\n        return helper(root, -float(\\'inf\\'), float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144855,
                "title": "easy-inorder-traversal-using-vector-c",
                "content": "**Observation**: Inorder traversal (left subtree, root, right subtree) of a Binary Search Tree would always give the node values in an increasing order.\\nHence we store the values of the nodes in a vector and check if the vector is strictly increasing. If not, return false, else return true.\\n\\n```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root, vector<int>& res){\\n        if(root==NULL) return;\\n        inOrder(root->left, res);\\n        res.push_back(root->val);\\n        inOrder(root->right, res);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL) return true;\\n        vector<int> res;\\n        inOrder(root, res);\\n        for(int i=0; i<res.size()-1; i++){\\n            if(res[i]>=res[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root, vector<int>& res){\\n        if(root==NULL) return;\\n        inOrder(root->left, res);\\n        res.push_back(root->val);\\n        inOrder(root->right, res);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL) return true;\\n        vector<int> res;\\n        inOrder(root, res);\\n        for(int i=0; i<res.size()-1; i++){\\n            if(res[i]>=res[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052667,
                "title": "pair-approach-helpful-in-many-lc-problems",
                "content": "`Please give a upvote if you like else comment for any doubts.`\\n\\n**Approach:** The idea is to use traverse the tree recursively and in each recursive calls return a pair of minimum element, maximum element and the current subtree is BST or not. After each Left and Right recursive calls ends check if the root having these LST and RST follows the BST property or not. If found to be true then return the corresponding pairs to it\\'s parent.\\n\\nBelow is the implementation of the same:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // From each recursive calls return the\\n    // minimum, maximum and isBST flag for\\n    // each subtree\\n    pair<pair<long long int, long long int>, bool> dfs(TreeNode *root) {\\n        \\n        // If root is NULL then it is BST\\n        // return the MAX, MIN, true\\n        // and MAX is return as minimum value \\n        // to validate the BST property for node\\n        // having at least 1 leaf node`\\n        if(root == NULL) {\\n            return {{LLONG_MAX, LLONG_MIN}, true};\\n        }\\n        \\n        // Left and Right Calls\\n        pair<pair<long long int, long long int>, bool> P1 = dfs(root->left);\\n        pair<pair<long long int, long long int>, bool> P2 = dfs(root->right);\\n        \\n        // Find the if the current root is BST\\n        // LST and RST is also BST\\n        bool ans = P1.second && P2.second\\n                    && (root->val > P1.first.second\\n                        && root->val < P2.first.first);\\n        \\n        // Find the current minimum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int minimum = min(1LL*root->val,\\n                                    min(P1.first.first,\\n                                        P2.first.first));\\n        \\n        // Find the current maximum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int maximum = max(1LL*root->val,\\n                                    max(P1.first.second,\\n                                        P2.first.second));\\n        \\n        // Return the corresponding pair for\\n        // each recursive calls\\n        return {{minimum, maximum}, ans};\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        \\n        if(root->left == NULL\\n           and root->right == NULL) return true;\\n        \\n        pair<pair<long long int, long long int>, bool> P = dfs(root);\\n        return P.second;\\n    }\\n};\\n```\\n*Time Complexity: O(N)\\nAuxiliary Space: O(H), where H is the maximum height of the tree.*",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // From each recursive calls return the\\n    // minimum, maximum and isBST flag for\\n    // each subtree\\n    pair<pair<long long int, long long int>, bool> dfs(TreeNode *root) {\\n        \\n        // If root is NULL then it is BST\\n        // return the MAX, MIN, true\\n        // and MAX is return as minimum value \\n        // to validate the BST property for node\\n        // having at least 1 leaf node`\\n        if(root == NULL) {\\n            return {{LLONG_MAX, LLONG_MIN}, true};\\n        }\\n        \\n        // Left and Right Calls\\n        pair<pair<long long int, long long int>, bool> P1 = dfs(root->left);\\n        pair<pair<long long int, long long int>, bool> P2 = dfs(root->right);\\n        \\n        // Find the if the current root is BST\\n        // LST and RST is also BST\\n        bool ans = P1.second && P2.second\\n                    && (root->val > P1.first.second\\n                        && root->val < P2.first.first);\\n        \\n        // Find the current minimum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int minimum = min(1LL*root->val,\\n                                    min(P1.first.first,\\n                                        P2.first.first));\\n        \\n        // Find the current maximum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int maximum = max(1LL*root->val,\\n                                    max(P1.first.second,\\n                                        P2.first.second));\\n        \\n        // Return the corresponding pair for\\n        // each recursive calls\\n        return {{minimum, maximum}, ans};\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        \\n        if(root->left == NULL\\n           and root->right == NULL) return true;\\n        \\n        pair<pair<long long int, long long int>, bool> P = dfs(root);\\n        return P.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562349,
                "title": "simple-javascript-solution-recursive-clean",
                "content": "Runtime: 52 ms, faster than 99.19% of JavaScript online submissions for Validate Binary Search Tree.\\nMemory Usage: 37.1 MB, less than 100.00% of JavaScript online submissions for Validate Binary Search Tree.\\n```\\nfunction isValidBST(root, min, max) {\\n  if (!root) { \\n    return true;\\n  }\\n\\n  if (min !== undefined && root.val <= min) {\\n    return false;\\n  }\\n\\n  if (max !== undefined && root.val >= max) { \\n    return false;\\n  }\\n \\n  return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max); \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isValidBST(root, min, max) {\\n  if (!root) { \\n    return true;\\n  }\\n\\n  if (min !== undefined && root.val <= min) {\\n    return false;\\n  }\\n\\n  if (max !== undefined && root.val >= max) { \\n    return false;\\n  }\\n \\n  return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520381,
                "title": "c-really-easy-in-order-traversal-solution-90-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // base case\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        \\n        // visit the left sub-tree\\n        if (!isValidBST(root->left)) {\\n            return false;\\n        }\\n        \\n        // an in-order traversal of a valid binary search tree\\n        // will always process nodes in-order. if the pervious\\n        // node is larger than current value, this condition\\n        // fails and we can assume that the tree isn\\'t a valid BST\\n        if (previous && previous->val >= root->val) {\\n            return false;\\n        }\\n        \\n        // set the previous node to the current node\\n        previous = root;\\n        \\n        // visit the right sub-tree\\n        return isValidBST(root->right);\\n    }\\nprivate:\\n    TreeNode* previous = nullptr;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // base case\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        \\n        // visit the left sub-tree\\n        if (!isValidBST(root->left)) {\\n            return false;\\n        }\\n        \\n        // an in-order traversal of a valid binary search tree\\n        // will always process nodes in-order. if the pervious\\n        // node is larger than current value, this condition\\n        // fails and we can assume that the tree isn\\'t a valid BST\\n        if (previous && previous->val >= root->val) {\\n            return false;\\n        }\\n        \\n        // set the previous node to the current node\\n        previous = root;\\n        \\n        // visit the right sub-tree\\n        return isValidBST(root->right);\\n    }\\nprivate:\\n    TreeNode* previous = nullptr;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452792,
                "title": "inorder-traversal-c-solution-both-iterative-and-recursive",
                "content": "You can check if binary tree to be a BST by checking if the the inorder traversal is in sorted (ascending) order. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return isBST_inorder_iterative(root); \\n    }\\n    \\n    bool isBST_inorder_recurse(TreeNode* p, TreeNode* &prev) {\\n        if(p == NULL) return true;\\n        \\n        if(!isBST_inorder_recurse(p->left, prev)) return false;\\n        if(prev != NULL && prev->val >= p->val) return false;\\n        prev = p;\\n        return isBST_inorder_recurse(p->right, prev);\\n        \\n    }\\n    \\n    bool isBST_inorder_iterative(TreeNode* p) {\\n        if(p == NULL) return true;\\n        stack<TreeNode*> st;\\n        TreeNode *curr = p;\\n        TreeNode *prev = NULL;\\n        \\n        while(curr != NULL || !st.empty()) {\\n            \\n            while(curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            }\\n            curr = st.top(); st.pop();\\n            if(prev != NULL && prev->val >= curr->val) return false;\\n            prev = curr;\\n            curr = curr->right;\\n        }\\n        return true;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return isBST_inorder_iterative(root); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 357687,
                "title": "javascript-inorder-traverse-solution",
                "content": "```\\nvar isValidBST = function(root, lower = -Infinity, upper = Infinity) {\\n    let arr = []; \\n    var traverse = function(root) {\\n        if (!root) return; \\n        traverse(root.left); \\n        arr.push(root.val);\\n        traverse(root.right);\\n    }; \\n    \\n    traverse(root);\\n    \\n    for (let i = 0; i < arr.length-1; i++) {\\n        if (arr[i] >= arr[i+1]) return false;\\n    };\\n    \\n    return true;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidBST = function(root, lower = -Infinity, upper = Infinity) {\\n    let arr = []; \\n    var traverse = function(root) {\\n        if (!root) return; \\n        traverse(root.left); \\n        arr.push(root.val);\\n        traverse(root.right);\\n    }; \\n    \\n    traverse(root);\\n    \\n    for (let i = 0; i < arr.length-1; i++) {\\n        if (arr[i] >= arr[i+1]) return false;\\n    };\\n    \\n    return true;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258041,
                "title": "a-golang-solution",
                "content": "```\\nfunc isValidBST(root *TreeNode) bool {     \\n        return validate(root, math.MinInt64, math.MaxInt64)\\n}\\n        \\nfunc validate(root *TreeNode, min, max int) bool {\\n        if root == nil {   \\n                return true\\n        }                  \\n        \\n        if root.Val <= min || root.Val >= max {\\n                return false\\n        }\\n                                                                                                                                                                                                            \\n        return validate(root.Left, min, root.Val) && validate(root.Right, root.Val, max)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValidBST(root *TreeNode) bool {     \\n        return validate(root, math.MinInt64, math.MaxInt64)\\n}\\n        \\nfunc validate(root *TreeNode, min, max int) bool {\\n        if root == nil {   \\n                return true\\n        }                  \\n        \\n        if root.Val <= min || root.Val >= max {\\n                return false\\n        }\\n                                                                                                                                                                                                            \\n        return validate(root.Left, min, root.Val) && validate(root.Right, root.Val, max)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197536,
                "title": "c-4ms-100-simple-recursive-soln",
                "content": "I used a ```long``` instead of ```int``` to handle the edge cases with nodes in the tree that are already INT_MIN or INT_MAX.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValidRecur(root, LONG_MIN, LONG_MAX);\\n    }\\n    \\n    bool isValidRecur(TreeNode* root, long min, long max) {\\n        if (!root)\\n            return true;\\n        int val = root->val;\\n        if (val <= min || val >= max)\\n            return false;\\n        return isValidRecur(root->left, min, val) &&\\n               isValidRecur(root->right, val, max);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```long```\n```int```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValidRecur(root, LONG_MIN, LONG_MAX);\\n    }\\n    \\n    bool isValidRecur(TreeNode* root, long min, long max) {\\n        if (!root)\\n            return true;\\n        int val = root->val;\\n        if (val <= min || val >= max)\\n            return false;\\n        return isValidRecur(root->left, min, val) &&\\n               isValidRecur(root->right, val, max);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141734,
                "title": "concise-java-solutions",
                "content": "```\\n    public boolean isValidBST(TreeNode root) {\\n        List<Integer> inorder = inorder(root);\\n        return isSorted(inorder);\\n    }\\n    \\n    public List<Integer> inorder(TreeNode node){\\n        if(node == null) return new ArrayList<>();\\n        List<Integer> res = new ArrayList<>();\\n        res.addAll(inorder(node.left));\\n        res.add(node.val);\\n        res.addAll(inorder(node.right));\\n        return res;\\n    }\\n    \\n    public boolean isSorted(List<Integer> l){\\n        for(int i=1; i<l.size(); i++){\\n            if(l.get(i) <= l.get(i-1)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isValidBST(TreeNode root) {\\n        List<Integer> inorder = inorder(root);\\n        return isSorted(inorder);\\n    }\\n    \\n    public List<Integer> inorder(TreeNode node){\\n        if(node == null) return new ArrayList<>();\\n        List<Integer> res = new ArrayList<>();\\n        res.addAll(inorder(node.left));\\n        res.add(node.val);\\n        res.addAll(inorder(node.right));\\n        return res;\\n    }\\n    \\n    public boolean isSorted(List<Integer> l){\\n        for(int i=1; i<l.size(); i++){\\n            if(l.get(i) <= l.get(i-1)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32195,
                "title": "golang-concise-solution-using-dfs",
                "content": "We need to take care of not only the relation between a parent, but also the grandparent.\\nActually all nodes have their own both minimum and maximum value constraint.\\nThis article explains the common mistake we might make.\\nhttp://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/\\n\\n```\\nfunc isValidBST(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tres, v := true, root.Val\\n\\tdoValidateBST(&res, root.Left, &v, nil)\\n\\tdoValidateBST(&res, root.Right, nil, &v)\\n\\treturn res\\n}\\n\\nfunc doValidateBST(res *bool, node *TreeNode, upperBound, lowerBound *int) {\\n\\tif node == nil || !*res {\\n\\t\\treturn\\n\\t}\\n\\tif (upperBound != nil && node.Val >= *upperBound) ||\\n\\t\\t(lowerBound != nil && node.Val <= *lowerBound) {\\n\\t\\t*res = false\\n\\t\\treturn\\n\\t}\\n\\n\\tv := node.Val\\n\\tdoValidateBST(res, node.Left, &v, lowerBound)\\n\\tdoValidateBST(res, node.Right, upperBound, &v)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidBST(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tres, v := true, root.Val\\n\\tdoValidateBST(&res, root.Left, &v, nil)\\n\\tdoValidateBST(&res, root.Right, nil, &v)\\n\\treturn res\\n}\\n\\nfunc doValidateBST(res *bool, node *TreeNode, upperBound, lowerBound *int) {\\n\\tif node == nil || !*res {\\n\\t\\treturn\\n\\t}\\n\\tif (upperBound != nil && node.Val >= *upperBound) ||\\n\\t\\t(lowerBound != nil && node.Val <= *lowerBound) {\\n\\t\\t*res = false\\n\\t\\treturn\\n\\t}\\n\\n\\tv := node.Val\\n\\tdoValidateBST(res, node.Left, &v, lowerBound)\\n\\tdoValidateBST(res, node.Right, upperBound, &v)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32220,
                "title": "ruby-recursive-solution",
                "content": "```\\ndef is_valid_bst(root, min = -Float::INFINITY, max = Float::INFINITY)\\n    return true unless root\\n    if root.val <= min || root.val >= max\\n        return false\\n    else\\n        is_valid_bst(root.left, min, root.val) && is_valid_bst(root.right, root.val, max)\\n    end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_valid_bst(root, min = -Float::INFINITY, max = Float::INFINITY)\\n    return true unless root\\n    if root.val <= min || root.val >= max\\n        return false\\n    else\\n        is_valid_bst(root.left, min, root.val) && is_valid_bst(root.right, root.val, max)\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 32402,
                "title": "simple-java-solution-recursive-validation",
                "content": "    public class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, (long)Integer.MIN_VALUE, (long)Integer.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root, long min, long max) {\\n        if(root == null) return true;\\n        long val = root.val;\\n        return (val >= min && val <= max && isValidBST(root.left, min, val -1) && isValidBST(root.right, val+1, max));\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, (long)Integer.MIN_VALUE, (long)Integer.MAX_VALUE);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32411,
                "title": "8ms-c-solution",
                "content": "    bool isValidBST(struct TreeNode* root) {\\n\\tif (NULL == root)\\n\\t\\treturn true;\\n\\n\\tif (NULL != root->left)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->left;\\n\\t\\twhile (current->right != NULL)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->right;\\n\\t\\t}\\n\\t\\tif (current->val >= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif (NULL != root->right)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->right;\\n\\t\\twhile (NULL != current->left)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->left;\\n\\t\\t}\\n\\t\\tif ( current->val <= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !isValidBST(root->left))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (!isValidBST(root->right))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}",
                "solutionTags": [],
                "code": "    bool isValidBST(struct TreeNode* root) {\\n\\tif (NULL == root)\\n\\t\\treturn true;\\n\\n\\tif (NULL != root->left)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->left;\\n\\t\\twhile (current->right != NULL)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->right;\\n\\t\\t}\\n\\t\\tif (current->val >= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif (NULL != root->right)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->right;\\n\\t\\twhile (NULL != current->left)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->left;\\n\\t\\t}\\n\\t\\tif ( current->val <= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !isValidBST(root->left))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (!isValidBST(root->right))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 32419,
                "title": "my-c-solution-12ms-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            if(root==NULL)\\n            return true;\\n            if(root->left==NULL && root->right==NULL)\\n            return true;\\n            bool left=true;\\n            bool right=true;\\n            if(root->left)\\n            {\\n                left=isValidBST(root->left);\\n                TreeNode* rightest=root->left;\\n                while(rightest->right)\\n                {\\n                    rightest=rightest->right;\\n                }\\n                left=left&&(root->val>rightest->val);\\n            }\\n            if(root->right)\\n            {\\n                right=isValidBST(root->right);\\n                TreeNode* leftest=root->right;\\n                while(leftest->left)\\n                leftest=leftest->left;\\n                right=right&&(root->val<leftest->val);\\n            }\\n            return left&&right;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            if(root==NULL)\\n            return true;\\n            if(root->left==NULL && root->right==NULL)\\n            return true;\\n            bool left=true;\\n            bool right=true;\\n            if(root->left)\\n            {\\n                left=isValidBST(root->left);\\n                TreeNode* rightest=root->left;\\n                while(rightest->right)\\n                {\\n                    rightest=rightest->right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 32490,
                "title": "my-recursive-solution-no-passing-bounds",
                "content": "Inorder traversal, check valid in left->root->right order.\\nThe traversal should in strict ascending order.\\n\\n 1. leftchild subproblem is not valid, return false.\\n 2. current value is not greater than last value (if exists), return false. Otherwise, update the last.\\n 3. check rightchild subproblem\\n\\n\\nclass Solution \\n{\\npublic:\\n\\n    TreeNode* last = NULL;\\n    bool isValidBST(TreeNode *root) \\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            bool leftRes = isValidBST(root->left);\\n            //short cut\\n            if(leftRes == false)\\n                return false;\\n            if(last && last->val >= root->val)\\n                return false;\\n            last = root;\\n            return isValidBST(root->right);\\n        }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n\\n    TreeNode* last = NULL;\\n    bool isValidBST(TreeNode *root) \\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            bool leftRes = isValidBST(root->left);\\n            //short cut\\n            if(leftRes == false)\\n                return false;\\n            if(last && last->val >= root->val)\\n                return false;\\n            last = root;\\n            return isValidBST(root->right);\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575626,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570656,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568573,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1892160,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1572391,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1835136,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568018,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1574053,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570321,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1567009,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1575626,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570656,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568573,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1892160,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1572391,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1835136,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568018,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1574053,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570321,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1567009,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1573325,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1576712,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1567857,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1569782,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1569395,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1572371,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1795787,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1574415,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1573251,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 2053693,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1852868,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1852078,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1747915,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1732816,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1726671,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1575322,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1574073,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1573486,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1573344,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1573316,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1572959,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572839,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572790,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572762,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572687,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572514,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572308,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572210,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572132,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1571827,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1570413,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 1574701,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 1574503,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2066892,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2066748,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2064698,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2062539,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2050515,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2050467,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2031246,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2030796,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2027691,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2016068,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2013386,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2011238,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2009408,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2008817,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2004491,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 1969500,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 1967746,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 1956270,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1956125,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1950307,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1922696,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1912121,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1910894,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879552,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1873506,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1871866,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1864697,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1847227,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1842621,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1826913,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1826564,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1823971,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1820379,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1809953,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1794525,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1792486,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1782253,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1780545,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1777949,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1766315,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1761810,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1751961,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1728296,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1722428,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1714172,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1713120,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1711864,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            }
        ]
    },
    {
        "title": "House Robber",
        "question_content": "<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <b>without alerting the police</b></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,9,3,1]\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 156523,
                "title": "from-good-to-great-how-to-approach-most-of-dp-problems",
                "content": "There is some frustration when people publish their perfect fine-grained algorithms without sharing any information abut how they were derived. This is an attempt to change the situation. There is not much more explanation but it\\'s rather an example of higher level improvements. Converting a solution to the next step shouldn\\'t be as hard as attempting to come up with perfect algorithm at first attempt.\\n\\nThis particular problem and most of others can be approached using the following sequence:\\n1. Find recursive relation\\n2. Recursive (top-down)\\n3. Recursive + memo (top-down) \\n4. Iterative + memo (bottom-up) \\n5. Iterative + N variables (bottom-up)\\n\\n**Step 1.** Figure out recursive relation. \\nA robber has 2 options: a) rob current house `i`; b) don\\'t rob current house. \\nIf an option \"a\" is selected it means she can\\'t rob previous `i-1` house but can safely proceed to the one before previous `i-2` and gets all cumulative loot that follows.\\nIf an option \"b\" is selected the robber gets all the possible loot from robbery of `i-1` and all the following buildings.\\nSo it boils down to calculating what is more profitable: \\n* robbery of current house + loot from houses before the previous\\n* loot from the previous house robbery and any loot captured before that\\n\\n`rob(i) = Math.max( rob(i - 2) + currentHouseValue, rob(i - 1) )`\\n\\n**Step 2.** Recursive (top-down)\\nConverting the recurrent relation from Step 1 shound\\'t be very hard.\\n```\\npublic int rob(int[] nums) {\\n    return rob(nums, nums.length - 1);\\n}\\nprivate int rob(int[] nums, int i) {\\n    if (i < 0) {\\n        return 0;\\n    }\\n    return Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\\n}\\n```\\nThis algorithm will process the same `i` multiple times and it needs improvement. Time complexity: [to fill]\\n\\n**Step 3.** Recursive + memo (top-down).\\n```\\nint[] memo;\\npublic int rob(int[] nums) {\\n    memo = new int[nums.length + 1];\\n    Arrays.fill(memo, -1);\\n    return rob(nums, nums.length - 1);\\n}\\n\\nprivate int rob(int[] nums, int i) {\\n    if (i < 0) {\\n        return 0;\\n    }\\n    if (memo[i] >= 0) {\\n        return memo[i];\\n    }\\n    int result = Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\\n    memo[i] = result;\\n    return result;\\n}\\n```\\nMuch better, this should run in `O(n)` time. Space complexity is `O(n)` as well, because of the recursion stack, let\\'s try to get rid of it.\\n\\n**Step 4.** Iterative + memo (bottom-up) \\n```\\npublic int rob(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int[] memo = new int[nums.length + 1];\\n    memo[0] = 0;\\n    memo[1] = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n        int val = nums[i];\\n        memo[i+1] = Math.max(memo[i], memo[i-1] + val);\\n    }\\n    return memo[nums.length];\\n}\\n```\\n\\n**Step 5.** Iterative + 2 variables (bottom-up)\\nWe can notice that in the previous step we use only `memo[i]` and `memo[i-1]`, so going just 2 steps back. We can hold them in 2 variables instead. This optimization is met in Fibonacci sequence creation and some other problems [to paste links].\\n\\n```\\n/* the order is: prev2, prev1, num  */\\npublic int rob(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int prev1 = 0;\\n    int prev2 = 0;\\n    for (int num : nums) {\\n        int tmp = prev1;\\n        prev1 = Math.max(prev2 + num, prev1);\\n        prev2 = tmp;\\n    }\\n    return prev1;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int rob(int[] nums) {\\n    return rob(nums, nums.length - 1);\\n}\\nprivate int rob(int[] nums, int i) {\\n    if (i < 0) {\\n        return 0;\\n    }\\n    return Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\\n}\\n```\n```\\nint[] memo;\\npublic int rob(int[] nums) {\\n    memo = new int[nums.length + 1];\\n    Arrays.fill(memo, -1);\\n    return rob(nums, nums.length - 1);\\n}\\n\\nprivate int rob(int[] nums, int i) {\\n    if (i < 0) {\\n        return 0;\\n    }\\n    if (memo[i] >= 0) {\\n        return memo[i];\\n    }\\n    int result = Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\\n    memo[i] = result;\\n    return result;\\n}\\n```\n```\\npublic int rob(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int[] memo = new int[nums.length + 1];\\n    memo[0] = 0;\\n    memo[1] = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n        int val = nums[i];\\n        memo[i+1] = Math.max(memo[i], memo[i-1] + val);\\n    }\\n    return memo[nums.length];\\n}\\n```\n```\\n/* the order is: prev2, prev1, num  */\\npublic int rob(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int prev1 = 0;\\n    int prev2 = 0;\\n    for (int num : nums) {\\n        int tmp = prev1;\\n        prev1 = Math.max(prev2 + num, prev1);\\n        prev2 = tmp;\\n    }\\n    return prev1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55693,
                "title": "c-1ms-o-1-space-very-simple-solution",
                "content": "    #define max(a, b) ((a)>(b)?(a):(b))\\n    int rob(int num[], int n) {\\n        int a = 0;\\n        int b = 0;\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (i%2==0)\\n            {\\n                a = max(a+num[i], b);\\n            }\\n            else\\n            {\\n                b = max(a, b+num[i]);\\n            }\\n        }\\n        \\n        return max(a, b);\\n    }",
                "solutionTags": [],
                "code": "    #define max(a, b) ((a)>(b)?(a):(b))\\n    int rob(int num[], int n) {\\n        int a = 0;\\n        int b = 0;\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (i%2==0)\\n            {\\n                a = max(a+num[i], b);\\n            }\\n            else\\n            {\\n                b = max(a, b+num[i]);\\n            }\\n        }\\n        \\n        return max(a, b);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1605797,
                "title": "c-python-4-simple-solutions-w-explanation-optimization-from-brute-force-to-dp",
                "content": "We are given an array of money in each house `A` and we need to return the maximum amount we can rob without robbing from any two adjacent houses.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nLet\\'s try solving with brute-force approach. For each house, we have two choices -\\n1. **Dont rob** the house and **move to next house**.\\n2. **Rob** the house and **move to the house after next house** (We dont move directly to next house because we can rob adjacent houses).\\n\\nSo, we will just try with both these choices and choose the one the yields the maximum amount of loot.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A, int i = 0) {\\n        return i < size(A) ? max(rob(A, i+1), A[i] + rob(A, i+2)) : 0;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rob(self, A, i = 0):\\n        return max(self.rob(A, i+1), A[i] + self.rob(A, i+2)) if i < len(A) else 0\\n```\\n\\n***Time Complexity :*** <code>O(2<sup>N</sup>)</code>, where `N` is the number of elements in `A`. At each index, we have two choices of either robbing or not robbing the current house. Thus this leads to time complexity of <code>2\\\\*2*2...n times \\u2248 O(2<sup>N</sup>)</code>\\n***Space Complexity :*** <code>O(N)</code>, required by implicit recursive stack. The max depth of recursion can go upto `N`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nIn the above solution, we were performing many redundant repeated computations. This can be observed by drawing out the recursive tree for above function and observing that `rob(i)` is called multiple times. But `rob(i)` is nothing but the maximum amount of loot we can get starting at index `i` and this amount remains the same at each call.\\n\\nSo, instead of re-computing multiple times, we can store the result of a function call and directly reuse it on future calls instead of recomputing from scratch. This calls for **dynamic programming**, or memoization to be more specific. Here, we can use a linear `dp` array where `dp[i]` will denote the maximum amount of loot we can get starting at `i` index. Initially all elements of `dp` are initialized to `-1` denoting they haven\\'t been computed yet, Each time, we will save the computed result in this `dp` for an index `i` and directly return it if a future call is made to this index.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        vector<int> dp(size(A),-1);\\n        return rob(A, dp, 0);\\n    }\\n    int rob(vector<int>& A, vector<int>& dp, int i) {\\n        if(i >= size(A)) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        return dp[i] = max(rob(A, dp, i+1), A[i] + rob(A, dp, i+2));\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary>One-Liner</summary>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int dp[101]{[0 ... 100] = -1};\\n    int rob(vector<int>& A, int i = 0) {\\n        return i < size(A) ? dp[i] != -1 ? dp[i] : dp[i] = max(rob(A, i+1), A[i] + rob(A, i+2)) : 0;\\n    }\\n};\\n```\\n\\n</details>\\n</blockquote>\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rob(self, A):\\n        @cache\\n        def rob(i):\\n            return max(rob(i+1), A[i] + rob(i+2)) if i < len(A) else 0\\n        return rob(0)\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, We calculate the result for each index only once & there are `N` indices. Thus overall time complexity is `O(N)`.\\n***Space Complexity :*** <code>O(N)</code>, required for `dp` and implicit recursive stack. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Tabulation)***\\n\\nWe can implement the same logic as above in an iterate approach as well. Here, we again use a `dp` array to save the results of computation. In this case, `dp[i]` will denote maximum loot that we can get by considering till `i`th index. At every index,\\n* We can keep same loot as we had at previous index - `dp[i-1]`\\n* Or, we can rob the current house and add it to the loot we have at `i-2`th index - `A[i] + dp[i-2]`\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        if(size(A) == 1) return A[0];\\n        vector<int> dp(A);\\n        dp[1] = max(A[0], A[1]);\\n        for(int i = 2; i < size(A); i++)\\n            dp[i] = max(dp[i-1], A[i] + dp[i-2]);\\n        return dp.back();\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rob(self, A):\\n        if len(A) == 1: return A[0]\\n        dp = [*A]\\n        dp[1] = max(A[0], A[1])\\n        for i in range(2, len(A)):\\n            dp[i] = max(dp[i-1], A[i] + dp[i-2])\\n        return dp[-1]\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, just single iteration is performed from `2` to `N` to compute each `dp[i]`.\\n***Space Complexity :*** <code>O(N)</code>, required for `dp`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space-Optimzed Dynamic Programming)***\\n\\nWe can observe that the above dp solution relied only on the previous two indices in `dp` to compute the value of current `dp[i]`. So, we dont really need to maintain the whole `dp` array and can instead just maintain the values of previous index (denoted as **`prev`** below) and previous-to-previous index (denoted as **`prev2`**) and we can calculate the value for current index (**`cur`**) using just these two variables and roll-forward each time.\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        int prev2 = 0, prev = 0, cur = 0;\\n        for(auto i : A) {\\n            cur = max(prev, i + prev2);\\n            prev2 = prev;\\n            prev = cur;\\n        }\\n        return cur;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rob(self, A):\\n        prev2, prev, cur = 0,0,0\\n        for i in A:\\n            cur = max(prev, i + prev2)\\n            prev2 = prev\\n            prev = cur\\n        return cur\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** <code>O(1)</code>, only constant extra space is used.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A, int i = 0) {\\n        return i < size(A) ? max(rob(A, i+1), A[i] + rob(A, i+2)) : 0;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, A, i = 0):\\n        return max(self.rob(A, i+1), A[i] + self.rob(A, i+2)) if i < len(A) else 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        vector<int> dp(size(A),-1);\\n        return rob(A, dp, 0);\\n    }\\n    int rob(vector<int>& A, vector<int>& dp, int i) {\\n        if(i >= size(A)) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        return dp[i] = max(rob(A, dp, i+1), A[i] + rob(A, dp, i+2));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int dp[101]{[0 ... 100] = -1};\\n    int rob(vector<int>& A, int i = 0) {\\n        return i < size(A) ? dp[i] != -1 ? dp[i] : dp[i] = max(rob(A, i+1), A[i] + rob(A, i+2)) : 0;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, A):\\n        @cache\\n        def rob(i):\\n            return max(rob(i+1), A[i] + rob(i+2)) if i < len(A) else 0\\n        return rob(0)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        if(size(A) == 1) return A[0];\\n        vector<int> dp(A);\\n        dp[1] = max(A[0], A[1]);\\n        for(int i = 2; i < size(A); i++)\\n            dp[i] = max(dp[i-1], A[i] + dp[i-2]);\\n        return dp.back();\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, A):\\n        if len(A) == 1: return A[0]\\n        dp = [*A]\\n        dp[1] = max(A[0], A[1])\\n        for i in range(2, len(A)):\\n            dp[i] = max(dp[i-1], A[i] + dp[i-2])\\n        return dp[-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        int prev2 = 0, prev = 0, cur = 0;\\n        for(auto i : A) {\\n            cur = max(prev, i + prev2);\\n            prev2 = prev;\\n            prev = cur;\\n        }\\n        return cur;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, A):\\n        prev2, prev, cur = 0,0,0\\n        for i in A:\\n            cur = max(prev, i + prev2)\\n            prev2 = prev\\n            prev = cur\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55696,
                "title": "python-solution-3-lines",
                "content": "Based on the recursive formula:\\n\\n>     f(0) = nums[0]\\n>     f(1) = max(num[0], num[1])\\n>     f(k) = max( f(k-2) + nums[k], f(k-1) )\\n\\n    class Solution:\\n        \\n        def rob(self, nums):\\n            \\n            last, now = 0, 0\\n            \\n            for i in nums: last, now = now, max(last + i, now)\\n                    \\n            return now",
                "solutionTags": [],
                "code": "Based on the recursive formula:\\n\\n>     f(0) = nums[0]\\n>     f(1) = max(num[0], num[1])\\n>     f(k) = max( f(k-2) + nums[k], f(k-1) )\\n\\n    class Solution:\\n        \\n        def rob(self, nums):\\n            \\n            last, now = 0, 0\\n            \\n            for i in nums: last, now = now, max(last + i, now)\\n                    \\n            return now",
                "codeTag": "Java"
            },
            {
                "id": 55681,
                "title": "java-o-n-solution-space-o-1",
                "content": "    public int rob(int[] num) {\\n        int[][] dp = new int[num.length + 1][2];\\n        for (int i = 1; i <= num.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\\n            dp[i][1] = num[i - 1] + dp[i - 1][0];\\n        }\\n        return Math.max(dp[num.length][0], dp[num.length][1]);\\n    }\\n\\ndp[i][1] means we rob the current house and dp[i][0] means we don't,\\n\\nso it is easy to convert this to O(1) space\\n\\n    public int rob(int[] num) {\\n        int prevNo = 0;\\n        int prevYes = 0;\\n        for (int n : num) {\\n            int temp = prevNo;\\n            prevNo = Math.max(prevNo, prevYes);\\n            prevYes = n + temp;\\n        }\\n        return Math.max(prevNo, prevYes);\\n    }",
                "solutionTags": [],
                "code": "    public int rob(int[] num) {\\n        int[][] dp = new int[num.length + 1][2];\\n        for (int i = 1; i <= num.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\\n            dp[i][1] = num[i - 1] + dp[i - 1][0];\\n        }\\n        return Math.max(dp[num.length][0], dp[num.length][1]);\\n    }\\n\\ndp[i][1] means we rob the current house and dp[i][0] means we don't,\\n\\nso it is easy to convert this to O(1) space\\n\\n    public int rob(int[] num) {\\n        int prevNo = 0;\\n        int prevYes = 0;\\n        for (int n : num) {\\n            int temp = prevNo;\\n            prevNo = Math.max(prevNo, prevYes);\\n            prevYes = n + temp;\\n        }\\n        return Math.max(prevNo, prevYes);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1605133,
                "title": "c-discussing-all-solutions-dp-with-constant-space",
                "content": "This is a classic 1D-DP problem where at every step we have a choice to make ...\\nSo the first and foremost thing in any DP problem is to find the reccurence relation !!\\n    At every ith house robber has 2 options: *a) rob current house i.* *b) don\\'t rob current house.*\\n* In case he is robbing the (i)th house, the money he can get till the i-th house == money robbed till (i-2)th house + money robbed at (i)th house....let\\'s say total money robbed in this case equals to X.\\n* In case he is not robbing, money robbed till i-th house==money robbed till (i-1)th house...lets say total money robbed in this case equals to Y.\\n* So , the maxm money he gets till i-th house is the max(X,Y).\\n\\nExample of case (a) --> nums={2,3,2} ... Here, the robber will rob the house at index-2 as nums[index-2] + nums[index-0] > nums[index-1]\\nExample of case (b)--> nums={2,7,3} ... here maximum money robbed till index-2 will not be equal to nums[index-2] + nums[index-0]... as nums[index-1] is greater than the sum of money at both those houses ...\\n\\n*We can achieve the desired solution to this problem via mutliple ways, let\\'s start with the simpler ones and then will look forward to optimize the **Time and Space Complexities***\\n\\n\\n1. **Simple Recursion**\\n\\n* Time  Complexcity  :  O ( 2^n )   Gives us TLE\\n* Space Complexcity : O( 1 )\\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int>& nums,int idx){\\n        if(idx>=nums.size())return 0;\\n        return max(nums[idx]+rec(nums,idx+2),rec(nums,idx+1));\\n    }\\n    int rob(vector<int>& nums) {\\n        return rec(nums,0);\\n    }\\n};\\n```\\n\\n\\n2. **Memoization**\\n\\n* Time  Complexcity  :  O (n)\\n* Space Complexcity : O(n)\\n    \\n ```   \\nclass Solution {\\npublic:\\n   int rec(vector<int>& nums,int idx,vector<int>&dp){\\n        if(idx >= nums.size()) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        return dp[idx] = max(rec(nums, idx+1, dp), nums[idx] + rec(nums, idx+2, dp));\\n   }\\n   int rob(vector<int>& nums) {\\n       vector<int>dp(nums.size()+1,-1);\\n       return rec(nums,0,dp);\\n   }\\n};\\n```\\n\\n\\n3. **Dynamic Programming**\\n\\n* Time Complexity : O(n)\\n* Space Complexity : O(n)    \\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        vector<int>dp(nums.size());\\n        dp[0]=nums[0];\\n        dp[1]=max(nums[0],nums[1]);\\n        for(int i=2;i<nums.size();i++){\\n            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n\\n4.**Dynamic Programming**  (improved version)\\n \\n* Time Complexity : O(n)\\n* Space complexity : O(1)\\n\\nWe can optimize the space now,\\nas we can see we only need to know the answer till (i-1)th idx and (i-2)th idx to have an answer for the (i)th idx. And we don\\'t really care about the whole dp-vector, so there is no point maintaining one... 3 variables will do the job, prev_ans (for i-1), prev_ans2(for i-2) and curr_ans !!\\n\\n* dp[i - 2] - previous answer(till i-2 idx) -> prev_ans2\\n* dp[i - 1] - previous answer(till i-1 idx) -> prev_ans\\n* dp[i] - current answer(can be prev_ans or prev_ans2+nums[i]) -> curr_ans\\nSo we will get rid of the dp-vector and thus our SC will get reduced down to O(1)\\n(It is very similar to fibonacci series Space optimization)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        \\n        int prev_ans2=nums[0], prev_ans=max(nums[0],nums[1]),curr_ans=prev_ans;\\n        \\n        for(int i = 2; i < n; i++){\\n            curr_ans = max(prev_ans, prev_ans2 + nums[i]);\\n            prev_ans2 = prev_ans;\\n            prev_ans = curr_ans;\\n        }\\n        return curr_ans;\\n    }\\n};    \\n```\\nWell, Thanks for reading it out !!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(vector<int>& nums,int idx){\\n        if(idx>=nums.size())return 0;\\n        return max(nums[idx]+rec(nums,idx+2),rec(nums,idx+1));\\n    }\\n    int rob(vector<int>& nums) {\\n        return rec(nums,0);\\n    }\\n};\\n```\n```   \\nclass Solution {\\npublic:\\n   int rec(vector<int>& nums,int idx,vector<int>&dp){\\n        if(idx >= nums.size()) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        return dp[idx] = max(rec(nums, idx+1, dp), nums[idx] + rec(nums, idx+2, dp));\\n   }\\n   int rob(vector<int>& nums) {\\n       vector<int>dp(nums.size()+1,-1);\\n       return rec(nums,0,dp);\\n   }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        vector<int>dp(nums.size());\\n        dp[0]=nums[0];\\n        dp[1]=max(nums[0],nums[1]);\\n        for(int i=2;i<nums.size();i++){\\n            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        \\n        int prev_ans2=nums[0], prev_ans=max(nums[0],nums[1]),curr_ans=prev_ans;\\n        \\n        for(int i = 2; i < n; i++){\\n            curr_ans = max(prev_ans, prev_ans2 + nums[i]);\\n            prev_ans2 = prev_ans;\\n            prev_ans = curr_ans;\\n        }\\n        return curr_ans;\\n    }\\n};    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 55695,
                "title": "java-dp-solution-o-n-runtime-and-o-1-space-with-inline-comment",
                "content": "    public int rob(int[] num) {\\n        int rob = 0; //max monney can get if rob current house\\n        int notrob = 0; //max money can get if not rob current house\\n        for(int i=0; i<num.length; i++) {\\n            int currob = notrob + num[i]; //if rob current value, previous house must not be robbed\\n            notrob = Math.max(notrob, rob); //if not rob ith house, take the max value of robbed (i-1)th house and not rob (i-1)th house\\n            rob = currob;\\n        }\\n        return Math.max(rob, notrob);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int rob(int[] num) {\\n        int rob = 0; //max monney can get if rob current house\\n        int notrob = 0; //max money can get if not rob current house\\n        for(int i=0; i<num.length; i++) {\\n            int currob = notrob + num[i]; //if rob current value, previous house must not be robbed\\n            notrob = Math.max(notrob, rob); //if not rob ith house, take the max value of robbed (i-1)th house and not rob (i-1)th house\\n            rob = currob;\\n        }\\n        return Math.max(rob, notrob);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55761,
                "title": "java-0ms-solution-using-dynamic-programming",
                "content": "    public int rob(int[] nums) {  \\n        if(nums.length==0) return 0;\\n        if(nums.length==1) return nums[0];\\n\\n        //Initialize an arrays to store the money\\n    \\tint[] mark = new int[nums.length];\\n\\n        //We can infer the formula from problem:mark[i]=max(num[i]+mark[i-2],mark[i-1])\\n        //so initialize two nums at first.\\n    \\tmark[0] = nums[0];\\n    \\tmark[1] = Math.max(nums[0], nums[1]);\\n\\n        //Using Dynamic Programming to mark the max money in loop.\\n    \\tfor(int i=2;i<nums.length;i++){\\n    \\t\\tmark[i] = Math.max(nums[i]+mark[i-2], mark[i-1]);\\n    \\t}\\n\\t\\treturn mark[nums.length-1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int rob(int[] nums) {  \\n        if(nums.length==0) return 0;\\n        if(nums.length==1) return nums[0];\\n\\n        //Initialize an arrays to store the money\\n    \\tint[] mark = new int[nums.length];\\n\\n        //We can infer the formula from problem:mark[i]=max(num[i]+mark[i-2],mark[i-1])\\n        //so initialize two nums at first.\\n    \\tmark[0] = nums[0];\\n    \\tmark[1] = Math.max(nums[0], nums[1]);\\n\\n        //Using Dynamic Programming to mark the max money in loop.\\n    \\tfor(int i=2;i<nums.length;i++){\\n    \\t\\tmark[i] = Math.max(nums[i]+mark[i-2], mark[i-1]);\\n    \\t}\\n\\t\\treturn mark[nums.length-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55977,
                "title": "python-dp-solution-4-line-o-n-time-o-1-space-easy-to-understand-with-detailed-explanation",
                "content": "The idea is the store the max sum we can get for each house use it to calculate the following houses until we get the final result.\\n\\nIn the path that the robber chose to rob with max money, it is guaranteed that either the last house (num[-1]) or the 2nd last house (num[-2]) will be robbed. So we can compare the max sum path that includes num[-1] with the max sum path that includes num[-2] and return the larger one.\\n\\nTo get the sums of the two paths, we scan from left to right. A sliding window of size 4, `[max_3_house_before, max_2_house_before, adjacent, cur]`, is used to calculate the max sum till the current house. The last element, `cur`, of the window is the money of the current house we are scanning. The 1st element, `max_3_house_before`, stores the max sum till the house that is 3 steps before the current one. The 2nd element, `max_2_house_before`, stores the max sum till the house that is 2 steps before the current one. The 3rd element, `adjacent`, stores the max sum till the house that are one step before the current one. To reach the current house, we either came from the house that is 3 steps before or from the one that is 2 steps before because visiting two adjacent houses is not allowed. So we can get the max sum till the current house by `max(cur+max_3_house_before, cur+max_2_house_before)`. \\n\\nBefore scanning the next house we update the window by moving one house forward: `max_3_house_before, max_2_house_before, adjacent = max_2_house_before, adjacent, max(max_3_house_before+cur, max_2_house_before+cur)`.\\n\\nWhen we finished the scanning, the max sum exists in either `max_2_house_before` or `adjacent`. So we return `max(max_2_house_before, adjacent)`.\\n\\nFor example: `num = [1,7,9,4]`, at the beginning,  `max_3_house_before, max_2_house_before, adjacent` are initialized to 0, so it is like putting 3 zeros before the input list `[0, 0, 0, 1, 7, 9, 4]`. Here are steps for calculating the max sum for each house(the sliding window is marked by parentheses):\\n\\n> [(0, 0, 0, **1**), 7, 9, 4], cur = max(0+1, 0+1)\\n\\n> -> [ (0, 0, 1, **7**), 9, 4], cur = max(0+7, 0+7)\\n\\n> -> [(0, 1, 7, **9**), 4], cur =  max(0+9, 1+9)\\n\\n> -> [(1, 7, 10, **4**)], cur = max(1+4, 7+4)\\n\\n> -> [7, 10, 11],  10 is the max sum of path that includes num[-2], 11 is the max sum of path that includes num[-1], so return max(10, 11)\\n\\nCode:\\n\\n        class Solution:\\n            # @param num, a list of integer\\n            # @return an integer\\n            def rob(self, num):\\n                max_3_house_before, max_2_house_before, adjacent = 0, 0, 0\\n                for cur in num:\\n                    max_3_house_before, max_2_house_before, adjacent = \\\\\\n                    max_2_house_before, adjacent, max(max_3_house_before+cur, max_2_house_before+cur)\\n                return max(max_2_house_before, adjacent)\\n\\nThere is a better solution using only 2 variables [here][1] but I found out myself too dumb and was able to understand it after I stared at it for 30min:(\\n\\n\\n  [1]: https://leetcode.com/discuss/30102/4-line-python-o-1-space-o-n-time-with-explaination-simplest",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is the store the max sum we can get for each house use it to calculate the following houses until we get the final result.\\n\\nIn the path that the robber chose to rob with max money, it is guaranteed that either the last house (num[-1]) or the 2nd last house (num[-2]) will be robbed. So we can compare the max sum path that includes num[-1] with the max sum path that includes num[-2] and return the larger one.\\n\\nTo get the sums of the two paths, we scan from left to right. A sliding window of size 4, `[max_3_house_before, max_2_house_before, adjacent, cur]`, is used to calculate the max sum till the current house. The last element, `cur`, of the window is the money of the current house we are scanning. The 1st element, `max_3_house_before`, stores the max sum till the house that is 3 steps before the current one. The 2nd element, `max_2_house_before`, stores the max sum till the house that is 2 steps before the current one. The 3rd element, `adjacent`, stores the max sum till the house that are one step before the current one. To reach the current house, we either came from the house that is 3 steps before or from the one that is 2 steps before because visiting two adjacent houses is not allowed. So we can get the max sum till the current house by `max(cur+max_3_house_before, cur+max_2_house_before)`. \\n\\nBefore scanning the next house we update the window by moving one house forward: `max_3_house_before, max_2_house_before, adjacent = max_2_house_before, adjacent, max(max_3_house_before+cur, max_2_house_before+cur)`.\\n\\nWhen we finished the scanning, the max sum exists in either `max_2_house_before` or `adjacent`. So we return `max(max_2_house_before, adjacent)`.\\n\\nFor example: `num = [1,7,9,4]`, at the beginning,  `max_3_house_before, max_2_house_before, adjacent` are initialized to 0, so it is like putting 3 zeros before the input list `[0, 0, 0, 1, 7, 9, 4]`. Here are steps for calculating the max sum for each house(the sliding window is marked by parentheses):\\n\\n> [(0, 0, 0, **1**), 7, 9, 4], cur = max(0+1, 0+1)\\n\\n> -> [ (0, 0, 1, **7**), 9, 4], cur = max(0+7, 0+7)\\n\\n> -> [(0, 1, 7, **9**), 4], cur =  max(0+9, 1+9)\\n\\n> -> [(1, 7, 10, **4**)], cur = max(1+4, 7+4)\\n\\n> -> [7, 10, 11],  10 is the max sum of path that includes num[-2], 11 is the max sum of path that includes num[-1], so return max(10, 11)\\n\\nCode:\\n\\n        class Solution:\\n            # @param num, a list of integer\\n            # @return an integer\\n            def rob(self, num):\\n                max_3_house_before, max_2_house_before, adjacent = 0, 0, 0\\n                for cur in num:\\n                    max_3_house_before, max_2_house_before, adjacent = \\\\\\n                    max_2_house_before, adjacent, max(max_3_house_before+cur, max_2_house_before+cur)\\n                return max(max_2_house_before, adjacent)\\n\\nThere is a better solution using only 2 variables [here][1] but I found out myself too dumb and was able to understand it after I stared at it for 30min:(\\n\\n\\n  [1]: https://leetcode.com/discuss/30102/4-line-python-o-1-space-o-n-time-with-explaination-simplest",
                "codeTag": "Java"
            },
            {
                "id": 55838,
                "title": "dp-o-n-time-o-1-space-with-easy-to-understand-explanation",
                "content": "For every house k, there are two options: either to rob it (include this house: i) or not rob it (exclude this house: e). \\n\\n1. Include this house:\\ni = num[k] + e (money of this house + money robbed excluding the previous house)\\n\\n2. Exclude this house:\\ne = max(i, e) (max of money robbed including the previous house or money robbed excluding the previous house)\\n(note that i and e of the previous step, that's why we use tmp here to store the previous i when calculating e, to make O(1) space)\\n\\nHere is the code:\\n\\n    public class Solution {\\n        public int rob(int[] num) {\\n            int i = 0;\\n            int e = 0;\\n            for (int k = 0; k<num.length; k++) {\\n                int tmp = i;\\n                i = num[k] + e;\\n                e = Math.max(tmp, e);\\n            }\\n            return Math.max(i,e);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int rob(int[] num) {\\n            int i = 0;\\n            int e = 0;\\n            for (int k = 0; k<num.length; k++) {\\n                int tmp = i;\\n                i = num[k] + e;\\n                e = Math.max(tmp, e);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1605334,
                "title": "java-dp-with-and-without-space-explained",
                "content": "**Intution:** At every i-th house we have two choices to make, i.e., rob the i-th house or don\\'t rob it.\\n* Case1 : **Don\\'t rob the i-th house -** then we can rob the i-1 th house...so we will have max money robbed till i-1 th house\\n*  Case 2 : **Rob the i-th house -** then we cann\\'t rob the i-1 th house but we can rob i-2 th house....so we will have max money robbed till i-2 th house + money of i-th house.\\n**Example:** \\n1.) If the array is [1,5,3] then robber will rob the 1st index house because arr[1] > arr[0]+arr[2] (i.e., at last index, arr[i-1] > arr[i-2]+arr[i])\\n2.) If the array is [1,2,3] then robber will rob the 0th and 2nd index house because arr[0]+arr[2] > arr[1] (i.e., at last index, arr[i-2] + arr[i] > arr[i-1])\\n   \\n\\n**Approach 1: Dynamic Programming** \\nT.C : O(n)\\nS.C : O(n)\\n```\\n   class Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        dp[0]=nums[0];\\n        if(n==1){\\n            return nums[0];\\n        }\\n        \\n        dp[1] = Math.max(nums[0],nums[1]);\\n        \\n        for(int i=2;i<n;i++){\\n            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);\\n        }\\n        \\n        return dp[n-1];\\n\\n    }\\n}\\n```\\n\\n\\n**Approach 2: Modified Dynammic Programming**\\nT.C : O(n)\\nS.C : O(1)\\n\\n**Explanation:** We actually don\\'t need to have full dp array to store the previous values beacause we need only two previous values that is max robbery till i-2 th index and i-1 th index which we can store using two variables dp2 and dp1 resepectively.\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        if(n == 1) return nums[0];\\n        \\n        int dp2=nums[0], dp1=Math.max(nums[0],nums[1]),dp=dp1;\\n        \\n        for(int i = 2; i < n; i++){\\n            dp = Math.max(dp1, dp2 + nums[i]);\\n            dp2 = dp1;\\n            dp1 = dp;\\n        }\\n        return dp;\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n   class Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        dp[0]=nums[0];\\n        if(n==1){\\n            return nums[0];\\n        }\\n        \\n        dp[1] = Math.max(nums[0],nums[1]);\\n        \\n        for(int i=2;i<n;i++){\\n            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);\\n        }\\n        \\n        return dp[n-1];\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        if(n == 1) return nums[0];\\n        \\n        int dp2=nums[0], dp1=Math.max(nums[0],nums[1]),dp=dp1;\\n        \\n        for(int i = 2; i < n; i++){\\n            dp = Math.max(dp1, dp2 + nums[i]);\\n            dp2 = dp1;\\n            dp1 = dp;\\n        }\\n        return dp;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846004,
                "title": "python-4-lines-easy-dp-solution-explained",
                "content": "Nice and easy dynamic programming problem! Let `dp1` be maximum gain we can get, using last `i-1` houses and `dp2` maximum gain we can get, using `i` houses. How we need to update these numbers if we go from `i` to `i+1`? So `dp1` and `dp2` should mean gain for `i` and `i+1` houses.\\n\\n1. `dp1 = dp2`, gain to rob `i+1-1` houses is gain to rob `i` houses.\\n2. `dp2 = max(dp1 + num, dp2)`: we have 2 choices: either rob house number `i+1`, then we can rob `i`th house, so we have total gain `dp1 + num`, or we do not rob `i+1`th house, then we can gain `dp2`.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        dp1, dp2 = 0, 0\\n        for num in nums:\\n            dp1, dp2 = dp2, max(dp1 + num, dp2)          \\n        return dp2 \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums):\\n        dp1, dp2 = 0, 0\\n        for num in nums:\\n            dp1, dp2 = dp2, max(dp1 + num, dp2)          \\n        return dp2 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 55736,
                "title": "c-my-solution-dp",
                "content": "    class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            const int n = nums.size();\\n            if (n == 0) return 0;\\n            if (n == 1) return nums[0];\\n            if (n == 2) return max(nums[0], nums[1]);\\n            vector<int> f(n, 0);\\n            f[0] = nums[0];\\n            f[1] = max(nums[0], nums[1]);\\n            for (int i = 2; i < n; ++i)\\n                f[i] = max(f[i-2] + nums[i], f[i-1]);\\n            return f[n-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            const int n = nums.size();\\n            if (n == 0) return 0;\\n            if (n == 1) return nums[0];\\n            if (n == 2) return max(nums[0], nums[1]);\\n            vector<int> f(n, 0);\\n            f[0] = nums[0];\\n            f[1] = max(nums[0], nums[1]);\\n            for (int i = 2; i < n; ++i)\\n                f[i] = max(f[i-2] + nums[i], f[i-1]);\\n            return f[n-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 346376,
                "title": "python-dynamic-programming-20-ms",
                "content": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        if length==0:\\n            return 0\\n        if length==1:\\n            return nums[0]\\n        if length==2:\\n            return max(nums)\\n\\t\\t\\t\\n        dp = [0]*length # assign dp array\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, length):\\n            dp[i] = max(dp[i-2]+nums[i], dp[i-1])\\n        print(dp)\\n        \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        if length==0:\\n            return 0\\n        if length==1:\\n            return nums[0]\\n        if length==2:\\n            return max(nums)\\n\\t\\t\\t\\n        dp = [0]*length # assign dp array\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, length):\\n            dp[i] = max(dp[i-2]+nums[i], dp[i-1])\\n        print(dp)\\n        \\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846111,
                "title": "c-four-simple-approch",
                "content": "**Recoursive Solution**   \\n```\\nTime  Complexcity  :  O ( 2^N )   Give you TLE\\nSpace Complexcity : O( 1 )\\n``` \\n\\n```\\nclass Solution {\\npublic:\\n    int Fun(vector<int>& nums,int index){\\n        if(index>=nums.size())return 0;\\n        return max(nums[index]+Fun(nums,index+2),Fun(nums,index+1));\\n    }\\n    int rob(vector<int>& nums) {\\n        return Fun(nums,0);\\n    }\\n};\\n```\\n\\n**Recoursion with Memo**\\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( N )\\n``` \\n\\n```\\nclass Solution {\\npublic:\\n    int DP(vector<int>& nums,int index,vector<int>&dp){\\n        if(index>=nums.size())return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        return dp[index] = max(nums[index]+DP(nums,index+2,dp),DP(nums,index+1,dp));\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return DP(nums,0,dp);\\n    }\\n};\\n\\n```\\n\\n**Bottom Up Dp Or Tabulation**\\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( N )\\n``` \\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        if (nums.size() == 1) return nums[0];\\n\\n        vector<int> dp[nums.size()];\\n        dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n\\n**Most Efficent One**\\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( 1 )\\n``` \\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int sum1 = 0,sum2 = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(!(i&1))sum1=max(sum1+nums[i],sum2);\\n            else sum2 = max(sum2+nums[i],sum1);\\n        }\\n        return max(sum1,sum2);\\n    }\\n};\\n```\\n\\n\\nIf you Like This Please **Upvote** it\\nAny doubt comments there\\nThank you  **:)**",
                "solutionTags": [],
                "code": "```\\nTime  Complexcity  :  O ( 2^N )   Give you TLE\\nSpace Complexcity : O( 1 )\\n```\n```\\nclass Solution {\\npublic:\\n    int Fun(vector<int>& nums,int index){\\n        if(index>=nums.size())return 0;\\n        return max(nums[index]+Fun(nums,index+2),Fun(nums,index+1));\\n    }\\n    int rob(vector<int>& nums) {\\n        return Fun(nums,0);\\n    }\\n};\\n```\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( N )\\n```\n```\\nclass Solution {\\npublic:\\n    int DP(vector<int>& nums,int index,vector<int>&dp){\\n        if(index>=nums.size())return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        return dp[index] = max(nums[index]+DP(nums,index+2,dp),DP(nums,index+1,dp));\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return DP(nums,0,dp);\\n    }\\n};\\n\\n```\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( N )\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        if (nums.size() == 1) return nums[0];\\n\\n        vector<int> dp[nums.size()];\\n        dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( 1 )\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int sum1 = 0,sum2 = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(!(i&1))sum1=max(sum1+nums[i],sum2);\\n            else sum2 = max(sum2+nums[i],sum1);\\n        }\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263528,
                "title": "python-bottom-up-dp-from-o-n-to-o-1-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bottom up DP**\\n- Let `dp[i]` is the maximum of amount money we can rob in `houses[0..i]`.\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\\n        return dp[n-1]\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is number of houses.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP (Space Optimzed)**\\n- Since our `dp` only access 3 do states: current dp `dp`, previous dp `dp1`, previous of previous dp `dp2`. So we can optimize to `O(1)` in Space Complexity.\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        dp, dp1, dp2 = 0, 0, 0\\n        for i in range(len(nums)):\\n            dp = max(dp1, dp2 + nums[i])\\n            dp2 = dp1\\n            dp1 = dp\\n        return dp1\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is number of houses.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\\n        return dp[n-1]\\n```\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        dp, dp1, dp2 = 0, 0, 0\\n        for i in range(len(nums)):\\n            dp = max(dp1, dp2 + nums[i])\\n            dp2 = dp1\\n            dp1 = dp\\n        return dp1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55679,
                "title": "o-1-space-java-and-c",
                "content": "Since we are not allowed to rob two adjacent houses, we keep two variables `pre` and `cur`. During the `i`-th loop, `pre` records the maximum profit that we do not rob the `i - 1`-th house and thus the current house (the `i`-th house) can be robbed while `cur` records the profit that we have robbed the `i - 1`-th house. \\n\\nThe code is as follows.\\n\\n* Java\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int pre = 0, cur = 0;\\n        for (int num : nums) {\\n            final int temp = Integer.max(pre + num, cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n}\\n```\\n\\n* C++\\n```\\nclass Solution {\\npublic: \\n    int rob(vector<int>& nums) {\\n        int n = nums.size(), pre = 0, cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            int temp = max(pre + nums[i], cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int pre = 0, cur = 0;\\n        for (int num : nums) {\\n            final int temp = Integer.max(pre + num, cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic: \\n    int rob(vector<int>& nums) {\\n        int n = nums.size(), pre = 0, cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            int temp = max(pre + nums[i], cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55953,
                "title": "3-lines-solution-in-javascript",
                "content": "    return nums.reduce(function(p, n) { \\n        return [p[1], Math.max(p[0] + n, p[1])]; \\n    }, [0,0])[1];\\n\\nvariable p records previous 2 max values: p[1] is the previous one and p[0] is the one before previous one. p is initialized as [0,0]. variable n is the value at each position.",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "    return nums.reduce(function(p, n) { \\n        return [p[1], Math.max(p[0] + n, p[1])]; \\n    }, [0,0])[1];\\n\\nvariable p records previous 2 max values: p[1] is the previous one and p[0] is the one before previous one. p is initialized as [0,0]. variable n is the value at each position.",
                "codeTag": "Unknown"
            },
            {
                "id": 650881,
                "title": "c-using-dp-easy-concise-and-clean-code",
                "content": "***Pls upvote if you find this helpful :)***\\n\\nBasic idea is to break the problem into subproblems by solving it for 1 house,2 houses and then so on. So we can observe logically that value with n houses is max(value with n-1 houses,value with n-2 houses+value of nth house).Therefore we create dp array and fill it with similar logic to find the value with n houses.\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[1]=nums[0];\\n        for(int i=2;i<=n;i++){\\n            dp[i]=max(dp[i-1],dp[i-2]+nums[i-1]);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[1]=nums[0];\\n        for(int i=2;i<=n;i++){\\n            dp[i]=max(dp[i-1],dp[i-2]+nums[i-1]);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55907,
                "title": "simplest-java-solution",
                "content": "    public class Solution {\\n    \\n        public int rob(int[] num) {\\n            int last = 0;\\n            int now = 0;\\n            int tmp;\\n            for (int n :num) {\\n                tmp = now;\\n                now = Math.max(last + n, now);\\n                last = tmp;\\n            }\\n            return now;        \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n        public int rob(int[] num) {\\n            int last = 0;\\n            int now = 0;\\n            int tmp;\\n            for (int n :num) {\\n                tmp = now;\\n                now = Math.max(last + n, now);\\n                last = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 299056,
                "title": "python-o-n-time-o-1-space-4-lines",
                "content": "The idea is from *ldthu* whose original answer was written in Java. https://leetcode.com/problems/house-robber/discuss/55838/DP-O(N)-time-O(1)-space-with-easy-to-understand-explanation\\n\\n\\nAt each house there are two options: either to rob it or not to rob it. \\n\\n**Option 1**: If rob, then **rob = not_rob + nums[i]**\\n(max money if rob the current house = max money if not rob                    the last house + amount of the current house)\\n**Option 2**: If not rob, then **not_rob = max(rob, not_rob)**\\n                (max money if not rob the current house = max money at the                    last house, either rob or not rob)\\n\\n**Varibles:** rob = max money if rob the current house\\n\\t\\t  not_rob = max money if not rob the current house. \\n\\t\\t  Both variables are initially set to 0\\n\\n**Complexity:**\\ntime = O(n)\\nSpace = O(1)\\n\\nHere is the code:\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        rob, not_rob = 0, 0\\n        for num in nums:\\n            rob, not_rob = not_rob + num, max(rob, not_rob)\\n        return max(rob, not_rob)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        rob, not_rob = 0, 0\\n        for num in nums:\\n            rob, not_rob = not_rob + num, max(rob, not_rob)\\n        return max(rob, not_rob)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282624,
                "title": "easy-to-read-javascript-o-n-time-o-1-space-iterative",
                "content": "```\\nvar rob = function(nums) {\\n    /*\\n    Runtime: 56 ms, faster than 100.00% of JavaScript online submissions for House Robber.\\n    Memory Usage: 33.8 MB, less than 25.89% of JavaScript online submissions for House Robber.\\n    \\n    O(n) time, O(1) space\\n\\t\\n\\t- Bottom up strategy\\n\\t- Iterative\\n\\t- Memoization\\n\\t\\n\\tTrick: At index [i], you only need to know the maximum profit at [i - 1] and [i - 2]. This is a slight variation on fibonacci.\\n    */\\n    \\n    if (!nums.length) return 0;\\n    if (nums.length === 1) return nums[0];\\n    if (nums.length === 2) return Math.max(nums[0], nums[1]);\\n    \\n    let maxAtTwoBefore = nums[0];\\n    let maxAtOneBefore = Math.max(nums[0], nums[1]);\\n    \\n    for (let i = 2; i < nums.length; i++) {\\n        const maxAtCurrent = Math.max(nums[i] + maxAtTwoBefore, maxAtOneBefore);\\n        \\n        maxAtTwoBefore = maxAtOneBefore;\\n        maxAtOneBefore = maxAtCurrent;\\n    }\\n    \\n    return maxAtOneBefore;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    /*\\n    Runtime: 56 ms, faster than 100.00% of JavaScript online submissions for House Robber.\\n    Memory Usage: 33.8 MB, less than 25.89% of JavaScript online submissions for House Robber.\\n    \\n    O(n) time, O(1) space\\n\\t\\n\\t- Bottom up strategy\\n\\t- Iterative\\n\\t- Memoization\\n\\t\\n\\tTrick: At index [i], you only need to know the maximum profit at [i - 1] and [i - 2]. This is a slight variation on fibonacci.\\n    */\\n    \\n    if (!nums.length) return 0;\\n    if (nums.length === 1) return nums[0];\\n    if (nums.length === 2) return Math.max(nums[0], nums[1]);\\n    \\n    let maxAtTwoBefore = nums[0];\\n    let maxAtOneBefore = Math.max(nums[0], nums[1]);\\n    \\n    for (let i = 2; i < nums.length; i++) {\\n        const maxAtCurrent = Math.max(nums[i] + maxAtTwoBefore, maxAtOneBefore);\\n        \\n        maxAtTwoBefore = maxAtOneBefore;\\n        maxAtOneBefore = maxAtCurrent;\\n    }\\n    \\n    return maxAtOneBefore;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805852,
                "title": "c-apni-bhasha-mein-easy-explanation-dp-1d-interview-prep",
                "content": "# Approach & Intuition\\n- Explained in the code.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        LOGIC\\n\\n        KARNA KYA HAIN\\u2753\\n        1. Main chor hu mujhe chori karni hain.\\n        2. Mujhe jyada se jyada lootna hain bina police ko pata lage.\\n        3. Dikkat hain ki main 2 adjacent house se chori nahin kar sakta kyoki\\n        udhar security system laga hain.\\n        4. Mujhe houseAmount array is given now I want to loot as much as I can \\n        without informing the police.\\n\\n        APPROACH & INTUITION\\n        1. Ab chor ke paas 2 choice hain:-\\n        - Kisi ghar ki chori kare to agle ghar ko chodke aage ke gharo mein\\n        chori kare.\\n        - Ya to current ghar chod de aur aage ke gharo se chori kare.\\n        2. So its a type of \\uD83D\\uDCA1Pick/Non-Pick\\uD83D\\uDCA1variant.\\n        3. So Pick/non-pick mein we will use RECURSION\\n        4. What do we do in RECURSION\\u2753\\n        - Visualize it in the form of indexes.\\n        - Do all stuff on these indexes according to statement.\\n        - Count means SUM , minimize means min , maximize means max\\n        5. What is the relation here\\u2753\\n        pick = f(i-2)+currentHomeAmount \\n        =>current ghar liya to pichle ghar ko\\n        chod diya .\\n        notPick = f(i-1)+0 \\n        => current ghar ko chodke pichla ghar liya\\n        BASE CASE:- \\n        ind <0 hua to matlab hamne chori nahin ki abhi tak -return 0\\n        ind 0 hua to matlab hamne pehle ghar ki chori kari abhi tak-return nums[0]\\n        6.Ab inme se max nikalna hain.\\n        7. Now there will overlapping-subproblems\\n        8. RECUSRSION -> MEMOIZATION -> TABULATION -> SpaceOPTIMIZATION\\n        9. RECUSRION to Memoization\\n        - Check the changing parameter(house no)\\n        - Declare dp array of size n\\n        - Store the max result as dp[i]\\n        - Check if dp[ind] is not looted before.\\n        10. Memoization to Tabulation\\n        - Declare the dp array size.\\n        - Declare the base cases.\\n        - Iterate till last house\\n        - Replace f(ind) with dp[ind]\\n        11. Tabulation to Space Optimization\\n        - Try to find do we need a dp array?\\n        - Try to find if there is any pattern found amond dp[i],dp[i-1],..\\n        - Gneralize this in terms of variables\\n\\n//==============================================================================================\\n        \\n       \\t//Recursive Solution\\n           int Recursion(int i, vector<int> &nums)\\n       \\t    {\\n       \\t        if (i == 0)\\n       \\t            return nums[i];\\n       \\t        if (i < 0)\\n       \\t            return 0;\\n       \\t        int pick = nums[i] + Recursion(i - 2, nums);\\n       \\t        int nonPick = 0 + Recursion(i - 1, nums);\\n       \\t        return max(pick, nonPick);\\n       \\t    }\\n       \\tint rob(vector<int> &nums)\\n       \\t{\\n       \\t    int n = nums.size() - 1;\\n       \\t    return Recursion(n, nums);\\n       \\t}\\n\\n       \\t//Memoization\\n \\t        int Memoization(int i, vector<int> &nums, vector<int> &dp)\\n       \\t        {\\n       \\t            if (i == 0)\\n       \\t                return nums[0];\\n       \\t            if (i < 0)\\n       \\t                return 0;\\n       \\t            if (dp[i] != -1)\\n       \\t                return dp[i];\\n       \\t            int pick = nums[i] + Memoization(i - 2, nums, dp);\\n       \\t            int nonPick = 0 + Memoization(i - 1, nums, dp);\\n       \\t            return dp[i] = max(pick, nonPick);\\n       \\t        }\\n       \\t    int rob(vector<int> &nums)\\n       \\t    {\\n       \\t        int n = nums.size();\\n       \\t        vector<int> dp(n, -1);\\n       \\t        return Memoization(n-1, nums, dp);\\n       \\t    }\\n\\n       \\t//Tabulation(Unoptimized)\\n int rob(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n            vector<int> dp(n, -1);\\n            dp[0] = nums[0];\\n            for (int i = 1; i < n; i++)\\n            {\\n                int pick = nums[i];\\n                if (i > 1)\\n                    pick = pick + dp[i - 2];\\n                int notPick = 0 + dp[i - 1];\\n                dp[i] = max(pick, notPick);\\n            }\\n            return dp[n - 1];\\n        }\\n\\n   \\t//Tabulation(Optimized)\\n    int rob(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int prev1 = nums[0];\\n        int prev = 0;\\n        int curri = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            int pick = nums[i];\\n            if (i > 1)\\n                pick = pick + prev;\\n            int notPick = 0 + prev1;\\n            curri = max(pick, notPick);\\n            prev = prev1;\\n            prev1 = curri;\\n        }\\n        return prev1;\\n    }\\n};\\n```\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        LOGIC\\n\\n        KARNA KYA HAIN\\u2753\\n        1. Main chor hu mujhe chori karni hain.\\n        2. Mujhe jyada se jyada lootna hain bina police ko pata lage.\\n        3. Dikkat hain ki main 2 adjacent house se chori nahin kar sakta kyoki\\n        udhar security system laga hain.\\n        4. Mujhe houseAmount array is given now I want to loot as much as I can \\n        without informing the police.\\n\\n        APPROACH & INTUITION\\n        1. Ab chor ke paas 2 choice hain:-\\n        - Kisi ghar ki chori kare to agle ghar ko chodke aage ke gharo mein\\n        chori kare.\\n        - Ya to current ghar chod de aur aage ke gharo se chori kare.\\n        2. So its a type of \\uD83D\\uDCA1Pick/Non-Pick\\uD83D\\uDCA1variant.\\n        3. So Pick/non-pick mein we will use RECURSION\\n        4. What do we do in RECURSION\\u2753\\n        - Visualize it in the form of indexes.\\n        - Do all stuff on these indexes according to statement.\\n        - Count means SUM , minimize means min , maximize means max\\n        5. What is the relation here\\u2753\\n        pick = f(i-2)+currentHomeAmount \\n        =>current ghar liya to pichle ghar ko\\n        chod diya .\\n        notPick = f(i-1)+0 \\n        => current ghar ko chodke pichla ghar liya\\n        BASE CASE:- \\n        ind <0 hua to matlab hamne chori nahin ki abhi tak -return 0\\n        ind 0 hua to matlab hamne pehle ghar ki chori kari abhi tak-return nums[0]\\n        6.Ab inme se max nikalna hain.\\n        7. Now there will overlapping-subproblems\\n        8. RECUSRSION -> MEMOIZATION -> TABULATION -> SpaceOPTIMIZATION\\n        9. RECUSRION to Memoization\\n        - Check the changing parameter(house no)\\n        - Declare dp array of size n\\n        - Store the max result as dp[i]\\n        - Check if dp[ind] is not looted before.\\n        10. Memoization to Tabulation\\n        - Declare the dp array size.\\n        - Declare the base cases.\\n        - Iterate till last house\\n        - Replace f(ind) with dp[ind]\\n        11. Tabulation to Space Optimization\\n        - Try to find do we need a dp array?\\n        - Try to find if there is any pattern found amond dp[i],dp[i-1],..\\n        - Gneralize this in terms of variables\\n\\n//==============================================================================================\\n        \\n       \\t//Recursive Solution\\n           int Recursion(int i, vector<int> &nums)\\n       \\t    {\\n       \\t        if (i == 0)\\n       \\t            return nums[i];\\n       \\t        if (i < 0)\\n       \\t            return 0;\\n       \\t        int pick = nums[i] + Recursion(i - 2, nums);\\n       \\t        int nonPick = 0 + Recursion(i - 1, nums);\\n       \\t        return max(pick, nonPick);\\n       \\t    }\\n       \\tint rob(vector<int> &nums)\\n       \\t{\\n       \\t    int n = nums.size() - 1;\\n       \\t    return Recursion(n, nums);\\n       \\t}\\n\\n       \\t//Memoization\\n \\t        int Memoization(int i, vector<int> &nums, vector<int> &dp)\\n       \\t        {\\n       \\t            if (i == 0)\\n       \\t                return nums[0];\\n       \\t            if (i < 0)\\n       \\t                return 0;\\n       \\t            if (dp[i] != -1)\\n       \\t                return dp[i];\\n       \\t            int pick = nums[i] + Memoization(i - 2, nums, dp);\\n       \\t            int nonPick = 0 + Memoization(i - 1, nums, dp);\\n       \\t            return dp[i] = max(pick, nonPick);\\n       \\t        }\\n       \\t    int rob(vector<int> &nums)\\n       \\t    {\\n       \\t        int n = nums.size();\\n       \\t        vector<int> dp(n, -1);\\n       \\t        return Memoization(n-1, nums, dp);\\n       \\t    }\\n\\n       \\t//Tabulation(Unoptimized)\\n int rob(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n            vector<int> dp(n, -1);\\n            dp[0] = nums[0];\\n            for (int i = 1; i < n; i++)\\n            {\\n                int pick = nums[i];\\n                if (i > 1)\\n                    pick = pick + dp[i - 2];\\n                int notPick = 0 + dp[i - 1];\\n                dp[i] = max(pick, notPick);\\n            }\\n            return dp[n - 1];\\n        }\\n\\n   \\t//Tabulation(Optimized)\\n    int rob(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int prev1 = nums[0];\\n        int prev = 0;\\n        int curri = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            int pick = nums[i];\\n            if (i > 1)\\n                pick = pick + prev;\\n            int notPick = 0 + prev1;\\n            curri = max(pick, notPick);\\n            prev = prev1;\\n            prev1 = curri;\\n        }\\n        return prev1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846002,
                "title": "python-dynamic-programming-easy-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # dynamic programming - decide each problem by its sub-problems:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # dynamic programming - decide each problem by its sub-problems:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491888,
                "title": "javascript-from-noob-to-pro",
                "content": "The best way to start DP related problem is to think about the problem first and build a recursive strategy. This is because recursion is easier and you can apply memoization rather quickly compared to tabulation. And you will get a solution anyway after which you can optimize the solution. In any interview, getting a solution is the key.\\n\\nLet\\'s take the sample here:\\n\\n```\\n[ 2, 7, 9, 3, 1 ]\\n```\\n\\nLet\\'s say we start at house with amount 2. Then we can do two things:\\n\\n- Skip the house and move on\\n- Rob the house and skip next house\\n\\nWe can make this generic by saying at any starting house. And we want to start at the very first house (only start the logic, to rob or not is a different thing) since we want to maximize the robbery. So Let\\'s turn this into the most naive recursive solution.\\n\\n```javascript\\n// O(2^n) time | O(2^n) space\\nvar rob = function(nums, idx = 0) {\\n    if (idx >= nums.length) {\\n        return 0;\\n    }\\n    \\n    const sumIfSkipped = rob(nums, idx + 1);\\n    const sumIfRobbed = nums[idx] + rob(nums, idx + 2);\\n    \\n    return Math.max(sumIfSkipped, sumIfRobbed);\\n};\\n```\\n\\nYou know what happened when I submit this solution? You guessed it right, it timed out. The reason is, we are doing the same work multiple times, at each index. To speed it up, let\\'s add memoization to it.\\n\\n```javascript\\n// O(n) time | O(n) space\\nvar rob = function(nums, idx = 0, memo = {}) {\\n    if (idx in memo) {\\n        return memo[idx];\\n    }\\n    \\n    if (idx >= nums.length) {\\n        return 0;\\n    }\\n    \\n    const sumIfSkipped = rob(nums, idx + 1, memo);\\n    const sumIfRobbed = nums[idx] + rob(nums, idx + 2, memo);\\n    \\n    return memo[idx] = Math.max(sumIfSkipped, sumIfRobbed);\\n};\\n```\\n\\nThis is better, from exponential (2 to the power of n) to 2 times n in complexity. The results of my run are as follows:\\n\\n![image](https://assets.leetcode.com/users/images/c469eb53-70b2-49ec-8122-3b47e9f85bb1_1632851070.6599624.png)\\n\\nIt was fast, but I think we can certainly do better. And that is by using iteration instead of recursion. We start by observing the existing code, and we make two observations:\\n\\n- If we decide to skip the house at index i, then we are computing max robbery possible starting from house at index i+1.\\n- If we decide to rob the house at index i, then we are computing max robbery possible starting from house at index i+2.\\n\\nSo at every house, we are doing two lookups. To make this easier, let\\'s construct a DP table and iterate the given array from right to left. This is why tabulation is also called as bottom-up approach.\\n\\n```javascript\\n// O(n) time | O(n) space\\nvar rob = function(nums) {\\n    const table = new Array(nums.length + 2);\\n    \\n    table[nums.length + 0] = 0;\\n    table[nums.length + 1] = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        const sumIfSkipped = table[i + 1];\\n        const sumIfRobbed = nums[i] + table[i + 2];\\n        \\n        table[i] = Math.max(sumIfSkipped, sumIfRobbed);\\n    }\\n    \\n    return table[0];\\n}\\n```\\n\\nThe complexity is the same as the previous solution with memoization, but this is even faster, since we are skipping the stack frames and recursive function calls. The results of my run are as follows:\\n\\n![image](https://assets.leetcode.com/users/images/f0849698-cb8a-4204-8e69-dbe196864630_1632851628.583106.png)\\n\\nWe aren\\'t done yet! If you notice, we are only making two lookups, and we can reduce the space complexity if we get rid of the table and use two variables for that. This way, we will get the solution to O(1) space, which will super impress your interviewer.\\n\\n```javascript\\n// O(n) time | O(1) space\\nvar rob = function(nums) {\\n    let robbedIdxPlus1 = 0;\\n    let robbedIdxPlus2 = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        const sumIfSkipped = robbedIdxPlus1;\\n        const sumIfRobbed = nums[i] + robbedIdxPlus2;\\n        \\n        const maxRobbedAtIdx = Math.max(sumIfSkipped, sumIfRobbed);\\n        \\n        robbedIdxPlus2 = robbedIdxPlus1;\\n        robbedIdxPlus1 = maxRobbedAtIdx;\\n    }\\n    \\n    return robbedIdxPlus1;\\n}\\n```\\n\\nAnd the results? Here is an even faster submission:\\n\\n![image](https://assets.leetcode.com/users/images/32293b77-c7ce-47c3-862b-fe738c069134_1632851778.8733077.png)\\n\\nAre we done? I think so. If you find an even better way, be sure to let me know in the comments!",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n[ 2, 7, 9, 3, 1 ]\\n```\n```javascript\\n// O(2^n) time | O(2^n) space\\nvar rob = function(nums, idx = 0) {\\n    if (idx >= nums.length) {\\n        return 0;\\n    }\\n    \\n    const sumIfSkipped = rob(nums, idx + 1);\\n    const sumIfRobbed = nums[idx] + rob(nums, idx + 2);\\n    \\n    return Math.max(sumIfSkipped, sumIfRobbed);\\n};\\n```\n```javascript\\n// O(n) time | O(n) space\\nvar rob = function(nums, idx = 0, memo = {}) {\\n    if (idx in memo) {\\n        return memo[idx];\\n    }\\n    \\n    if (idx >= nums.length) {\\n        return 0;\\n    }\\n    \\n    const sumIfSkipped = rob(nums, idx + 1, memo);\\n    const sumIfRobbed = nums[idx] + rob(nums, idx + 2, memo);\\n    \\n    return memo[idx] = Math.max(sumIfSkipped, sumIfRobbed);\\n};\\n```\n```javascript\\n// O(n) time | O(n) space\\nvar rob = function(nums) {\\n    const table = new Array(nums.length + 2);\\n    \\n    table[nums.length + 0] = 0;\\n    table[nums.length + 1] = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        const sumIfSkipped = table[i + 1];\\n        const sumIfRobbed = nums[i] + table[i + 2];\\n        \\n        table[i] = Math.max(sumIfSkipped, sumIfRobbed);\\n    }\\n    \\n    return table[0];\\n}\\n```\n```javascript\\n// O(n) time | O(1) space\\nvar rob = function(nums) {\\n    let robbedIdxPlus1 = 0;\\n    let robbedIdxPlus2 = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        const sumIfSkipped = robbedIdxPlus1;\\n        const sumIfRobbed = nums[i] + robbedIdxPlus2;\\n        \\n        const maxRobbedAtIdx = Math.max(sumIfSkipped, sumIfRobbed);\\n        \\n        robbedIdxPlus2 = robbedIdxPlus1;\\n        robbedIdxPlus1 = maxRobbedAtIdx;\\n    }\\n    \\n    return robbedIdxPlus1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378700,
                "title": "python-multiple-solutions",
                "content": "Since we can\\'t rob two adjacent houses we need to check what is the maximum gain starting at the first and second house. From there we check what is the maximum gain we can make by robing houses at distance `2` and `3` from our current position. \\n\\nAnother way to look at it is we can take all the gains we made to arrive at two houses `i - 2` before the current house and whatever is there in the current house or we can take all the gains we made up to the previous house.\\n\\nThis is a dynamic programming problem. If we go with the above without caching previous computations we will end up with an `O(n^2)` algorithm. We have multiple strategies to cache intermediate results (see below).\\n# Recursive\\nWe create a chache in the object initializer. Our entry point function just call the recursive function for the first and second house. We check whether we are past the end of the array or if we already computed the max gain for positions that are distance `2` or `3` from our current position.\\n\\n## Top down\\n\\nLook Before You Leap (LBYL) --> We check whether the position is already in the cache using `if` and return that otherwise we compute it\\n\\nTop down --> We start at the first house, end at last house\\n\\n```python\\nclass Solution:\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def rob_rec(self, nums, start):\\n        if start >= len(nums):\\n            return 0\\n        \\n        if start in self.cache:\\n            return self.cache[start]\\n        \\n        self.cache[start] = nums[start] + max(self.rob_rec(nums, start+2), self.rob_rec(nums, start+3))\\n        return self.cache[start]\\n        \\n    def rob(self, nums: List[int]) -> int:\\n        return max(self.rob_rec(nums, 0), self.rob_rec(nums, 1))\\n```\\n\\n## Botom up\\n\\nEasier to Ask Forgiveness than Permission (EAFP) --> We use a `try...except` and suppose the value is already there and if not compute it\\n\\nBottom up --> We start at the last house and go back to the first\\n\\n```python\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.cache = {}\\n    \\n    def rob_rec(self, nums, current):\\n        if current < 0: # Beyond array boundary\\n            return 0\\n        \\n        try:\\n            return self.cache[current]\\n        except:\\n        \\n            self.cache[current] = max(self.rob_rec(nums, current - 1),\\n                                      nums[current] + self.rob_rec(nums, current - 2))\\n        return self.cache[current]\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        return self.rob_rec(nums, len(nums) - 1)\\n```\\n\\nTime `O(n)` / Space `O(n)`\\n\\n# Reversing the list\\nHere the idea is that there is only one way to rob the last two houses, i.e. take what is there. So we already have our max gain for those two positions. We can work our way backward from there until we rach the first and second house and return the maximum gain between those two.\\n\\n```python\\nfrom itertools import islice\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        nums.append(0)\\n        nums.reverse()\\n        for idx, num in enumerate(islice(nums, 3, None), 3):\\n            nums[idx] = max(num + nums[idx - 2], num + nums[idx - 3])\\n            \\n        return max(nums[-1], nums[-2])\\n```\\n\\nTime `O(n)` / Space `O(1)`\\n\\n# Rolling window\\nHere the idea is we need only to remeber what is the maximum gain at the next 3 houses from current position. We start at the end of the array and walk our way back to the first and second house.\\n\\n## Botom up\\n\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:        \\n        house_1 = 0\\n        house_2 = 0\\n        house_3 = 0\\n        for num in reversed(nums):\\n            temp = house_1\\n            house_1 = max(num + house_2, num + house_3)\\n            house_3 = house_2\\n            house_2 = temp\\n            \\n        return max(house_1, house_2)\\n```\\n\\n## Top down\\n\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev1, prev2 = 0, 0\\n        for num in nums:\\n            prev1, prev2 = max(prev2 + num, prev1), prev1\\n            \\n        return prev1\\n```\\n\\nTime `O(n)` / Space `O(1)`",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def rob_rec(self, nums, start):\\n        if start >= len(nums):\\n            return 0\\n        \\n        if start in self.cache:\\n            return self.cache[start]\\n        \\n        self.cache[start] = nums[start] + max(self.rob_rec(nums, start+2), self.rob_rec(nums, start+3))\\n        return self.cache[start]\\n        \\n    def rob(self, nums: List[int]) -> int:\\n        return max(self.rob_rec(nums, 0), self.rob_rec(nums, 1))\\n```\n```python\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.cache = {}\\n    \\n    def rob_rec(self, nums, current):\\n        if current < 0: # Beyond array boundary\\n            return 0\\n        \\n        try:\\n            return self.cache[current]\\n        except:\\n        \\n            self.cache[current] = max(self.rob_rec(nums, current - 1),\\n                                      nums[current] + self.rob_rec(nums, current - 2))\\n        return self.cache[current]\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        return self.rob_rec(nums, len(nums) - 1)\\n```\n```python\\nfrom itertools import islice\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        nums.append(0)\\n        nums.reverse()\\n        for idx, num in enumerate(islice(nums, 3, None), 3):\\n            nums[idx] = max(num + nums[idx - 2], num + nums[idx - 3])\\n            \\n        return max(nums[-1], nums[-2])\\n```\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:        \\n        house_1 = 0\\n        house_2 = 0\\n        house_3 = 0\\n        for num in reversed(nums):\\n            temp = house_1\\n            house_1 = max(num + house_2, num + house_3)\\n            house_3 = house_2\\n            house_2 = temp\\n            \\n        return max(house_1, house_2)\\n```\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev1, prev2 = 0, 0\\n        for num in nums:\\n            prev1, prev2 = max(prev2 + num, prev1), prev1\\n            \\n        return prev1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55737,
                "title": "well-commented-java-o-n-time-constant-space",
                "content": "    public class Solution {\\n        public int rob(int[] nums) {\\n            // If we get invalid input, return 0\\n            if (nums == null || nums.length == 0) return 0;\\n            \\n            // Keep track of whether or not we robbed the previous house\\n            int robbedPrevious = 0;\\n            int didNotRobPrevious = 0;\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                \\n                // If we don't rob the current house, take the max of robbing and not robbing the previous house\\n                int currentNotRobbed = Math.max(robbedPrevious, didNotRobPrevious);\\n                \\n                // If we rob the current house, add the current money robbed to what we got from not robbing previous\\n                int currentIsRobbed = didNotRobPrevious + nums[i];\\n                \\n                // Update our values for the next iteration\\n                didNotRobPrevious = currentNotRobbed;\\n                robbedPrevious = currentIsRobbed;\\n            }\\n            \\n            // Return the maximum we could have robbed provided we looked at both options\\n            return Math.max(robbedPrevious, didNotRobPrevious);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int rob(int[] nums) {\\n            // If we get invalid input, return 0\\n            if (nums == null || nums.length == 0) return 0;\\n            \\n            // Keep track of whether or not we robbed the previous house\\n            int robbedPrevious = 0;\\n            int didNotRobPrevious = 0;\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                \\n                // If we don't rob the current house, take the max of robbing and not robbing the previous house\\n                int currentNotRobbed = Math.max(robbedPrevious, didNotRobPrevious);\\n                \\n                // If we rob the current house, add the current money robbed to what we got from not robbing previous\\n                int currentIsRobbed = didNotRobPrevious + nums[i];\\n                \\n                // Update our values for the next iteration\\n                didNotRobPrevious = currentNotRobbed;\\n                robbedPrevious = currentIsRobbed;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 710200,
                "title": "all-3-approaches-recursion-memoization-dp",
                "content": "DP made easy - for DP problems please dont write top-down directly\\n1. Write recursive solution\\n2. Convert that into Top-Down or Bottom-Up(Memoization)\\n\\n```\\n// Recursion Time - O(n^2) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        return getMaxAmount(nums, nums.length - 1);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums, int n) {\\n       if(n < 0) return 0; \\n       if(n == 0) return nums[0];\\n       if(n == 1) return Integer.max(nums[1], nums[0]);\\n       return Integer.max(nums[n] + getMaxAmount(nums, n-2), getMaxAmount(nums, n-1));\\n    }\\n}\\n\\n\\n// DP - Memoization Time - O(n^2) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        int dp[] = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return getMaxAmount(nums, nums.length - 1, dp);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums, int n, int[] dp) {\\n       if(n < 0) return 0; \\n       if(n == 0) return nums[0];\\n       if(n == 1) return Integer.max(nums[1], nums[0]);\\n       if(dp[n] != -1) return dp[n]; \\n       dp[n] = Integer.max(nums[n] + getMaxAmount(nums, n-2, dp), getMaxAmount(nums, n-1, dp));\\n       return dp[n]; \\n    }\\n}\\n\\n// DP - Top Down Time - O(n) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        return getMaxAmount(nums);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums) {\\n       int dp[] = new int[nums.length];\\n       dp[0] = nums[0];\\n       dp[1] = Integer.max(nums[1], nums[0]); \\n       for(int i = 2; i < nums.length; i++) {\\n           if(dp[i] > 0) return dp[i]; \\n            dp[i] = Integer.max(nums[i] + dp[i-2], dp[i-1]);\\n       }\\n       return dp[nums.length-1]; \\n    }\\n}\\n\\n// Optimised DP \\n// Time O(n)\\n// Space O(1)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        return getMaxAmount(nums);\\n    }\\n    \\n     public int getMaxAmount(int[] nums) { \\n        nums[1] = Math.max(nums[1], nums[0]);\\n        for(int i = 2; i < nums.length; i++) {\\n            nums[i] = Math.max(nums[i] + nums[i-2], nums[i-1]);\\n           System.out.println(nums[i]); \\n        }  \\n         return nums[nums.length-1]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursion Time - O(n^2) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        return getMaxAmount(nums, nums.length - 1);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums, int n) {\\n       if(n < 0) return 0; \\n       if(n == 0) return nums[0];\\n       if(n == 1) return Integer.max(nums[1], nums[0]);\\n       return Integer.max(nums[n] + getMaxAmount(nums, n-2), getMaxAmount(nums, n-1));\\n    }\\n}\\n\\n\\n// DP - Memoization Time - O(n^2) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        int dp[] = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return getMaxAmount(nums, nums.length - 1, dp);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums, int n, int[] dp) {\\n       if(n < 0) return 0; \\n       if(n == 0) return nums[0];\\n       if(n == 1) return Integer.max(nums[1], nums[0]);\\n       if(dp[n] != -1) return dp[n]; \\n       dp[n] = Integer.max(nums[n] + getMaxAmount(nums, n-2, dp), getMaxAmount(nums, n-1, dp));\\n       return dp[n]; \\n    }\\n}\\n\\n// DP - Top Down Time - O(n) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        return getMaxAmount(nums);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums) {\\n       int dp[] = new int[nums.length];\\n       dp[0] = nums[0];\\n       dp[1] = Integer.max(nums[1], nums[0]); \\n       for(int i = 2; i < nums.length; i++) {\\n           if(dp[i] > 0) return dp[i]; \\n            dp[i] = Integer.max(nums[i] + dp[i-2], dp[i-1]);\\n       }\\n       return dp[nums.length-1]; \\n    }\\n}\\n\\n// Optimised DP \\n// Time O(n)\\n// Space O(1)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        return getMaxAmount(nums);\\n    }\\n    \\n     public int getMaxAmount(int[] nums) { \\n        nums[1] = Math.max(nums[1], nums[0]);\\n        for(int i = 2; i < nums.length; i++) {\\n            nums[i] = Math.max(nums[i] + nums[i-2], nums[i-1]);\\n           System.out.println(nums[i]); \\n        }  \\n         return nums[nums.length-1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871646,
                "title": "first-missing-positive-c-two-solutions-o-n-time-100",
                "content": "<b>The problem</b>\\nHonestly, it was surpising to me to find out that this problem is marked as hard.\\nWhen I saw the problem, I thought it was probably easy or medium difficulty.\\nI had done some similar problems previously, that required me to use the original array and negate numbers at indices according to some other values.\\nI guess it can appear hard to solve it in linear time, if you miss the clue.\\n\\n<b>Approach</b>\\nThe main thing here is to really understand the question. They are looking for the first positive integer, of <b>ALL</b> positive integers, that does not exist in the given array.\\nThis implies that the first missing number can be in range from ```1``` to ```N``` (size of the input).\\nNow we only have to figure out which one is the first in the sequence that is not present in the array.\\n\\n<b>Solution 1</b>\\nCreate a new array of input size, with all values set to ```-1```.\\nFor each value in the original array, set ```newArray[value - 1]``` to ```1```, if the value is within the ```1``` - ```N``` range.\\nNow we go through the new array and look for the first ```-1``` value. The missing number is ```index + 1```, since we are looking only for positive numbers and we start count from 1, while index is zero based.\\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\n<b>Solution 2</b>\\nVery similar to first solution, but we use the original array instead of creating a new one. So the space complexity is constant.\\nSince we don\\'t need to look at the negative values in the array, we set them to ```0```. Then we use the original array to negate all the numbers at indices for which the value exists in the array.\\nIt is a little tricky, and my solution might require some polishing, but overall, it isn\\'t difficult.\\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\nAny suggestions or advice on how to improve the solutions are always welcome. Thank you!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```1```\n```N```\n```-1```\n```newArray[value - 1]```\n```1```\n```1```\n```N```\n```-1```\n```index + 1```\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\n```0```\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55793,
                "title": "short-0ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int x = 0, y = 0;\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (i & 1) {\\n                    x = max(x + nums[i], y);\\n                } else {\\n                    y = max(y + nums[i], x);\\n                }\\n            }\\n            return max(x, y);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int x = 0, y = 0;\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (i & 1) {\\n                    x = max(x + nums[i], y);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 55959,
                "title": "4-line-python-o-1-space-o-n-time-with-explaination-simplest",
                "content": "    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def rob(self, num):\\n            # DP O(n) time, O(1) space\\n            # ik: max include house k\\n            # ek: max exclude house k, (Note: ek is also the maximum for house 1,...,k-1)\\n            # i[k+1]: num[k] + ek #can't include house k\\n            # e[k+1]: max(ik, ek) # can either include house k or exclude house k\\n            i, e = 0, 0\\n            for n in num: #from k-1 to k\\n                i, e = n+e, max(i,e)\\n            return max(i,e)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def rob(self, num):\\n            # DP O(n) time, O(1) space\\n            # ik: max include house k\\n            # ek: max exclude house k, (Note: ek is also the maximum for house 1,...,k-1)\\n            # i[k+1]: num[k] + ek #can't include house k\\n            # e[k+1]: max(ik, ek) # can either include house k or exclude house k\\n            i, e = 0, 0\\n            for n in num: #from k-1 to k\\n                i, e = n+e, max(i,e)\\n            return max(i,e)",
                "codeTag": "Java"
            },
            {
                "id": 2909861,
                "title": "c-3-approachs-memoization-tabulation-space-optimization",
                "content": "# Intuition\\nApproach that clicks into my mind is use recursion since we have to find all the ways to get maximum sum.\\n\\n# Approach\\nFor each house, we have two options- \\ni) Either rob that house, add its money to the sum and move to next-to-next house.\\nii) Or don\\'t rob that house and move to next one.\\nand At last find maximum sum.\\n\\n# Memoization\\n```\\nint rec(vector<int> &nums, int idx, vector<int> &dp)\\n{\\n    if(idx>=nums.size()) return 0;\\n    \\n    if(dp[idx]!=-1) dp[idx];\\n    \\n    return dp[idx] = max(rec(nums, idx+1, dp), nums[idx]+rec(nums, idx+2, dp));\\n}\\n\\nint rob(vector<int>& nums) \\n{\\n    vector<int> dp(nums.size()+1, -1);\\n    return rec(nums, 0, dp);\\n    \\n}\\n```\\n### Complexity\\n- Time complexity:\\nO(N) (recursion)\\n\\n- Space complexity:\\nO(N) (dp) + O(N) (recursion auxiliary space)\\n\\n# Tabulation\\n\\n```\\nint rob(vector<int>& nums)\\n{\\n    if(nums.size()==1) return nums[0];\\n    \\n    vector<int> dp(nums.size());\\n    \\n    dp[0] = nums[0];\\n    dp[1] = max(dp[0], nums[1]);\\n    \\n    for(int i=2; i<nums.size(); i++)\\n    {\\n        dp[i] = max(dp[i-1], dp[i-2]+nums[i]);\\n    }\\n    return dp[nums.size()-1];\\n}\\n```\\n### Complexity\\n- Time complexity:\\nO(N) (loop)\\n\\n- Space complexity:\\nO(N) (dp)\\n\\n# Space Optimization\\n```\\nint rob(vector<int>& nums)\\n{\\n    if(nums.size()==1) return nums[0];\\n    \\n    int pre2 = nums[0];\\n    int pre1 = max(nums[0], nums[1]);\\n    int cur;\\n    \\n    for(int i=2; i<nums.size(); i++)\\n    {\\n        cur = max(pre1, pre2+nums[i]);\\n        pre2 = pre1;\\n        pre1 = cur;\\n    }\\n    return pre1;\\n}\\n```\\n### Complexity\\n- Time complexity:\\nO(N) (loop)\\n\\n- Space complexity:\\nO(1) \\n\\n\\n    \\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint rec(vector<int> &nums, int idx, vector<int> &dp)\\n{\\n    if(idx>=nums.size()) return 0;\\n    \\n    if(dp[idx]!=-1) dp[idx];\\n    \\n    return dp[idx] = max(rec(nums, idx+1, dp), nums[idx]+rec(nums, idx+2, dp));\\n}\\n\\nint rob(vector<int>& nums) \\n{\\n    vector<int> dp(nums.size()+1, -1);\\n    return rec(nums, 0, dp);\\n    \\n}\\n```\n```\\nint rob(vector<int>& nums)\\n{\\n    if(nums.size()==1) return nums[0];\\n    \\n    vector<int> dp(nums.size());\\n    \\n    dp[0] = nums[0];\\n    dp[1] = max(dp[0], nums[1]);\\n    \\n    for(int i=2; i<nums.size(); i++)\\n    {\\n        dp[i] = max(dp[i-1], dp[i-2]+nums[i]);\\n    }\\n    return dp[nums.size()-1];\\n}\\n```\n```\\nint rob(vector<int>& nums)\\n{\\n    if(nums.size()==1) return nums[0];\\n    \\n    int pre2 = nums[0];\\n    int pre1 = max(nums[0], nums[1]);\\n    int cur;\\n    \\n    for(int i=2; i<nums.size(); i++)\\n    {\\n        cur = max(pre1, pre2+nums[i]);\\n        pre2 = pre1;\\n        pre1 = cur;\\n    }\\n    return pre1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831866,
                "title": "easy-js-solution",
                "content": "```\\n/*\\nAt each house, we can choose to either rob or skip\\nIf we choose to rob, we can\\'t rob the next house\\nIf we choose to skip, we can rob the next house\\n\\ndp[i] is the maximum amount of money we can rob without alerting the police at house i\\ndp[i] = max(dp[i-2] + nums[i], dp[i-1])\\n*/\\nvar rob = function(nums) {\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    let dp = new Array(nums.length);\\n    dp[0] = nums[0];\\n    dp[1] = Math.max(nums[0], nums[1]);\\n    for (let i = 2; i < nums.length; i++) {\\n        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);\\n    }\\n    return dp[nums.length - 1];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nAt each house, we can choose to either rob or skip\\nIf we choose to rob, we can\\'t rob the next house\\nIf we choose to skip, we can rob the next house\\n\\ndp[i] is the maximum amount of money we can rob without alerting the police at house i\\ndp[i] = max(dp[i-2] + nums[i], dp[i-1])\\n*/\\nvar rob = function(nums) {\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    let dp = new Array(nums.length);\\n    dp[0] = nums[0];\\n    dp[1] = Math.max(nums[0], nums[1]);\\n    for (let i = 2; i < nums.length; i++) {\\n        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);\\n    }\\n    return dp[nums.length - 1];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2909981,
                "title": "recursion-memoization-tabulation-space-optimization",
                "content": "**1. Recursion: [Not accepted : TLE]**\\n```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int>& nums){\\n        if(ind==0) return nums[ind];    \\n        if(ind<0) return 0;\\n        int pick=nums[ind]+ f(ind-2,nums);\\n        int notPick=f(ind-1,nums);\\n        return max(pick,notPick); \\n    }\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        return f(n-1,nums);\\n    }\\n};\\n```\\n**TC: O(2^N)** , where N is the number of elements in A. At each index, we have two choices of either robbing or not robbing the current house. Thus this leads to time complexity of 2*2*2...n times \\u2248 O(2^N)\\n**SC: O(N)** , It is recursive stack space.\\n\\n**2. Memoization/Top-down DP: [accepted]**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        return f(n-1,nums,dp);\\n    }\\n    int f(int ind,vector<int>& nums, vector<int>& dp){\\n        if(ind==0) return nums[ind];\\n        if(ind<0) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int pick= nums[ind]+ f(ind-2,nums,dp);\\n        int notPick= f(ind-1,nums,dp);\\n        return dp[ind]=max(pick,notPick);\\n    }\\n};\\n```\\n**TC:** O(N) \\n**SC:** O(N)+O(N), one is recursive stack space and anothe O(N) is for dp array.\\n\\n**3. Tabulation/Buttom Up DP:**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            int pick=nums[i];\\n            if(i>1) pick+=dp[i-2];\\n            int notPick=dp[i-1];\\n            dp[i]=max(pick,notPick);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**TC:** O(N) \\n**SC:** O(N), for dp array.\\n\\n**4. Space Optimization:**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        int prev=nums[0], prev2=0;\\n        for(int i=1;i<n;i++){\\n            int pick=nums[i]+prev2;\\n            int notPick=prev;\\n            int cur=max(pick,notPick);\\n            prev2=prev;\\n            prev=cur;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n**TC:** O(N) \\n**SC:** O(1)\\n\\n***Do an upvote if this is helpful!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int>& nums){\\n        if(ind==0) return nums[ind];    \\n        if(ind<0) return 0;\\n        int pick=nums[ind]+ f(ind-2,nums);\\n        int notPick=f(ind-1,nums);\\n        return max(pick,notPick); \\n    }\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        return f(n-1,nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        return f(n-1,nums,dp);\\n    }\\n    int f(int ind,vector<int>& nums, vector<int>& dp){\\n        if(ind==0) return nums[ind];\\n        if(ind<0) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int pick= nums[ind]+ f(ind-2,nums,dp);\\n        int notPick= f(ind-1,nums,dp);\\n        return dp[ind]=max(pick,notPick);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            int pick=nums[i];\\n            if(i>1) pick+=dp[i-2];\\n            int notPick=dp[i-1];\\n            dp[i]=max(pick,notPick);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        int prev=nums[0], prev2=0;\\n        for(int i=1;i<n;i++){\\n            int pick=nums[i]+prev2;\\n            int notPick=prev;\\n            int cur=max(pick,notPick);\\n            prev2=prev;\\n            prev=cur;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55976,
                "title": "java-o-n-dp-solution-with-13-lines-clean-code",
                "content": "     public int rob(int[] num) {\\n    \\t\\tint n = num.length;\\n    \\t\\tif (n < 2)\\n    \\t\\t\\treturn n == 0 ? 0 : num[0];\\n    \\t\\tint[] cache = new int[n];\\n    \\t\\tcache[0] = num[0];\\n    \\t\\tcache[1] = num[0] > num[1] ? num[0] : num[1];\\n    \\t\\tfor (int i = 2; i < n; i++) {\\n    \\t\\t\\tcache[i] = cache[i - 2] + num[i];\\n    \\t\\t\\tcache[i] = cache[i] > cache[i-1]? cache[i] : cache[i-1];\\n    \\t\\t}\\n    \\t\\treturn cache[n - 1];\\n    \\t}",
                "solutionTags": [],
                "code": "     public int rob(int[] num) {\\n    \\t\\tint n = num.length;\\n    \\t\\tif (n < 2)\\n    \\t\\t\\treturn n == 0 ? 0 : num[0];\\n    \\t\\tint[] cache = new int[n];\\n    \\t\\tcache[0] = num[0];\\n    \\t\\tcache[1] = num[0] > num[1] ? num[0] : num[1];\\n    \\t\\tfor (int i = 2; i < n; i++) {\\n    \\t\\t\\tcache[i] = cache[i - 2] + num[i];\\n    \\t\\t\\tcache[i] = cache[i] > cache[i-1]? cache[i] : cache[i-1];\\n    \\t\\t}\\n    \\t\\treturn cache[n - 1];\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 55972,
                "title": "explanation-of-the-recursive-formula",
                "content": "By using Dynamic Programming, we can get the maximum amount of money step by step.\\n\\nFor every house  along the street, there are two situations,\\n\\n **1. If the previous house had been robbed, we can't rob the current house,**\\n\\n    currentMaxValue = max(previousNoRobbery, previousYesRobbery);\\n\\n **2. If the previous house hadn't been robbed, we can rob the current house,**\\n\\n    currentMaxValue = moneyOfCurrentHouse + previousNoRobbery\\n\\n\\n----------\\nHere's the code:\\n\\n    int rob(vector<int> &num) {\\n        int preNoRob = 0, preYesRob = 0;\\n        \\n        for(int i = 1; i <= num.size(); ++i) {\\n            int preNoRobTemp = preNoRob;\\n            preNoRob = max(preNoRob, preYesRob); // situation 1\\n            preYesRob = num[i-1] + preNoRobTemp; // situation 2\\n        }\\n        return max(preNoRob, preYesRob);\\n    }",
                "solutionTags": [],
                "code": "By using Dynamic Programming, we can get the maximum amount of money step by step.\\n\\nFor every house  along the street, there are two situations,\\n\\n **1. If the previous house had been robbed, we can't rob the current house,**\\n\\n    currentMaxValue = max(previousNoRobbery, previousYesRobbery);\\n\\n **2. If the previous house hadn't been robbed, we can rob the current house,**\\n\\n    currentMaxValue = moneyOfCurrentHouse + previousNoRobbery\\n\\n\\n----------\\nHere's the code:\\n\\n    int rob(vector<int> &num) {\\n        int preNoRob = 0, preYesRob = 0;\\n        \\n        for(int i = 1; i <= num.size(); ++i) {\\n            int preNoRobTemp = preNoRob;\\n            preNoRob = max(preNoRob, preYesRob); // situation 1\\n            preYesRob = num[i-1] + preNoRobTemp; // situation 2\\n        }\\n        return max(preNoRob, preYesRob);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2910165,
                "title": "python-c-rust-iterative-recursive-solutions-explained-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Dynamic Programming* approach to explore all possible paths. Time complexity is linear: **O(N)**. \\n****\\n\\n**Python #1.** Recursive DFS with memoization. Here, we consider each house and (i) either skip it (ii) or rob and skip the next one. This way, we will make a branching decision at every house, thus, exploring all possible scenarios of massive robbery. Space complexity is linear: **O(N)**.\\n```\\nclass Solution:\\n    \\n    def rob(self, nums):\\n        \\n        @cache\\n        def dfs(i):\\n            return max(dfs(i+1), nums[i] + dfs(i+2)) if i < len(nums) else 0\\n        \\n        return dfs(0)\\n```\\n\\n**C++ #1.** Iterative. The same logic as above, but updating the state explicitly. Space complexity is linear: **O(N)**.\\n```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n+2,0);\\n        \\n        for (int i = n-1; i >= 0; i--)\\n            dp[i] = max(dp[i+1], nums[i] + dp[i+2]);\\n    \\n        return dp[0];\\n    }\\n};\\n```\\n\\n**C++ #2.** Iterative. From the solution above, we notice that we don\\'t need to maintain the whole `dp` array. Only three values `dp[i]`, `dp[i+1]` and `dp[i+2]` are used in the cycle. Space complexity is constant: **O(1)**.\\n```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int dp0 = 0, dp1 = 0, dp2 = 0;\\n\\n        for (int n : nums)\\n            dp0 = max(dp1, n + dp2),  // [1] max profit at current house\\n            dp2 = dp1,                // [2] shift last 2 values to be \\n            dp1 = dp0;                //     used in the next iteration\\n\\n        return dp0;\\n    }\\n};\\n```\\n\\n**Python #3.** The last one can be compactified even further using Python\\'s multiple assignment.\\n```\\nclass Solution:\\n\\n    def rob(self, nums):\\n        dp1 = dp2 = 0\\n        for n in nums: \\n            dp2, dp1 = dp1, max(dp1, dp2 + n)\\n        return dp1\\n```\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** One-liner for the last Python solution.\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        return reduce(lambda dp, n: (max(n + dp[1], dp[0]), dp[0]), nums, [0,0])[0]\\n```\\n\\n**Rust.** One-liner with the same logic as above.\\n```\\nimpl Solution\\n{\\n    pub fn rob(nums: Vec<i32>) -> i32\\n    {\\n        nums.into_iter()\\n            .fold((0,0), |(dp1,dp2), n| (dp1.max(n + dp2), dp1)).0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def rob(self, nums):\\n        \\n        @cache\\n        def dfs(i):\\n            return max(dfs(i+1), nums[i] + dfs(i+2)) if i < len(nums) else 0\\n        \\n        return dfs(0)\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n+2,0);\\n        \\n        for (int i = n-1; i >= 0; i--)\\n            dp[i] = max(dp[i+1], nums[i] + dp[i+2]);\\n    \\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int dp0 = 0, dp1 = 0, dp2 = 0;\\n\\n        for (int n : nums)\\n            dp0 = max(dp1, n + dp2),  // [1] max profit at current house\\n            dp2 = dp1,                // [2] shift last 2 values to be \\n            dp1 = dp0;                //     used in the next iteration\\n\\n        return dp0;\\n    }\\n};\\n```\n```\\nclass Solution:\\n\\n    def rob(self, nums):\\n        dp1 = dp2 = 0\\n        for n in nums: \\n            dp2, dp1 = dp1, max(dp1, dp2 + n)\\n        return dp1\\n```\n```\\nclass Solution:\\n    def rob(self, nums):\\n        return reduce(lambda dp, n: (max(n + dp[1], dp[0]), dp[0]), nums, [0,0])[0]\\n```\n```\\nimpl Solution\\n{\\n    pub fn rob(nums: Vec<i32>) -> i32\\n    {\\n        nums.into_iter()\\n            .fold((0,0), |(dp1,dp2), n| (dp1.max(n + dp2), dp1)).0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846231,
                "title": "simple-java-solution-with-explaination-100-faster-0ms-o-n-time-dp",
                "content": "We cannot just keep sum of odd and even index elements and return the max out of them because of case like below -\\n[3,2,2,3] as per odd and even elements -> max(5,5) return 5 but answer would be 6. As just by considering 0 and last index element only we get max profit here. It is not mandatory to pick alternate elements to get max result.\\n1. Take an dp array of size n+1. where n is length of nums array.\\n2. dp[0] will denote max profit with 0 number of houses. hence it is 0.\\n3. dp[1] will be max profit with 1 house. which is num[0].\\n4. now for every next element i.e. dp[2] onwards we have a choice to either include the alternative element or exclude it so that we can make more profit by considering element next to alternate one. \\n5. so while considering current element i we have to choose either use previous max score i.e. dp[i] OR add current element to the 2nd max. i.e. dp[i+1]=max(dp[i], dp[i-1]+nums[i])\\n6.after loop finishes we have the dp[n] as answer.\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==0) {\\n            return 0;\\n        }\\n        int[] dp = new int[nums.length+1];\\n        dp[1]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            dp[i+1]=Math.max(dp[i],dp[i-1]+nums[i]);\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==0) {\\n            return 0;\\n        }\\n        int[] dp = new int[nums.length+1];\\n        dp[1]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            dp[i+1]=Math.max(dp[i],dp[i-1]+nums[i]);\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55938,
                "title": "dp-with-two-variables-easiest-solution-i-think-o-n",
                "content": "I use two variables respectively to store the maximum amount of money for both action: rob and not rob. \\n\\nTo determine the maximum amount of money that we can rob from the first house to the current house, we need to consider two choice - rob this house or not:\\n\\n+ if we don't rob this house, the maximum amount of money is the bigger one between to rob and not to rob the previous house;\\n\\n+ if we rob this house, the maximum amount of money is the amount of money that we don't rob the previous house plus the money in the current house.\\n\\nThat is,\\n\\n> notRob[i+1] = max(notRob[i], Rob[i]); \\n\\n> Rob[i+1] = notRob[i] + moneyInHouse[i+1]\\n\\nSo, the Python code is like:\\n\\n    # @param {integer[]} nums\\n    # @return {integer}\\n    def rob(self, nums):\\n    \\tRob = non_Rob = 0\\n    \\tfor n in nums:\\n    \\t\\tnon_Rob, Rob = max(non_Rob, Rob), non_Rob + n\\n    \\treturn max(Rob, non_Rob)\\n\\n For people who don't use Python: The assignment statement in the loop calculate the two value first and then assign them to the variables on the left of `=`, which means the values of `non_Rob` and `Rob` won't change until we get both two new values.\\n\\nSorry for my poor English. If the idea is not clearly explained, please remind me.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "I use two variables respectively to store the maximum amount of money for both action: rob and not rob. \\n\\nTo determine the maximum amount of money that we can rob from the first house to the current house, we need to consider two choice - rob this house or not:\\n\\n+ if we don't rob this house, the maximum amount of money is the bigger one between to rob and not to rob the previous house;\\n\\n+ if we rob this house, the maximum amount of money is the amount of money that we don't rob the previous house plus the money in the current house.\\n\\nThat is,\\n\\n> notRob[i+1] = max(notRob[i], Rob[i]); \\n\\n> Rob[i+1] = notRob[i] + moneyInHouse[i+1]\\n\\nSo, the Python code is like:\\n\\n    # @param {integer[]} nums\\n    # @return {integer}\\n    def rob(self, nums):\\n    \\tRob = non_Rob = 0\\n    \\tfor n in nums:\\n    \\t\\tnon_Rob, Rob = max(non_Rob, Rob), non_Rob + n\\n    \\treturn max(Rob, non_Rob)\\n\\n For people who don't use Python: The assignment statement in the loop calculate the two value first and then assign them to the variables on the left of `=`, which means the values of `non_Rob` and `Rob` won't change until we get both two new values.\\n\\nSorry for my poor English. If the idea is not clearly explained, please remind me.",
                "codeTag": "Python3"
            },
            {
                "id": 55799,
                "title": "easy-java-solution-using-dp",
                "content": "public class Solution {\\n    public int rob(int[] nums) {\\n        \\n        //if nums is null or length 0, return 0\\n        if(nums==null || nums.length==0)\\n            return 0;\\n            \\n        //if only 1 element is present,return it as the answer\\n        if(nums.length==1)\\n            return nums[0];\\n            \\n        //array to store the maxProfit attained\\n        int[] maxProfit=new int[nums.length];\\n        \\n        //assign fisrt value\\n        maxProfit[0]=nums[0];\\n        \\n        //second value is higher of first and second\\n        maxProfit[1]=Math.max(nums[0],nums[1]);\\n        \\n        //do dynamic programming for subsequent values\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            maxProfit[i]=Math.max(maxProfit[i-2]+nums[i],maxProfit[i-1]);\\n        }\\n        \\n        //return the last value as answer\\n        return maxProfit[nums.length-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        \\n        //if nums is null or length 0, return 0\\n        if(nums==null || nums.length==0)\\n            return 0;\\n            \\n        //if only 1 element is present,return it as the answer\\n        if(nums.length==1)\\n            return nums[0];\\n            \\n        //array to store the maxProfit attained\\n        int[] maxProfit=new int[nums.length];\\n        \\n        //assign fisrt value\\n        maxProfit[0]=nums[0];\\n        \\n        //second value is higher of first and second\\n        maxProfit[1]=Math.max(nums[0],nums[1]);\\n        \\n        //do dynamic programming for subsequent values\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            maxProfit[i]=Math.max(maxProfit[i-2]+nums[i],maxProfit[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 527520,
                "title": "dp-solution-and-explained-well-for-beginners-only",
                "content": "I will go through step by step to get you understand in better way, so that you all can solve further dp problems easily. *( for being beginner in solving dp problems i can understand the pain,but believe me after this solution you all will get some idea that how to tackle dp problem )*. :)\\n\\nokay, we will start with basics :\\n**Ques**  what if only one house was there?\\n**Ans** So easy right :D , thief will rob that house and get the money.\\n\\n**Ques** what if two house were there with different amount of money?\\n**Ans** umm,not that difficult, the one with max amount of money, thief will go into that house. Easy right !\\n\\nReal problem comes when we have more number of house, but believe me you have already cracked the logic.\\n\\nSo, assume you are starting with first house, after that you can either go to third or fourth or fifth or sixth or last one, depending on which house will give you more profit.(robber can\\'t go to second house as it is adjacent to first).\\nright? That makes sense !\\nBut out of that third or fourth or fifth or sixth etc.. which house to choose?\\n**Ans** Here comes the idea of storing value into an array and that array will going to store maximum amount of money robber can get, if he chooses any house as first house to rob.\\nex : let us suppose 7 houses are there with some amount of money correspondingly :\\n\\nh1,h2,h3,h4,h5,h6,h7.\\n23,12,32,26,20,21,19.\\n\\nAssume robber can go from left to right only,\\nso if he start with h6 or h7  leaving behind all the houses,maximum amount of money he will get same as amount is present in h6 or h7, (as we are assuming robber can go only  left to right).\\n\\nwe will make array as same size of amount array,and name as **dp[ ] =** __ , __ , __ , __ , __ , 21 , 19 (assume index starting from 1 and index representing house numbers).\\nhere each index will going to store maximum amount of money robber will get, if he start robing from that particular house.\\nyou can see that h6 and h7 house values are directly written in dp array.\\n\\nokay,let us come to analysis :\\nif robber went to h1, then next house which he has to go depends on which house is giving maximum amount of money out of h3,h4,h5,h6,h7.\\n\\nSTEP 1 : **max amount of money if he start from h1 or dp[1]= amount of money he get from h1 house + Max amount of money from (h3,h4,h5,h6,h7).**\\nokay,but how we will going to calculate max amount robber can get from h3,h4,h5,h6,h7.\\n**Ans** Same as above !\\nSTEP 2 :**max amount of money if he start from h3 or dp[3] = amount of money he get from h3 house + Max amount of money from (h5,h6,h7).**\\nlike wise we will continue in recursive fashion,until we hit the second last house or last house.\\n\\nSTEP 3 : **max amount of money if he start from h5 or dp[5]= amount of money he get from h5 house + Max amount of money from (h7).**\\n**dp[5]=20+19**\\n**dp[ ] =** __ , __ , __ , __ , 39 , 21 , 19. \\nnow we can calculate for *STEP 2* ,\\ndp[3]=amount in house h3 + max amount we can get from (h5,h6,h7).\\ndp[3]=32 + max of (39,21,19).\\ndp[3]=71\\n**dp[ ] =** __ , __ , 71 , __ , 39 , 21 , 19.\\nnow we can calculate same for *STEP 1*,\\ndp[1]=amount in house h1 + max amount we can get from (h3,h4,h5,h6,h7).\\nBut,\\nwe know what max amount we can get from h3,h5,h6,h7 but don\\'t know about h4.At first, we need to calculate that :\\nSTEP 4 : **max amount of money if he start from h4 or dp[4] = amount of money he get from h4 house + Max amount of money from (h6,h7)**\\ndp[4]=26+ max of (21,19)\\ndp[4]=47\\n**dp[ ] =** __ , __ , 71 , 47 , 39 , 21 , 19.\\nnow, we can go back to calculate *STEP 1* \\ndp[1]=amount in house h1 + max amount we can get from (h3,h4,h5,h6,h7).\\ndp[1]=23+max of (71,47,39,21,19)\\ndp[1]=94\\n**dp[ ] =** 94, __ , 71 , 47 , 39 , 21 , 19.\\nSTEP 5 : **max amount of money if he start from h2or dp[2] = amount of money he get from h4 house + Max amount of money from (h4,h5,h6,h7)**\\ndp[2]=12+ max of(47,39,21,19)\\ndp[2]=59\\n**dp[ ] =** 94, 59 , 71 , 47 , 39 , 21 , 19.\\nsince in question asking for the maximum amount, so the answer is 94.\\n\\nlet us go through the code now :\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1){\\n            return nums[0];\\n        }\\n        if(n==2){\\n            return Math.max(nums[0],nums[1]);\\n        }\\n\\t\\t/*above are just  for special conditions when array length is less than 2*/\\n\\t\\t\\n        int[] dp=new int[n]; //creating array\\n        Arrays.fill(dp,-1);\\n        dp[n-1]=nums[n-1];\\n        dp[n-2]=nums[n-2];\\n        \\n        for(int i=0;i<nums.length;i++){\\n        helper(dp,nums,i);\\n        }\\n        return  Arrays.stream(dp).max().getAsInt();\\n    }\\n    public int helper(int[] dp,int[] nums,int i){\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int max=-1;\\n        for(int j=i+2;j<nums.length;j++){\\n            dp[j]=helper(dp,nums,j);\\n            if(max<dp[j])\\n                max=dp[j];\\n        }\\n        dp[i]=nums[i]+max;\\n        return dp[i];\\n    }\\n}\\n```\\n\\nI have spent an hour just to explain, how to solve dp question.\\nthanks for reading, hope you all got some sort of glimpse, that how to encounter dp problems.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1){\\n            return nums[0];\\n        }\\n        if(n==2){\\n            return Math.max(nums[0],nums[1]);\\n        }\\n\\t\\t/*above are just  for special conditions when array length is less than 2*/\\n\\t\\t\\n        int[] dp=new int[n]; //creating array\\n        Arrays.fill(dp,-1);\\n        dp[n-1]=nums[n-1];\\n        dp[n-2]=nums[n-2];\\n        \\n        for(int i=0;i<nums.length;i++){\\n        helper(dp,nums,i);\\n        }\\n        return  Arrays.stream(dp).max().getAsInt();\\n    }\\n    public int helper(int[] dp,int[] nums,int i){\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int max=-1;\\n        for(int j=i+2;j<nums.length;j++){\\n            dp[j]=helper(dp,nums,j);\\n            if(max<dp[j])\\n                max=dp[j];\\n        }\\n        dp[i]=nums[i]+max;\\n        return dp[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847007,
                "title": "house-robber-python-dp-explanation-approaching-a-dp",
                "content": "What we have to know is, I think, why this problem is a DP.\\nDP, Dynamic Programming, is commonly used when the next result can be easily derived from the previous result, or the set of previous result is strongly affecting toward the next result. In this case, memorizing previous status, or results, of the same calculation faciliates total calculations and improves time efficiency by accessing old data with O(1) complexity, i.e. array, dict, or hashmap.\\n\\nThe key to solve a DP, in my opinion, is \"Which statement should be memorized.\", and the easiest way to catch whether a problem is a DP is that the answer can be represented as a sequence.\\n\\nFor instance, Fibonacci sequence which is one of the most common examples for a DP.\\nBy definition, ```S``` is a fibonacci sequence where ```S(n) = S(n-1) + S(n-2)``` and ```S(n)``` represents ```S-nth``` element.\\nIn most cases, the value of ```S(0)``` and ```S(1)``` is given, assuming 0-indexed.\\nIn other words, if ```S(0) = 1```, ```S(1) = 1```, the sequence ```S``` will be ```1, 1, 2, 3, 5, 8,...```.\\nFrom this example, I\\'d like to emphasize as **essentials** that \\n\\n* We should find a sequence from a question\\n* Some initial values must be defined, which will be a terminate condition when code uses recursive.\\n\\nLet\\'s start with House Robber.\\nIt says \\'The only constraint is not to rob adjacent houses.\\'\\nWhich menas that I have to decide to rob n-th house or not before visiting the next house, (n+1)-th house. \\nSince we are not a prophet, we don\\'t know the consequences before we trying it. So, let\\'s dig it little more.\\nAt the point of decision, we have two options.\\n\\n* Rob this house and skip the next\\n* Skip this hous to rob the next\\n\\nHowever, if we change our point of view, options can be re-written.\\n\\n* Rob this house if the result of robbing 0-th to (n-2)-th house is better than the result of robbing (n-1)-th house\\n* If not, skip this house\\n\\nPersonally, I call this transformation as a magic of sequence because it is allowed due to the definition of sequence.\\n\\nNow, I can derive a sequence, such as\\n```Rob(n) = max(Rob(n-2) + Money(n), Rob(n-1))```\\nwhere ```Rob(n)``` is the maximum of the sum of robbed money from 0-th house to n-th house, and ```Money(n)``` is the amount of money in the n-th house. **(First essential)**\\nBecause we need up to two previous robbed money, we have to calculate the initial values, ```Rob(0)```,``` Rob(1)```. **(Second essential)**\\n```Rob(0) = Money(0)```\\n```Rob(1) = max(Money(0), Money(1))```\\n\\nConsequently, the basement of function is\\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\trobs = [0] * len(nums) # assign and initialize robs array\\n\\t\\trobs[0], robs[1] = nums[0], max(nums[:2]) # second essential\\n\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\trobs[i] = max(robs[i-1], robs[i-2]+nums[i]) # applying sequence\\n\\t\\treturn robs[-1] \\n```\\n\\nThe constraint of this problem is ```0 <= nums.length <= 100``` and it is crucial to finish this code.\\nThe reason is if ```nums.length``` is less than 2, it is not going to work because of index out of bound error at ```robs[i] = max(robs[i-1], robs[i-2]+nums[i])```. \\n\\nAs a result, it will be\\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) == 0:\\n\\t\\t\\treturn 0 # no house, no outcome\\n\\t\\telif len(nums) == 1:\\n\\t\\t\\treturn nums[0] # one house, focus on what we have\\n\\t\\telse:\\n\\t\\t\\trobs = [0] * len(nums) # assign and initialize robs array\\n\\t\\t\\trobs[0], robs[1] = nums[0], max(nums[:2]) # second essential\\n\\t\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\t\\trobs[i] = max(robs[i-1], robs[i-2]+nums[i]) # applying sequence\\n\\t\\t\\treturn robs[-1] \\n```\\n\\nSince we only traverse houses once, time complexity is ```O(N)```, where ```N``` is the number of houses.\\nAssigning ```robs``` is also ```O(N)``` so time complexity is not going to be changed.\\nSpace complexity is ```O(N)``` as well because we are recording the amout in terms of ```robs```.\\n\\nPlus,\\nIt could be developed to ```O(1)``` space complexity because we only need to 2 previous results at maximum.\\nIn this case, the code will be\\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) == 0:\\n\\t\\t\\treturn 0 # no house, no outcome\\n\\t\\telif len(nums) == 1:\\n\\t\\t\\treturn nums[0] # one house, focus on what we have\\n\\t\\telse:\\n\\t\\t\\trobs0, robs1 = nums[0], max(nums[:2]) # second essential\\n\\t\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\t\\t # applying sequence\\n\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\trobs1 = max(robs0, robs1+num[i])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\trobs0 = max(robs1, robs0+num[i])\\n\\t\\t\\treturn max(robs0, robs1)\\n```\\n\\nI hope it would be helpful.\\n\\nAlso, I\\'m a very big fan of writing pythonic-code although this isn\\'t obviously.\\nSo, if you guys have a woderful idea, please don\\'t hesitate to share for others.\\n\\nThanks a lot for your attention.\\n\\np.s.) Any comment will be welcomed including typo, gramatical error since English is my second language.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```S```\n```S(n) = S(n-1) + S(n-2)```\n```S(n)```\n```S-nth```\n```S(0)```\n```S(1)```\n```S(0) = 1```\n```S(1) = 1```\n```S```\n```1, 1, 2, 3, 5, 8,...```\n```Rob(n) = max(Rob(n-2) + Money(n), Rob(n-1))```\n```Rob(n)```\n```Money(n)```\n```Rob(0)```\n``` Rob(1)```\n```Rob(0) = Money(0)```\n```Rob(1) = max(Money(0), Money(1))```\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\trobs = [0] * len(nums) # assign and initialize robs array\\n\\t\\trobs[0], robs[1] = nums[0], max(nums[:2]) # second essential\\n\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\trobs[i] = max(robs[i-1], robs[i-2]+nums[i]) # applying sequence\\n\\t\\treturn robs[-1] \\n```\n```0 <= nums.length <= 100```\n```nums.length```\n```robs[i] = max(robs[i-1], robs[i-2]+nums[i])```\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) == 0:\\n\\t\\t\\treturn 0 # no house, no outcome\\n\\t\\telif len(nums) == 1:\\n\\t\\t\\treturn nums[0] # one house, focus on what we have\\n\\t\\telse:\\n\\t\\t\\trobs = [0] * len(nums) # assign and initialize robs array\\n\\t\\t\\trobs[0], robs[1] = nums[0], max(nums[:2]) # second essential\\n\\t\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\t\\trobs[i] = max(robs[i-1], robs[i-2]+nums[i]) # applying sequence\\n\\t\\t\\treturn robs[-1] \\n```\n```O(N)```\n```N```\n```robs```\n```O(N)```\n```O(N)```\n```robs```\n```O(1)```\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) == 0:\\n\\t\\t\\treturn 0 # no house, no outcome\\n\\t\\telif len(nums) == 1:\\n\\t\\t\\treturn nums[0] # one house, focus on what we have\\n\\t\\telse:\\n\\t\\t\\trobs0, robs1 = nums[0], max(nums[:2]) # second essential\\n\\t\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\t\\t # applying sequence\\n\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\trobs1 = max(robs0, robs1+num[i])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\trobs0 = max(robs1, robs0+num[i])\\n\\t\\t\\treturn max(robs0, robs1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 845997,
                "title": "c-house-robber-dp-time-o-n-space-o-1-beats-100",
                "content": "This is very simple 1-D DP problem. At every position we have two choices, either we can choose current house and add it with the previous alternate i.e \\n```\\ndp[i] = nums[i] + dp[i - 2];\\n```\\nor we can select the previous for maximum answer\\n```\\ndp[i] = dp[i -1]\\n```\\nSo now we merge them \\n```\\ndp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\\n```\\nThis approach is used in many similar problems in which we have to select alternates.\\n\\n## Lets code it:\\n\\n```\\nclass Solution {\\n    int dp[105];\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n        if(n == 0) return 0;        \\n        dp[0] = nums[0];        \\n\\t\\t\\n        if(n == 1) return dp[0];        \\t\\t\\n        dp[1] = max(dp[0], nums[1]);        \\n\\t\\t\\n        for(int i = 2; i < n; i++){\\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\n**TC : O(n)\\nSpace : O(n)**\\n\\n## Further Space Optimization\\nAs we can see we need to maintain 3 states\\n1. dp[i - 2] - previous answer -> ```prev1```\\n2. dp[i - 1] - previous alternate answer -> ```prev2```\\n3. dp[i] - current answer -> ```ans```\\n\\nSo we will replace dp array with above 3 variables\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return 0;\\n        \\n        int prev1, prev2;\\n        prev1 = nums[0];\\n        \\n        if(n == 1) return prev1;\\n        \\n        prev2 = max(prev1, nums[1]);\\n        int ans = prev2;\\n        for(int i = 2; i < n; i++){\\n            ans = max(prev2, prev1 + nums[i]);\\n            prev1 = prev2;\\n            prev2 = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**TC : O(n)\\nSpace : O(1)**\\n \\nPlease comment if you have any doubt or a better solution. Please Upvote if you find this helpful!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i] = nums[i] + dp[i - 2];\\n```\n```\\ndp[i] = dp[i -1]\\n```\n```\\ndp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\\n```\n```\\nclass Solution {\\n    int dp[105];\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n        if(n == 0) return 0;        \\n        dp[0] = nums[0];        \\n\\t\\t\\n        if(n == 1) return dp[0];        \\t\\t\\n        dp[1] = max(dp[0], nums[1]);        \\n\\t\\t\\n        for(int i = 2; i < n; i++){\\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\n```prev1```\n```prev2```\n```ans```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return 0;\\n        \\n        int prev1, prev2;\\n        prev1 = nums[0];\\n        \\n        if(n == 1) return prev1;\\n        \\n        prev2 = max(prev1, nums[1]);\\n        int ans = prev2;\\n        for(int i = 2; i < n; i++){\\n            ans = max(prev2, prev1 + nums[i]);\\n            prev1 = prev2;\\n            prev2 = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167616,
                "title": "javascript-clean-dp-solution",
                "content": "```\\nvar rob = function(nums) {\\n    if(nums.length === 0) return 0;\\n    if(nums.length === 1) return nums[0];\\n    let totals = [nums[0], Math.max(nums[0], nums[1])];\\n    for(let i = 2; i < nums.length; i ++){\\n        totals[i] = Math.max(totals[i - 1], totals[i - 2] + nums[i]);\\n    }\\n    return totals[totals.length - 1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rob = function(nums) {\\n    if(nums.length === 0) return 0;\\n    if(nums.length === 1) return nums[0];\\n    let totals = [nums[0], Math.max(nums[0], nums[1])];\\n    for(let i = 2; i < nums.length; i ++){\\n        totals[i] = Math.max(totals[i - 1], totals[i - 2] + nums[i]);\\n    }\\n    return totals[totals.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55887,
                "title": "5-lines-0-ms-c-o-1-space-c-solution",
                "content": "    class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int it1 = 0, it2 = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                it1 = max(it1 + nums[i], it2);\\n                swap(it1, it2);\\n            }\\n            return it2;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int it1 = 0, it2 = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                it1 = max(it1 + nums[i], it2);\\n                swap(it1, it2);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1605472,
                "title": "easy-c-o-n-time-o-1-space-solution-with-explanation",
                "content": "**Please upvote if you like the solution and feel free to comment if you have any query**\\n\\n**APPROACH:**\\nLet ans[i] be the maximum amount of money the robber can steal till the ith house.\\n\\nSuppose the robber is at house i, so he has 2 choices:\\n* Rob the current house. After this he cannot rob the house no i-1 due to the adjacent constraints given in the problem so we move on to finding the answer till house no i-2.\\n* Skip the current house and find the answer till the house no i-1.\\n\\nSo the relation becomes **ans[i]=max(ans[i-1],nums[i]+ans[i-2])**\\n\\nThe base case will arise when:\\n1. i=0: In this case we have only 1 house so we rob money from it and the answer for this subproblem will be nums[0]\\n2. i=1. In this case we have 2 houses so we can either steal from second house and skip the first or skip the second and steal from first. so the answer for this subproblem will be max(nums[0],nums[1])\\n\\nFor other cases, we use the relation defined earlier in this explanation.\\n\\nUsing this relation one can use a dp array to store the answer till the ith and (i-1)th index and use then to calculate the answer till (i+1)th index. But this solution will have a O(N) space complexity. \\n\\nWe can definitely improve it. Have a close look at the relation and you\\'ll observe that we\\'re using the anwsers of the previous 2 indexes only so we can store them into 2 variables and update them accordingly when a new iteration begins.\\n\\nSo we finally have a solution with O(N) time complexity and O(1)  space complexity.\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        int a=nums[0],b=max(nums[0],nums[1]);\\n        for(int i=2;i<n;i++){\\n            int tmp=b;\\n            b=max(nums[i]+a,b);\\n            a=tmp;\\n        }\\n        return b;\\n    }\\n};\\n```\\n**I hope this helps**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        int a=nums[0],b=max(nums[0],nums[1]);\\n        for(int i=2;i<n;i++){\\n            int tmp=b;\\n            b=max(nums[i]+a,b);\\n            a=tmp;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605193,
                "title": "with-explanation-dp-with-o-l-time-and-o-1-space-in-python",
                "content": "# Explanation\\nFor each day, the robber has two choices - to rob or not to rob. Also, you can only rob when you didn\\'t rob on the previous day. Here, I create a dp table with size L `(L = len(nums))` and `dp[i]` represents **the maximum amount of money you can rob until the ith day**. The goal of this problem is to calculate `dp[-1]`, which is the maximum amount of money you can rob until the last day.\\n\\nNow, let\\'s write a formula.\\n1. If you didn\\'t rob yesterday (i - 1th day), you should always rob today (ith day) to maximize the amount. This can be written as `dp[i - 2] + nums[i]`, because `dp[i - 2]` denotes the maximum amount of money you can rob until the day before yesterday, and in that case you should always rob today. Note that all the elements in nums are nonnegative.\\n2. If you robbed on the previous day (i - 1th day), you can\\'t rob today. This can be written as `dp[i - 1]`.\\n\\nYou choose the maximum value between these two choices above, and the larger one is the maximum value you can rob up until today. Therefore, we get this formula.\\n\\n`dp[i] = max(nums[i - 2] + nums[i], dp[i - 1])`\\n\\nUsing this formula, you can write this first approach.\\n\\n\\n# DP with O(L) time and O(L) space\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        #edge case\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        #dp\\n        L = len(nums)\\n        dp = [0 for _ in range(L)]\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, L):\\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\\n        \\n        return dp[-1]\\n```\\n\\nHowever, you can optimize this furthermore. Note that in calculating `dp[i]`, you are just referencing `dp[i - 2]` and `dp[i - 1]`. In other words, all you need is the two values (yesterday and the day before yesterday), and you can discard the old values in the dp table.\\n\\n![image](https://assets.leetcode.com/users/images/22c4bb3b-43f2-4e84-bba4-502cf7d6b461_1638381140.0612247.jpeg)\\n\\nLet `a` be the maximum at the day before yesterday, and let `b` the maximum at yesterday, today\\'s maximum is `max(a + nums[i], b)`. And for the next day, this becomes the maximum at yesterday, and maximum at the day before yesterday is now `a`. So you can write this formula.\\n\\n`a, b = b, max(a + nums[i], b)`\\n\\nThis indicates new `a` is replaced with `b`, and new `b` is replaced with `max(a + nums[i], b)`. By repeating this, you can calculate until the last day without storing all the values along the way. Finally, `b` at the end is what you want. So you can write the improved version.\\n\\n# [Optimization] DP with O(L) time and O(1) space\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        #edge case\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        #dp (less space)\\n        L = len(nums)\\n        a, b = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, L):\\n            a, b = b, max(a + nums[i], b)\\n        \\n        return b\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        #edge case\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        #dp\\n        L = len(nums)\\n        dp = [0 for _ in range(L)]\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, L):\\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\\n        \\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        #edge case\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        #dp (less space)\\n        L = len(nums)\\n        a, b = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, L):\\n            a, b = b, max(a + nums[i], b)\\n        \\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216515,
                "title": "recursive-solution-and-it-s-conversion-to-dp",
                "content": "Hey guys, if you able to solve this question recursively, then maybe you can easily understand how it can be solved using DP.\\nLet\\'s take one example [ 3 , 1 , 2 , 9 , 3 ] , if you select any element, then you can\\'t select it\\'s adjacent, that means you need to skip one element and if skipping the current element, then you can again start selection from it\\'s adjacent. \\nLeft child : taking current + skipping next  \\nRight child : skipping current and again start selection from next element.\\n\\n                         fun([ 3, 1, 2 , 9, 3 ])\\n                        /                        \\\\\\n                3 + fun([2,9,3])            fun([1,2,9,3]) _______\\n                    /        \\\\                       /            \\\\\\n             2 + fun([3])  fun([9,3])       1+ fun([9,3])   fun([2,9,3])      \\n                   |          |                   |               /     \\\\\\n                   3       max(9,3)           max(9,3)   2+fun([3])    fun([9,3])\\n                                                               |           |\\n                                                               3        max(9,3)\\n    \\n```\\ndef rob(self, arr: List[int]) -> int:\\n        arrLength = len(arr)\\n        if arrLength == 0: return 0\\n        elif arrLength == 1: return arr[0]\\n        elif arrLength == 2: return max(arr[0], arr[1])\\n        else:\\n            return max(arr[0] + self.rob(arr[2:]), self.rob(arr[1:]))\\n```\\n\\nFrom the about flow, you can check \\nfun([2,9,3])  -> calculated 2 times   // 1 extra calculation \\nfun([9,3])     -> calculated 3 times   // 2 extra calculation\\nfun([3])        -> calculated 2 times   // 1 extra calculation\\nIn length of 5, we are calculating 4 times extra values.. isn\\'t that making solution worst. \\nNow, just simply add dictionary / array whatever you want to store values to avoid same calculation by fetching that stored value. \\n\\n\\tdef rob(self, arr: List[int]) -> int:\\n\\t\\tself.data = arr\\n\\t\\tself.totalElements = len(arr)\\n\\t\\tself.dp = [-1]*(self.dataLen+1)\\n\\t\\treturn self.recursive(0)\\n\\n    # Here we are passing index from where we need to start selection..\\n    def recursive(self , i):\\n        if self.dp[i] != -1:\\n            # Few consoles for better visualization.. \\n            print(i, self.dp[i], \"Already have answer :) \") \\n            return self.dp[i]\\n        # How many elements left \\n        t = self.totalElements - i\\n        if t == 0: self.dp[i]= 0\\n        elif t == 1: self.dp[i] = self.data[-1]\\n        elif t == 2: self.dp[i] = max(self.data[-1], self.data[-2])\\n        else: self.dp[i] = max(self.data[i] + self.recursive(i+2), self.recursive(i+1))\\n        # Few consoles for better visualization.. \\n        print(i, self.dp[i], \"calculation :( \")\\n        return self.dp[i]\\n\\n\\nAbove solution was top-down approach, we had broken down larger problem into smaller, but it can be solved by bottom-up approach as well. Let\\'s see how it can be.\\nAgain taking same example :  [ 3 , 1 , 2 , 9 , 3 ]\\nWe can start from last element  : 3\\nif we have only this element, then our answer = dp[4] =  3\\nfrom second last : [9, 3] => best / max => dp[3] = 9\\nfrom last third [2,9,3] , why not doing same thing we had done in top-down approach => either 2 + [3]   or [9, 3] \\nSo now, we already done calculation so far, dp[2] = max ( 2 + dp[4]  and dp[3] )  \\nfrom last fourth [1,2,9,3]  => dp[1] = max ( 1 + [9,3] , [2,9,3] ) = max ( 1 + dp[3] , dp[2] ) \\nand from first [3,1,2,9,3]  => dp[0] = max ( 3 + [2,9,3], [1,2,9,3] ) = max( 3 + dp[2], dp[1])\\nSo did you saw pattern dp[ i ] = max( arr[i] + dp[i+2], dp[i+1] )\\n\\n*One more easy way to understand this. *\\n\\ndp[i] is storing max sum from i -> n , but we don\\'t know at any i, arr[i] is contributing in max sum or not.\\nBut it is 100% sure that for any i, dp[i+2] definately didn\\'t included either arr[i] or arr [i+1] , since we dp[i+2] is sum from i+2 -> n. That\\'s how we got this relation ..\\ndp[ i ] = ( arr[i] + dp[i+2] ,  dp [i+1] )\\n\\n\\tdef rob(self, arr: List[int]) -> int:\\n\\t\\tn = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(n-1, -1, -1):\\n            if i+1 < n and arr[i] + dp[i+2] > dp[i+1]:  dp[i] = arr[i] + dp[i+2]\\n            else: dp[i] = max(dp[i+1], arr[i])\\n        return dp[0]\\n\\nOr same can be done in forward direction, either way we are doing same, not including adjacents , so it won\\'t affect answer .\\n\\n\\tdef rob(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [0]*(n)\\n        for i in range(n):\\n            if i > 1 and arr[i] + dp[i-2] > dp[i-1]:   dp[i] = arr[i] + dp[i-2]\\n            else: dp[i] = max(dp[i-1], arr[i])\\n        return dp[n-1]\\n\\nTime : O(n)\\nSpace : O(n) \\n\\nWant some more optimisation :) \\nin a loop, we only need two values dp[i-1] and dp[i-2] to generate new value .. so we can optimize in terms of space.\\n\\n```\\ndef rob(self, arr: List[int]) -> int:\\n        incl = 0\\n        excl = 0\\n\\n        for i in arr:\\n            # Current max by excluding current element \\n            new_excl = max(excl, incl)\\n\\n            # Current max including current element\\n            incl = excl + i\\n            excl = new_excl\\n\\n        return max(excl , incl)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ndef rob(self, arr: List[int]) -> int:\\n        arrLength = len(arr)\\n        if arrLength == 0: return 0\\n        elif arrLength == 1: return arr[0]\\n        elif arrLength == 2: return max(arr[0], arr[1])\\n        else:\\n            return max(arr[0] + self.rob(arr[2:]), self.rob(arr[1:]))\\n```\n```\\ndef rob(self, arr: List[int]) -> int:\\n        incl = 0\\n        excl = 0\\n\\n        for i in arr:\\n            # Current max by excluding current element \\n            new_excl = max(excl, incl)\\n\\n            # Current max including current element\\n            incl = excl + i\\n            excl = new_excl\\n\\n        return max(excl , incl)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 491274,
                "title": "javascript-solution",
                "content": "### The idea\\n1. The robber can either `rob` the current house, or `not rob` the current house.\\n2. If the robber choose to `rob` the current house, it means he has to skip the next house\\n3. If the robber choose `not rob` the current house, it means he can go to the next house and decide again.\\n``` javascript\\n/**\\n * Top-Down w/ Memoization \\n */\\nvar rob1 = function(nums) {\\n    let memo = [];\\n    \\n    let recur = function(i) {\\n        if (i >= nums.length) return 0;\\n        if (memo[i]!=null) return memo[i];\\n        \\n        memo[i] = Math.max(recur(i+2) + nums[i], recur(i+1))\\n        return memo[i];\\n    }\\n    return recur(0);\\n};\\n```\\n``` javascript\\n/**\\n * Bottom-Up\\n */\\nvar rob2 = function(nums) {\\n    let memo = [];\\n    memo[0] = 0;\\n    memo[1] = nums[0];\\n    \\n    for (let i=1;i<nums.length;i++) {\\n        memo[i+1] = Math.max(memo[i], memo[i-1] + nums[i]);\\n    }\\n    \\n    return memo[nums.length];   \\n}\\n```\\n``` javascript\\n/**\\n * Bottom-Up O(1) Space\\n */\\nvar rob = function(nums) {\\n    let prevMax = 0, curMax = 0;\\n    for (let n of nums) {\\n        let temp = curMax;\\n        curMax = Math.max(prevMax + n, curMax); // rob vs !rob\\n        prevMax = temp;\\n    }\\n    return Math.max(curMax, prevMax);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * Top-Down w/ Memoization \\n */\\nvar rob1 = function(nums) {\\n    let memo = [];\\n    \\n    let recur = function(i) {\\n        if (i >= nums.length) return 0;\\n        if (memo[i]!=null) return memo[i];\\n        \\n        memo[i] = Math.max(recur(i+2) + nums[i], recur(i+1))\\n        return memo[i];\\n    }\\n    return recur(0);\\n};\\n```\n``` javascript\\n/**\\n * Bottom-Up\\n */\\nvar rob2 = function(nums) {\\n    let memo = [];\\n    memo[0] = 0;\\n    memo[1] = nums[0];\\n    \\n    for (let i=1;i<nums.length;i++) {\\n        memo[i+1] = Math.max(memo[i], memo[i-1] + nums[i]);\\n    }\\n    \\n    return memo[nums.length];   \\n}\\n```\n``` javascript\\n/**\\n * Bottom-Up O(1) Space\\n */\\nvar rob = function(nums) {\\n    let prevMax = 0, curMax = 0;\\n    for (let n of nums) {\\n        let temp = curMax;\\n        curMax = Math.max(prevMax + n, curMax); // rob vs !rob\\n        prevMax = temp;\\n    }\\n    return Math.max(curMax, prevMax);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246618,
                "title": "",
                "content": "\\u8FD9\\u4E2A\\u95EE\\u9898\\u5927\\u6982\\u5C31\\u662F\\u8BF4\\uFF0C\\u4E00\\u4E2A\\u5C0F\\u5077\\u5077\\u4E1C\\u897F\\uFF0C\\u4F46\\u662F\\u5B83\\u4E0D\\u80FD\\u5077\\u76F8\\u90BB\\u7684\\u4E24\\u5BB6\\u4EBA\\u7684\\u4E1C\\u897F\\uFF0C\\u8FD9\\u6837\\u4F1A\\u88AB\\u6293\\u4F4F\\uFF0C\\u53EA\\u80FD\\u9694\\u7740\\u5077\\uFF0C\\u8BF7\\u95EE\\uFF0C\\u600E\\u4E48\\u5077\\u624D\\u80FD\\u5229\\u76CA\\u6700\\u5927\\u5316\\uFF0C\\u56E0\\u4E3A\\u6BCF\\u4E2A\\u623F\\u5B50\\u7684\\u4EF7\\u503C\\u4E0D\\u4E00\\u6837\\uFF0C\\u5047\\u5982\\u6709\\u4E24\\u5BB6\\uFF0C\\u4E00\\u5BB6\\u6709100\\u5757\\uFF0C\\u4E00\\u5BB6\\u6709\\u4E00\\u4E2A\\u4EBF\\uFF0C\\u4F60\\u9009\\u62E9\\u4E0D\\u597D\\uFF0C\\u9009\\u4E86100\\u7684\\u90A3\\u5BB6\\uFF0C\\u90A3\\u5C31\\u4E8F\\u5927\\u53D1\\u4E86\\uFF0C\\u4E00\\u4E2A\\u4EBF\\u7684\\u4E0B\\u6B21\\u518D\\u6765\\u5077\\u5427\\u3002\\n\\n\\u6309\\u7167\\u4E0A\\u9762\\u7684\\u601D\\u8DEF\\uFF0C\\u6211\\u4EEC\\u6765\\u601D\\u8003\\u8FD9\\u4E2A\\u95EE\\u9898\\uFF0C\\u6211\\u4EEC\\u4ECE\\u6700\\u540E\\u4E00\\u5BB6\\u5F00\\u59CB\\u8003\\u8651\\uFF0C\\u9009\\u62E9\\u5C31\\u4E24\\u4E2A\\uFF0C\\u5077\\u6216\\u8005\\u4E0D\\u5077\\uFF0C\\u5077\\u4E86\\u4F1A\\u600E\\u4E48\\u6837\\uFF0C\\u4E0D\\u5077\\u4F1A\\u600E\\u4E48\\u6837\\uFF0C\\u5176\\u5B9E\\u5173\\u7CFB\\u5F0F\\u8DDF\\u4E0A\\u9762\\u662F\\u5DEE\\u4E0D\\u591A\\u7684\\uFF0C\\u6211\\u5077\\u4E86\\u7684\\u8BDD\\uFF0C\\u6BD4\\u5982\\u5077\\u7684\\u662Fn\\uFF0C\\u90A3\\u4E48\\u4E0B\\u6B21\\u53EA\\u80FD\\u4ECEn-2\\u5F00\\u59CB\\u8003\\u8651\\u5B83\\u7684\\u6700\\u5927\\u4EF7\\u503C\\u65B9\\u6848\\u3002\\u4E0D\\u5077\\u7684\\u8BDD\\uFF0C\\u5C31\\u662F\\u8003\\u8651n-1\\u7684\\u6700\\u5927\\u4EF7\\u503C\\u65B9\\u6848\\u3002\\n\\n\\u6700\\u7B80\\u5355\\u7684\\u5B9E\\u73B0\\u5C31\\u662F\\u9012\\u5F52\\u6765\\u5B9E\\u73B0\\uFF0C\\u4E3B\\u8981\\u662F\\u8981\\u8003\\u8651\\u4E00\\u4E0B\\u51FD\\u6570\\u7684\\u51FA\\u53E3\\u6761\\u4EF6\\uFF0C\\u5373\\u5077\\u5230\\u7B2C\\u4E00\\u5BB6\\u4E86\\u662F\\u4EC0\\u4E48\\u6837\\uFF0C\\u4EE5\\u53CA\\u7B2C\\u4E00\\u5BB6\\u4E4B\\u524D\\u6CA1\\u6709\\u4EBA\\u5BB6\\u4E86\\u600E\\u4E48\\u529E\\u3002\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n\\n\\n```java\\n//can not pass\\nclass Solution {\\n    public int rob(int[] nums) {\\n        return rob(nums,nums.length-1);\\n    }\\n    \\n    private int rob(int[] nums,int n){\\n        if(n < 0){\\n            return 0;\\n        }else if(n == 0){\\n            return nums[0];\\n        }else{\\n            int A = rob(nums,n-2) + nums[n];\\n            int B = rob(nums,n-1);\\n            return A > B ? A : B;\\n        }\\n    }\\n}\\n```\\n\\n\\u5F88\\u53EF\\u60DC\\uFF0C\\u867D\\u7136\\u903B\\u8F91\\u4E0A\\u6B63\\u786E\\uFF0C\\u4F46\\u662F\\u7531\\u4E8E\\u662F\\u9012\\u5F52\\uFF0C\\u5728\\u6570\\u636E\\u89C4\\u6A21\\u5927\\u4E00\\u70B9\\u4E4B\\u540E\\uFF0C\\u5C31\\u4E0D\\u884C\\u4E86\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u524D\\u9762\\u4E5F\\u8BF4\\u5230\\uFF0C\\u5B58\\u5728\\u5927\\u91CF\\u7684\\u91CD\\u53E0\\u5B50\\u95EE\\u9898\\uFF0C\\u95EE\\u9898\\u591A\\u4E00\\u4E2A\\u8F93\\u5165\\uFF0C\\u90A3\\u4E48\\u8BA1\\u7B97\\u7684\\u89C4\\u6A21\\u5C31\\u8981\\u4E58\\u4E0A2\\uFF0C\\u6240\\u4EE5\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3A2^n\\u8FD9\\u4E2A\\u7EA7\\u522B\\u3002\\u6240\\u4EE5\\u6B64\\u65B9\\u6848\\u653E\\u5728leetcode\\u4E0A\\u4F1A\\u8D85\\u65F6\\uFF0C\\u4E0B\\u9762\\u5C31\\u662F\\u60F3\\u529E\\u6CD5\\u628A\\u4ED6\\u6539\\u6210\\u975E\\u9012\\u5F52\\u7684\\u7248\\u672C\\u3002\\n\\n\\u524D\\u9762\\u63D0\\u5230\\uFF0C\\u8BA1\\u7B97\\u51FA\\u6765\\u7684\\u5B50\\u95EE\\u9898\\u5B8C\\u5168\\u53EF\\u4EE5\\u5B58\\u5728\\u4E00\\u4E2A\\u5730\\u65B9\\uFF0C\\u4E0B\\u6B21\\u8981\\u7528\\u76F4\\u63A5\\u53D6\\u3002OK\\uFF0C\\u7528\\u975E\\u9012\\u5F52\\u7248\\u672C\\u7684\\u6570\\u7EC4\\u7248\\u672C\\u5B9E\\u73B0\\u662F\\uFF1A\\n\\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0){\\n            return 0;\\n        }\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n        int[] tmp = new int[nums.length];\\n        tmp[0] = nums[0];\\n        tmp[1] = nums[0] > nums[1] ? nums[0] : nums[1];\\n        for(int i=2;i<nums.length;i++){\\n            int A = tmp[i-2] + nums[i];\\n            int B = tmp[i-1];\\n            int max = A > B ? A : B;\\n            tmp[i] = max;\\n        }\\n        return tmp[nums.length-1];\\n    }\\n}\\n```\\n\\n\\u4E3B\\u4F53\\u8FD8\\u662F\\u4E0A\\u9762\\u63D0\\u5230\\u7684\\u90A3\\u4E2A\\u5173\\u7CFB\\uFF0C\\u53EA\\u662F\\u6211\\u4EEC\\u5C06\\u5B50\\u95EE\\u9898\\u7684\\u7ED3\\u679C\\u653E\\u5728\\u4E86\\u4E00\\u4E2A\\u4E34\\u65F6\\u6570\\u7EC4\\u4E2D\\u3002\\u4E34\\u65F6\\u6570\\u7EC4\\u4E2D\\u5B58\\u653E\\u7684\\u90FD\\u662F\\u5B50\\u95EE\\u9898\\u7684\\u6700\\u4F18\\u89E3\\u3002\\u6BD4\\u5982tmp[1]\\u91CC\\u9762\\u5B58\\u653E\\u7684\\u5C31\\u662F\\u524D\\u4E24\\u4E2A\\u5143\\u7D20\\u4E2D\\u6700\\u5927\\u503C\\uFF0C\\u5373\\u6700\\u4F18\\u89E3\\u3002\\u5F53\\u8BA1\\u7B97\\u524D\\u4E09\\u4E2A\\u6570\\u4E2D\\u6700\\u4F18\\u89E3\\u7684\\u65F6\\u5019\\uFF0C\\u6211\\u53EA\\u8981\\u505A\\u4E00\\u4E2A\\u9009\\u62E9\\uFF0C\\u5373\\u8981\\u4E0D\\u8981\\u9009\\u62E9nums[2]\\u8FD9\\u4E2A\\u5143\\u7D20\\uFF0C\\u9009\\u62E9\\u7684\\u8BDD\\uFF0C\\u90A3\\u4E48\\u6211\\u5C31\\u4ECEtmp[2-2]\\u4E2D\\u5F97\\u5230\\u6700\\u4F18\\u89E3\\uFF0C\\u52A0\\u8D77\\u6765\\u5C31\\u662F\\u5F53\\u524D\\u6700\\u4F18\\u89E3\\uFF0C\\u4E0D\\u9009\\u62E9\\u7684\\u8BDD\\uFF0C\\u5C31\\u4ECEtmp[2-1]\\u4E2D\\u9009\\u62E9\\u6700\\u4F18\\u89E3\\u3002\\u4F9D\\u6B21\\u4E0B\\u53BB\\uFF0Ctmp\\u4E2D\\u6700\\u540E\\u4E00\\u4E2A\\u503C\\u5C31\\u662F\\u6574\\u4E2A\\u5E8F\\u5217\\u4E2D\\u7EC4\\u5408\\u7684\\u6700\\u4F18\\u89E3\\u4E86\\u3002\\n\\n\\u8FD9\\u91CC\\u6CE8\\u610F\\u4E00\\u4E0B\\uFF0C\\u8FD9\\u91CC\\u5176\\u5B9E\\u662F\\u8BB0\\u5FC6\\u5316\\u641C\\u7D22\\u7684\\u601D\\u60F3\\u6765\\u5B9E\\u73B0\\u7684\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u6CE8\\u610F\\u5230\\uFF0C\\u5176\\u5B9E\\u662F\\u81EA\\u9876\\u5411\\u4E0B\\u6765\\u770B\\u7684\\uFF0C\\u4ECE\\u7B2C\\u4E00\\u4E2A\\u6570\\u5B57\\u6765\\u4E00\\u76F4\\u63A8\\u5230\\u6700\\u540E\\u3002\\u7136\\u800C\\u52A8\\u6001\\u89C4\\u5212\\u7684\\u601D\\u60F3\\u662F\\u4ECE\\u5E95\\u5411\\u4E0A\\u7684\\uFF0C\\u53C2\\u89C1\\u7B2C\\u4E00\\u4E2A\\u9012\\u5F52\\u7248\\u672C\\u7684\\u5B9E\\u73B0\\u3002\\u6211\\u4EEC\\u5148\\u8003\\u8651\\u7684\\u662F\\u6700\\u7EC8\\u7684n\\uFF0C\\u800C\\u4E0D\\u662F\\u8003\\u8651\\u4ECE0\\u5F00\\u59CB\\u3002\\u6240\\u4EE5\\u5728\\u8BBE\\u8BA1\\u601D\\u60F3\\u4E0A\\u662F\\u6709\\u6240\\u533A\\u522B\\u7684\\uFF0C\\u4F46\\u662F\\u53C8\\u662F\\u975E\\u5E38\\u7C7B\\u4F3C\\uFF0C\\u6709\\u7684\\u4EBA\\u5C06\\u4ED6\\u4EEC\\u5F52\\u4F4D\\u4E00\\u7C7B\\uFF0C\\u6211\\u60F3\\uFF0C\\u5B83\\u4EEC\\u5728\\u5927\\u591A\\u6570\\u573A\\u666F\\u4E0B\\u53EF\\u4EE5\\u4E92\\u6362\\u7684\\u5316\\uFF0C\\u53EF\\u4EE5\\u8BA4\\u4E3A\\u90FD\\u662F\\u5E7F\\u4E49\\u4E0A\\u7684DP\\u7B97\\u6CD5\\u5427\\uFF0C\\u56E0\\u4E3ADP\\u6BD5\\u7ADF\\u53EA\\u662F\\u4E00\\u79CD\\u601D\\u60F3\\uFF0C\\u6B63\\u8FC7\\u6765\\u5B9E\\u73B0\\u53CD\\u8FC7\\u6765\\u5B9E\\u73B0\\u4E5F\\u672A\\u5C1D\\u4E0D\\u53EF\\u3002\\n\\n\\u6211\\u4EEC\\u7528\\u4E00\\u4E2A\\u6570\\u7EC4\\u6765\\u5B58\\u653E\\u5B50\\u95EE\\u9898\\u7684\\u6700\\u4F18\\u89E3\\uFF0C\\u5927\\u5927\\u964D\\u4F4E\\u4E86\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF0Cleetcode\\u4E0A\\u4E5F\\u987A\\u5229\\u901A\\u8FC7\\u3002\\u5176\\u5B9E\\u8FD9\\u4E2A\\u662F\\u4E00\\u79CD\\u8BB0\\u5FC6\\u5316\\u641C\\u7D22\\u7684\\u601D\\u60F3\\uFF0C\\u4E0A\\u9762\\u8FD9\\u4E2A\\u7528\\u4E86\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u5176\\u5B9E\\u5B8C\\u5168\\u6CA1\\u6709\\u5FC5\\u8981\\u7528\\u6570\\u7EC4\\uFF0C\\u7528\\u4E24\\u4E2A\\u53D8\\u91CF\\u5373\\u53EF\\uFF1A\\n\\n\\n```java\\n//the best solution  think\\n//\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u548C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u8868\\u73B0\\u6700\\u597D\\u7684\\u4E00\\u79CD\\u65B9\\u5F0F\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0){\\n            return 0;\\n        }\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n        int a = nums[0];\\n        int b = nums[0] > nums[1] ? nums[0] : nums[1];\\n        for(int i=2;i<nums.length;i++){\\n            int A = a + nums[i];\\n            int B = b;\\n            int max = A > B ? A : B;\\n            a = b;\\n            b = max;\\n        }\\n        return b;\\n    }\\n}\\n```\\n\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E0D\\u53D8\\uFF0C\\u7A7A\\u95F4\\u4E0A\\u5360\\u7528\\u7684\\u66F4\\u5C11\\u4E86\\u3002\\u4E0B\\u9762\\u6211\\u4EEC\\u8FD8\\u662F\\u4ECE\\u5E95\\u5411\\u4E0A\\u7684\\u601D\\u60F3\\u6765\\u89E3\\u51B3\\u4E00\\u4E0B\\u8FD9\\u4E2A\\u95EE\\u9898\\u5427\\u3002\\u6240\\u4EE5\\u6211\\u4EEC\\u8FD8\\u662F\\u4ECE\\u6700\\u540E\\u4E00\\u4E2A\\u5143\\u7D20\\u5F00\\u59CB\\u601D\\u8003\\uFF0C\\u4ECE\\u540E\\u5F80\\u524D\\u627E\\uFF0C\\u4E00\\u76F4\\u627E\\u5230\\u7B2C\\u4E00\\u4E2A\\u7ED3\\u675F\\u3002\\n\\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n <= 0){\\n            return 0;\\n        }\\n        \\n        if(n == 1){\\n            return nums[0];\\n        }\\n        \\n        int[] tmp = new int[n];\\n        tmp[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                tmp[i] = Math.max(tmp[i],nums[j] + (j+2<n?tmp[j+2]:0));\\n            }\\n        }\\n        return tmp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n//can not pass\\nclass Solution {\\n    public int rob(int[] nums) {\\n        return rob(nums,nums.length-1);\\n    }\\n    \\n    private int rob(int[] nums,int n){\\n        if(n < 0){\\n            return 0;\\n        }else if(n == 0){\\n            return nums[0];\\n        }else{\\n            int A = rob(nums,n-2) + nums[n];\\n            int B = rob(nums,n-1);\\n            return A > B ? A : B;\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0){\\n            return 0;\\n        }\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n        int[] tmp = new int[nums.length];\\n        tmp[0] = nums[0];\\n        tmp[1] = nums[0] > nums[1] ? nums[0] : nums[1];\\n        for(int i=2;i<nums.length;i++){\\n            int A = tmp[i-2] + nums[i];\\n            int B = tmp[i-1];\\n            int max = A > B ? A : B;\\n            tmp[i] = max;\\n        }\\n        return tmp[nums.length-1];\\n    }\\n}\\n```\n```java\\n//the best solution  think\\n//\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u548C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u8868\\u73B0\\u6700\\u597D\\u7684\\u4E00\\u79CD\\u65B9\\u5F0F\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0){\\n            return 0;\\n        }\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n        int a = nums[0];\\n        int b = nums[0] > nums[1] ? nums[0] : nums[1];\\n        for(int i=2;i<nums.length;i++){\\n            int A = a + nums[i];\\n            int B = b;\\n            int max = A > B ? A : B;\\n            a = b;\\n            b = max;\\n        }\\n        return b;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n <= 0){\\n            return 0;\\n        }\\n        \\n        if(n == 1){\\n            return nums[0];\\n        }\\n        \\n        int[] tmp = new int[n];\\n        tmp[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                tmp[i] = Math.max(tmp[i],nums[j] + (j+2<n?tmp[j+2]:0));\\n            }\\n        }\\n        return tmp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55676,
                "title": "java-4-liner-tc-o-n-sc-o-1",
                "content": "Assigning value to 'prev' in same line while calculating current maximum.\\n(prev(H1), last(H2), curr(H3), House4) -> (House1, prev(H2), last(H3), curr(H4))\\n```\\npublic int rob(int[] nums) {\\n     int prev=0, last=0;\\n     for (int curr : nums)\\n         last = Math.max(prev+curr, prev=last);\\n     return last;\\n}",
                "solutionTags": [],
                "code": "Assigning value to 'prev' in same line while calculating current maximum.\\n(prev(H1), last(H2), curr(H3), House4) -> (House1, prev(H2), last(H3), curr(H4))\\n```\\npublic int rob(int[] nums) {\\n     int prev=0, last=0;\\n     for (int curr : nums)\\n         last = Math.max(prev+curr, prev=last);\\n     return last;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2909648,
                "title": "easy-to-understand-linear-complexity-no-dp-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n         /*\\n       2 1 1 2 \\n       take 2 than skip 1 , 1 again take 2 -->  answer -> 4\\n        */\\n\\n        int evenPos_Sum=0 , oddPos_Sum=0 , max_sum=0; \\n       \\n        for(int i=0;i<nums.size();i++){\\n            //if at even index position -> 0,2,4...\\n            if(!(i&1)){\\n          evenPos_Sum+=nums[i];\\n           evenPos_Sum = max(evenPos_Sum,oddPos_Sum);\\n            }\\n            //if at odd index position -> 1,3,5...\\n            if((i&1)){\\n          oddPos_Sum+=nums[i];\\n          oddPos_Sum = max(evenPos_Sum,oddPos_Sum);\\n            }\\n}\\n   \\n        max_sum = max(evenPos_Sum,oddPos_Sum);\\n        return max_sum;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n         /*\\n       2 1 1 2 \\n       take 2 than skip 1 , 1 again take 2 -->  answer -> 4\\n        */\\n\\n        int evenPos_Sum=0 , oddPos_Sum=0 , max_sum=0; \\n       \\n        for(int i=0;i<nums.size();i++){\\n            //if at even index position -> 0,2,4...\\n            if(!(i&1)){\\n          evenPos_Sum+=nums[i];\\n           evenPos_Sum = max(evenPos_Sum,oddPos_Sum);\\n            }\\n            //if at odd index position -> 1,3,5...\\n            if((i&1)){\\n          oddPos_Sum+=nums[i];\\n          oddPos_Sum = max(evenPos_Sum,oddPos_Sum);\\n            }\\n}\\n   \\n        max_sum = max(evenPos_Sum,oddPos_Sum);\\n        return max_sum;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818729,
                "title": "python3-four-lines-w-explanation-faster-than-96-97-dynamic-programming",
                "content": "# Please upvote if you find this helpful! :)\\n\\n# Intuition\\n- At every house we will have two options: rob or skip\\n- Because we cannot rob a house that is next door to another, and because all values will be non-negative, we will always leave either one or two houses unrobbed between robbed houses.\\n- Given the conditions, it will never make sense to skip three or more houses in a row since we could rob houses in-between.\\n\\n# Approach\\n1. `bag` is the amount stolen so far, starting from zero, with two options for having skipped the previous house or potentially robbed the previous house\\n   a. `bag[0]` is the amount we\\'ll have if we have skipped the previous house\\n   b. `bag[1]` is the max of skipping vs robbing the previous house\\n   c. If we choose to skip twice in a row, `bag[0]` and `bag[1]` will be equal, so it will always be best to rob the following house\\n2. During each iteration:\\n   a. Pull the next value from `nums` and assign it to `house`\\n   b. Add `bag[0] + house` and compare it to `bag[1]`\\n   c. Simultaneously, move `bag[1]` to `bag[0]` and update `bag[1]` to the max of the previous step\\n3. At the end of the iterations, return `bag[1]` as that is the max possible haul of stolen goods\\n   \\n# Example\\nstart:\\n`nums = [2, 7, 9, 3, 1]; bag = (0, 0)`\\n\\niterations:\\n- `house = 2; bag = (0, 0)` -> `bag = (0, 2)`\\n  - `bag[1]` moves to `bag[0]`\\n  - `bag[1]` becomes 2 because 0 + 2 > 0\\n- `house = 7; bag = (0, 2)` -> `bag = (2, 7)`\\n  - `bag[1]` moves to `bag[0]`\\n  - `bag[1]` becomes 7 because 0 + 7 > 2\\n- `house = 9; bag = (2, 7)` -> `bag = (7, 11)`\\n  - `bag[1]` moves to `bag[0]`\\n  - `bag[1]` becomes 11 because 2 + 9 > 7\\n- `house = 3; bag = (7, 11)` -> `bag = (11, 11)`\\n   - `bag[1]` moves to `bag[0]`\\n   - `bag[1]` stays at 11 because 7 + 3 < 11\\n- `house = 1; bag = (11, 11)` -> `bag = (11, 12)`\\n   - `bag[1]` moves to `bag[0]`\\n   - `bag[1]` becomes 12 because 11 + 1 > 11\\n\\nend:\\n`return bag[1]` -> 12\\n\\nNote: It could be looked at as if, with each iteration, we are appending the new value and chopping off every element but the last two.\\n\\n\\nExecution time: 30 ms (faster than 96.97%)\\nMemory usage: 13.9 MB (smaller than 19.80%)\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        bag = (0, 0)\\n\\n        for house in nums:\\n            bag = (bag[1], max(bag[0] + house, bag[1]))\\n\\n        return bag[1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        bag = (0, 0)\\n\\n        for house in nums:\\n            bag = (bag[1], max(bag[0] + house, bag[1]))\\n\\n        return bag[1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180198,
                "title": "java-dp-in-depth-explanation",
                "content": "This problem is an iconic DP problem so that means we solve the main problem by solving several sub problems first, and use the result of sub problems to handle our main problem. \\n  \\n  To solve this DP problem, we could use an equation: `maxSum[n] = Math.max(maxSum[i - 1], maxSum[i - 2] + nums[i] ) `. How do we come up with such a formula? Let\\'s look the example below.\\n  \\n  **Step 1.** When we came to the `idx 0` house, what\\'s the max profit we can rob? The answer is 7 because the only house we can rob is `0`th house. Hence, we rob the `0`th house. The max Sum at `idx 0` now is 7. \\n  `nums      = [7, 10, 12, 7, 9, 14]`\\n  `maxSum = [7]`  \\n  \\n   **Step 2.**  When we came to the `idx 1` house, what\\'s the max profit we can rob? We have two options now, right? We either rob `0`th house or `1` th house. 10 > 7 so we rob `idx 1` house. Therefore, maxSum[1] = Math.max(10, 7) = 10\\n  `nums      = [7, 10, 12, 7, 9, 14]`\\n  `maxSum = [7, 10]`  \\n  \\n   **Step 3.** When we came to the `idx 2` house, what\\'s the max profit we can rob? We either rob both (`idx 0` house and `idx 2` house) or (`idx 1` house), right? 7 + 12 > 10. Therefore, maxSum[2] = Math.max(7+12, 10) = 19\\n    `nums      = [7, 10, 12, 7, 9, 14]`\\n    `maxSum = [7, 10, 19]`\\n\\t\\n\\t\\n**Step 4.** When we came to the `idx 3` house, what\\'s the max profit we can rob? Now we can start applying the concept of DP. At `idx 2` house, the max profit we can have is 19. Now we either keep this max profit `19` or we rob `idx 3` house. Therefore, maxSum[3] = Math.max(19, 10 + 7) = 19. Do you get the idea at this point now? If not, let\\'s keep moving forward.\\n\\t`nums      = [7, 10, 12, 7, 9, 14]`\\n    `maxSum = [7, 10, 19, 19]` \\n\\t\\n\\t\\n**Step 5.** When we came to the `idx 4` house, what\\'s the max profit we can rob? At `idx 3` house, the max profit we can have is 19. Now we either keep this max profit `19`, or we can rob `idx 4` house. Therefore, maxSum[4] = Math.max(19, 19 + 9) = 28.\\n\\t`nums      = [7, 10, 12, 7, 9, 14]`\\n    `maxSum = [7, 10, 19, 19, 28]` \\n\\t\\n**Step 6.** When we came to the `idx 5` house, what\\'s the max profit we can rob? maxSum[4] = Math.max(28, 19 + 14) = 33.\\n    `nums      = [7, 10, 12, 7, 9, 14]`\\n    `maxSum = [7, 10, 19, 19, 28, 33]` \\n\\nI hope my explanation is helpful for you guys to ace the coding interview and become a professional robber **: )**\\n\\t\\nBelow is my Solution in Java:\\n\\t\\n```\\nclass Solution \\n{\\n    public int rob(int[] nums) \\n    {\\n        // O(n) time | O(n) space\\n        if(nums.length == 0)    return 0;\\n        if(nums.length == 1)    return nums[0];\\n        \\n        int[] maxSum = nums.clone();\\n        maxSum[1] = Math.max(nums[0], nums[1]);\\n        \\n        for(int i = 2; i < nums.length; i++)\\n            maxSum[i] = Math.max(maxSum[i-1], maxSum[i-2] + nums[i]);\\n        \\n        return maxSum[nums.length-1];\\n    }\\n}\\n```\\n\\n===================================================\\nSince the solution above has O(n) time and O(n) space, and now your interviwer ask you that \"Can you do better\"? Of course, we can. We even know how to rob the house w/ algorithms. To decrease the space complexity, we simply get rid of int[ ] maxSum. We use two variables to track the max profit. \\n```\\nclass Solution \\n{\\n    public int rob(int[] nums) \\n    {\\n        // O(n) time || O(1) space\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n\\n        int second = nums[0];\\n        int first = Math.max(nums[0], nums[1]);\\n\\n        for(int i = 2; i < nums.length; i++)\\n        {\\n            int cur = Math.max(first, second + nums[i]);\\n            second = first;\\n            first = cur;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int rob(int[] nums) \\n    {\\n        // O(n) time | O(n) space\\n        if(nums.length == 0)    return 0;\\n        if(nums.length == 1)    return nums[0];\\n        \\n        int[] maxSum = nums.clone();\\n        maxSum[1] = Math.max(nums[0], nums[1]);\\n        \\n        for(int i = 2; i < nums.length; i++)\\n            maxSum[i] = Math.max(maxSum[i-1], maxSum[i-2] + nums[i]);\\n        \\n        return maxSum[nums.length-1];\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int rob(int[] nums) \\n    {\\n        // O(n) time || O(1) space\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n\\n        int second = nums[0];\\n        int first = Math.max(nums[0], nums[1]);\\n\\n        for(int i = 2; i < nums.length; i++)\\n        {\\n            int cur = Math.max(first, second + nums[i]);\\n            second = first;\\n            first = cur;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248441,
                "title": "c-recursion-memoization-dp-three-approaches",
                "content": "BRUTE FORCE\\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int a = robHelper(nums, i+2) + nums[i];\\n        int b = robHelper(nums, i+1);\\n        return max(a,b);\\n    }\\n    int rob(vector<int>& nums){\\n        return robHelper(nums,0);\\n    }\\n};\\n```\\nThis solution will show TLE\\n\\nMEMOIZATION\\n\\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i, int*dp){\\n        int n = nums.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        \\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        \\n        int a = robHelper(nums, i+2,dp) + nums[i];\\n        int b = robHelper(nums, i+1,dp);\\n        int ans = max(a,b);\\n        dp[i] = ans;\\n        return ans;\\n    }\\n    int rob(vector<int>& nums){\\n        int n = nums.size();\\n        int *dp = new int[n+1];\\n        for(int i=0; i<=n; i++){\\n            dp[i] = -1;\\n        }\\n        return robHelper(nums,0,dp);\\n    }\\n};\\n```\\n\\nDYNAMIC PROGRAMMING\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int *dp = new int[nums.size()];\\n        int n = nums.size();\\n        if(n==0) {\\n            return 0;\\n        }\\n        if(n==1){\\n         return nums[0];   \\n        }\\n        if(n==2){\\n          return max(nums[1],nums[0]);  \\n        }\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i = 2; i <nums.size(); i++){\\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1]);\\n        }\\n        return dp[nums.size()-1];\\n        delete[] dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int a = robHelper(nums, i+2) + nums[i];\\n        int b = robHelper(nums, i+1);\\n        return max(a,b);\\n    }\\n    int rob(vector<int>& nums){\\n        return robHelper(nums,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i, int*dp){\\n        int n = nums.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        \\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        \\n        int a = robHelper(nums, i+2,dp) + nums[i];\\n        int b = robHelper(nums, i+1,dp);\\n        int ans = max(a,b);\\n        dp[i] = ans;\\n        return ans;\\n    }\\n    int rob(vector<int>& nums){\\n        int n = nums.size();\\n        int *dp = new int[n+1];\\n        for(int i=0; i<=n; i++){\\n            dp[i] = -1;\\n        }\\n        return robHelper(nums,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int *dp = new int[nums.size()];\\n        int n = nums.size();\\n        if(n==0) {\\n            return 0;\\n        }\\n        if(n==1){\\n         return nums[0];   \\n        }\\n        if(n==2){\\n          return max(nums[1],nums[0]);  \\n        }\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i = 2; i <nums.size(); i++){\\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1]);\\n        }\\n        return dp[nums.size()-1];\\n        delete[] dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312003,
                "title": "c-simple-solution-with-o-1-memory",
                "content": "``` csharp\\n  public int Rob(int[] nums) {\\n        if(nums == null || nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        int firstPrevious = 0;\\n        int secondPrevious = 0;\\n        int current = 0;\\n                        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            secondPrevious = firstPrevious;\\n            firstPrevious = current;\\n            current = Math.Max(firstPrevious, secondPrevious + nums[i]);\\n        }\\n        \\n        return current;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` csharp\\n  public int Rob(int[] nums) {\\n        if(nums == null || nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        int firstPrevious = 0;\\n        int secondPrevious = 0;\\n        int current = 0;\\n                        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            secondPrevious = firstPrevious;\\n            firstPrevious = current;\\n            current = Math.Max(firstPrevious, secondPrevious + nums[i]);\\n        }\\n        \\n        return current;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299751,
                "title": "c-straightforward-easy",
                "content": "```\\npublic class Solution {\\n    public int Rob(int[] nums) {\\n        for (int i = 2; i < nums.Length; i++) {\\n            if (i > 2)\\n                nums[i] += Math.Max(nums[i - 2], nums[i - 3]);\\n            else\\n                nums[i] += nums[i - 2];\\n        }\\n        return nums.Length > 1 ? Math.Max(nums[nums.Length - 1], nums[nums.Length - 2]) : nums.Sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Rob(int[] nums) {\\n        for (int i = 2; i < nums.Length; i++) {\\n            if (i > 2)\\n                nums[i] += Math.Max(nums[i - 2], nums[i - 3]);\\n            else\\n                nums[i] += nums[i - 2];\\n        }\\n        return nums.Length > 1 ? Math.Max(nums[nums.Length - 1], nums[nums.Length - 2]) : nums.Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55950,
                "title": "share-my-2ms-c-dp-solution-with-o-1-space",
                "content": "f(j) indicates the robber has made a dicison for jth house for the max money, the recursion can be f(j) = max(f(j-1), f(j-2)+nums[j]); it can be implemented by iteration with O(1) space.\\n\\n    #define max(x,y)  (((x)>(y))?(x):(y))\\n    int rob(int* nums, int numsSize) {\\n        int x0 = 0, x1 = 0, x2 = 0;\\n        \\n        //f(j) = max(f(j-1),f(j-2)+nums[i])\\n        for(int i = 0; i < numsSize; i++)\\n        {\\n            x2 = max(x0+nums[i],x1);\\n            x0 = x1;\\n            x1 = x2;\\n        }\\n        \\n        return x2;\\n    }",
                "solutionTags": [],
                "code": "f(j) indicates the robber has made a dicison for jth house for the max money, the recursion can be f(j) = max(f(j-1), f(j-2)+nums[j]); it can be implemented by iteration with O(1) space.\\n\\n    #define max(x,y)  (((x)>(y))?(x):(y))\\n    int rob(int* nums, int numsSize) {\\n        int x0 = 0, x1 = 0, x2 = 0;\\n        \\n        //f(j) = max(f(j-1),f(j-2)+nums[i])\\n        for(int i = 0; i < numsSize; i++)\\n        {\\n            x2 = max(x0+nums[i],x1);\\n            x0 = x1;\\n            x1 = x2;\\n        }\\n        \\n        return x2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55947,
                "title": "java-dp-solution-without-extra-space",
                "content": "    //f(i) : harvest from house 0 to i\\n    //f(i) = max{f(i-2), f(i-3)} + a[i], i>=3\\n    \\n    //f(2) = a[0] + a[2],     i= 2\\n    //f(1) = a[1],            i= 1\\n    //f(0) = a[0],            i= 0\\n\\n    public class Solution {\\n        public int rob(int[] nums) {\\n            if(nums == null || nums.length ==0) return 0;\\n            \\n            int len = nums.length;\\n            if(len == 1) return nums[0];\\n            if(len == 2) return Math.max(nums[0],nums[1]);\\n            if(len == 3) return Math.max(nums[0]+nums[2], nums[1]);\\n            \\n            nums[2] = nums[0]+nums[2];//f(2) = a[0] + a[2]\\n            \\n            for(int i=3; i<len; i++){\\n                nums[i] = Math.max(nums[i-3], nums[i-2])+nums[i];\\n            }\\n            \\n            return Math.max(nums[len-1], nums[len-2]);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int rob(int[] nums) {\\n            if(nums == null || nums.length ==0) return 0;\\n            \\n            int len = nums.length;\\n            if(len == 1) return nums[0];\\n            if(len == 2) return Math.max(nums[0],nums[1]);\\n            if(len == 3) return Math.max(nums[0]+nums[2], nums[1]);\\n            \\n            nums[2] = nums[0]+nums[2];//f(2) = a[0] + a[2]\\n            \\n            for(int i=3; i<len; i++){\\n                nums[i] = Math.max(nums[i-3], nums[i-2])+nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2909432,
                "title": "python-o-1-space-optimized-dynamic-programming-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we cannot rob adjacent homes, we need to figure out the most optimal robbing path to take. Note, this does not always equate to every odd index house or every even index. To solve this problem, we can utilize dynamic programming to ensure we always have the most optimal robbing path until a given house. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCommon way to solve this problem is to create a dp array to keep track of the optimal robbing path. For our optimal profit, we can either include this house in the robbing or not.\\n\\nA simple ex: [2,1,1,2]\\nDP Array:    [2,2,3,4] -> *(dp[i] = max profit robbing from 0 to house[i])*\\n   \\n- At house 1, the most optimal profit is 2 from robbing house 1\\n- At house 2, the most optimal profit is either robbing only house 2 or only house 1, hence, optimal is 2. i.e. we don\\'t rob house 2 since there is a more optimal robbing path.\\n- At house 3, the most optimal profit is either robbing house 1 and 3 = 3 or only house 2 = 1, hence we get 3.\\n- At house 4, the most optimal profit is if we include this house in the robbing but we also rob house 1.\\n\\nFrom this we can determine that if we have a DP array, we can set \\n**dp[i] = max of ( dp[i-1] ) or ( nums[i] + dp[i-2] ) **\\n(Skip current house in robbing) or (Include current house in robbing + 2 houses back so not adjacent)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) optimized to O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nCommon Dynamic Programming Solution with O(N).\\n*DP Arr is 1-indexed for ease of computation*\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Input:  [  2,1,1,2]\\n        DP Arr: [0,2,2,3,4]\\n        \"\"\"\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        opt = [0] * (len(nums)+1)\\n        opt[1] = nums[0]\\n        for n in range(1,len(nums)):\\n            # Max of previous optimal (skip this house) or 2 houses back and rob this house\\n            opt[n+1] = max(opt[n], nums[n] + opt[n-1])\\n\\n        return opt[-1]\\n```\\nOptimized to constant space since we only need to store the last 2 most optimal profits. \\nWe use temp var since oneBack value is changed. \\n*See comments for alternative way to not use temp var in python.*\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        twoBack = 0\\n        oneBack = nums[0]\\n        for n in range(1,len(nums)):\\n            temp = oneBack\\n            # Choice between include current house in robbing or not\\n            oneBack = max(oneBack, nums[n] + twoBack)\\n            twoBack = temp\\n\\n        return oneBack\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Input:  [  2,1,1,2]\\n        DP Arr: [0,2,2,3,4]\\n        \"\"\"\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        opt = [0] * (len(nums)+1)\\n        opt[1] = nums[0]\\n        for n in range(1,len(nums)):\\n            # Max of previous optimal (skip this house) or 2 houses back and rob this house\\n            opt[n+1] = max(opt[n], nums[n] + opt[n-1])\\n\\n        return opt[-1]\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        twoBack = 0\\n        oneBack = nums[0]\\n        for n in range(1,len(nums)):\\n            temp = oneBack\\n            # Choice between include current house in robbing or not\\n            oneBack = max(oneBack, nums[n] + twoBack)\\n            twoBack = temp\\n\\n        return oneBack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605804,
                "title": "c-python-java-simple-and-clean-dynamic-programming-solution",
                "content": "**Idea:**\\nFirst, we have some edge cases.\\nThen, we use simple DP: for each house, we can\\'t rob two adjacent houses. So either we rob the previous one - `dp[i-1]`, or the two before and the current one - `nums[i]+dp[i-2]`.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n)\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # dynamic programming - decide each problem by its sub-problems:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n        \\n        return dp[-1]\\n```\\n**Java:**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        // edge cases:\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0], nums[1]);\\n        for (int i=2; i<nums.length; i++)\\n            dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.length-1];\\n    }\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # dynamic programming - decide each problem by its sub-problems:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n        \\n        return dp[-1]\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        // edge cases:\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0], nums[1]);\\n        for (int i=2; i<nums.length; i++)\\n            dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605688,
                "title": "all-solutions-from-recursion-to-constant-space-dp-c",
                "content": "* For each house you have 2 choices , rob the current house or don\\'t robe.\\n* If you rob the ith house then you will go to (i+2)th house next , as you can\\'t robe 2 adjacent houses.\\n## Solution 1 : Recursion\\n```\\nclass Solution {\\n    int helper(vector<int>& nums , int ind){\\n        \\n        //base case\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        //Choice 1 : Rob current house\\n        int money1 = nums[ind] + helper(nums , ind+2);\\n        \\n        //Choice 2: Don\\'t rob current house\\n        int money2 = helper(nums , ind+1);\\n        \\n        return max(money1 , money2);\\n    }\\n    \\npublic:\\n    int rob(vector<int>& nums) {\\n        return helper(nums,0);\\n    }\\n};\\n```\\n\\nTime Complexity : O(2^n), this will give us TLE\\nWe can optimise this solution using memoization and bottom up DP.\\n\\n## Solution 2: Recursion + Memoization\\n```\\nclass Solution {\\n    int helper(vector<int>& nums , int ind , vector<int>& dp){\\n        \\n        //base case\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        \\n        //Choice 1 : Rob current house\\n        int money1 = nums[ind] + helper(nums , ind+2 , dp);\\n        \\n        //Choice 2: Don\\'t rob current house\\n        int money2 = helper(nums , ind+1 , dp);\\n        \\n        return dp[ind] = max(money1 , money2);\\n    }\\n    \\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size() , -1);\\n        return helper(nums,0,dp);\\n    }\\n};\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n## Solution 3: Bottom Up DP\\ndp[i] denotes maximum money we can get till ith house.\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n        \\n        vector<int> dp(n,-1);\\n        \\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0] , nums[1]);\\n        for(int i=2;i<n;i++){\\n            dp[i] = max(nums[i] + dp[i-2] , dp[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n## Solution 4: Optimised Dp\\nFor every ith house we need 2 values:\\na) total money including robbing from i-1 house.\\nb) total money without robbing i-1 house.\\n\\nTherefore we maintain just 2 variables and not the dp array.\\n```\\nint rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n        \\n        int inc = nums[0]; //robbing house 0\\n        int excl = 0; //not robbing house 0\\n        \\n        for(int i=1;i<n;i++){\\n            int newInc = excl + nums[i]; //robbing ith house\\n            excl = max(inc , excl); // not robbing ith house\\n            inc = newInc;\\n        }\\n        return max(inc , excl);\\n    }\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n***If you find the solution helpful, please Upvote!***\\n**Happy Coding!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int helper(vector<int>& nums , int ind){\\n        \\n        //base case\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        //Choice 1 : Rob current house\\n        int money1 = nums[ind] + helper(nums , ind+2);\\n        \\n        //Choice 2: Don\\'t rob current house\\n        int money2 = helper(nums , ind+1);\\n        \\n        return max(money1 , money2);\\n    }\\n    \\npublic:\\n    int rob(vector<int>& nums) {\\n        return helper(nums,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int helper(vector<int>& nums , int ind , vector<int>& dp){\\n        \\n        //base case\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        \\n        //Choice 1 : Rob current house\\n        int money1 = nums[ind] + helper(nums , ind+2 , dp);\\n        \\n        //Choice 2: Don\\'t rob current house\\n        int money2 = helper(nums , ind+1 , dp);\\n        \\n        return dp[ind] = max(money1 , money2);\\n    }\\n    \\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size() , -1);\\n        return helper(nums,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n        \\n        vector<int> dp(n,-1);\\n        \\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0] , nums[1]);\\n        for(int i=2;i<n;i++){\\n            dp[i] = max(nums[i] + dp[i-2] , dp[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nint rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n        \\n        int inc = nums[0]; //robbing house 0\\n        int excl = 0; //not robbing house 0\\n        \\n        for(int i=1;i<n;i++){\\n            int newInc = excl + nums[i]; //robbing ith house\\n            excl = max(inc , excl); // not robbing ith house\\n            inc = newInc;\\n        }\\n        return max(inc , excl);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133686,
                "title": "c-five-approaches-bruteforce-topdown-optimised-bottomup-time-space",
                "content": "**Bruteforce Recursion - TLE**\\nTime Complexity: O (2^N)\\nSpace Complexity: O (N)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        return robUtil(nums, 0);\\n    }\\n    int robUtil (vector<int>& nums, int start) {\\n        if (start>=nums.size()) return 0;\\n        return max(nums[start]+robUtil (nums, start+2), robUtil (nums, start+1));\\n    }\\n};\\n```\\n**Recursion + Memoisation (Top-Down)**\\nTime Complexity: O (N)\\nSpace Complexity: O (N)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        vector <int> dp (nums.size(), -1);\\n        return robUtil(nums, 0, dp);\\n    }\\n    int robUtil (vector<int>& nums, int start, vector <int>& dp) {\\n        if (start>=nums.size()) return 0;\\n        if (dp[start]>-1) return dp[start];\\n        return dp[start]=max(nums[start]+robUtil (nums, start+2, dp), robUtil (nums, start+1, dp));\\n    }\\n};\\n```\\n\\n**Optimised DP (Bottom-Up)**\\nTime Complexity: O (N)\\nSpace Complexity: O (N)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return nums[0];\\n        vector<int> dp(nums.size()+1, -1);\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            dp[i+1] = max(nums[i]+dp[i-1], dp[i]);\\n        }\\n        return dp[nums.size()];\\n    }\\n};\\n```\\n\\n**Very Optimised Bottom Up (#1)**\\nTime Complexity: O (N)\\nSpace Complexity: O (1)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        int prevByOne=0;\\n        int prevByTwo=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            int cur=max(nums[i]+prevByTwo, prevByOne);\\n            prevByTwo=prevByOne;\\n            prevByOne=cur;\\n        }\\n        return prevByOne;\\n    }\\n};\\n```\\n\\n**Very Optimised Bottom Up (#2)**\\nWill add explanation some other day\\nTime Complexity: O (N)\\nSpace Complexity: O (1)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return nums[0];\\n        int rob1 = 0;\\n        int rob2 = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            int rob = max(nums[i]+rob1, rob2);\\n            rob1=rob2;\\n            rob2=rob;\\n        }\\n        return rob2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        return robUtil(nums, 0);\\n    }\\n    int robUtil (vector<int>& nums, int start) {\\n        if (start>=nums.size()) return 0;\\n        return max(nums[start]+robUtil (nums, start+2), robUtil (nums, start+1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        vector <int> dp (nums.size(), -1);\\n        return robUtil(nums, 0, dp);\\n    }\\n    int robUtil (vector<int>& nums, int start, vector <int>& dp) {\\n        if (start>=nums.size()) return 0;\\n        if (dp[start]>-1) return dp[start];\\n        return dp[start]=max(nums[start]+robUtil (nums, start+2, dp), robUtil (nums, start+1, dp));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return nums[0];\\n        vector<int> dp(nums.size()+1, -1);\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            dp[i+1] = max(nums[i]+dp[i-1], dp[i]);\\n        }\\n        return dp[nums.size()];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        int prevByOne=0;\\n        int prevByTwo=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            int cur=max(nums[i]+prevByTwo, prevByOne);\\n            prevByTwo=prevByOne;\\n            prevByOne=cur;\\n        }\\n        return prevByOne;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return nums[0];\\n        int rob1 = 0;\\n        int rob2 = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            int rob = max(nums[i]+rob1, rob2);\\n            rob1=rob2;\\n            rob2=rob;\\n        }\\n        return rob2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759165,
                "title": "python3-solution-with-a-detailed-explanation-house-robber",
                "content": "Following solutions are not mine,the first solution comes from [here](https://leetcode.com/problems/house-robber/discuss/55959/4-line-python.-O(1)-space-O(n)-time.-With-explaination.-Simplest). The second one [here](https://leetcode.com/problems/house-robber/discuss/346376/Python-Dynamic-Programming-20-ms). \\n\\nEDIT: I now think that I should have talked about second solution first. Go read the whole post and start with whichever you feel is easier. \\n\\n\\nAs it\\'s mentioned in the problem statement, you can\\'t rob two adjacent houses. That\\'s I think the most important part of the problem to fully understand. Let\\'s try `nums = [1,2,3,1]` example! It\\'s obvious, right? You rob (not you, the thief)  `nums[0] + nums[2] = 4`. At first glance, what came to my mind was that what if we sum every other number starting from zero index (`sum(nums[::2])`) and start from index 1 (`sum(nums[1::2])`) and return the max of two! This works for the above example but it\\'s not going to work in general! Consider this example! `nums = [7,2,3,4]`! you need to choose `nums[0] + nums[3] = 11` to maximize your profit (thief\\'s profit). That\\'s why the above approach doesn\\'t work. \\n\\nReminder: In a list you can slice using `[start index : end index: step]`! In the above paragraph, `nums[::2] = num[0:-1:2]`. \\n\\nFor the first solution, the idea is similar to dynamic programming, but, not implemented using the DP approach. What I mean is that you move from left to right in `nums` and decide to whether include the current house `curr` in the robbery (view this problem as a `0/1 knapsack` problem where you decide whether to include an item in the knapsack or not). But, in contradiction to dp, you don\\'t store each step in an array (something we\\'ll do in the second solution). \\n\\nHere, we first define two parameters `curr_included` and `max_curr_excluded` (line `#1`) to keep track of whether we want to include `curr` or not. In the loop of line `#2`, we go from left to right in `nums`. There are two cases: 1) if we want to include `curr` or 2) we don\\'t want to include `curr` ! Regardless of what we decide here `max_curr_excluded` keep track of maximum profit so far excluding `curr`. Note that while we\\'re at an element, the previous element used to be `curr` at some point, right? However, the `max_curr_excluded` doesn\\'t care if something used to be `curr`, it just doesn\\'t want to include the `curr` we\\'re at right now. Does this make sense? Let\\'s check again the `nums = [7, 2, 3, 4]` example! If you do print some stuff (check the code below), you see something like this. \\n\\n```\\ncurr_included =  7 , max_curr_excluded=  0 <---- curr = 7\\ncurr_included =  2 , max_curr_excluded=  7 <---- curr = 2\\ncurr_included =  10 , max_curr_excluded=  7 <---- curr = 3\\ncurr_included =  11 , max_curr_excluded=  10 <---- curr = 4\\n\\n```\\n\\nOnce we include `nums[0]`, `curr_included = 7` while `max_curr_excluded` is still zero since it cannot include `curr`. However, once we move to `nums[1] = 2`, both variables get updated! `curr_included` cannot include `7` (two adjacent houses) anymore while `max_curr_excluded = 7` because it shows the maximum excluding `curr`.  We keep moving toward the end of the array. Let\\'s see what happens when we\\'re at the last element `curr = 4`. Here, we include `4` to be added to the `curr_included`, which we\\'ll give us `11`. Note that `max_curr_excluded` hasn\\'t considered the `curr = 4` yet, and shows the maximum up to the previous point. The `max_curr_excluded` up to the previous point, doesn\\'t included the previous point itself, right? Since it excluded that `curr`! Therefore, it\\'s eligible to add `curr = 4` to `max_curr_excluded` because it doesn\\'t include the adjacent house. That\\'s what we do in line `#3` to update `curr_included`. As for `max_curr_excluded` however, we use the `max` of two variables, none of which includes `curr` we\\'re looking at right now. Finally, we return the `max` of the two. The maximum we\\'re returning shows two cases. Whether the last element is included (`curr_included`) or the last element is not included (`max_curr_excluded`).\\n\\n```\\n# first solution\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        curr_included, max_curr_excluded = 0, 0 #1\\n        for curr in nums: #2\\n            curr_included, max_curr_excluded = curr+max_curr_excluded, max(curr_included, max_curr_excluded) #3\\n            #print(\\'curr_included = \\',curr_included, \\', max_curr_excluded= \\', max_curr_excluded, \\'<---- curr =\\', curr)\\n            \\n        return max(curr_included, max_curr_excluded)\\n```\\n\\n\\nThe second solution is a dynamic programming approach (I find this easier to understand). The idea is similar to the above! You move from left to right in `nums` and decide whether to include current house or not. Similar to any dp problem, there\\'re some base cases. You return `0` if `nums = []` (line `#1`). If the `len(nums) == 1`, you return its only value. If it has `len(nums) == 2`, you return the `max` of two values (line `#3`). These cases are projected in the `dp` array that we generated to keep track of maximum profit at each on the input array. For the main `loop`, we start from index `2` to the end of the array since the base cases cover up to index `2`. At each `i`, we check whether we should included `curr = nums[i]` or not in line `#6`. We either choose the maximum up to previous `i`, which means that we don\\'t need to included `curr = nums[i]` (note that I\\'m using `curr` to make a connection between this solution and the previous one. I don\\'t use `curr` in this solution) if `dp[i-1]` is larger than `dp[i-2]  + nums[i]`. However, similar to the previous appraoch, whatever goes into the `dp` shows the maximum up to index `i` regardless of `nums[i]` is included or not. \\n\\n\\nFinally, we return the maximum of two cases, including last element or not, which are shown in `dp[-1]` and `dp[-2]`. \\n\\n```\\n# second solution\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        \\n        if len(nums) == 0: #1\\n            return 0\\n        \\n        if len(nums) == 1: #1\\n            return nums[0]\\n        \\n        if len(nums) == 2: #3\\n            return max(nums[0], nums[1])\\n        \\n        dp[0] = nums[0] #4\\n        dp[1] = max(nums[:2]) #5\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-2] + nums[i], dp[i-1]) #6\\n            \\n        return max(dp[-1], dp[-2])\\n```\\n\\nThat\\'s it! \\n\\n==================================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix them\\n\\nFinal note 2: I\\'m writing it to help myself understand the subject better. Hope you also find it helpful.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ncurr_included =  7 , max_curr_excluded=  0 <---- curr = 7\\ncurr_included =  2 , max_curr_excluded=  7 <---- curr = 2\\ncurr_included =  10 , max_curr_excluded=  7 <---- curr = 3\\ncurr_included =  11 , max_curr_excluded=  10 <---- curr = 4\\n\\n```\n```\\n# first solution\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        curr_included, max_curr_excluded = 0, 0 #1\\n        for curr in nums: #2\\n            curr_included, max_curr_excluded = curr+max_curr_excluded, max(curr_included, max_curr_excluded) #3\\n            #print(\\'curr_included = \\',curr_included, \\', max_curr_excluded= \\', max_curr_excluded, \\'<---- curr =\\', curr)\\n            \\n        return max(curr_included, max_curr_excluded)\\n```\n```\\n# second solution\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        \\n        if len(nums) == 0: #1\\n            return 0\\n        \\n        if len(nums) == 1: #1\\n            return nums[0]\\n        \\n        if len(nums) == 2: #3\\n            return max(nums[0], nums[1])\\n        \\n        dp[0] = nums[0] #4\\n        dp[1] = max(nums[:2]) #5\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-2] + nums[i], dp[i-1]) #6\\n            \\n        return max(dp[-1], dp[-2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55810,
                "title": "well-explained-java-dynamic-programming-style-code-good-for-beginners-like-me",
                "content": "    public class Solution {\\n    public int rob(int[] nums) {\\n        /*\\n        Dynamic programming\\n        Bottom-up approach\\n        Since we cannot rob 2 adjacent houses, generally, we cannot rob house[n] and house [n-1] at the same night\\n        So the basic idea is to see if house[n-1] has been robbed\\n        If house[n-1] has been robbed, then the optimal approach should be max{robbedmoney(n-1), robbedmoney(n-2)+nums[n]}\\n        If house[n-1] hasn't been robbed, then the optimal approach should be robbedmoney(n-2)+nums[n]\\n        */\\n        \\n        int l = nums.length;\\n        if (l == 0){\\n            return 0;\\n        }\\n\\n        int[] robbedmoney = new int[l]; //robbedmoney[i] array is used to store the maximum amount of money that can be robbed from the first i houses.\\n        for (int i = 0; i < l; i ++){\\n            if (i == 0){\\n                robbedmoney[i] = nums[i];\\n            }\\n            else if (i == 1){\\n                robbedmoney[i] = Math.max(nums[i], nums[i-1]);\\n            }\\n            else{\\n                robbedmoney[i] = Math.max(robbedmoney[i - 2] + nums[i], robbedmoney[i-1]);\\n            }\\n        }\\n        \\n        return robbedmoney[l - 1];\\n        \\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        /*\\n        Dynamic programming\\n        Bottom-up approach\\n        Since we cannot rob 2 adjacent houses, generally, we cannot rob house[n] and house [n-1] at the same night\\n        So the basic idea is to see if house[n-1] has been robbed\\n        If house[n-1] has been robbed, then the optimal approach should be max{robbedmoney(n-1), robbedmoney(n-2)+nums[n]}",
                "codeTag": "Java"
            },
            {
                "id": 2909316,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int temp,max,max1;\\n        if(nums.length==1)\\n         return nums[0];\\n         if(nums.length==2)\\n           return Math.max(nums[0],nums[1]);\\n        max=nums[0];\\n        max1=nums[1];\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            max1=Math.max(max1,max);\\n            if(max+nums[i]>=max)\\n               max+=nums[i];\\n            temp=max;\\n            max=max1;\\n            max1=temp;\\n        }\\n        return Math.max(max1,max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int temp,max,max1;\\n        if(nums.length==1)\\n         return nums[0];\\n         if(nums.length==2)\\n           return Math.max(nums[0],nums[1]);\\n        max=nums[0];\\n        max1=nums[1];\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            max1=Math.max(max1,max);\\n            if(max+nums[i]>=max)\\n               max+=nums[i];\\n            temp=max;\\n            max=max1;\\n            max1=temp;\\n        }\\n        return Math.max(max1,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779597,
                "title": "comprehensive-python-explanation",
                "content": "Let\\'s walk through how to start with the basic recursive solution and work all the way up to the solution with the best time and space complexity! First we have to identify the recursive relationship:\\n\\nBase cases:\\n1. If we only have one house to rob, we rob it\\n2. If we have only two houses to rob, then we cannot rob both so we rob the one with the most money\\n\\nThat was pretty simple! But what if we have more than two houses? Well, let\\'s think about it as if we are at the `n`th house and we already robbed the previous houses. We can either rob this house or not. If we do rob the house, we cannot rob the `n-1`th house, so the total amount of money we get is the total amount of money after robbing the first `n-2` houses plus the money at the `n`th house. If we don\\'t rob the `n`th house, then we still have the same amount of money as we had after robbing the `n-1`th house. Using this, we can construct our first solution:\\n\\n**Basic Recursion Solution; Time: O(2^N), Space: O(1) --> TLE**\\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# helper method to find the most money we can get for robbing the first n houses\\n\\tdef rob_n_houses(n):\\n\\t\\t# if there is only one house to rob\\n\\t\\tif n == 1:\\n\\t\\t\\t# rob it\\n\\t\\t\\treturn nums[0]\\n\\t\\t# if there are only two houses to rob\\n\\t\\tif n == 2: \\n\\t\\t\\t# rob the one with the most money\\n\\t\\t\\treturn max(nums[0], nums[1])\\n\\t\\t\\t\\n\\t\\t# otherwise we can either rob this house and not the previous one\\n\\t\\t# or we can not rob this house and rob any houses before it\\n\\n\\t\\t# if we rob this house (nums[-1]), we can\\'t rob nums[n-2], but we can rob any before that\\n\\t\\trob_this_house = nums[n-1] + rob_n_houses(n-2)\\n\\n\\t\\t# if we don\\'t rob nums[n-1], we can rob any house before it, meaning this is the same as rob_n_houses(n-1)\\n\\t\\tdont_rob_this_house = rob_n_houses(n-1)\\n\\t\\t# do whatever gets us the most money\\n\\t\\treturn max(rob_this_house, dont_rob_this_house)\\n\\t# originally we can rob any of the houses\\n\\treturn rob_n_houses(len(nums))\\n```\\nThis is the most basic solution, taking advantage of the recursive relationship we explored above. However, it is quite slow and results in a time limit exception because it has a time complextiy of ```O(2^N)``` since we need to make 2 recursive calls at each point and those recursive calls make recursive calls of their own. This can be illustrated with the following diagram about the fibonnaci sequence (credit to [Prateek Narang](https://www.scaler.com/topics/fibonacci-series-in-c/)):\\n![image](https://assets.leetcode.com/users/images/0b8e23d2-abd9-4553-b622-5efb833ba81a_1665202511.7852473.png)\\nTo improve on this solution, we can use memoization, one of the core DP techniques. Memoization just means storing our previous results. One way to do this is with python\\'s built in ```@cache```, which stores previous return values from a function call.\\n\\n**Cache Memoization Solution: Time: O(N), Space: O(N)**\\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# helper method to find the most money we can get for robbing the first n houses\\n\\t@cache # store previous calls to this helper method\\n\\tdef rob_n_houses(n):\\n\\t\\t# if there is only one house to rob\\n\\t\\tif n == 1:\\n\\t\\t\\t# rob it\\n\\t\\t\\treturn nums[0]\\n\\t\\t# if there are only two houses to rob\\n\\t\\tif n == 2: \\n\\t\\t\\t# rob the one with the most money\\n\\t\\t\\treturn max(nums[0], nums[1])\\n\\t\\t# otherwise we can either rob this house and not the previous one\\n\\t\\t# or we can not rob this house and rob any houses before it\\n\\n\\t\\t# if we rob this house (nums[-1]), we can\\'t rob nums[n-2], but we can rob any before that\\n\\t\\trob_this_house = nums[n-1] + rob_n_houses(n-2)\\n\\n\\t\\t# if we don\\'t rob nums[n-1], we can rob any house before it, meaning this is the same as rob_n_houses(n-1)\\n\\t\\tdont_rob_this_house = rob_n_houses(n-1)\\n\\t\\t# do whatever gets us the most money\\n\\t\\treturn max(rob_this_house, dont_rob_this_house)\\n\\t# originally we can rob any of the houses\\n\\treturn rob_n_houses(len(nums))\\n```\\nThe time complexity is now ```O(N)``` since we only need to make one calculation for every value from ```1``` to ```n```. The space is also ```O(N)``` since we are now storing the answers to recursive calls to ```rob_n_houses```. To show that we are capable of implementing the same functionality as python\\'s `@cache`, let\\'s store the results ourselves by using a list where the ```i```th index corresponds to the result of ```rob_n_houses(i)```. We will start our array with `[0, nums[0]]`, since we would have `0` dollars after robbing zero houses. I would recommend going this route in an interview rather than using `@cache`.\\n\\n**List Memoization Solution; Time: O(N), Space: O(N)**\\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# we have 0 dollars after robbing no houses and nums[0] dollars after robbing the first house\\n\\trob_n_houses = [0, nums[0]]\\n\\t# go through the rest of the houses\\n\\tfor i in range(1, len(nums)):\\n\\t\\t# if we rob this house\\n\\t\\trob_this_house = nums[i] + rob_n_houses[-2]\\n\\t\\t# if we dont\\n\\t\\tdont_rob_this_house = rob_n_houses[-1]\\n\\t\\t# add the max amt of money at this point\\n\\t\\trob_n_houses.append(max(rob_this_house, dont_rob_this_house))\\n\\t# return money after robbing all the houses\\n\\treturn rob_n_houses[-1] \\n```\\nThis is a great solution, but we can do even better! When we add the newest number to ```rob_n_houses``` , we actually only need to access the previous numbers in ```rob_n_houses```, so we can just use a tuple to store the last two!\\n\\n**Optimized Memoization Solution; Time: O(N), Space: O(1)**\\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# we have 0 dollars after robbing no houses and nums[0] dollars after robbing the first house\\n\\tlast_two = (0, nums[0])\\n\\t# go through the rest of the houses\\n\\tfor i in range(1, len(nums)):\\n\\t\\t# if we rob this house\\n\\t\\trob_this_house = nums[i] + last_two[0]\\n\\t\\t# if we dont\\n\\t\\tdont_rob_this_house = last_two[1]\\n\\t\\t# update the amt of money we could have gotten from the last two houses\\n\\t\\tlast_two = (last_two[1], max(rob_this_house, dont_rob_this_house))\\n\\t# return money after robbing all the houses\\n\\treturn last_two[1]\\n```\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! If you have any questions, please feel free to ask in the comments and I will try to answer them. Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# helper method to find the most money we can get for robbing the first n houses\\n\\tdef rob_n_houses(n):\\n\\t\\t# if there is only one house to rob\\n\\t\\tif n == 1:\\n\\t\\t\\t# rob it\\n\\t\\t\\treturn nums[0]\\n\\t\\t# if there are only two houses to rob\\n\\t\\tif n == 2: \\n\\t\\t\\t# rob the one with the most money\\n\\t\\t\\treturn max(nums[0], nums[1])\\n\\t\\t\\t\\n\\t\\t# otherwise we can either rob this house and not the previous one\\n\\t\\t# or we can not rob this house and rob any houses before it\\n\\n\\t\\t# if we rob this house (nums[-1]), we can\\'t rob nums[n-2], but we can rob any before that\\n\\t\\trob_this_house = nums[n-1] + rob_n_houses(n-2)\\n\\n\\t\\t# if we don\\'t rob nums[n-1], we can rob any house before it, meaning this is the same as rob_n_houses(n-1)\\n\\t\\tdont_rob_this_house = rob_n_houses(n-1)\\n\\t\\t# do whatever gets us the most money\\n\\t\\treturn max(rob_this_house, dont_rob_this_house)\\n\\t# originally we can rob any of the houses\\n\\treturn rob_n_houses(len(nums))\\n```\n```O(2^N)```\n```@cache```\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# helper method to find the most money we can get for robbing the first n houses\\n\\t@cache # store previous calls to this helper method\\n\\tdef rob_n_houses(n):\\n\\t\\t# if there is only one house to rob\\n\\t\\tif n == 1:\\n\\t\\t\\t# rob it\\n\\t\\t\\treturn nums[0]\\n\\t\\t# if there are only two houses to rob\\n\\t\\tif n == 2: \\n\\t\\t\\t# rob the one with the most money\\n\\t\\t\\treturn max(nums[0], nums[1])\\n\\t\\t# otherwise we can either rob this house and not the previous one\\n\\t\\t# or we can not rob this house and rob any houses before it\\n\\n\\t\\t# if we rob this house (nums[-1]), we can\\'t rob nums[n-2], but we can rob any before that\\n\\t\\trob_this_house = nums[n-1] + rob_n_houses(n-2)\\n\\n\\t\\t# if we don\\'t rob nums[n-1], we can rob any house before it, meaning this is the same as rob_n_houses(n-1)\\n\\t\\tdont_rob_this_house = rob_n_houses(n-1)\\n\\t\\t# do whatever gets us the most money\\n\\t\\treturn max(rob_this_house, dont_rob_this_house)\\n\\t# originally we can rob any of the houses\\n\\treturn rob_n_houses(len(nums))\\n```\n```O(N)```\n```1```\n```n```\n```O(N)```\n```rob_n_houses```\n```i```\n```rob_n_houses(i)```\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# we have 0 dollars after robbing no houses and nums[0] dollars after robbing the first house\\n\\trob_n_houses = [0, nums[0]]\\n\\t# go through the rest of the houses\\n\\tfor i in range(1, len(nums)):\\n\\t\\t# if we rob this house\\n\\t\\trob_this_house = nums[i] + rob_n_houses[-2]\\n\\t\\t# if we dont\\n\\t\\tdont_rob_this_house = rob_n_houses[-1]\\n\\t\\t# add the max amt of money at this point\\n\\t\\trob_n_houses.append(max(rob_this_house, dont_rob_this_house))\\n\\t# return money after robbing all the houses\\n\\treturn rob_n_houses[-1] \\n```\n```rob_n_houses```\n```rob_n_houses```\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# we have 0 dollars after robbing no houses and nums[0] dollars after robbing the first house\\n\\tlast_two = (0, nums[0])\\n\\t# go through the rest of the houses\\n\\tfor i in range(1, len(nums)):\\n\\t\\t# if we rob this house\\n\\t\\trob_this_house = nums[i] + last_two[0]\\n\\t\\t# if we dont\\n\\t\\tdont_rob_this_house = last_two[1]\\n\\t\\t# update the amt of money we could have gotten from the last two houses\\n\\t\\tlast_two = (last_two[1], max(rob_this_house, dont_rob_this_house))\\n\\t# return money after robbing all the houses\\n\\treturn last_two[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2399156,
                "title": "4-approaches-recursion-memoization-tabulation-space-optimization",
                "content": "**Logic :** \\n* If you observe carefully, then you can see that this is a decision making problem as on each step we have the choice of taking it (robbing that house) or not take it (not robbing that house). \\n\\n* If we take it then we add it to our sum and skip 1 house to move to the third one.. If we don\\'t take it then we move to the next house and don\\'t add anything to our sum/or add 0.\\n\\n* At every step, we calculate the maximum out of both the situations and move forward accordingly.\\n\\n**Approach 1 : Normal Recursion**\\n\\n```\\n       int solve(int i, vector<int>&nums){\\n        \\n        if(i==0){\\n            return nums[i];\\n        }    \\n        if(i<0){                         // prevents negative indexing for take case\\n            return 0;\\n        }\\n        \\n        int take = solve(i-2,nums)+nums[i];     //adding nums[i] and skipping 1 house\\n        int not_take = solve(i-1,nums)+0;       //adding 0 and moving to the next house\\n        \\n        return max(take,not_take);              // return max of both situations\\n    }\\n        \\n    int rob(vector<int>& nums) {\\n         return solve(nums.size()-1,nums);\\n    }\\n```\\n\\nTime : O(2^N)   \\nSpace : O(N)     --> Recursion stack space\\n\\n\\n**Approach 2 : Recursion -> Memoization**\\n\\n* We can see that there are many subproblems that are computed already and now are being recomputed like for f(5) we need f(4) and f(3) and then for f(4) we again need f(3) and f(2). So it is evident that we are recalculating a lot of stuff.\\n\\n* So, we are going to memoize it using a dp vector where we store the values which we calculate during recursion. If the value is stored in dp vector we will use it directly and won\\'t recalculate the same thing again, otherwise we will solve that subproblem and store its value in dp vector.\\n\\n```\\n       int solve(int i, vector<int>&nums,vector<int>&dp){\\n        \\n        if(i==0){\\n            return nums[i];\\n        }    \\n        if(i<0){\\n            return 0;\\n        }        \\n        \\n        if(dp[i]!=-1){           // if value is precalculated then use it\\n            return dp[i];\\n        }\\n        \\n        int take = solve(i-2,nums,dp)+nums[i];  // else calculate it \\n        int not_take = solve(i-1,nums,dp)+0;\\n        \\n        dp[i]=max(take,not_take);              // after calculation store it in dp vector to reuse it and prevent recalculation.\\n        return dp[i];\\n    }\\n        \\n    int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return solve(nums.size()-1,nums,dp);\\n    }\\n```\\n\\nSpace : O(N) for recursion and O(N) for Dp vector\\nTime : O(N)\\n\\n**Approach 3 : Tabulation**\\n\\n* We can see that we are taking an extra O(N) space for recursion. Let\\'s remove it by converting our top-down approach to an iterative bottom-up approach.\\n\\n```\\n        int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        \\n        dp[0]=nums[0];\\n\\n        for(int i = 1;i<nums.size();i++){\\n            if(i>1) dp[i] = max(dp[i-1],dp[i-2]+nums[i]); // taking the max of take and non take conditions\\n            else dp[i] = max(dp[i-1],nums[i]);      //bcs if i=1 , dp[i-2] won\\'t exist\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```\\n\\nTime : O(N)\\nSpace : O(N)\\n\\n**Approach 4 : Space optimized to O(1)**\\n\\n* If you observe the solution of approach 3 carefully, you will notice that at each step we require only dp[i-1] and dp[i-2] i.e. the previous 2 values of function.\\n\\n* We don\\'t need to maintain the whole dp vector .. we can just keep track of the last two values of the function to obtain the current value and keep modifying our three pointers.\\n\\n```\\n        int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        \\n        int prev = nums[0];\\n        int curr,prev2;\\n        \\n        for(int i = 1;i<nums.size();i++){\\n\\n           if(i>1) curr = max(prev,prev2+nums[i]);\\n            else curr = max(prev,nums[i]);\\n            prev2 = prev;\\n            prev = curr;   \\n        }\\n        return prev;\\n    }\\n```\\n\\nSpace : O(1)\\nTime : O(N)\\n\\n**P.S.**\\n1. Upvote if helpful",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n       int solve(int i, vector<int>&nums){\\n        \\n        if(i==0){\\n            return nums[i];\\n        }    \\n        if(i<0){                         // prevents negative indexing for take case\\n            return 0;\\n        }\\n        \\n        int take = solve(i-2,nums)+nums[i];     //adding nums[i] and skipping 1 house\\n        int not_take = solve(i-1,nums)+0;       //adding 0 and moving to the next house\\n        \\n        return max(take,not_take);              // return max of both situations\\n    }\\n        \\n    int rob(vector<int>& nums) {\\n         return solve(nums.size()-1,nums);\\n    }\\n```\n```\\n       int solve(int i, vector<int>&nums,vector<int>&dp){\\n        \\n        if(i==0){\\n            return nums[i];\\n        }    \\n        if(i<0){\\n            return 0;\\n        }        \\n        \\n        if(dp[i]!=-1){           // if value is precalculated then use it\\n            return dp[i];\\n        }\\n        \\n        int take = solve(i-2,nums,dp)+nums[i];  // else calculate it \\n        int not_take = solve(i-1,nums,dp)+0;\\n        \\n        dp[i]=max(take,not_take);              // after calculation store it in dp vector to reuse it and prevent recalculation.\\n        return dp[i];\\n    }\\n        \\n    int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return solve(nums.size()-1,nums,dp);\\n    }\\n```\n```\\n        int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        \\n        dp[0]=nums[0];\\n\\n        for(int i = 1;i<nums.size();i++){\\n            if(i>1) dp[i] = max(dp[i-1],dp[i-2]+nums[i]); // taking the max of take and non take conditions\\n            else dp[i] = max(dp[i-1],nums[i]);      //bcs if i=1 , dp[i-2] won\\'t exist\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```\n```\\n        int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        \\n        int prev = nums[0];\\n        int curr,prev2;\\n        \\n        for(int i = 1;i<nums.size();i++){\\n\\n           if(i>1) curr = max(prev,prev2+nums[i]);\\n            else curr = max(prev,nums[i]);\\n            prev2 = prev;\\n            prev = curr;   \\n        }\\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942309,
                "title": "python3-o-n-time-o-1-space-explained-with-code",
                "content": "Solution and description mainly based on the following:\\n1. [Answer by @GavinCode](https://leetcode.com/problems/house-robber/discuss/55938/DP-with-two-variables-Easiest-Solution-(I-think)-O(n))\\n2. [Answer by @cjhuo](https://leetcode.com/problems/house-robber/discuss/55977/Python-DP-solution-4-line-O(n)-time-O(1)-space-easy-to-understand-with-detailed-explanation)\\n3. [Answer by @huangclose](https://leetcode.com/problems/house-robber/discuss/55959/4-line-python.-O(1)-space-O(n)-time.-With-explaination.-Simplest)\\n\\nThis question honestly stumped me and I found a lot of the explanations didn\\'t help all too much, so I thought I\\'d try write my own explanation. I also tried to use longer more descriptive names on variables.\\n\\nYou can boil down this problem into a dynamic programming solution by considering the following.\\n\\nAt the first house, the maximum you can steal is whatever is in the first house\\n\\nAt the second house, since you can\\'t steal from 2 houses in a row you should take the max of:\\n* the money in the first house\\n* the money in the second house\\n\\nThen for any house past the second you must figure out what the maxium amount of money you can steal up until that house is.\\n\\nSo at house `i` past the second house there are two choices:\\n1. Rob house `i`:\\n\\t* In this case you cannot consider the max amount you can steal at house `i - 1` as if you do, you could rob 2 houses in a row and set off an alarm.\\n\\t* So you want to take whatever is in house `i` PLUS the max you can take from house `i - 2` so you don\\'t set off an alarm.\\n\\n2. Don\\'t rob house `i`:\\n\\t* In this case you want to take the max amount of money that you can steal at house `i - 1`.\\n\\t* This is because you are not stealing from house `i` and you\\'ve already figured out the maximum\\n\\t  you can take up until house `i - 1` previously, so you should take that...\\n\\nIn order to maximize your takings, you want to choose the case that will result in the most amount of money.\\nIE: the maximum between case 1 and case 2.\\n\\nAssuming you store the max amount possible at house `i` in an array called `max_possible_at_house`, the formula \\nfor choosing between case 1 and case 2 is:\\n\\n```python\\nmax(\\n\\tmax_possible_at_house[i - 2] + money_in_house_i,  # Case 1, rob the house\\n\\tmax_possible_at_house[i - 1] # Case 2, don\\'t rob the house\\n)\\n```\\n\\nUsing an array to store the maximums, you would initialize the first two entries as:\\n\\n```python\\nmax_possible_at_house[0] = nums[0] # value in the first house\\nmax_possible_at_house[1] = max(nums[0], nums[1]) # The maxium we could take between the first two houses\\n```\\n\\nThen your loop would start at index `2`, and each position is in the array is filled with the formula above.\\n\\nYou then return the last element in `max_possible_at_house` as it will be the maximum possible after considering all the houses.\\n\\n**But wait! There\\'s more!**\\n\\nWe can actually omit storing the maximums in a new array by realizing that at house `i`, you only need to know:\\n\\t- amount you can take from house `i`\\n\\t- max amount you can take up to house `i - 2`\\n\\t- max amount you can take up to house `i - 1`\\n\\nSo you do not need to store an array of all the possible maximums, instead you can use two variables.\\nOne to track `max_2_houses_ago`, ie: max at house `i-2`, and `max_last_house`, ie: max at house `i - 1`.\\n\\nWith that, here is the solution:\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n\\t\\n\\t\\t# On the first iteration we haven\\'t stolen anything because we haven\\'t seen two houses, \\n\\t\\t# so our maxes will be 0.\\n        max_2_houses_ago = max_last_house = 0\\n        \\n\\t\\tfor house_value in nums:\\n            # Python lets us do some really fancy swapping.\\n            # The following is equivalent to:\\n            # temp = max_2_houses_ago\\n            # max_2_houses_ago = max_last_house\\n            # max_last_house = max(temp + house_value, max_last_house)\\n\\t\\t\\t\\n            max_2_houses_ago, max_last_house = max_last_house, max(max_2_houses_ago + house_value, max_last_house)\\n            \\n        return max_last_house\\n```\\n\\nI hope this was helpful! I found this solution really hard to wrap my head around.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nmax(\\n\\tmax_possible_at_house[i - 2] + money_in_house_i,  # Case 1, rob the house\\n\\tmax_possible_at_house[i - 1] # Case 2, don\\'t rob the house\\n)\\n```\n```python\\nmax_possible_at_house[0] = nums[0] # value in the first house\\nmax_possible_at_house[1] = max(nums[0], nums[1]) # The maxium we could take between the first two houses\\n```\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n\\t\\n\\t\\t# On the first iteration we haven\\'t stolen anything because we haven\\'t seen two houses, \\n\\t\\t# so our maxes will be 0.\\n        max_2_houses_ago = max_last_house = 0\\n        \\n\\t\\tfor house_value in nums:\\n            # Python lets us do some really fancy swapping.\\n            # The following is equivalent to:\\n            # temp = max_2_houses_ago\\n            # max_2_houses_ago = max_last_house\\n            # max_last_house = max(temp + house_value, max_last_house)\\n\\t\\t\\t\\n            max_2_houses_ago, max_last_house = max_last_house, max(max_2_houses_ago + house_value, max_last_house)\\n            \\n        return max_last_house\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559247,
                "title": "python-3-dp-with-space-optimization-5-lines-beats-92-1",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev = 0\\n        curr = 0\\n        # every loop, calculate the maximum cumulative amount of money until current house\\n        for i in nums:\\n            # as the loop begins\\uFF0Ccurr represents dp[k-1]\\uFF0Cprev represents dp[k-2]\\n            # dp[k] = max{ dp[k-1], dp[k-2] + i }\\n            prev, curr = curr, max(curr, prev + i)\\n            # as the loop ends\\uFF0Ccurr represents dp[k]\\uFF0Cprev represents dp[k-1]\\n\\n        return curr\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev = 0\\n        curr = 0\\n        # every loop, calculate the maximum cumulative amount of money until current house\\n        for i in nums:\\n            # as the loop begins\\uFF0Ccurr represents dp[k-1]\\uFF0Cprev represents dp[k-2]\\n            # dp[k] = max{ dp[k-1], dp[k-2] + i }\\n            prev, curr = curr, max(curr, prev + i)\\n            # as the loop ends\\uFF0Ccurr represents dp[k]\\uFF0Cprev represents dp[k-1]\\n\\n        return curr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118575,
                "title": "dp-solution-for-fun",
                "content": "I\\'m still learning DP, got the idea from best time to buy or sell stocks. Basically the main idea is to decide whether or not to steal the current house or not. `dp[i]` represents the maximum value I have after leaving house `i`th house.\\n\\n`dp[i] = dp[i -1]` means I\\'m not stealing this house, my value is retained from last house.\\n`dp[i] = dp[i - 2] + nums[i]` means the sum of the stash in current house and 2 houses ago is more than what I got from last house. So stealing the current house will give me more value.\\n\\nStill in the process of learning DP in general, more than welcome to give me feedback to optimize the code. Thanks~\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums == null || nums.length < 1) return 0;\\n        if (nums.length < 2) return nums[0];\\n        int[] dp = new int[nums.length];\\n        \\n        dp[0] = nums[0];\\n        dp[1] = Math.max(dp[0], nums[1]);\\n        for (int i = 2; i < nums.length; i++) {\\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\\n        }\\n        return dp[nums.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums == null || nums.length < 1) return 0;\\n        if (nums.length < 2) return nums[0];\\n        int[] dp = new int[nums.length];\\n        \\n        dp[0] = nums[0];\\n        dp[1] = Math.max(dp[0], nums[1]);\\n        for (int i = 2; i < nums.length; i++) {\\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\\n        }\\n        return dp[nums.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55908,
                "title": "o-n-java-solution-using-dp",
                "content": "    public int rob(int[] nums) {\\n        int len = nums.length;\\n        if(len == 0) return 0;\\n        if(len == 1) return nums[0];\\n        int[] val = new int[len];\\n        val[0] = nums[0];\\n        val[1] = Math.max(nums[0], nums[1]);\\n        for(int i=2; i<len; i++)\\n            val[i] = Math.max(nums[i] + val[i-2], val[i-1]);\\n        return val[len-1];\\n    }\\n\\n**For each house, the maximum amount you can get is either the amount you get from two houses before this one plus the amount you get from this one, or the amount you get from the neighbor house before this one (so you can't get any from this one), whatever is larger.**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int rob(int[] nums) {\\n        int len = nums.length;\\n        if(len == 0) return 0;\\n        if(len == 1) return nums[0];\\n        int[] val = new int[len];\\n        val[0] = nums[0];\\n        val[1] = Math.max(nums[0], nums[1]);\\n        for(int i=2; i<len; i++)\\n            val[i] = Math.max(nums[i] + val[i-2], val[i-1]);\\n        return val[len-1];\\n    }\\n\\n**For each house, the maximum amount you can get is either the amount you get from two houses before this one plus the amount you get from this one, or the amount you get from the neighbor house before this one (so you can't get any from this one), whatever is larger.**",
                "codeTag": "Unknown"
            },
            {
                "id": 55990,
                "title": "dp-2ms-c-space-o-1-concise-with-explaination",
                "content": "**DP 2ms using C++, with/without memoization, concise solution with explaination**\\n\\nAssume we start from left to right, then here I use dp array to store i-th house's max money I can squeeze. The idea is that since we cannot get a quote from adjacent house, the dp[i-1] can only be compared to discard or replace current position's max money. E.g. :\\n\\nFor bonanzas like this:**5=10=13= 1 = 7 = 2**\\n\\nWill yield dp array like: **5=10=18=18=25=25**<------then return the last element.\\n\\nThe time complexity of DP straightforward version is O(n), space O(n).\\n\\n**DP straightforward:**\\n\\n    class Solution {\\n    public:\\n        int rob(vector<int> &A) {\\n            if(A.size()<=1)return A.empty()?0:A[0];\\n            vector<int> dp={A[0], max(A[1],A[0])};\\n            for(int i=2;i<A.size();i++)\\n                dp.push_back(max(A[i]+dp[i-2],dp[i-1]));\\n            return dp.back();\\n        }\\n    };\\n\\nThis solution costs me 2ms.\\n\\n\\n\\n\\nSince the dp array is only used with its newest two elements, we can reduce space using memoization. The idea is same with above solution except the dp array is replaced by int dp1, dp2. The time complexity is O(n), space O(1).\\n\\n**dp with memoization:**\\n\\n    class Solution {\\n    public:\\n        int rob(vector<int> &A) {\\n            if(A.size()<=1)return A.empty()?0:A[0];\\n            int dp1=A[0],dp2=max(A[1],A[0]);\\n            for(int i=2;i<A.size();i++){\\n                swap(dp1,dp2);\\n                dp2=max(A[i]+dp2,dp1);\\n            }\\n            return dp2;\\n        }\\n    };\\n\\nThis solution costs me 3ms.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int> &A) {\\n            if(A.size()<=1)return A.empty()?0:A[0];\\n            vector<int> dp={A[0], max(A[1],A[0])}",
                "codeTag": "Java"
            },
            {
                "id": 3385971,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& v) {\\n     \\n        int n=v.size();\\n           if(n==1)return v[0];\\n        int dp[n];\\n        dp[0]=v[0];\\n        dp[1]=max(v[0],v[1]);\\n        for(int i=2;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i]+dp[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/7efa2f9a-24cd-42a3-9cbc-29372b4b1421_1680774100.3589573.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& v) {\\n     \\n        int n=v.size();\\n           if(n==1)return v[0];\\n        int dp[n];\\n        dp[0]=v[0];\\n        dp[1]=max(v[0],v[1]);\\n        for(int i=2;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i]+dp[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909624,
                "title": "c-memoized-bottomup-sc-o-n-sc-o-1",
                "content": "**Memoized Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[105];\\n    int rec(int i, vector<int>&a) {\\n        if (i >= a.size()) {\\n            return 0;\\n        }\\n        if (dp[i] != -1) return dp[i];\\n        int op1 = rec(i + 1, a);\\n        int op2 = a[i] + rec(i + 2, a);\\n        return dp[i] = max(op1, op2);\\n    }\\n    int rob(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(0, nums);\\n    }\\n};\\n```\\n\\n**Bottom Up O(N) Space**\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = nums[0];  // base cases\\n        if (n == 1) return dp[0];\\n        dp[1] = max(nums[0] , nums[1]);  // base cases\\n\\n        for (int i = 2; i < n; i++) {\\n            dp[i] = max(dp[i - 1] , nums[i] + dp[i - 2]);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\n\\n**Bottom Up O(1) Space**\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        \\n        int prev2 = nums[0];     // dp[i-2]  base case\\n        int prev1 = max(nums[0] , nums[1]);    // dp[i-1]   it base case\\n        int curr = prev1;        // dp[i] \\n        \\n        for(int i=2;i<n;i++){\\n            curr = max(prev1 , nums[i] + prev2);   // dp[i] = max(dp[i-1] , nums[i] + dp[i-2])\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return curr;        // dp[n-1]\\n    }\\n};\\n```\\n\\n**All above solutions have TC O(N)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105];\\n    int rec(int i, vector<int>&a) {\\n        if (i >= a.size()) {\\n            return 0;\\n        }\\n        if (dp[i] != -1) return dp[i];\\n        int op1 = rec(i + 1, a);\\n        int op2 = a[i] + rec(i + 2, a);\\n        return dp[i] = max(op1, op2);\\n    }\\n    int rob(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = nums[0];  // base cases\\n        if (n == 1) return dp[0];\\n        dp[1] = max(nums[0] , nums[1]);  // base cases\\n\\n        for (int i = 2; i < n; i++) {\\n            dp[i] = max(dp[i - 1] , nums[i] + dp[i - 2]);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        \\n        int prev2 = nums[0];     // dp[i-2]  base case\\n        int prev1 = max(nums[0] , nums[1]);    // dp[i-1]   it base case\\n        int curr = prev1;        // dp[i] \\n        \\n        for(int i=2;i<n;i++){\\n            curr = max(prev1 , nums[i] + prev2);   // dp[i] = max(dp[i-1] , nums[i] + dp[i-2])\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return curr;        // dp[n-1]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909308,
                "title": "easiest-possible-dp-java",
                "content": "**EXPLANATION:**\\n\\nLet dp[i] == the max money we can get up until the i-th house. Then dp[i]=max(dp[i-1], nums[i]+dp[i-2]);\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        dp[0]=nums[0];\\n        for(int i=1; i<n; i++){\\n            if(i >= 2){\\n                dp[i]= Math.max(dp[i],Math.max(nums[i]+dp[i-2],dp[i-1]));\\n            }else{\\n                dp[i]=Math.max(nums[i],dp[i-1]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        dp[0]=nums[0];\\n        for(int i=1; i<n; i++){\\n            if(i >= 2){\\n                dp[i]= Math.max(dp[i],Math.max(nums[i]+dp[i-2],dp[i-1]));\\n            }else{\\n                dp[i]=Math.max(nums[i],dp[i-1]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139025,
                "title": "java-recursion-space-optimisation-faster-than-100",
                "content": "Let\\'s start. The flow will be:\\n* Recursion -> **T.C.: O(2^n), S.C.: O(1)**.\\n* Memoization -> **T.C.: O(N), S.C.: O(N) + O(N)**. (Auxillary Stack Space)\\n* Tabulation -> **T.C.: O(N), S.C.: O(N)**.\\n* Tabulation Space Optmisation -> **T.C.: O(N), S.C.: O(1)**.\\n\\nMost Important catch in the question:\\n\"**adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.**\"\\n\\nThis simply means **we cannot loot adjacent houses**, or simply saying **we can not access the adjacent elements from the array**.\\n\\nSo for every index `i` of the array, we can *either pick that element or not pick it*.\\n\\nOk. Let\\'s start coding.\\n\\n**Recursion:**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        return solve(nums, nums.length-1);\\n    }\\n    public int solve(int nums[], int ind){\\n        if(ind < 0)\\n            return 0;\\n        if(ind == 0)\\n            return nums[ind];\\n        int pick = nums[ind] + solve(nums, ind-2);\\n        int notPick = 0 + solve(nums, ind-1);\\n        return Math.max(pick, notPick);\\n    }\\n}\\n```\\n\\nNow let\\'s optmise this. We will just require 3 additonal steps:\\n1. Create a dp table of size of given array to store the pre-computed values and initialise it with -1.\\n2.  Check if the value at any index of the dp is modified, if modified return that without moving into recursion.\\n3.  Update the dp[i] value at the end of every recursion.\\n\\nThis step is called *memoisation*.\\n\\n**Memoisation:**\\n```\\nclass Solution {\\n    int dp[];\\n    public int rob(int[] nums) {\\n        dp = new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        return solve(nums, nums.length-1);\\n    }\\n    public int solve(int nums[], int ind){\\n        if(ind < 0)\\n            return 0;\\n        if(ind == 0)\\n            return nums[ind];\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int pick = nums[ind] + solve(nums, ind-2);\\n        int notPick = 0 + solve(nums, ind-1);\\n        return dp[ind] = Math.max(pick, notPick);\\n    }\\n}\\n```\\n\\nCan we optmise further ? Yes, we can. Let\\'s tabulate this. The only major change in this flow will be that we will be traversing the array from the start and not from the end.\\n\\n**Tabulation:**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int dp[] = new int[nums.length];\\n        dp[0] = nums[0]; // Base Condition 1\\n        int negativeIndexVal = 0; // Base Condition 2\\n        for(int i = 1; i < nums.length; i++){\\n            int pick = nums[i];\\n            if(i > 1)\\n                pick += dp[i-2];\\n            else pick += negativeIndexVal;\\n            int notPick = 0 + dp[i-1];\\n            dp[i] = Math.max(pick, notPick);\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```\\n\\nIf you carefully go through the iterations, you can see that we are only concerned about the `dp[nums.length-1]`, this means that the other values are useless. Then why unnecessarily use the extra space to store them. Let\\'s get rid of this. \\n\\nWe will do this by using variables to store the values at our `i-1` and `i-2` indexes.\\n\\n**Space Optmisation:**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int prev1 = nums[0];  // For value at i-1 index\\n\\t\\tint prev2 = 0; // For value at i-2 index\\n        for(int i = 1; i<nums.length; i++){\\n            int pick = nums[i] + prev2;\\n            int notPick = 0 + prev1;\\n            int curr = Math.max(pick, notPick);\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return prev1;\\n    }\\n}\\n```\\n\\nIsn\\'t it simple, short and sweet? \\uD83E\\uDD0C \\uD83E\\uDEE0 \\n\\nP.S.: Please upvote if you like it. \\uD83D\\uDC9C",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        return solve(nums, nums.length-1);\\n    }\\n    public int solve(int nums[], int ind){\\n        if(ind < 0)\\n            return 0;\\n        if(ind == 0)\\n            return nums[ind];\\n        int pick = nums[ind] + solve(nums, ind-2);\\n        int notPick = 0 + solve(nums, ind-1);\\n        return Math.max(pick, notPick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int dp[];\\n    public int rob(int[] nums) {\\n        dp = new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        return solve(nums, nums.length-1);\\n    }\\n    public int solve(int nums[], int ind){\\n        if(ind < 0)\\n            return 0;\\n        if(ind == 0)\\n            return nums[ind];\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int pick = nums[ind] + solve(nums, ind-2);\\n        int notPick = 0 + solve(nums, ind-1);\\n        return dp[ind] = Math.max(pick, notPick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int dp[] = new int[nums.length];\\n        dp[0] = nums[0]; // Base Condition 1\\n        int negativeIndexVal = 0; // Base Condition 2\\n        for(int i = 1; i < nums.length; i++){\\n            int pick = nums[i];\\n            if(i > 1)\\n                pick += dp[i-2];\\n            else pick += negativeIndexVal;\\n            int notPick = 0 + dp[i-1];\\n            dp[i] = Math.max(pick, notPick);\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int prev1 = nums[0];  // For value at i-1 index\\n\\t\\tint prev2 = 0; // For value at i-2 index\\n        for(int i = 1; i<nums.length; i++){\\n            int pick = nums[i] + prev2;\\n            int notPick = 0 + prev1;\\n            int curr = Math.max(pick, notPick);\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846461,
                "title": "the-art-of-dynamic-programming",
                "content": "**Synopsis:**\\n\\n`\\uD83C\\uDFA8 ` [The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Optimize Memory, ie. sliding window `a, b, c = dp[i + 2], dp[i + 1], dp[i]`\\n\\n---\\n\\n**All Possibilities:**\\n\\nThere are two use cases to consider for each current house:\\n\\n* **Case 1:** `\\u2705 take` (ie. rob) the current house\\n* **Case 2:**  `\\uD83D\\uDEAB skip` (ie. don\\'t rob) the current house\\n\\n---\\n\\n**Top-Down Details:**\\n\\nIf we rob the `i`<sup>th</sup> house, then we cannot rob the `i + 1`<sup>th</sup> house, thus the next candidate house to rob is the `i + 2`<sup>th</sup> house.  However, if we do *not* rob the `i`<sup>th</sup> house, then the next candidate house to rob is the `i + 1`<sup>th</sup> house.\\n\\n**Recursive Formulas:**\\n\\n* `\\u2705 take` (ie. rob) the current house:\\n\\t* `go(i + 2) + A[i]`\\n* `\\uD83D\\uDEAB skip` (ie. don\\'t rob) the current house:\\n\\t* `go(i + 1)`\\n\\n---\\n\\n**Bottom-Up Details:**\\n\\nThe bottom-up solutions simply mimic the top-down solution\\'s recursive stack unwinding.  Let `N` be the cardinality of `A` and let `i` denote the current `i`<sup>th</sup> house.  Since the top-down recursive stack \"bottoms-out\" at the base case when `i == N` or `i == N + 1`, thus we begin filling in the bottom-up solution from the right-most position `N - 1`.  This means we need to append two zeros onto the DP maxtrix to store the base cases when `i == N` and `i == N + 1` correspondingly.\\n\\n**Iterative Formulas:**\\n\\n* `\\u2705 take` (ie. rob) the current house:\\n\\t* `dp[i + 2] + A[i]`\\n* `\\uD83D\\uDEAB skip` (ie. don\\'t rob) the current house:\\n\\t* `dp[i + 1]`\\n\\n**Optimize Memory:**\\n\\n`a, b, c = dp[i + 2], dp[i + 1], dp[i]`\\n\\nThis problem essentially is as simple as `a, b, c`.  Since each `dp[i]` calculation is only dependent upon the previous two solutions, ie. `dp[i + 1]` and `dp[i + 2]`, we can reduce memory consumption from O(N) to O(1) via a sliding window of size 3: `a, b, c`.  Each time the window \"slides\", `a` \"drops off\" the window to make `c` available for the next computation via `a`, `b`.  In summary, `a` represents the optimal solution \"two-away\" from `c`, thus, when we choose `\\u2705` with `A[i]`, we add the value of `A[i]` onto the optimal solution \"two-away\" from `c`, which is `a`.  Otherwise when we choose `\\uD83D\\uDEAB` without `A[i]`, we use the optimal solution \"one-away\" from `c`, which is `b`.  Cheers!  \\uD83C\\uDF7A\\n\\n---\\n\\n**Kotlin Solutions**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        fun go(i: Int = 0): Int {\\n            if (N <= i)\\n                return 0\\n            var take = go(i + 2) + A[i]\\n            var skip = go(i + 1)\\n            return Math.max(take, skip)\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = 0): Int {\\n            if (N <= i)\\n                return 0\\n            if (!m.contains(i)) {\\n                var take = go(i + 2) + A[i]\\n                var skip = go(i + 1)\\n                m[i] = Math.max(take, skip)\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var dp = IntArray(N + 2) { 0 }\\n        for (i in N - 1 downTo 0) {\\n            var take = dp[i + 2] + A[i]\\n            var skip = dp[i + 1]\\n            dp[i] = Math.max(take, skip)\\n        }\\n        return dp[0]\\n    }\\n}\\n```\\n\\n4. Optimize Memory, ie. sliding window a, b, c = dp[i + 2], dp[i + 1], dp[i]\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var (a, b, c) = listOf(0, 0, 0)\\n        for (i in N - 1 downTo 0) {\\n            var take = a + A[i]\\n            var skip = b\\n            c = Math.max(take, skip)\\n            a = b; b = c\\n        }\\n        return c\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let go = (i = 0) => {\\n        if (N <= i)\\n            return 0;\\n        let take = go(i + 2) + A[i],\\n            skip = go(i + 1);\\n        return Math.max(take, skip);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n```\\nlet rob = (A, m = new Map()) => {\\n    let N = A.length;\\n    let go = (i = 0) => {\\n        if (N <= i)\\n            return 0;\\n        if (!m.has(i)) {\\n            let take = go(i + 2) + A[i],\\n                skip = go(i + 1);\\n            m.set(i, Math.max(take, skip));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let dp = Array(N + 2).fill(0);\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let take = dp[i + 2] + A[i],\\n            skip = dp[i + 1];\\n        dp[i] = Math.max(take, skip);\\n    }\\n    return dp[0];\\n};\\n```\\n\\n4. Optimize Memory, ie. sliding window a, b, c = dp[i + 2], dp[i + 1], dp[i]\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let [a, b, c] = [0, 0, 0];\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let take = a + A[i],\\n            skip = b;\\n        c = Math.max(take, skip);\\n        a = b, b = c;\\n    }\\n    return c;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        def go(i = 0):\\n            if N <= i:\\n                return 0\\n            take = go(i + 2) + A[i]\\n            skip = go(i + 1)\\n            return max(take, skip)\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0):\\n            if N <= i:\\n                return 0\\n            take = go(i + 2) + A[i]\\n            skip = go(i + 1)\\n            return max(take, skip)\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [0] * (N + 2)\\n        for i in range(N - 1, -1, -1):\\n            take = dp[i + 2] + A[i]\\n            skip = dp[i + 1]\\n            dp[i] = max(take, skip)\\n        return dp[0]\\n```\\n\\n4. Optimize Memory, ie. sliding window a, b, c = dp[i + 2], dp[i + 1], dp[i]\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        a, b, c = 0, 0, 0\\n        for i in range(N - 1, -1, -1):\\n            take = a + A[i]\\n            skip = b\\n            c = max(take, skip)\\n            a = b; b = c\\n        return c\\n```\\n\\n---\\n\\n**C++ Solutions**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i) {\\n            if (N <= i)\\n                return 0;\\n            auto take = go(i + 2) + A[i],\\n                 skip = go(i + 1);\\n            return max(take, skip);\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int rob(VI& A, Map m = {}) {\\n        int N = A.size();\\n        fun go = [&](auto i) {\\n            if (N <= i)\\n                return 0;\\n            if (m.find(i) == m.end()) {\\n                auto take = go(i + 2) + A[i],\\n                     skip = go(i + 1);\\n                m[i] = max(take, skip);\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        VI dp(N + 2);\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto take = dp[i + 2] + A[i],\\n                 skip = dp[i + 1];\\n            dp[i] = max(take, skip);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\n4. Optimize Memory, ie. sliding window a, b, c = dp[i + 2], dp[i + 1], dp[i]\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        auto [a, b, c] = make_tuple(0, 0, 0);\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto take = a + A[i],\\n                 skip = b;\\n            c = max(take, skip);\\n            a = b, b = c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        fun go(i: Int = 0): Int {\\n            if (N <= i)\\n                return 0\\n            var take = go(i + 2) + A[i]\\n            var skip = go(i + 1)\\n            return Math.max(take, skip)\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = 0): Int {\\n            if (N <= i)\\n                return 0\\n            if (!m.contains(i)) {\\n                var take = go(i + 2) + A[i]\\n                var skip = go(i + 1)\\n                m[i] = Math.max(take, skip)\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var dp = IntArray(N + 2) { 0 }\\n        for (i in N - 1 downTo 0) {\\n            var take = dp[i + 2] + A[i]\\n            var skip = dp[i + 1]\\n            dp[i] = Math.max(take, skip)\\n        }\\n        return dp[0]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var (a, b, c) = listOf(0, 0, 0)\\n        for (i in N - 1 downTo 0) {\\n            var take = a + A[i]\\n            var skip = b\\n            c = Math.max(take, skip)\\n            a = b; b = c\\n        }\\n        return c\\n    }\\n}\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let go = (i = 0) => {\\n        if (N <= i)\\n            return 0;\\n        let take = go(i + 2) + A[i],\\n            skip = go(i + 1);\\n        return Math.max(take, skip);\\n    };\\n    return go();\\n};\\n```\n```\\nlet rob = (A, m = new Map()) => {\\n    let N = A.length;\\n    let go = (i = 0) => {\\n        if (N <= i)\\n            return 0;\\n        if (!m.has(i)) {\\n            let take = go(i + 2) + A[i],\\n                skip = go(i + 1);\\n            m.set(i, Math.max(take, skip));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let dp = Array(N + 2).fill(0);\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let take = dp[i + 2] + A[i],\\n            skip = dp[i + 1];\\n        dp[i] = Math.max(take, skip);\\n    }\\n    return dp[0];\\n};\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let [a, b, c] = [0, 0, 0];\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let take = a + A[i],\\n            skip = b;\\n        c = Math.max(take, skip);\\n        a = b, b = c;\\n    }\\n    return c;\\n};\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        def go(i = 0):\\n            if N <= i:\\n                return 0\\n            take = go(i + 2) + A[i]\\n            skip = go(i + 1)\\n            return max(take, skip)\\n        return go()\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0):\\n            if N <= i:\\n                return 0\\n            take = go(i + 2) + A[i]\\n            skip = go(i + 1)\\n            return max(take, skip)\\n        return go()\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [0] * (N + 2)\\n        for i in range(N - 1, -1, -1):\\n            take = dp[i + 2] + A[i]\\n            skip = dp[i + 1]\\n            dp[i] = max(take, skip)\\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        a, b, c = 0, 0, 0\\n        for i in range(N - 1, -1, -1):\\n            take = a + A[i]\\n            skip = b\\n            c = max(take, skip)\\n            a = b; b = c\\n        return c\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i) {\\n            if (N <= i)\\n                return 0;\\n            auto take = go(i + 2) + A[i],\\n                 skip = go(i + 1);\\n            return max(take, skip);\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int rob(VI& A, Map m = {}) {\\n        int N = A.size();\\n        fun go = [&](auto i) {\\n            if (N <= i)\\n                return 0;\\n            if (m.find(i) == m.end()) {\\n                auto take = go(i + 2) + A[i],\\n                     skip = go(i + 1);\\n                m[i] = max(take, skip);\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        VI dp(N + 2);\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto take = dp[i + 2] + A[i],\\n                 skip = dp[i + 1];\\n            dp[i] = max(take, skip);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        auto [a, b, c] = make_tuple(0, 0, 0);\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto take = a + A[i],\\n                 skip = b;\\n            c = max(take, skip);\\n            a = b, b = c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55859,
                "title": "0ms-java-solution-using-dp-o-n-time-with-explanation",
                "content": "let sum[i] be the maximum amount of money when robber comes at i, he can either rob it or not depending on the money robbed at i-1 and i-2.\\n\\ncorner case: sum[0] = num[0], sum[1] = max(num[0],num[1])\\n\\ngenerally, at position i, sum[i] = max(sum[i-1], sum[i-2]+num[i])\\n\\n    public int rob(int[] nums) {\\n        int size = nums.length;\\n        if(size == 0) return 0;\\n        int[] sum = new int[size];\\n        sum[0] = nums[0];\\n        if(size == 1) return sum[0];\\n        sum[1] = Math.max(sum[0],nums[1]);\\n        if(size == 2) return sum[1];\\n        for(int i = 2;i<size;i++){\\n            sum[i] = Math.max(sum[i-1], sum[i-2]+nums[i]);\\n        }\\n        return sum[size-1];\\n    }\\n\\nAnother approach is to use two variables to store sum[i-1] and sum[i-2] iteratively in the previous program. This approach avoids building an array to store all of the sums, which only uses O(1) space.\\n\\n    public int rob(int[] nums) {\\n        int size = nums.length;\\n        if(size == 0) return 0;\\n        if(size == 1) return nums[0];\\n        if(size == 2) return Math.max(nums[0],nums[1]);\\n        int minusOne = Math.max(nums[0],nums[1]), minusTwo = nums[0], sum = minusOne;\\n        for(int i = 2;i<size;i++){\\n            sum = Math.max(minusOne, minusTwo+nums[i]);\\n            minusTwo = minusOne;\\n            minusOne = sum;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "let sum[i] be the maximum amount of money when robber comes at i, he can either rob it or not depending on the money robbed at i-1 and i-2.\\n\\ncorner case: sum[0] = num[0], sum[1] = max(num[0],num[1])\\n\\ngenerally, at position i, sum[i] = max(sum[i-1], sum[i-2]+num[i])\\n\\n    public int rob(int[] nums) {\\n        int size = nums.length;\\n        if(size == 0) return 0;\\n        int[] sum = new int[size];\\n        sum[0] = nums[0];\\n        if(size == 1) return sum[0];\\n        sum[1] = Math.max(sum[0],nums[1]);\\n        if(size == 2) return sum[1];\\n        for(int i = 2;i<size;i++){\\n            sum[i] = Math.max(sum[i-1], sum[i-2]+nums[i]);\\n        }\\n        return sum[size-1];\\n    }\\n\\nAnother approach is to use two variables to store sum[i-1] and sum[i-2] iteratively in the previous program. This approach avoids building an array to store all of the sums, which only uses O(1) space.\\n\\n    public int rob(int[] nums) {\\n        int size = nums.length;\\n        if(size == 0) return 0;\\n        if(size == 1) return nums[0];\\n        if(size == 2) return Math.max(nums[0],nums[1]);\\n        int minusOne = Math.max(nums[0],nums[1]), minusTwo = nums[0], sum = minusOne;\\n        for(int i = 2;i<size;i++){\\n            sum = Math.max(minusOne, minusTwo+nums[i]);\\n            minusTwo = minusOne;\\n            minusOne = sum;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55902,
                "title": "simple-java-5-line-solution-o-n-time-o-1-space",
                "content": "    if(num.length==0) return 0;\\n    if(num.length==1) return num[0];\\n    num[1] = Math.max(num[0], num[1]);\\n    for(int i=2;i<num.length;i++) num[i] = Math.max(num[i]+num[i-2], num[i-1]);\\n    return num[num.length-1];",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    if(num.length==0) return 0;\\n    if(num.length==1) return num[0];\\n    num[1] = Math.max(num[0], num[1]);\\n    for(int i=2;i<num.length;i++) num[i] = Math.max(num[i]+num[i-2], num[i-1]);\\n    return num[num.length-1];",
                "codeTag": "Unknown"
            },
            {
                "id": 3218951,
                "title": "198-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We first check if the input array nums is empty. If it is, we return 0, since we cannot rob any houses.\\n2. We then check if the length of nums is 1. If it is, we can only rob the single house, so we return the value of that house.\\n3. We create a list dp of the same length as nums, initialized to 0.\\n4. We set dp[0] to the value of the first house, since we can only rob that house if there is only one house.\\n5. We set dp[1] to the maximum of the first two houses, since we can only rob one of them.\\n6. We loop over the rest of the houses in nums, starting from the third house (index 2), and for each house, we calculate the maximum amount we can rob up to that house, by choosing whether to rob the current house or the previous house. We use the formula dp[i] = max(dp[i-1], dp[i-2] + nums[i]) to calculate this value.\\n7. Finally, we return the last value in dp, which represents the maximum amount we can rob from all the houses.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\\n        \\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\\n        \\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909869,
                "title": "python-bottom-up",
                "content": "# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        prev2 = nums[0]\\n        moneyRobbed = prev1 = max(nums[0], nums[1])\\n\\n        for i in range(2, len(nums)):\\n            moneyRobbed = max(prev1, prev2+nums[i])\\n\\n            prev2 = prev1\\n            prev1 = moneyRobbed\\n\\n        return moneyRobbed\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        prev2 = nums[0]\\n        moneyRobbed = prev1 = max(nums[0], nums[1])\\n\\n        for i in range(2, len(nums)):\\n            moneyRobbed = max(prev1, prev2+nums[i])\\n\\n            prev2 = prev1\\n            prev1 = moneyRobbed\\n\\n        return moneyRobbed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909848,
                "title": "c-short-and-fast-o-n-o-1",
                "content": "# Intuition\\n- We start by assuming that we have robbed the first house. (prev = nums[0])\\n- Hence we can\\'t pick the just next element. \\n- If we robb the house which is 2nd to the the current index ( if(i>1) non-adjacent). We have to add that money. \\n- And if we do not pick the house to robb. We are left with 1st house money. \\n- Lastly we take the max of both the conditions. And update the variables for further computations. \\n\\n# Approach\\n- We start using pick and Not pick method. \\n\\n# Complexity\\n- Time complexity: O(N) Single Pass \\n- Space complexity: O(1) No extra Space \\n\\n# Code\\n```\\n    int rob( vector<int>& nums ) {\\n        int n = nums.size();\\n        \\n        int prev = nums[0];\\n        int prev2 = 0;\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            \\n            int pick = nums[i];\\n            if( i>1 ) pick += prev2 ;\\n\\n            int notPick = prev ;  \\n\\n            int curr = max( pick, notPick );\\n            prev2 = prev ;\\n            prev = curr ;\\n        }\\n\\n        return prev ;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int rob( vector<int>& nums ) {\\n        int n = nums.size();\\n        \\n        int prev = nums[0];\\n        int prev2 = 0;\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            \\n            int pick = nums[i];\\n            if( i>1 ) pick += prev2 ;\\n\\n            int notPick = prev ;  \\n\\n            int curr = max( pick, notPick );\\n            prev2 = prev ;\\n            prev = curr ;\\n        }\\n\\n        return prev ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2909820,
                "title": "c-4-approaches-easy-to-understand",
                "content": "# Code\\n\\n**Approach 1: (Recursion : TLE)**\\n```\\nclass Solution {\\npublic:\\n    int find(int idx,vector<int>& nums)\\n    {\\n        if(idx==0) return nums[0];                // if i am on last then take that\\n\\n        int not_pick = 0 + find(idx-1,nums);   // not robbing curr house so can rob adjacency house\\n        int pick = nums[idx];\\n        if(idx-2 >= 0)\\n        {\\n            pick += find(idx-2,nums);          // robbing curr house so can not rob adjacency house\\n        }\\n\\n        return max(pick,not_pick);               // take max from both\\n    }\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        return find(n-1,nums,dp);\\n    }\\n};\\n# Complexity\\n# Time complexity : O(2^N) (recursion)\\n\\n# Space complexity : O(N) (recursion auxiliary space)\\n```\\n\\nApproach 2: (Memoization)\\n```\\nclass Solution {\\npublic:\\n    int find(int idx,vector<int>& nums,vector<int>& dp)\\n    {\\n        if(idx==0) return nums[0];\\n        if(dp[idx] != -1) return dp[idx];\\n\\n        int not_pick = 0 + find(idx-1,nums,dp);\\n        int pick = nums[idx];\\n        if(idx-2 >= 0)\\n        {\\n            pick += find(idx-2,nums,dp);\\n        }\\n\\n        return dp[idx] = max(pick,not_pick);\\n    }\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        return find(n-1,nums,dp);\\n    }\\n};\\n\\n# Complexity\\n# Time complexity : O(N) (recursion)\\n\\n# Space complexity : O(N) + O(N) (recursion auxiliary space)\\n``` \\n\\n\\nApproach 3: (Tabulation : Accepted)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\n        vector<int> dp(n,0);\\n        dp[0] = nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int not_pick = 0 + dp[i-1];\\n            int pick = nums[i];\\n            if(i-2 >= 0)\\n            {\\n                pick += dp[i-2];\\n            }\\n\\n            dp[i] = max(pick,not_pick);\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n# Complexity\\n# Time complexity : O(N)\\n\\n# Space complexity : O(N)\\n```\\n\\nApproach 4: (Space Optimization)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\n        int prev1 = nums[0];\\n        int prev2 = 0;\\n\\n        int curr;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int not_pick = 0 + prev1;\\n            int pick = nums[i];\\n            if(i-2 >= 0)\\n            {\\n                pick += prev2;\\n            }\\n            curr = max(pick,not_pick);\\n\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n\\n        return prev1;\\n    }\\n};\\n# Complexity\\n# Time complexity : O(N)\\n\\n# Space complexity : O(1)\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int idx,vector<int>& nums)\\n    {\\n        if(idx==0) return nums[0];                // if i am on last then take that\\n\\n        int not_pick = 0 + find(idx-1,nums);   // not robbing curr house so can rob adjacency house\\n        int pick = nums[idx];\\n        if(idx-2 >= 0)\\n        {\\n            pick += find(idx-2,nums);          // robbing curr house so can not rob adjacency house\\n        }\\n\\n        return max(pick,not_pick);               // take max from both\\n    }\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        return find(n-1,nums,dp);\\n    }\\n};\\n# Complexity\\n# Time complexity : O(2^N) (recursion)\\n\\n# Space complexity : O(N) (recursion auxiliary space)\\n```\n```\\nclass Solution {\\npublic:\\n    int find(int idx,vector<int>& nums,vector<int>& dp)\\n    {\\n        if(idx==0) return nums[0];\\n        if(dp[idx] != -1) return dp[idx];\\n\\n        int not_pick = 0 + find(idx-1,nums,dp);\\n        int pick = nums[idx];\\n        if(idx-2 >= 0)\\n        {\\n            pick += find(idx-2,nums,dp);\\n        }\\n\\n        return dp[idx] = max(pick,not_pick);\\n    }\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        return find(n-1,nums,dp);\\n    }\\n};\\n\\n# Complexity\\n# Time complexity : O(N) (recursion)\\n\\n# Space complexity : O(N) + O(N) (recursion auxiliary space)\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\n        vector<int> dp(n,0);\\n        dp[0] = nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int not_pick = 0 + dp[i-1];\\n            int pick = nums[i];\\n            if(i-2 >= 0)\\n            {\\n                pick += dp[i-2];\\n            }\\n\\n            dp[i] = max(pick,not_pick);\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n# Complexity\\n# Time complexity : O(N)\\n\\n# Space complexity : O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\n        int prev1 = nums[0];\\n        int prev2 = 0;\\n\\n        int curr;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int not_pick = 0 + prev1;\\n            int pick = nums[i];\\n            if(i-2 >= 0)\\n            {\\n                pick += prev2;\\n            }\\n            curr = max(pick,not_pick);\\n\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n\\n        return prev1;\\n    }\\n};\\n# Complexity\\n# Time complexity : O(N)\\n\\n# Space complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909756,
                "title": "java-memoization-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Memoization, inspired by 0/1 knapsack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake element at index i or skip it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nimport java.lang.*;\\nclass Solution {\\n\\n    public int helper(int[] nums, int i,HashMap<Integer,Integer> memo){\\n        if(memo.containsKey(i)){\\n            return memo.get(i);\\n        }\\n        if(i >= nums.length){\\n            return 0;\\n        }\\n        int notTake = 0;\\n        int take= nums[i]+helper(nums,i+2,memo);\\n        if (i < nums.length-1)    \\n            notTake = nums[i+1]+helper(nums,i+3,memo);\\n        memo.put(i,Math.max(take,notTake));\\n        return memo.get(i);\\n    }\\n    public int rob(int[] nums) {\\n        return helper(nums,0, new HashMap<Integer,Integer>());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.lang.*;\\nclass Solution {\\n\\n    public int helper(int[] nums, int i,HashMap<Integer,Integer> memo){\\n        if(memo.containsKey(i)){\\n            return memo.get(i);\\n        }\\n        if(i >= nums.length){\\n            return 0;\\n        }\\n        int notTake = 0;\\n        int take= nums[i]+helper(nums,i+2,memo);\\n        if (i < nums.length-1)    \\n            notTake = nums[i+1]+helper(nums,i+3,memo);\\n        memo.put(i,Math.max(take,notTake));\\n        return memo.get(i);\\n    }\\n    public int rob(int[] nums) {\\n        return helper(nums,0, new HashMap<Integer,Integer>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909722,
                "title": "c-simple-dp-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[1000] = {0};\\n\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        dp[0] = nums[0];\\n        if(n == 1)return nums[0];\\n        dp[1] = max(nums[1],nums[0]);\\n        for(int i = 2; i < n; i++)\\n        {\\n            dp[i] = max(dp[i-1],nums[i]+dp[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[1000] = {0};\\n\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        dp[0] = nums[0];\\n        if(n == 1)return nums[0];\\n        dp[1] = max(nums[1],nums[0]);\\n        for(int i = 2; i < n; i++)\\n        {\\n            dp[i] = max(dp[i-1],nums[i]+dp[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909274,
                "title": "java-0ms-100-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[1],nums[0]);\\n        for(int i = 2 ; i < nums.length ; i++){\\n            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[1],nums[0]);\\n        for(int i = 2 ; i < nums.length ; i++){\\n            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995444,
                "title": "c-dp-memoization-tabulation-space-optimization-o-1-space",
                "content": "**Approach 01 : Memoization/Top-Down DP (aka Recursive DP)**\\n\\nIdea : In every state of DP we have only two choice , eighter we will include current element in our result (with under the condition)  or we will skip the current (for be more banifited)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int now , vector<int>& nums, vector<int>& DP){\\n        if(now >= nums.size()){\\n            return 0;\\n        }\\n        int &ret = DP[now];\\n        if(ret != -1) return ret;\\n        \\n        int w1 = 0, w2 = 0;\\n        w1 = solve(now+1, nums, DP);\\n        w2 = nums[now] + solve(now+2, nums, DP); \\n        return ret = max(w1, w2);;\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int>DP(N, -1);\\n        \\n        int result = solve(0, nums, DP);\\n        return result;\\n    }\\n};\\n```\\n\\nTime Complexity : **O(N)**\\nSpace Complexity : **O(N)** for iterate all of the N item + **O(N)** space also required for Recursion stack Memory\\nso Total Space will be : **O(N)+O(N) ~ O(N)**.\\n\\n\\n**Approach 02 : Tabulation/ Buttom-Up DP (aka Iterative DP)**\\n\\nIdea : Idea is as simple as approach 01.\\n\\n**Code : **\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        \\n        if(N==0) return 0;\\n        if(N==1) return nums[0];\\n        \\n        vector<int>DP(N);\\n        DP[0] = nums[0];\\n        DP[1] = max(nums[0], nums[1]);\\n        \\n        for(int i=2; i<N; i++){\\n            DP[i] = max(DP[i-1], nums[i]+ DP[i-2]);\\n        }\\n        return DP[N-1];\\n    }\\n};\\n```\\n\\nTime Complexity : **O(N)** \\nSpace Complexity : **O(N)** , we omitted our recursion stack memory here :)\\n\\n**Approach 03: Space Optimization of Approach 02.**\\n\\nIdea : In approach 02 , we clearly see that we need only last two value for compute the current state. so we don\\'t need to store all previous state\\'s value at all. Here we will store only **previous** and **secondPrevious** value for compute the **current state**.\\n\\n**Code : **\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        if(N==1) return nums[0];\\n        \\n        int prev = nums[0], secondPrev = 0, current;\\n        \\n        for(int i=1; i<N; i++){\\n            \\n            current = nums[i] + secondPrev;\\n            current = max(current, prev);\\n            \\n            secondPrev = prev;\\n            prev = current;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n\\nTime Complexity : **O(N)** , to comute every state of DP.\\nSpace Complexity : **O(1)**, we use only constant space here.\\n\\n\\nThanks for Reading....\\nHappy learning :)\\nPlease Upvote if helpful :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int now , vector<int>& nums, vector<int>& DP){\\n        if(now >= nums.size()){\\n            return 0;\\n        }\\n        int &ret = DP[now];\\n        if(ret != -1) return ret;\\n        \\n        int w1 = 0, w2 = 0;\\n        w1 = solve(now+1, nums, DP);\\n        w2 = nums[now] + solve(now+2, nums, DP); \\n        return ret = max(w1, w2);;\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int>DP(N, -1);\\n        \\n        int result = solve(0, nums, DP);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        \\n        if(N==0) return 0;\\n        if(N==1) return nums[0];\\n        \\n        vector<int>DP(N);\\n        DP[0] = nums[0];\\n        DP[1] = max(nums[0], nums[1]);\\n        \\n        for(int i=2; i<N; i++){\\n            DP[i] = max(DP[i-1], nums[i]+ DP[i-2]);\\n        }\\n        return DP[N-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        if(N==1) return nums[0];\\n        \\n        int prev = nums[0], secondPrev = 0, current;\\n        \\n        for(int i=1; i<N; i++){\\n            \\n            current = nums[i] + secondPrev;\\n            current = max(current, prev);\\n            \\n            secondPrev = prev;\\n            prev = current;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791061,
                "title": "python-3-50ms-3-lines-dp-formula",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        last, now = 0, 0\\n        for i in nums: last, now = now, max(last + i, now)\\n        return now\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        last, now = 0, 0\\n        for i in nums: last, now = now, max(last + i, now)\\n        return now\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354469,
                "title": "dp-using-memoization-easy-understanding",
                "content": "class Solution {\\n    public int rob(int[] nums) {\\n        int[] dp = new int[nums.length+1];\\n        Arrays.fill(dp, -1);\\n        int res = houseRob(nums, 0, nums.length, dp);\\n        return(res);\\n    }\\n    \\n    public static int houseRob(int[] nums, int curr, int n, int[] dp){\\n        if(curr >= n){ \\n            return 0;\\n        }\\n        if(dp[curr] != -1) return dp[curr];\\n        \\n        // First time calculation\\n        int rob = nums[curr] + houseRob(nums, curr+2, n, dp);\\n        int doNot = houseRob(nums, curr+1, n, dp);\\n        \\n        return dp[curr] = Math.max(rob, doNot);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        int[] dp = new int[nums.length+1];\\n        Arrays.fill(dp, -1);\\n        int res = houseRob(nums, 0, nums.length, dp);\\n        return(res);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 835280,
                "title": "python-solution-good-explanation",
                "content": "We build dp[]. Suppose we are at the first house on the block, what is the most money we can make by being here? Well we can rob this house and make that much money, so dp[0] = nums[0]. Suppose we are at the second house on the block, what is the most money we can make by being here? Well we can either rob the first house and not rob the second or we can rob the second and not rob the first. We choose whichever makes us more money, so dp[1] = max(nums[0], nums[1]). Now suppose you are at the ith house, what is the most money we can make by being here? There are 2 cases. **Case 1:** If we rob the ith house that means we could not have robbed the i - 1th house because they are adjacent, so we could make dp[i - 2] + nums[i]. **Case 2:** If we dont rob the ith house then we should have robbed the i - 1th. I hope this helped someone.\\n```\\ndef rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        if len(nums) == 2:\\n            return max(nums[0], nums[1])\\n\\t\\tdp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])\\n        return dp[len(nums) - 1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        if len(nums) == 2:\\n            return max(nums[0], nums[1])\\n\\t\\tdp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])\\n        return dp[len(nums) - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 824923,
                "title": "javascript-solution-198",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nlet rob = function(nums) {\\n    let previous = 0;\\n    let current = 0;\\n    let temp; \\n    for (let x of nums) {\\n        temp = current; \\n        current = Math.max(x+previous, current);\\n        previous = temp;\\n    }\\n    return current;\\n}\\n```\\n**Runtime: 68 ms, faster than 90.14% of JavaScript online submissions for House Robber.**\\n**Memory Usage: 36.9 MB, less than 16.04% of JavaScript online submissions for House Robber.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nlet rob = function(nums) {\\n    let previous = 0;\\n    let current = 0;\\n    let temp; \\n    for (let x of nums) {\\n        temp = current; \\n        current = Math.max(x+previous, current);\\n        previous = temp;\\n    }\\n    return current;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488741,
                "title": "python-3-dp-recursion-93-100-tutorial-url-included",
                "content": "First time trying DP after 20 min Youtube learning and it\\'s interesting!\\nIf you are not familiar with DP, these videos are really helpful:\\nhttps://www.youtube.com/watch?v=vYquumk4nWw\\nhttps://www.youtube.com/watch?v=xOlhR_2QCXY\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:  \\n        n = len(nums)\\n        if not n:\\n            return 0        \\n        memo = [None] * n\\n        \\n        def steal(n):\\n            if memo[n] != None:\\n                return memo[n]\\n            if n == 0:\\n                result = nums[0]\\n            elif n == 1:\\n                result = max(nums[0], nums[1])\\n            else:\\n                result = max(steal(n-1),  nums[n] + steal(n-2))\\n            memo[n] = result\\n            return result\\n\\t\\t\\t\\n        return steal(n-1)\\n```\\n\\nThe bottom-up scheme has the same intuition thus also works.\\nHope these video help you. :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:  \\n        n = len(nums)\\n        if not n:\\n            return 0        \\n        memo = [None] * n\\n        \\n        def steal(n):\\n            if memo[n] != None:\\n                return memo[n]\\n            if n == 0:\\n                result = nums[0]\\n            elif n == 1:\\n                result = max(nums[0], nums[1])\\n            else:\\n                result = max(steal(n-1),  nums[n] + steal(n-2))\\n            memo[n] = result\\n            return result\\n\\t\\t\\t\\n        return steal(n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55675,
                "title": "96-5-python-sol",
                "content": "``` class Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = len(nums)\\n        if count == 0:\\n            return 0\\n        elif count == 1:\\n            return nums[0]\\n        elif count == 2: \\n            return max(nums[0], nums[1])\\n        \\n        memo = nums[:] # copy\\n        memo[1] = max(nums[0], nums[1])\\n        \\n        for i in range(2, count):\\n            memo[i] = max(memo[i-1], nums[i] + memo[i-2]) \\n        \\n        return memo[count-1] ```",
                "solutionTags": [],
                "code": "``` class Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = len(nums)\\n        if count == 0:\\n            return 0\\n        elif count == 1:\\n            return nums[0]\\n        elif count == 2: \\n            return max(nums[0], nums[1])\\n        \\n        memo = nums[:] # copy\\n        memo[1] = max(nums[0], nums[1])\\n        \\n        for i in range(2, count):\\n            memo[i] = max(memo[i-1], nums[i] + memo[i-2]) \\n        \\n        return memo[count-1] ```",
                "codeTag": "Java"
            },
            {
                "id": 55687,
                "title": "python-easy-to-understand-solution",
                "content": "dp[i] contains max amount that robber can take from house i \\nAt each index, we check for the max amount from 0 to index - 1, since we can't take the adjacent house's money\\nand we add the current amount to the max amount\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums: return 0\\n        \\n        dp = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                dp[i] = nums[i] + max(dp[:i-1])\\n            else:\\n                dp[i] = nums[i]\\n        return max(dp)\\n```\\nO(n) time and space complexity",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums: return 0\\n        \\n        dp = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                dp[i] = nums[i] + max(dp[:i-1])\\n            else:\\n                dp[i] = nums[i]\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55906,
                "title": "easy-to-understand-python-solutions-dynamic-programming",
                "content": "        \\n    # O(n) space\\n    def rob1(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) <= 2:\\n            return max(nums)\\n        res = [0] * len(nums)\\n        res[0], res[1] = nums[0], max(nums[0], nums[1])\\n        for i in xrange(2, len(nums)):\\n            res[i] = max(nums[i]+res[i-2], res[i-1])\\n        return res[-1]\\n    \\n    def rob2(self, nums):\\n        if not nums:\\n            return 0\\n        res = [0] * len(nums)\\n        for i in xrange(len(nums)):\\n            if i == 0:\\n                res[0] = nums[0]\\n            elif i == 1:\\n                res[1] = max(nums[0], nums[1])\\n            else:\\n                res[i] = max(nums[i]+res[i-2], res[i-1])\\n        return res[-1]\\n      \\n    # Constant space  \\n    def rob(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) <= 2:\\n            return max(nums)\\n        a, b = nums[0], max(nums[0], nums[1])\\n        for i in xrange(2, len(nums)):\\n            tmp = b\\n            b = max(nums[i]+a, b)\\n            a = tmp\\n        return b",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # O(n) space\\n    def rob1(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) <= 2:\\n            return max(nums)\\n        res = [0] * len(nums)\\n        res[0], res[1] = nums[0], max(nums[0], nums[1])\\n        for i in xrange(2, len(nums)):\\n            res[i] = max(nums[i]+res[i-2], res[i-1])\\n        return res[-1]\\n    \\n    def rob2(self, nums):\\n        if not nums:\\n            return 0\\n        res = [0] * len(nums)\\n        for i in xrange(len(nums)):\\n            if i == 0:\\n                res[0] = nums[0]\\n            elif i == 1:\\n                res[1] = max(nums[0], nums[1])\\n            else:\\n                res[i] = max(nums[i]+res[i-2], res[i-1])\\n        return res[-1]\\n      \\n    # Constant space  \\n    def rob(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) <= 2:\\n            return max(nums)\\n        a, b = nums[0], max(nums[0], nums[1])\\n        for i in xrange(2, len(nums)):\\n            tmp = b\\n            b = max(nums[i]+a, b)\\n            a = tmp\\n        return b",
                "codeTag": "Python3"
            },
            {
                "id": 55936,
                "title": "java-house-robber-solution",
                "content": "public class Solution {\\n\\n    public int rob(int[] nums) {\\n\\n       if(nums == null || nums.length == 0){\\n           return 0;\\n       }\\n\\n       if(nums.length == 1){\\n           return nums[0];\\n       }\\n\\n       if(nums.length == 2){\\n           return Math.max(nums[0], nums[1]);\\n       }\\n       \\n       \\n       int[] dp = new int[nums.length];\\n       dp[0] = nums[0];\\n       dp[1] = Math.max(nums[0], nums[1]);\\n       \\n       for(int i = 2; i < dp.length; i++){\\n           dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\\n       }\\n       \\n       return dp[dp.length - 1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int rob(int[] nums) {\\n\\n       if(nums == null || nums.length == 0){\\n           return 0;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 55937,
                "title": "0-ms-c-solution",
                "content": "    int rob(vector<int>& nums) {\\n    \\tint len=nums.size();\\n    \\tif(0==len) \\n    \\t\\treturn 0;\\n    \\tvector<int> bag;\\n    \\tif(len>0)  \\n    \\t\\tbag.push_back(nums[0]);\\n    \\tif(len>1) \\n    \\t\\tbag.push_back(max(nums[0],nums[1]));\\n    \\tfor(int i=2;i<len;++i)\\n    \\t\\tbag.push_back(max(bag[i-1],nums[i]+bag[i-2]));\\n    \\treturn bag[len-1];\\n    }",
                "solutionTags": [],
                "code": "    int rob(vector<int>& nums) {\\n    \\tint len=nums.size();\\n    \\tif(0==len) \\n    \\t\\treturn 0;\\n    \\tvector<int> bag;\\n    \\tif(len>0)  \\n    \\t\\tbag.push_back(nums[0]);\\n    \\tif(len>1) \\n    \\t\\tbag.push_back(max(nums[0],nums[1]));\\n    \\tfor(int i=2;i<len;++i)\\n    \\t\\tbag.push_back(max(bag[i-1],nums[i]+bag[i-2]));\\n    \\treturn bag[len-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3940935,
                "title": "putta-easy-solution-c-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> dp(n+1,0);\\n    for(int i = 1;i<n+1;i++){\\n        if (i >1)\\n        dp[i] = max(nums[i-1] + dp[i-2] ,dp[i-1]);\\n        else \\n        dp[i] = max(nums[i-1]  ,dp[i-1]);\\n\\n    }  \\n    return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> dp(n+1,0);\\n    for(int i = 1;i<n+1;i++){\\n        if (i >1)\\n        dp[i] = max(nums[i-1] + dp[i-2] ,dp[i-1]);\\n        else \\n        dp[i] = max(nums[i-1]  ,dp[i-1]);\\n\\n    }  \\n    return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372812,
                "title": "easy-clear-python-3-solution-recursive-memo-top-down",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        memo=[-1 for _ in range(len(nums))]\\n        def dp(i):\\n            if i<0:\\n                return 0 \\n            elif memo[i]>=0:\\n                return  memo[i]\\n            else:\\n                res=max(dp(i-2)+nums[i],dp(i-1))\\n                memo[i]=res\\n                return res\\n        return dp(len(nums)-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        memo=[-1 for _ in range(len(nums))]\\n        def dp(i):\\n            if i<0:\\n                return 0 \\n            elif memo[i]>=0:\\n                return  memo[i]\\n            else:\\n                res=max(dp(i-2)+nums[i],dp(i-1))\\n                memo[i]=res\\n                return res\\n        return dp(len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911051,
                "title": "concise-and-readable-no-additional-space",
                "content": "```csharp\\npublic class Solution\\n{\\n    public int Rob(int[] nums)\\n    {\\n        int max = nums[0];\\n        int s = 0;\\n\\n        foreach (int n in nums[1..])\\n        {\\n            (max, s) = (Math.Max(n + s, max), max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int Rob(int[] nums)\\n    {\\n        int max = nums[0];\\n        int s = 0;\\n\\n        foreach (int n in nums[1..])\\n        {\\n            (max, s) = (Math.Max(n + s, max), max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909291,
                "title": "100-recursive-easy",
                "content": "# Approach\\nRecursive solve using memorisation, if we have  computed already return if not for any i compute recursively.\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int dp[100] = {0};\\npublic:\\n    Solution(){\\n        for (int i=0 ; i < 100; i++) dp[i] = -1;\\n    }\\n    int rob(vector<int>& nums, int i=0) {\\n        if ( i >= nums.size()) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n\\n        return dp[i] = max(nums[i] + rob(nums,i+2), rob(nums,i+1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n    int dp[100] = {0};\\npublic:\\n    Solution(){\\n        for (int i=0 ; i < 100; i++) dp[i] = -1;\\n    }\\n    int rob(vector<int>& nums, int i=0) {\\n        if ( i >= nums.size()) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n\\n        return dp[i] = max(nums[i] + rob(nums,i+2), rob(nums,i+1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909246,
                "title": "c-dp-no-edge-cases-constant-memory-linear-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe solve the following subproblem: What is the optimal sum we can get up to some index?\\n\\nThis is trivial for the first element.\\nAfter that we take the maximum of either the value plus its second last element or just the last element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe save the maxima for the last and second last elements and iterate over the array.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - We iterate once over the whole array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$ - We only save the results of the last two iterations.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef int32_t i32;\\n\\n\\ninline i32\\nmaximum(i32 x, i32 y)\\n{\\n    return x > y ? x : y;\\n}\\n\\n\\ni32\\nrob(i32 *numbers, size_t numbersLength)\\n{\\n    i32 prePredecessor  = 0;\\n    i32 predecessor     = 0;\\n    i32 current         = 0;\\n\\n    for (size_t index = 0; index < numbersLength; index += 1)\\n    {\\n        prePredecessor  = predecessor;\\n        predecessor     = current;\\n        current         = maximum(prePredecessor + numbers[index], predecessor);\\n    }\\n    \\n    return current;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef int32_t i32;\\n\\n\\ninline i32\\nmaximum(i32 x, i32 y)\\n{\\n    return x > y ? x : y;\\n}\\n\\n\\ni32\\nrob(i32 *numbers, size_t numbersLength)\\n{\\n    i32 prePredecessor  = 0;\\n    i32 predecessor     = 0;\\n    i32 current         = 0;\\n\\n    for (size_t index = 0; index < numbersLength; index += 1)\\n    {\\n        prePredecessor  = predecessor;\\n        predecessor     = current;\\n        current         = maximum(prePredecessor + numbers[index], predecessor);\\n    }\\n    \\n    return current;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2909087,
                "title": "daily-leetcoding-challenge-december-day-14",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2806976,
                "title": "house-robber-solution-recursion-memoization-tabulation",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        //1.Recursion\\n        //return help(nums.length-1,nums);\\n        \\n        //2.Memoization - Top-down DP\\n        // int[] dp = new int[nums.length];\\n        // for(int i=0; i<dp.length; i++)\\n        // {\\n        //     dp[i] = -1;\\n        // }\\n        // return Memo(nums.length-1,nums,dp);\\n        \\n        //3.Tabulation - Bottom-Up Dp\\n        return DP(nums,nums.length);\\n    }\\n    \\n    int help(int index,int[] nums){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n           \\n        int include = help(index-2,nums) + nums[index];\\n        int exclude= help(index-1,nums);\\n        \\n        return Math.max(include,exclude);\\n    }\\n    int Memo(int index,int[] nums, int dp[]){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n           \\n        int include = Memo(index-2,nums,dp) + nums[index];\\n        int exclude= Memo(index-1,nums,dp);\\n        \\n        return dp[index]=Math.max(include,exclude);\\n    }\\n    int DP(int[] nums, int n){\\n        int dp[] = new int[n];\\n\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            int include = nums[i];\\n            if(i>1){\\n               include = include + dp[i-2];\\n            }  \\n            int exclude = dp[i-1];\\n            dp[i] = Math.max(include,exclude);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        //1.Recursion\\n        //return help(nums.length-1,nums);\\n        \\n        //2.Memoization - Top-down DP\\n        // int[] dp = new int[nums.length];\\n        // for(int i=0; i<dp.length; i++)\\n        // {\\n        //     dp[i] = -1;\\n        // }\\n        // return Memo(nums.length-1,nums,dp);\\n        \\n        //3.Tabulation - Bottom-Up Dp\\n        return DP(nums,nums.length);\\n    }\\n    \\n    int help(int index,int[] nums){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n           \\n        int include = help(index-2,nums) + nums[index];\\n        int exclude= help(index-1,nums);\\n        \\n        return Math.max(include,exclude);\\n    }\\n    int Memo(int index,int[] nums, int dp[]){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n           \\n        int include = Memo(index-2,nums,dp) + nums[index];\\n        int exclude= Memo(index-1,nums,dp);\\n        \\n        return dp[index]=Math.max(include,exclude);\\n    }\\n    int DP(int[] nums, int n){\\n        int dp[] = new int[n];\\n\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            int include = nums[i];\\n            if(i>1){\\n               include = include + dp[i-2];\\n            }  \\n            int exclude = dp[i-1];\\n            dp[i] = Math.max(include,exclude);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596573,
                "title": "o-n-time-o-1-space-clean-dp-solution-with-explanation",
                "content": "H1 H2 H3 H4\\n**99** \\n**99** 98\\n**99** 98 **60**\\n**99** 98 60 **100**\\n\\nScenario with 1 house and 2 houses can be decided. For 3 houses scenario, your choices are \\nwhat you would choose with 1 house plus current house OR what you would choose with 2 houses.\\nLikewise, with 4 houses, your choices are what you would choose in 2 houses scenario plus the current house OR just what you would choose with 3 houses.\\nTherefor with N houses, your choices are f(n - 2) + Nth house OR f(n-1).\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length == 1)\\n            return nums[0];\\n        if (nums.length == 2)\\n            return Math.max(nums[0], nums[1]);\\n        \\n        int maxSum = 0;\\n        int scheme1 = nums[0];\\n        int scheme2 = Math.max(nums[0], nums[1]);\\n        \\n        for (int i = 2; i < nums.length; i++){\\n            maxSum = Math.max(scheme1 + nums[i], scheme2);\\n            scheme1 = scheme2;\\n            scheme2 = maxSum;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n\\nThe above is for better understanding, the code can be further cleaned up to:\\n```\\n    public int rob(int[] nums) {\\n        if (nums.length == 0)\\n            return 0;\\n        \\n        int scheme1 = 0; //f(n-2)\\n        int scheme2 = 0; //f(n-1)\\n        \\n        for (int i = 0; i < nums.length; i++){\\n            int preScheme = scheme2;\\n            scheme2 = Math.max(scheme1 + nums[i], scheme2);\\n            scheme1 = preScheme;\\n        }\\n        \\n        return scheme2;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length == 1)\\n            return nums[0];\\n        if (nums.length == 2)\\n            return Math.max(nums[0], nums[1]);\\n        \\n        int maxSum = 0;\\n        int scheme1 = nums[0];\\n        int scheme2 = Math.max(nums[0], nums[1]);\\n        \\n        for (int i = 2; i < nums.length; i++){\\n            maxSum = Math.max(scheme1 + nums[i], scheme2);\\n            scheme1 = scheme2;\\n            scheme2 = maxSum;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\n```\\n    public int rob(int[] nums) {\\n        if (nums.length == 0)\\n            return 0;\\n        \\n        int scheme1 = 0; //f(n-2)\\n        int scheme2 = 0; //f(n-1)\\n        \\n        for (int i = 0; i < nums.length; i++){\\n            int preScheme = scheme2;\\n            scheme2 = Math.max(scheme1 + nums[i], scheme2);\\n            scheme1 = preScheme;\\n        }\\n        \\n        return scheme2;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2429533,
                "title": "rust-one-liner-with-comments",
                "content": "Imagine we are standing at house `i`. We can rob the house, but then we can\\'t rob the house before it, so the maximum total we can have is the maximum total we can have at house `i-2`, plus what we get at house `i`. Or we can keep whatever we can get up to house `i-1`, and avoid robbing house `i`. The base case is that without any houses, there is no money to rob, so the initial state for the DP is (0,0).\\n\\nI use `into_iter` to take ownership of nums and iterate over the numbers directly, and not complicate things with references. Then a fold to propagate the state according to the logic above.\\n\\n```\\nimpl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        nums.into_iter().fold((0, 0), |(pp, p), curr| (p, p.max(curr + pp))).1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        nums.into_iter().fold((0, 0), |(pp, p), curr| (p, p.max(curr + pp))).1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764927,
                "title": "java-4-solutions-recursion-memoization-tabulation-space-optimized-tabulation",
                "content": "```\\n// Method 1-\\n//     Recurion\\n//     TC - O(2^n)\\n//     SC - O(n)\\n    \\nclass Solution {\\n    public int rob(int[] nums) {\\n        return getMaximumSum(nums.length-1,nums);\\n    }\\n    public int getMaximumSum(int index,int [] nums)\\n    {\\n        if(index==0)return nums[index];\\n        if(index<0)return 0;\\n        int pick=nums[index]+ getMaximumSum(index-2,nums);\\n        int notPick=getMaximumSum(index-1,nums);\\n        return Math.max(pick,notPick);\\n    }\\n        \\n}\\n// Method 2 -\\n//     Using Memoization\\n//     TC - O(n)\\n//     SC - O(n)+O(n)\\n    \\nclass Solution {\\n    public int rob(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        return getMaximumSum(nums.length-1,nums,dp);\\n    }\\n    public int getMaximumSum(int index,int [] nums,int []dp)\\n    {\\n        if(index==0)return nums[index];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        int pick=nums[index]+ getMaximumSum(index-2,nums,dp);\\n        int notPick=getMaximumSum(index-1,nums,dp);\\n        dp[index]=Math.max(pick,notPick);\\n        return dp[index];\\n    }\\n        \\n}\\n\\n// Method 3-\\n//     Using Tabulation\\n//     SC - O(n)\\n//     TC -O(n)\\n    \\nclass Solution {\\n    public int rob(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int pick=nums[i];\\n            if(i>1)pick+=dp[i-2];\\n            int notPick=dp[i-1];\\n            dp[i]=Math.max(pick,notPick);\\n        }\\n        return dp[nums.length-1];\\n\\n   }\\n        \\n}\\n\\n// Method 4 -\\n//     Optimized Tabulation\\n//     TC - O(n)\\n//     SC -O(1)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int prev=nums[0];\\n        int secPrev=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int pick=nums[i]+secPrev;\\n            int notPick=prev;\\n            int curr=Math.max(pick,notPick);\\n            secPrev=prev;\\n            prev=curr;\\n        }\\n        return prev;\\n\\n   }\\n        \\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        return getMaximumSum(nums.length-1,nums);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1621030,
                "title": "java-recursion-recursion-memoization-optimized-solution",
                "content": "Before starting we need to consider two situations or we will be having two choices\\n**1) If an element is selected then the next element cannot be selected.\\n2) if an element is not selected then the next element can be selected.**\\n\\nRecursive Solution\\n\\n```\\nclass Solution {\\n    int solve(int[] nums,int l)\\n    {\\n        if(l>=nums.length)\\n            return 0;\\n        \\n        return Math.max(nums[l]+solve(nums,l+2),solve(nums,l+1));\\n    }\\n    public int rob(int[] nums) {\\n        \\n        return solve(nums,0);\\n    }\\n}\\n\\n```\\n\\nRecursive Solution leads to Time Limit error when large input is provided, because it recursively calculate amount which leads to repeatition.\\n\\nRecursive solution can further be optimized using memoization using an integer array, if solution at any point is already calculated it return the amount as it is.\\n\\n```\\nclass Solution {\\n    int[] dp;\\n    int solve(int[] nums,int l)\\n    {\\n        if(l>=nums.length)\\n            return 0;\\n        if(dp[l] != -1)\\n            return dp[l];\\n        \\n        return dp[l] = Math.max(nums[l]+solve(nums,l+2),solve(nums,l+1));\\n    }\\n    public int rob(int[] nums) {\\n        \\n        dp = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            dp[i] = -1;\\n        }\\n        \\n        return solve(nums,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int[] nums,int l)\\n    {\\n        if(l>=nums.length)\\n            return 0;\\n        \\n        return Math.max(nums[l]+solve(nums,l+2),solve(nums,l+1));\\n    }\\n    public int rob(int[] nums) {\\n        \\n        return solve(nums,0);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    int[] dp;\\n    int solve(int[] nums,int l)\\n    {\\n        if(l>=nums.length)\\n            return 0;\\n        if(dp[l] != -1)\\n            return dp[l];\\n        \\n        return dp[l] = Math.max(nums[l]+solve(nums,l+2),solve(nums,l+1));\\n    }\\n    public int rob(int[] nums) {\\n        \\n        dp = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            dp[i] = -1;\\n        }\\n        \\n        return solve(nums,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446375,
                "title": "brute-better-optimal-thought-process-matters",
                "content": "## Everyone will give solution, only few will give their thought process.\\n# [**My DSA-EndGame Link**](https://github.com/heyimvikash/DSA-EndGame)\\n# [**198. House Robber**](https://leetcode.com/problems/house-robber/)\\n# Thought Process :-\\n## 1. Think Recurrsively\\nA robber has 2 options: \\n- a) rob current house.\\n- b) don\\'t rob current house.\\n1. If Option A is selected then after robbing current house he will move ahead by 2 position.\\n2. If Option B is selected then he will move ahead by 1 position.\\n## Base Case : when N<1 then ANS is Zero\\n```java\\nint rob(int arr[],int n){\\n    if(n<1) return 0;\\n    return Math.max(arr[n-1]+rob(arr,n-2),rob(arr,n-1));\\n}\\n```\\n## 2. Optimise reccursive code using memonization\\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return rob(nums,n,dp);\\n    }\\n    int rob(int arr[],int n, int dp[]){\\n        if(n<1) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=Math.max(arr[n-1]+rob(arr,n-2,dp),rob(arr,n-1,dp));\\n    }\\n}\\n```\\n**Here TC - O(N) and SC - O(N) and Stack Space - O(N)**\\n## 3. Optimise Memonised code using tabulation\\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n+1];\\n        // intialise \\n        dp[0]=0; dp[1]=nums[0];\\n        for(int i=2;i<=n;i++){ // here i signifies n\\n           dp[i]=Math.max(nums[i-1]+dp[i-2],dp[i-1]); \\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n**Here TC - O(N) and SC - O(N)**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nint rob(int arr[],int n){\\n    if(n<1) return 0;\\n    return Math.max(arr[n-1]+rob(arr,n-2),rob(arr,n-1));\\n}\\n```\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return rob(nums,n,dp);\\n    }\\n    int rob(int arr[],int n, int dp[]){\\n        if(n<1) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=Math.max(arr[n-1]+rob(arr,n-2,dp),rob(arr,n-1,dp));\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n+1];\\n        // intialise \\n        dp[0]=0; dp[1]=nums[0];\\n        for(int i=2;i<=n;i++){ // here i signifies n\\n           dp[i]=Math.max(nums[i-1]+dp[i-2],dp[i-1]); \\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257348,
                "title": "c-recursive-top-down-bottom-up",
                "content": "**Solution 1 : Recursive Approach - O(2^n)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums, int curr) {\\n        if (curr >= nums.size()) {\\n            return 0;\\n        }\\n        \\n        int rob = nums[curr] + getMoney(nums, curr + 2);\\n        int dontRob = getMoney(nums, curr + 1);\\n        \\n        return max(rob, dontRob);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int maxMoney = getMoney(nums, 0);\\n        return maxMoney;\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 2 : Top Down DP**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums, int curr, vector <int> dp) {\\n        if (curr >= nums.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[curr] == 0) {\\n        \\n            int rob = nums[curr] + getMoney(nums, curr + 2, dp);\\n            int dontRob = getMoney(nums, curr + 1, dp);\\n\\n            dp[curr] = max(rob, dontRob);\\n        }\\n        \\n        return dp[curr];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        vector <int> dp(nums.size(), 0);\\n        int maxMoney = getMoney(nums, 0, dp);\\n        return maxMoney;\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 3 : Bottom Up DP - O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums) {\\n        vector <int> dp(nums.size(), 0);\\n        dp[0] = nums[0];      \\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (i == 1) {\\n                dp[i] = max(nums[i], nums[i - 1]);  \\n            } else {\\n                dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]);\\n            }\\n        }\\n        \\n        return dp[nums.size() - 1];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int maxMoney = getMoney(nums);\\n        return maxMoney;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums, int curr) {\\n        if (curr >= nums.size()) {\\n            return 0;\\n        }\\n        \\n        int rob = nums[curr] + getMoney(nums, curr + 2);\\n        int dontRob = getMoney(nums, curr + 1);\\n        \\n        return max(rob, dontRob);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int maxMoney = getMoney(nums, 0);\\n        return maxMoney;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums, int curr, vector <int> dp) {\\n        if (curr >= nums.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[curr] == 0) {\\n        \\n            int rob = nums[curr] + getMoney(nums, curr + 2, dp);\\n            int dontRob = getMoney(nums, curr + 1, dp);\\n\\n            dp[curr] = max(rob, dontRob);\\n        }\\n        \\n        return dp[curr];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        vector <int> dp(nums.size(), 0);\\n        int maxMoney = getMoney(nums, 0, dp);\\n        return maxMoney;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums) {\\n        vector <int> dp(nums.size(), 0);\\n        dp[0] = nums[0];      \\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (i == 1) {\\n                dp[i] = max(nums[i], nums[i - 1]);  \\n            } else {\\n                dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]);\\n            }\\n        }\\n        \\n        return dp[nums.size() - 1];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int maxMoney = getMoney(nums);\\n        return maxMoney;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216607,
                "title": "intuitive-python-solution-dp",
                "content": "The robber can rob only choose the maximum of previous maximum nums but not adjacent ones. So take the max of i-2 and i-3.\\n\\n```\\nclass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) <= 2:\\n\\t\\t\\treturn max(nums)\\n\\t\\tnums[2] = nums[0] + nums[2]\\n\\t\\tfor i in range(3, len(nums)):\\n\\t\\t\\tnums[i] = nums[i] + max(nums[i-2], nums[i-3])\\n\\t\\treturn max(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) <= 2:\\n\\t\\t\\treturn max(nums)\\n\\t\\tnums[2] = nums[0] + nums[2]\\n\\t\\tfor i in range(3, len(nums)):\\n\\t\\t\\tnums[i] = nums[i] + max(nums[i-2], nums[i-3])\\n\\t\\treturn max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855457,
                "title": "python-dp-solution-in-o-n-time",
                "content": "This is textbook example of a DP problem. The basic idea is we want to define our objective function, transition function, and build our base cases. \\n\\nFor this particular problem: \\n* Objective function: F(i) is the maximum number of money stolen given seeing i homes.\\n* Transition function f(i) = max(f(i-1) , f(i - 2) + nums[i])\\n* Base Cases: f(0) = 0 , f(1) = nums[0]\\n\\nExplanation:\\nThe objective function defines the optimal substructure at the ith position which is usually given by the problem statement.\\n\\nThe transition function is saying given the ith position how can we generate the next optimal substructure.\\nIn our case, there are two possibilities: We stole from the i - 1 th home so we don\\'t steal from the ith home to prevent triggering the security system. Or we didn\\'t steal from the i - 1th home so we can steal from the ith home. We have f(i) = max( f(i - 1),f(i - 2) + nums[i])\\n\\nThe base cases: There are two account for the two possibilities at each subproblem. So we have the case where there are no homes to steal from and the case where there is only one home to steal from on the street. (That\\'s one big home! must be a mansion)\\n\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0]\\n        if len(nums) == 0:\\n            return dp[0]\\n        dp.append(nums[0])\\n        for i in range(2,len(nums) + 1):\\n            dp.append(max(dp[i - 1],dp[i - 2] + nums[i - 1]))\\n        return dp[len(dp) - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0]\\n        if len(nums) == 0:\\n            return dp[0]\\n        dp.append(nums[0])\\n        for i in range(2,len(nums) + 1):\\n            dp.append(max(dp[i - 1],dp[i - 2] + nums[i - 1]))\\n        return dp[len(dp) - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529228,
                "title": "python-dp",
                "content": "\"\"\"\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \"\"\"\\n          Constraints:\\n            Cannot rob adjacant houses\\n            \\n          Goal:\\n            Find max you can rob in the neighborhood\\n          \\n          Lets build the problem up from most money of money you can rob in each index\\n          \\n          \\n          [4,1,1,4]\\n          \\n          \\n          [4]\\n          [4, 4]       \\n          [4, 4, 5]  dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\\n          [4, 4, 5, 8]\\n          \\n          \\n          If I choose to rob this house take the max of profit from the houses two to the left\\n          If I choose to not rob then take the max of the house one to the left\\n\\n\\n        \"\"\"\\n\\n        if nums is None or len(nums) == 0:\\n          return 0\\n        if len(nums) == 1:\\n          return nums[0]\\n    \\n      \\n        dp = [nums[0], max(nums[0], nums[1])]\\n        \\n        for i in range(2, len(nums)):\\n          dp.append(max(dp[i -2] + nums[i], dp[i - 1]))\\n        \\n        return dp[-1]\\n\\t\\t\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \"\"\"\\n          Constraints:\\n            Cannot rob adjacant houses\\n            \\n          Goal:\\n            Find max you can rob in the neighborhood\\n          \\n          Lets build the problem up from most money of money you can rob in each index\\n          \\n          \\n          [4,1,1,4]\\n          \\n          \\n          [4]\\n          [4, 4]       \\n          [4, 4, 5]  dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\\n          [4, 4, 5, 8]\\n          \\n          \\n          If I choose to rob this house take the max of profit from the houses two to the left\\n          If I choose to not rob then take the max of the house one to the left\\n\\n\\n        \"\"\"\\n\\n        if nums is None or len(nums) == 0:\\n          return 0\\n        if len(nums) == 1:\\n          return nums[0]\\n    \\n      \\n        dp = [nums[0], max(nums[0], nums[1])]\\n        \\n        for i in range(2, len(nums)):\\n          dp.append(max(dp[i -2] + nums[i], dp[i - 1]))\\n        \\n        return dp[-1]\\n\\t\\t\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 227675,
                "title": "c-well-commented-solution-dp-100",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& a);\\n};\\n\\nint Solution :: rob(vector<int>& a)\\n{\\n    int n = a.size();\\n    \\n    if(n==0) return 0;\\n    \\n    int dp[n];\\n    \\n    /* dp[i] represents the maximum value stolen after the thief has reached the ith house*/\\n    /* Note that it does not mean that he has to rob this house compulsorily */\\n    /* He has the option of robbing it or leaving it, depending upon his choices */\\n    \\n    memset(dp,0,sizeof(dp));\\n    \\n    int takeIt = 0;\\n    int leaveIt = 0;\\n    \\n    /* The thief comes to the first house */\\n    takeIt = a[0];\\n    leaveIt = 0;\\n    dp[0] = max(takeIt,leaveIt);\\n    \\n    // If there is only one house to rob, the you\\'re done */\\n    // Tricky corner case\\n    if(n==1) return dp[0];\\n    \\n    /* So now assume that the second house exists*/\\n    \\n    /* The thief goes to the 2nd house */\\n    // If he takes it, he has to give back the contents of house 1, if stolen */\\n    takeIt = a[1]; \\n    // If he leaves it, he\\'ll be just where he started off \\n    leaveIt = dp[0];\\n    dp[1] = max(takeIt,leaveIt);\\n    \\n    /* Now, apply the definition */\\n    for(int i=2; i<n; i++)\\n    {\\n        // If you take this, you are not eligible for the left house\\n        // Note that the i-2th house  need not be robbed compulsorily as per dp definition\\n        takeIt = a[i] + dp[i-2];\\n        \\n        // If you leave it, you\\'ll only get the benefits earned till  the last house\\n        leaveIt = dp[i-1];\\n        \\n        // Take the best of the two outcomes\\n        dp[i] = max(takeIt, leaveIt);\\n    }\\n    \\n    return dp[n-1];\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& a);\\n};\\n\\nint Solution :: rob(vector<int>& a)\\n{\\n    int n = a.size();\\n    \\n    if(n==0) return 0;\\n    \\n    int dp[n];\\n    \\n    /* dp[i] represents the maximum value stolen after the thief has reached the ith house*/\\n    /* Note that it does not mean that he has to rob this house compulsorily */\\n    /* He has the option of robbing it or leaving it, depending upon his choices */\\n    \\n    memset(dp,0,sizeof(dp));\\n    \\n    int takeIt = 0;\\n    int leaveIt = 0;\\n    \\n    /* The thief comes to the first house */\\n    takeIt = a[0];\\n    leaveIt = 0;\\n    dp[0] = max(takeIt,leaveIt);\\n    \\n    // If there is only one house to rob, the you\\'re done */\\n    // Tricky corner case\\n    if(n==1) return dp[0];\\n    \\n    /* So now assume that the second house exists*/\\n    \\n    /* The thief goes to the 2nd house */\\n    // If he takes it, he has to give back the contents of house 1, if stolen */\\n    takeIt = a[1]; \\n    // If he leaves it, he\\'ll be just where he started off \\n    leaveIt = dp[0];\\n    dp[1] = max(takeIt,leaveIt);\\n    \\n    /* Now, apply the definition */\\n    for(int i=2; i<n; i++)\\n    {\\n        // If you take this, you are not eligible for the left house\\n        // Note that the i-2th house  need not be robbed compulsorily as per dp definition\\n        takeIt = a[i] + dp[i-2];\\n        \\n        // If you leave it, you\\'ll only get the benefits earned till  the last house\\n        leaveIt = dp[i-1];\\n        \\n        // Take the best of the two outcomes\\n        dp[i] = max(takeIt, leaveIt);\\n    }\\n    \\n    return dp[n-1];\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55765,
                "title": "java-o-n-runtime-and-o-1-space-before-simplified-version-after-simplified-version",
                "content": "I saw an elegant solution but it's difficult to understand.  https://discuss.leetcode.com/topic/11082/java-o-n-solution-space-o-1/2\\n\\nKey point is: For each loop (house), we will make the `currNo` (current not robbed) and `currYes`(currently been robbed) to become the `prevYes` and `prevNo` for the next house.\\n\\nLet's see the before simplified version:\\n\\n```\\npublic static int rob(int[] nums) {\\n        int currYes = 0, currNo = 0;\\n        for (int x : nums) {\\n            int prevNo = currNo;\\n            int prevYes = currYes;\\n            currNo = Math.max(prevNo, prevYes);\\n            currYes = prevNo + x;\\n        }\\n        return Math.max(currNo, currYes);\\n    }\\n```\\n\\n\\nBut we find that `prevYes` only been used once, so we deleted it, Now in the for loop it's like\\n```\\npublic static int rob2(int[] nums) {\\n        int currYes = 0, currNo = 0;\\n        for (int x : nums) {\\n            int prevNo = currNo;\\n            currNo = Math.max(prevNo, currYes);\\n            currYes = prevNo + x;\\n        }\\n        return Math.max(currNo, currYes);\\n    }\\n\\n```\\nWhatever how you name the two variables. But I think these names are easier to understand.",
                "solutionTags": [],
                "code": "```\\npublic static int rob(int[] nums) {\\n        int currYes = 0, currNo = 0;\\n        for (int x : nums) {\\n            int prevNo = currNo;\\n            int prevYes = currYes;\\n            currNo = Math.max(prevNo, prevYes);\\n            currYes = prevNo + x;\\n        }\\n        return Math.max(currNo, currYes);\\n    }\\n```\n```\\npublic static int rob2(int[] nums) {\\n        int currYes = 0, currNo = 0;\\n        for (int x : nums) {\\n            int prevNo = currNo;\\n            currNo = Math.max(prevNo, currYes);\\n            currYes = prevNo + x;\\n        }\\n        return Math.max(currNo, currYes);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55915,
                "title": "6-line-in-c-constant-space-solution-easy-to-understand",
                "content": "      class Solution {\\n     public:\\n       int rob(vector<int>& nums) {\\n        int a=0,b=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n        int t=max(a,b+nums[i]);b=a;a=t;\\n        }\\n        return a;\\n     }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n       int rob(vector<int>& nums) {\\n        int a=0,b=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n        int t=max(a,b+nums[i]);b=a;a=t;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 55968,
                "title": "share-my-c-dp-sol",
                "content": "Say num.size() == n. Define f(i) be maximum sum from i to n-1 for the case you rob house i. Define g(i) be maximum sum from i to n-1 for the case that you do not rob house i. Therefore,\\n\\n> f(i) = num[i] + g(i+1) <--- rob house i plus the max sum of the case\\n> that you do not rob house i+1\\n> \\n> g(i) = max(f(i+1),g(i+1)) <--- do not rob house i. Get either the\\n> maximum sum of the case you rob house i+1, or of the case you do not\\n> rob house i+1\\n\\n \\nYou do this backwards from the last house and the final answer is max(f(0),g(0)).\\n\\nThe code:\\n\\n    int rob(vector<int>& nums) {\\n            int f=0, g=0;\\n            for(int i=nums.size()-1; i>=0; i--) {\\n                int f_nxt = nums[i] + g;\\n                int g_nxt = max(f,g);\\n                f = f_nxt;\\n                g = g_nxt;\\n            }\\n            return max(f,g);\\n        }",
                "solutionTags": [],
                "code": "Say num.size() == n. Define f(i) be maximum sum from i to n-1 for the case you rob house i. Define g(i) be maximum sum from i to n-1 for the case that you do not rob house i. Therefore,\\n\\n> f(i) = num[i] + g(i+1) <--- rob house i plus the max sum of the case\\n> that you do not rob house i+1\\n> \\n> g(i) = max(f(i+1),g(i+1)) <--- do not rob house i. Get either the\\n> maximum sum of the case you rob house i+1, or of the case you do not\\n> rob house i+1\\n\\n \\nYou do this backwards from the last house and the final answer is max(f(0),g(0)).\\n\\nThe code:\\n\\n    int rob(vector<int>& nums) {\\n            int f=0, g=0;\\n            for(int i=nums.size()-1; i>=0; i--) {\\n                int f_nxt = nums[i] + g;\\n                int g_nxt = max(f,g);\\n                f = f_nxt;\\n                g = g_nxt;\\n            }\\n            return max(f,g);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3323577,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, vector<int>& nums, vector <int>& dp) {\\n        if (idx == 0)\\n            return nums[0];\\n        if (idx < 0)\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int pick = nums[idx] + solve(idx-2, nums, dp);\\n        int notPick = 0 + solve(idx-1, nums, dp);\\n        return dp[idx] = max (pick, notPick);\\n    }\\npublic:\\t\\n    int rob(vector<int>& nums) {   \\n        int n = nums.size(); \\n\\t    vector <int> dp(n, -1);\\n\\t    int maxSum = solve(n-1, nums, dp);\\n\\t    return maxSum;\\n\\t}\\n};\\n```\\n\\n# Approach 2\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int prev1 = nums[0], prev2 = 0;\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        int pick = nums[i];\\n\\t        if (i > 1)\\n\\t        pick += prev2;\\n            int notPick = 0 + prev1;\\n\\t        int curr = max (pick, notPick);\\n\\t        prev2 = prev1;\\n\\t        prev1 = curr;\\n\\t    }\\n\\t    return prev1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, vector<int>& nums, vector <int>& dp) {\\n        if (idx == 0)\\n            return nums[0];\\n        if (idx < 0)\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int pick = nums[idx] + solve(idx-2, nums, dp);\\n        int notPick = 0 + solve(idx-1, nums, dp);\\n        return dp[idx] = max (pick, notPick);\\n    }\\npublic:\\t\\n    int rob(vector<int>& nums) {   \\n        int n = nums.size(); \\n\\t    vector <int> dp(n, -1);\\n\\t    int maxSum = solve(n-1, nums, dp);\\n\\t    return maxSum;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int prev1 = nums[0], prev2 = 0;\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        int pick = nums[i];\\n\\t        if (i > 1)\\n\\t        pick += prev2;\\n            int notPick = 0 + prev1;\\n\\t        int curr = max (pick, notPick);\\n\\t        prev2 = prev1;\\n\\t        prev1 = curr;\\n\\t    }\\n\\t    return prev1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132866,
                "title": "python-o-n-1-time-fully-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Robber will think reversly, and try to solve problem in reverse manner\\n- we will start from $$house(0)$$ at $$house(0)$$ only one possibility is there that is that house only.\\n- now, from next house onwards we will try to take maximum of\\n1. cost if we include current $$house(i)$$ that is $$incl = nums[i]+house(i-2)(assuming house(i-2 has optimal solution))$$\\n2. cost if we skip current house(i) that is excl = house(i-1)(same assumption)\\n- cost of current $$house(i) = max(incl, excl)$$\\n- do this for $$n-1$$ iteration and answer lies in $$memo(n-1)$$, n-1 because we made all optimal choices and finished searching all houses (if permitted) and maximum lies in last optimal choice which depends on whole chain of house searching.\\n\\n# Complexity\\n- Time complexity:$$O(n-1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n-1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def helper():\\n            memo = [0 for _ in range(len(nums))]\\n            memo[0] = nums[0]\\n            for i in range(1, len(nums)):\\n                incl = nums[i]+memo[i-2] if i-2 >=0 else nums[i]\\n                excl = memo[i-1]\\n                memo[i] = max(incl, excl)\\n            return memo[len(nums)-1]\\n        return helper()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def helper():\\n            memo = [0 for _ in range(len(nums))]\\n            memo[0] = nums[0]\\n            for i in range(1, len(nums)):\\n                incl = nums[i]+memo[i-2] if i-2 >=0 else nums[i]\\n                excl = memo[i-1]\\n                memo[i] = max(incl, excl)\\n            return memo[len(nums)-1]\\n        return helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829831,
                "title": "0ms-solution-fully-explained-phase-of-transfer-function-o-n-java",
                "content": "# Approach : Using Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Explanation :\\n- The trick is the dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]) statement (Phase of Transfer Function).\\n\\n# Code\\n```\\nclass Solution \\n{\\n    Integer[] dp;//Intrger object\\n    public int rob(int[] nums) \\n    {\\n        dp=new Integer[nums.length];//Initialize an arrays to store the money\\n        return profit(nums,nums.length-1);\\n    }\\n    private int profit(int[] nums, int i)\\n    {\\n        if(i<0)\\n          return 0;\\n        if(dp[i]!=null)\\n          return dp[i];\\n        return dp[i]=Math.max(profit(nums,i-2)+nums[i],profit(nums,i-1));\\n//phase of transfer function (We can infer the formula from problem:mark[i]=max(num[i]+mark[i-2],mark[i-1])                        \\n    }\\n}\\n```\\n\\n## *If you find this solution easy to understand and helpful, then please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D*",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    Integer[] dp;//Intrger object\\n    public int rob(int[] nums) \\n    {\\n        dp=new Integer[nums.length];//Initialize an arrays to store the money\\n        return profit(nums,nums.length-1);\\n    }\\n    private int profit(int[] nums, int i)\\n    {\\n        if(i<0)\\n          return 0;\\n        if(dp[i]!=null)\\n          return dp[i];\\n        return dp[i]=Math.max(profit(nums,i-2)+nums[i],profit(nums,i-1));\\n//phase of transfer function (We can infer the formula from problem:mark[i]=max(num[i]+mark[i-2],mark[i-1])                        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741820,
                "title": "fast-c-dynamic-recursion",
                "content": "```\\nclass Solution {\\nprivate:\\n    int robCount(vector<int>& nums, int i, vector<int>& robbox) {\\n        if (i>nums.size()-1) return 0;\\n        if (robbox[i]>=0) return robbox[i];\\n        return robbox[i] = nums[i] + max(robCount(nums, i+2, robbox),robCount(nums, i+3, robbox));\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        vector<int> robbox(nums.size(), -1);\\n        return max(robCount(nums, 0, robbox), robCount(nums, 1, robbox));\\n    }\\n};\\n```\\n\\n*Upvote solution if you liked it!*",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int robCount(vector<int>& nums, int i, vector<int>& robbox) {\\n        if (i>nums.size()-1) return 0;\\n        if (robbox[i]>=0) return robbox[i];\\n        return robbox[i] = nums[i] + max(robCount(nums, i+2, robbox),robCount(nums, i+3, robbox));\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        vector<int> robbox(nums.size(), -1);\\n        return max(robCount(nums, 0, robbox), robCount(nums, 1, robbox));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657099,
                "title": "python-can-you-beat-this-easy-solution",
                "content": "```\\ndef rob(self, nums: List[int]) -> int:\\n        prev=0\\n        curr=0\\n        for x in nums:\\n            temp=prev\\n            prev=curr\\n            curr=max(x+temp,prev)\\n        return curr\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef rob(self, nums: List[int]) -> int:\\n        prev=0\\n        curr=0\\n        for x in nums:\\n            temp=prev\\n            prev=curr\\n            curr=max(x+temp,prev)\\n        return curr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2553410,
                "title": "python-solution-dp-and-memoization-best-approach-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # \\'dp\\' is used to store sub-problem results\\n        dp={}\\n        \\n        def solve(i):\\n            if i >= len(nums):\\n                return 0\\n            if i in dp:\\n                return dp[i]    # memoization\\n            else:\\n                dp[i] = max(nums[i]+solve(i+2), solve(i+1))  \\n            return dp[i]\\n        \\n        \\n        return solve(0)\\n```\\n**Note**: we are incrementing i+2 because adjacent house can alert the police.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # \\'dp\\' is used to store sub-problem results\\n        dp={}\\n        \\n        def solve(i):\\n            if i >= len(nums):\\n                return 0\\n            if i in dp:\\n                return dp[i]    # memoization\\n            else:\\n                dp[i] = max(nums[i]+solve(i+2), solve(i+1))  \\n            return dp[i]\\n        \\n        \\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507801,
                "title": "c-recursion-memoization-tabulation",
                "content": "**RECURSION:-**\\nThe idea of the problem is easy if we choose the ith element than we have to choose i+2 th element else we can choose the (i+1)th element.\\n```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int> &nums,int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2)+nums[i];\\n        int notake=help(nums,i+1);\\n        res=max(take,notake);\\n        return res;\\n    }\\n    int rob(vector<int>& nums) {\\n        return help(nums,0);\\n    }\\n};\\n```\\n**MEMOIZATION**\\n```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int> &nums,int i,vector<int> &dp){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2,dp)+nums[i];\\n        int notake=help(nums,i+1,dp);\\n        res=max(take,notake);\\n        return dp[i]=res;\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return help(nums,0,dp);\\n    }\\n};\\n```\\n**TABULATION**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n+1,0);\\n        v[0]=0;\\n        v[1]=nums[0];\\n        for(int i=2;i<=n;i++){\\n            v[i]=max(v[i-2]+nums[i-1],v[i-1]);\\n        }\\n        return v[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int> &nums,int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2)+nums[i];\\n        int notake=help(nums,i+1);\\n        res=max(take,notake);\\n        return res;\\n    }\\n    int rob(vector<int>& nums) {\\n        return help(nums,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int> &nums,int i,vector<int> &dp){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2,dp)+nums[i];\\n        int notake=help(nums,i+1,dp);\\n        res=max(take,notake);\\n        return dp[i]=res;\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return help(nums,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n+1,0);\\n        v[0]=0;\\n        v[1]=nums[0];\\n        for(int i=2;i<=n;i++){\\n            v[i]=max(v[i-2]+nums[i-1],v[i-1]);\\n        }\\n        return v[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280017,
                "title": "c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space",
                "content": "***\\n***Please Upvote if it helps.....***\\n***\\n***Solution :***\\n***\\n***\\nAs we need to find the sum of subsequences, one approach that comes to our mind is to generate all subsequences and pick the one with the maximum sum. \\n\\nTo generate all the subsequences, we can use the pick/non-pick technique. This technique can be briefly explained as follows:\\n\\n* At every index of the array, we have two options.\\n* First, to pick the array element at that index and consider it in our subsequence.\\n* Second, to leave the array element at that index and not to consider it in our subsequence.\\n\\n\\nFirst, we will try to form the recursive solution to the problem with the pick/non-pick technique. There is one more catch, the problem wants us to have only non-adjacent elements of the array in the subsequence, therefore we need to address that too.\\n***\\n***\\n***Steps to form the recursive solution:-***\\n***\\n\\n***Step 1:*** Form the function in terms of indexes: \\n\\n* We are given an array which can be easily thought of in terms of indexes. \\n* We can define our function f(ind) as : Maximum sum of the subsequence starting from index 0 to index ind.\\n* We need to return f(n-1) as our final answer.\\n\\n***Step 2:*** Try all the choices to reach the goal.\\n\\nAs mentioned earlier we will use the pick/non-pick technique to generate all subsequences. We also need to take care of the non-adjacent elements in this step.\\n\\n* If we pick an element then, pick = arr[ind] + f(ind-2). The reason we are doing f(ind-2) is because we have picked the current index element so we need to pick a non-adjacent element so we choose the index \\u2018ind-2\\u2019 instead of \\u2018ind-1\\u2019.\\n* Next we need to ignore the current element in our subsequence. So nonPick= 0 + f(ind-1). As we don\\u2019t pick the current element, we can consider the adjacent element in the subsequence.\\n\\nOur pseudocode till this step will be:\\n\\n![image](https://assets.leetcode.com/users/images/37f857f3-b55e-4e8b-a9fe-c60ba5f2d11f_1657777829.2284176.png)\\n\\n\\n***Step 3:*** Take the maximum of all the choices\\n\\nAs the problem statement asks to find the maximum subsequence total, we will return the maximum of two choices of step2.\\n\\n![image](https://assets.leetcode.com/users/images/ae7d9bed-45c5-4efd-8683-04f07d34aa51_1657777846.7399182.png)\\n***\\n***\\n\\n***Base Conditions***\\n***\\n\\nThe base conditions for the recursive function will be as follows:\\n\\n* If ind=0, then we know to reach at index=0, we would have ignored the element at index = 1. Therefore, we can simply return the value of arr[ind] and consider it in the subsequence.\\n* If ind<0, this case can hit when we call f(ind-2) at ind=1. In this case we want to return to the calling function so we simply return 0 so that nothing is added to the subsequence sum.\\n\\nOur final pseudo-code will be:\\n\\n![image](https://assets.leetcode.com/users/images/eeeb521f-840f-4066-96b7-92e88f0d2826_1657777914.744225.png)\\n\\n***\\n***\\n***Memoization approach***\\n***\\nIf we observe the recursion tree, we will observe a number of overlapping subproblems. Therefore the recursive solution can be memoized to reduce the time complexity.\\n***\\n***Recursion tree diagram:***\\n![image](https://assets.leetcode.com/users/images/bbe32ffd-2efe-4ffe-afea-6d142431ca92_1657777955.877174.png)\\n***\\n\\n***Steps to convert Recursive code to memoization solution:***\\n***\\n\\n* Create a dp[n] array initialized to -1.\\n* Whenever we want to find the answer of a particular value (say n), we first check whether the answer is already calculated using the dp array(i.e dp[n] != -1 ). If yes, simply return the value from the dp array.\\n* If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[n] to the solution we get.\\n***\\n***\\n***C++ Code:***\\n***\\n```\\nint solveUtil(int ind, vector<int>& arr, vector<int>& dp){\\n    \\n    if(dp[ind]!=-1) return dp[ind];\\n    \\n    if(ind==0) return arr[ind];\\n    if(ind<0)  return 0;\\n    \\n    int pick= arr[ind]+ solveUtil(ind-2, arr,dp);\\n    int nonPick = 0 + solveUtil(ind-1, arr, dp);\\n    \\n    return dp[ind]=max(pick, nonPick);\\n}\\n\\nint solve(int n, vector<int>& arr){\\n    vector<int> dp(n,-1);\\n    return solveUtil(n-1, arr, dp);\\n}\\n\\n```\\n***\\n\\n***Output: 11***\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n***Reason:*** The overlapping subproblems will return the answer in constant time O(1). Therefore the total number of new subproblems we solve is \\u2018n\\u2019. Hence total time complexity is O(N).\\n\\n***Space Complexity: O(N)***\\n\\n***Reason:*** We are using a recursion stack space(O(N)) and an array (again O(N)). Therefore total space complexity will be O(N) + O(N) \\u2248 O(N)\\n***\\n***\\n\\n***Tabulation approach***\\n***\\n* Declare a dp[] array of size n.\\n* First initialize the base condition values, i.e dp[0] as 0.\\n* Set an iterative loop which traverses the array( from index 1 to n-1) and for every index calculate pick  and nonPick\\n*  And then we can set dp[i] = max (pick, nonPick)\\n***\\n***\\n***C++ Code:***\\n***\\n```\\nint solveUtil(int n, vector<int>& arr, vector<int>& dp){\\n    \\n    dp[0]= arr[0];\\n    \\n    for(int i=1 ;i<n; i++){\\n        int pick = arr[i];\\n        if(i>1)\\n            pick += dp[i-2];\\n        int nonPick = 0+ dp[i-1];\\n        \\n        dp[i]= max(pick, nonPick);\\n    }\\n    return dp[n-1];\\n}\\n\\nint solve(int n, vector<int>& arr){\\n    vector<int> dp(n,-1);\\n    return solveUtil(n, arr, dp);\\n}\\n```\\n***\\n***Output: 11***\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n***Reason:*** We are running a simple iterative loop\\n\\n***Space Complexity: O(N)***\\n\\n***Reason:*** We are using an external array of size \\u2018n+1\\u2019.\\n***\\n***\\n***Part 3: Space Optimization***\\n\\nIf we closely look the values required at every iteration,\\n\\n***dp[i] , dp[i-1] and  dp[i-2]***\\n\\nwe see that for any i, we do need only the last two values in the array. So is there a need to maintain a whole array for it? \\n\\nThe answer is \\u2018No\\u2019. Let us call dp[i-1] as prev and dp[i-2] as prev2. Now understand the following illustration.\\n\\n![image](https://assets.leetcode.com/users/images/8a0fea97-2a7b-4a0c-9262-0684fa6ad77d_1657778207.2451472.png)\\n\\n\\n* Each iteration\\u2019s cur_i and prev becomes the next iteration\\u2019s prev and prev2 respectively.\\n* Therefore after calculating cur_i, if we update prev and prev2 according to the next step, we will always get the answer. \\n* After the iterative loop has ended we can simply return prev as our answer.\\n***\\n\\n***C++ Code:***\\n```\\nint solve(int n, vector<int>& arr){\\n    int prev = arr[0];\\n    int prev2 =0;\\n    \\n    for(int i=1; i<n; i++){\\n        int pick = arr[i];\\n        if(i>1)\\n            pick += prev2;\\n        int nonPick = 0 + prev;\\n        \\n        int cur_i = max(pick, nonPick);\\n        prev2 = prev;\\n        prev= cur_i;\\n        \\n    }\\n    return prev;\\n}\\n```\\n***\\n***Output: 11***\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n***Reason:*** We are running a simple iterative loop\\n\\n***Space Complexity: O(1)***\\n\\n***Reason:*** We are not using any extra space.\\n***\\n***\\n***Please Upvote if it helps.....***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solveUtil(int ind, vector<int>& arr, vector<int>& dp){\\n    \\n    if(dp[ind]!=-1) return dp[ind];\\n    \\n    if(ind==0) return arr[ind];\\n    if(ind<0)  return 0;\\n    \\n    int pick= arr[ind]+ solveUtil(ind-2, arr,dp);\\n    int nonPick = 0 + solveUtil(ind-1, arr, dp);\\n    \\n    return dp[ind]=max(pick, nonPick);\\n}\\n\\nint solve(int n, vector<int>& arr){\\n    vector<int> dp(n,-1);\\n    return solveUtil(n-1, arr, dp);\\n}\\n\\n```\n```\\nint solveUtil(int n, vector<int>& arr, vector<int>& dp){\\n    \\n    dp[0]= arr[0];\\n    \\n    for(int i=1 ;i<n; i++){\\n        int pick = arr[i];\\n        if(i>1)\\n            pick += dp[i-2];\\n        int nonPick = 0+ dp[i-1];\\n        \\n        dp[i]= max(pick, nonPick);\\n    }\\n    return dp[n-1];\\n}\\n\\nint solve(int n, vector<int>& arr){\\n    vector<int> dp(n,-1);\\n    return solveUtil(n, arr, dp);\\n}\\n```\n```\\nint solve(int n, vector<int>& arr){\\n    int prev = arr[0];\\n    int prev2 =0;\\n    \\n    for(int i=1; i<n; i++){\\n        int pick = arr[i];\\n        if(i>1)\\n            pick += prev2;\\n        int nonPick = 0 + prev;\\n        \\n        int cur_i = max(pick, nonPick);\\n        prev2 = prev;\\n        prev= cur_i;\\n        \\n    }\\n    return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836989,
                "title": "c-o-n-time-100-faster-dp-memoization",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int n = nums.size();\\n        vector<int>dp(n+1, 0);\\n        \\n        if(n == 1) return nums[0];\\n        if(n == 2) return max(nums[0], nums[1]);\\n        \\n        dp[0] = nums[0], dp[1] = nums[1];\\n        for(int i = 2; i<n; i++){\\n            dp[i] = max((dp[i-2] + nums[i]), dp[i-1]);\\n            dp[i-1] = max(dp[i-1], dp[i-2]);\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int n = nums.size();\\n        vector<int>dp(n+1, 0);\\n        \\n        if(n == 1) return nums[0];\\n        if(n == 2) return max(nums[0], nums[1]);\\n        \\n        dp[0] = nums[0], dp[1] = nums[1];\\n        for(int i = 2; i<n; i++){\\n            dp[i] = max((dp[i-2] + nums[i]), dp[i-1]);\\n            dp[i-1] = max(dp[i-1], dp[i-2]);\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 1700182,
                "title": "c-100-faster-without-extra-space-o-n",
                "content": "**Please Upvote if You Like :)**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {    \\n    int n=nums.size();\\n    int even=0;\\n    int odd=0;\\n    for(int i=0;i<n;i++)\\n    { \\n        if(i%2==0)\\n        {\\n            even+=nums[i];\\n            if(even<odd)\\n            {\\n                even=odd;\\n            }\\n        }\\n        else\\n        {\\n            odd+=nums[i];\\n            if(even>odd)\\n            {\\n                odd=even;\\n            }\\n        }     \\n    }\\n    return max(even,odd); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {    \\n    int n=nums.size();\\n    int even=0;\\n    int odd=0;\\n    for(int i=0;i<n;i++)\\n    { \\n        if(i%2==0)\\n        {\\n            even+=nums[i];\\n            if(even<odd)\\n            {\\n                even=odd;\\n            }\\n        }\\n        else\\n        {\\n            odd+=nums[i];\\n            if(even>odd)\\n            {\\n                odd=even;\\n            }\\n        }     \\n    }\\n    return max(even,odd); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684688,
                "title": "0ms-c-dp-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n  \\n    int inc = nums[0] , exc = 0;\\n    \\n    for(int index = 1 ; index < nums.size() ; index++)\\n    {\\n        int ninc = exc + nums[index];\\n        int nexc = max(inc , exc);\\n        \\n        inc = ninc;\\n        exc = nexc;\\n    }\\n    return max(inc,exc);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n  \\n    int inc = nums[0] , exc = 0;\\n    \\n    for(int index = 1 ; index < nums.size() ; index++)\\n    {\\n        int ninc = exc + nums[index];\\n        int nexc = max(inc , exc);\\n        \\n        inc = ninc;\\n        exc = nexc;\\n    }\\n    return max(inc,exc);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605941,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        nums.into_iter()\\n            .fold((0, 0), |(a, b), x| (a.max(b + x), a))\\n            .0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        nums.into_iter()\\n            .fold((0, 0), |(a, b), x| (a.max(b + x), a))\\n            .0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605258,
                "title": "python-dynamic-programming-dp-o-n-time-o-1-space-explaination",
                "content": "User DP algorithms:\\n**Approach**: Bottom->Up\\n**Recursive formula**: m[i] = max(m[i-1], m[i-2]+nums[i-2])\\nwhere m[i] is maximum money that the robber can get tonight when he walks thought the i(th) horse\\n**Clarify the formula**:  \\nOn a i(th) horse, we have two choices\\nFirst: skip -> m[i] = m[i-1]\\nSecond: Stole this horse -> he just ignore i-1(th)horse -> m[i] = m[i-2]+nums[i]\\nSo maximun mount of money is maximun two above choices\\n\\nIf you have any question, free feel comment bellow\\nUpvote if it is useful. Have a nice day coders :D\\n\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0]\\n        nums[1] = max(nums[1], nums[0])\\n        for i in range(2, n):\\n            nums[i] = max(nums[i-1], nums[i-2]+nums[i])\\n            \\n        return nums[n-1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0]\\n        nums[1] = max(nums[1], nums[0])\\n        for i in range(2, n):\\n            nums[i] = max(nums[i-1], nums[i-2]+nums[i])\\n            \\n        return nums[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591372,
                "title": "c-two-approaches-both-beat-100",
                "content": "**Approach 1-**\\nBottom up dp TC-O(N), SC-O(N)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        vector<int> dp(n,0);\\n        dp[0]=nums[0];\\n        dp[1]=max(nums[0],nums[1]);        \\n        for(int i=2;i<n;i++)\\n        {\\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n\\n```\\n**Approach 2 (Best)-**\\nWe can notice in approach 1 that we only need 2 variables instead of the whole DP array. TC-O(N), SC-O(1). \\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return 0;\\n        int prev1 = 0;\\n        int prev2 = 0;\\n        for (int i=0;i<nums.size();++i) \\n        {\\n            int temp = prev1;\\n            prev1 = max(prev2 + nums[i], prev1);\\n            prev2 = temp;\\n        }\\n        return prev1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        vector<int> dp(n,0);\\n        dp[0]=nums[0];\\n        dp[1]=max(nums[0],nums[1]);        \\n        for(int i=2;i<n;i++)\\n        {\\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return 0;\\n        int prev1 = 0;\\n        int prev2 = 0;\\n        for (int i=0;i<nums.size();++i) \\n        {\\n            int temp = prev1;\\n            prev1 = max(prev2 + nums[i], prev1);\\n            prev2 = temp;\\n        }\\n        return prev1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579854,
                "title": "python-from-recursion-to-top-down-to-bottom-up",
                "content": "**Recursion sol: Time and Space: O(2^N)**\\n`Recurrence Relation: rob(i) = max(rob(i - 2) + currentHouseValue, rob(i - 1))`\\n*Credits for this relation goes to @heroes3001*\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        return self.robMax(nums, len(nums) - 1) # start from the last/top\\n    \\n    \\n    def robMax(self, nums, i):\\n        if i < 0:\\n            return 0 # when i < 0 we just have to return 0\\n        return max(nums[i] + self.robMax(nums, i - 2), self.robMax(nums, i - 1))\\n```\\n\\n**Recursion + caching = Top-Down: Time and Space: O(N)**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        dp = [-1 for _ in range(len(nums))] # cache\\n        return self.robMax(nums, dp, len(nums) - 1)\\n    \\n    \\n    def robMax(self, nums, dp, i):\\n        if i < 0:\\n            return 0\\n        \\n        if dp[i] != -1: # if the value of dp[i] is not default i.e. -1 that means we have already calculated it so we dont have to do it again we just have to return it\\n            return dp[i]\\n        \\n        dp[i] = max(nums[i] + self.robMax(nums, dp, i - 2), self.robMax(nums, dp, i - 1))\\n        return dp[i]\\n```\\n\\n**Bottom Up sol: Converting Top Down, Time and Space: O(N)**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        dp = [-1 for _ in range(len(nums))]\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1]) # the base cases where rob1 is the amount you can take from 1 house and rob2 is the amount you can take from 2 houses (that will be the maximum of nums[0] and nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]) # the recurrence relation\\n        return dp[len(nums) - 1] # the last value will be your maximum amount of robbery\\n```\\n\\nIn the above solution if we notice carefully we just need the values of the last two values and not a whole array so we can further optimize it.\\n\\n**Bottom Up sol: Time: O(n) Space: O(1)**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        rob1, rob2 = nums[0], max(nums[0], nums[1])\\n        \\n        for n in nums[2:]:\\n            temp = max(rob1 + n, rob2) # the max amount we can rob from the given house and from the prev\\'s previous and from the previous house\\n            rob1, rob2 = rob2, temp # update both the variables \\n            \\n        return temp # return the max amount\\n```\\nThe last solution can be hard to visualize but try dry running it with a few examples and you\\'ll get it.\\nI hope you understand all the solutions :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        return self.robMax(nums, len(nums) - 1) # start from the last/top\\n    \\n    \\n    def robMax(self, nums, i):\\n        if i < 0:\\n            return 0 # when i < 0 we just have to return 0\\n        return max(nums[i] + self.robMax(nums, i - 2), self.robMax(nums, i - 1))\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        dp = [-1 for _ in range(len(nums))] # cache\\n        return self.robMax(nums, dp, len(nums) - 1)\\n    \\n    \\n    def robMax(self, nums, dp, i):\\n        if i < 0:\\n            return 0\\n        \\n        if dp[i] != -1: # if the value of dp[i] is not default i.e. -1 that means we have already calculated it so we dont have to do it again we just have to return it\\n            return dp[i]\\n        \\n        dp[i] = max(nums[i] + self.robMax(nums, dp, i - 2), self.robMax(nums, dp, i - 1))\\n        return dp[i]\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        dp = [-1 for _ in range(len(nums))]\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1]) # the base cases where rob1 is the amount you can take from 1 house and rob2 is the amount you can take from 2 houses (that will be the maximum of nums[0] and nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]) # the recurrence relation\\n        return dp[len(nums) - 1] # the last value will be your maximum amount of robbery\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        rob1, rob2 = nums[0], max(nums[0], nums[1])\\n        \\n        for n in nums[2:]:\\n            temp = max(rob1 + n, rob2) # the max amount we can rob from the given house and from the prev\\'s previous and from the previous house\\n            rob1, rob2 = rob2, temp # update both the variables \\n            \\n        return temp # return the max amount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472747,
                "title": "my-easy-c-solution-0ms-better-than-100",
                "content": "plz upvote my solution\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        const auto N = nums.size();\\n        if(N == 0) return 0;\\n        if(N == 1) return nums[0];\\n\\n        std::vector<int> dp(N);dp[0] = nums[0];dp[1] = std::max(nums[0],nums[1]);\\n        for (int i = 2; i < N; ++i) {\\n            dp[i] = std::max(dp[i - 2] + nums[i],dp[i-1]);\\n        }\\n        return dp[N-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        const auto N = nums.size();\\n        if(N == 0) return 0;\\n        if(N == 1) return nums[0];\\n\\n        std::vector<int> dp(N);dp[0] = nums[0];dp[1] = std::max(nums[0],nums[1]);\\n        for (int i = 2; i < N; ++i) {\\n            dp[i] = std::max(dp[i - 2] + nums[i],dp[i-1]);\\n        }\\n        return dp[N-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419217,
                "title": "simple-o-n-javascript-solution-dynamic-programming",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar rob = function(nums) {\\n   let prev = 0,\\n       curr = 0;\\n    \\n    //prev means house at i - 2, curr is house at i - 1\\n    for(let i = 0; i < nums.length; i++){\\n        let temp = Math.max(nums[i] + prev, curr);\\n        prev = curr;\\n        curr = temp;\\n    }\\n    return curr;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar rob = function(nums) {\\n   let prev = 0,\\n       curr = 0;\\n    \\n    //prev means house at i - 2, curr is house at i - 1\\n    for(let i = 0; i < nums.length; i++){\\n        let temp = Math.max(nums[i] + prev, curr);\\n        prev = curr;\\n        curr = temp;\\n    }\\n    return curr;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1345827,
                "title": "dp-0-1-knapsack-memoization-and-tabulation-c",
                "content": "**TOP-DOWN MEMOIZATION** \\n\\n```\\nclass Solution {\\npublic: \\n    int dp[102]; \\n    \\n    int rob(vector<int>& nums) {  \\n        \\n        memset(dp, -1, sizeof(dp)); \\n        \\n        return knapSack(nums, nums.size());\\n        \\n    } \\n    \\n    int knapSack(vector<int> &nums, int n)  { \\n        \\n        if (n <= 0) { \\n            return 0;\\n        } \\n        \\n        if (dp[n] != -1) { \\n            return dp[n];\\n        }\\n        \\n        return dp[n] = max(nums[n-1] + knapSack(nums, n-2), knapSack(nums, n-1));\\n    }\\n};\\n``` \\n\\n**BOTTOM-UP TABULATION** \\n```\\nclass Solution {\\npublic: \\n    \\n    int rob(vector<int>& nums) {  \\n        \\n        int n = nums.size(); \\n        \\n        int dp[n+1]; \\n        \\n        dp[0] = 0;  \\n        dp[1] = nums[0];\\n        \\n        for (int i = 2; i <= n; i++) { \\n            \\n            dp[i] = max (nums[i-1] + dp[i-2], dp[i-1]);\\n        } \\n        \\n        return dp[n];\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int dp[102]; \\n    \\n    int rob(vector<int>& nums) {  \\n        \\n        memset(dp, -1, sizeof(dp)); \\n        \\n        return knapSack(nums, nums.size());\\n        \\n    } \\n    \\n    int knapSack(vector<int> &nums, int n)  { \\n        \\n        if (n <= 0) { \\n            return 0;\\n        } \\n        \\n        if (dp[n] != -1) { \\n            return dp[n];\\n        }\\n        \\n        return dp[n] = max(nums[n-1] + knapSack(nums, n-2), knapSack(nums, n-1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    \\n    int rob(vector<int>& nums) {  \\n        \\n        int n = nums.size(); \\n        \\n        int dp[n+1]; \\n        \\n        dp[0] = 0;  \\n        dp[1] = nums[0];\\n        \\n        for (int i = 2; i <= n; i++) { \\n            \\n            dp[i] = max (nums[i-1] + dp[i-2], dp[i-1]);\\n        } \\n        \\n        return dp[n];\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286131,
                "title": "c-approach-explanation",
                "content": "Give it a try :)\\n**How to start ?**\\nFor this problem recursive approach will not work.\\nThink for a better approach\\nBelow solution is based on bottom-up approach(DP)\\n*I\\' will try to add other approaches later, Please comment if you got any *\\n\\nEXPLANATION:\\nNote: the probem says you can not rob alternate house and we need to rob maximum value, so we can observe  that we if we choose to rob house[i] then we cann\\'t rob house[i+1], we have to rob from house[i+2].\\nhence you got two choices and we\\'ll take maximum of them\\n  1. To rob ith-house and jump to (i+2)th-house\\n       amount_when_ith_house_choosen=amount[i] + amount from (i+2)th to last house\\n  2. To not rob i-th house and move to (i+1)th house\\n    \\tamount_when_ith_house_not_choosen=amount from (i+1)th to last house   \\nSo, we will continue searching till we reach the end and store the maximum amount robbed from both the choices into an array\\nThe last index of the array will be the aanswer.\\n\\t\\t\\ndp[i] = max( dp[i-2] + amount[i] , dp[i-1]) = max(choose to rob i-th house, choose not to rob i-th house)\\n\\n\\nclass Solution {\\npublic:\\n   \\n#    DP\\n     //DP- don\\'t be scared :)\\n    int rob(vector<int>&nums){\\n        if(nums.size()==1) return nums[0];\\n        int n=nums.size();\\n        int *dp=new int[nums.size()];\\n        dp[0]=nums[0]; \\n        dp[1]=max(nums[1],nums[0]);\\n        for(int i=2;i<n;i++){\\n            dp[i]=max(dp[i-2] + nums[i] , dp[i-1]);\\n        }\\n        int ans= dp[n-1];\\n        delete[] dp; //free this memory\\n        return ans;\\n    }\\n    \\n    \\n  #     USING RECURSION ---> TLE(Time Limit Exceeded)  [Not working]\\n    //using recursion\\n    int helper(vector<int>&nums, int n, int s){\\n        if(s==n-1) return nums[s];\\n        if(s>=n) return 0;\\n        \\n        int robbed=helper(nums,n,s+2) + nums[s];\\n        int not_robbed=helper(nums,n,s+1); \\n        \\n        return max(robbed, not_robbed);\\n    }\\n    \\n    int robRec(vector<int>& nums) {\\n        int n=nums.size();\\n        return helper(nums,n,0);\\n    }\\n};\\n\\n*I have tried my best to explain this problem, if still something I missed something please let me know*",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n#    DP\\n     //DP- don\\'t be scared :)\\n    int rob(vector<int>&nums){\\n        if(nums.size()==1) return nums[0];\\n        int n=nums.size();\\n        int *dp=new int[nums.size()];\\n        dp[0]=nums[0]; \\n        dp[1]=max(nums[1],nums[0]);\\n        for(int i=2;i<n;i++){\\n            dp[i]=max(dp[i-2] + nums[i] , dp[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1164281,
                "title": "python-6-lines-o-1-space-iterating-from-the-start",
                "content": "We build the dependency graph from the start of the list. It contains just 2 elements - f (the first preceding element) and s (the element that precedes f). \\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        f,s = 0,0\\n        for i in nums:\\n            f,s = max(f, s + i),f\\n        return f\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        f,s = 0,0\\n        for i in nums:\\n            f,s = max(f, s + i),f\\n        return f\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161208,
                "title": "cpp-3-approach-recursion-memoization-dynamic-programming-100-faster",
                "content": "**BRUTE FORCE**\\n\\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int a = robHelper(nums, i+2) + nums[i];\\n        int b = robHelper(nums, i+1);\\n        return max(a,b);\\n    }\\n    int rob(vector<int>& nums){\\n        return robHelper(nums,0);\\n    }\\n};\\n```\\nThis solution will show TLE\\n\\n\\n\\n**MEMOIZATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i, int*dp){\\n        int n = nums.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        \\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        \\n        int a = robHelper(nums, i+2,dp) + nums[i];\\n        int b = robHelper(nums, i+1,dp);\\n        int ans = max(a,b);\\n        dp[i] = ans;\\n        return ans;\\n    }\\n    int rob(vector<int>& nums){\\n        int n = nums.size();\\n        int *dp = new int[n+1];\\n        for(int i=0; i<=n; i++){\\n            dp[i] = -1;\\n        }\\n        return robHelper(nums,0,dp);\\n    }\\n};\\n\\n```\\n\\n**DYNAMIC PROGRAMMING**\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int *dp = new int[nums.size()];\\n        int n = nums.size();\\n        if(n==0) {\\n            return 0;\\n        }\\n        if(n==1){\\n         return nums[0];   \\n        }\\n        if(n==2){\\n          return max(nums[1],nums[0]);  \\n        }\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i = 2; i <nums.size(); i++){\\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1]);\\n        }\\n        return dp[nums.size()-1];\\n        delete[] dp;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int a = robHelper(nums, i+2) + nums[i];\\n        int b = robHelper(nums, i+1);\\n        return max(a,b);\\n    }\\n    int rob(vector<int>& nums){\\n        return robHelper(nums,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i, int*dp){\\n        int n = nums.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        \\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        \\n        int a = robHelper(nums, i+2,dp) + nums[i];\\n        int b = robHelper(nums, i+1,dp);\\n        int ans = max(a,b);\\n        dp[i] = ans;\\n        return ans;\\n    }\\n    int rob(vector<int>& nums){\\n        int n = nums.size();\\n        int *dp = new int[n+1];\\n        for(int i=0; i<=n; i++){\\n            dp[i] = -1;\\n        }\\n        return robHelper(nums,0,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991999,
                "title": "recursion-and-memoization-c-aditya-verma-approach",
                "content": "Recursion -\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // recursive\\n    \\n    int fun(vector<int> &v, int i)\\n    {\\n        if(i<0)\\n            return 0;\\n            \\n        int num1 = fun(v,i-2) + v[i];\\n        int num2 = fun(v,i-1);\\n        \\n        return max(num1,num2);\\n    }\\n    \\n    int rob(vector<int>& v) \\n    {   \\n        int n = v.size();\\n        return fun(v,n-1);\\n    }\\n};\\n```\\n\\nMemoization - \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // memoization\\n    \\n    vector<int> dp;\\n    \\n    int fun(vector<int> &v, int i)\\n    {\\n        if(i<0)\\n            return 0;\\n            \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int num1 = fun(v,i-2) + v[i];\\n        int num2 = fun(v,i-1);\\n        \\n        return dp[i] = max(num1,num2);\\n    }\\n    \\n    int rob(vector<int>& v) \\n    {   \\n        int n = v.size();\\n        \\n        dp.clear();\\n        dp.resize(n+1,-1);\\n        return fun(v,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // recursive\\n    \\n    int fun(vector<int> &v, int i)\\n    {\\n        if(i<0)\\n            return 0;\\n            \\n        int num1 = fun(v,i-2) + v[i];\\n        int num2 = fun(v,i-1);\\n        \\n        return max(num1,num2);\\n    }\\n    \\n    int rob(vector<int>& v) \\n    {   \\n        int n = v.size();\\n        return fun(v,n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // memoization\\n    \\n    vector<int> dp;\\n    \\n    int fun(vector<int> &v, int i)\\n    {\\n        if(i<0)\\n            return 0;\\n            \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int num1 = fun(v,i-2) + v[i];\\n        int num2 = fun(v,i-1);\\n        \\n        return dp[i] = max(num1,num2);\\n    }\\n    \\n    int rob(vector<int>& v) \\n    {   \\n        int n = v.size();\\n        \\n        dp.clear();\\n        dp.resize(n+1,-1);\\n        return fun(v,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860590,
                "title": "java-dp-solution-faster-than-100-submission",
                "content": "**Java self explanatory Code**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        int dp[] = new int[nums.length];\\n        dp[0]=nums[0];\\n        dp[1]=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);//maximum of the previous element or the sum of current element and the previous of previous element.\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        int dp[] = new int[nums.length];\\n        dp[0]=nums[0];\\n        dp[1]=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);//maximum of the previous element or the sum of current element and the previous of previous element.\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847546,
                "title": "length-of-last-word-java-beats-100-simple-and-explained",
                "content": "This problem is real simple when we start to iterate from end to beginning of the given string.\\n1. First while loop, iterates over all the empty spaces at the end\\nExample String: ```s = \"Hello \"``` Last word is \\'Hello\\', but there is an extra space, thus we are removing all such spaces from consideration in this loop.\\n2. Second loop iterates over the last word and count number of characters in it\\n```\\npublic int lengthOfLastWord(String s) {\\n\\tint i = s.length() - 1, len = 0;\\n\\twhile (i >= 0 && s.charAt(i) == \\' \\') {i--;};\\n\\twhile (i >= 0 && s.charAt(i) != \\' \\'){ len++; i--;}\\n\\treturn len;\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```s = \"Hello \"```\n```\\npublic int lengthOfLastWord(String s) {\\n\\tint i = s.length() - 1, len = 0;\\n\\twhile (i >= 0 && s.charAt(i) == \\' \\') {i--;};\\n\\twhile (i >= 0 && s.charAt(i) != \\' \\'){ len++; i--;}\\n\\treturn len;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846848,
                "title": "python-recursive-dp-using-lru-cache-super-simple",
                "content": "The lru_cache deorator is a great way to solve DP problems intuitively. Instead of having to store state in a map or a DP table, you can take a more mathematical approach to problems like these and not worry about the memoisation aspect of it.\\n\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        from functools import lru_cache\\n        \\n        n = len(nums)\\n        \\n        @lru_cache(maxsize=None)\\n        def dp(i, state, cur):\\n            if i >= n:\\n                return cur\\n            if state == True:\\n                return dp(i+1, False, cur)\\n            else:\\n                l = dp(i+1, False, cur)\\n                r = dp(i+1, True, cur+nums[i])\\n                \\n                return max(l, r)\\n        return dp(0, False, 0)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        from functools import lru_cache\\n        \\n        n = len(nums)\\n        \\n        @lru_cache(maxsize=None)\\n        def dp(i, state, cur):\\n            if i >= n:\\n                return cur\\n            if state == True:\\n                return dp(i+1, False, cur)\\n            else:\\n                l = dp(i+1, False, cur)\\n                r = dp(i+1, True, cur+nums[i])\\n                \\n                return max(l, r)\\n        return dp(0, False, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846151,
                "title": "faster-than-100-00-memory-less-than-98-42-cpp-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n\\t\\t\\n        int lastmax=nums[0],maxi=max(nums[0],nums[1]);\\n        \\n        for(int i=2;i<n;++i) {\\n            int extra=maxi;\\n            maxi=max(maxi, lastmax+nums[i]);\\n            lastmax=extra;\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n\\t\\t\\n        int lastmax=nums[0],maxi=max(nums[0],nums[1]);\\n        \\n        for(int i=2;i<n;++i) {\\n            int extra=maxi;\\n            maxi=max(maxi, lastmax+nums[i]);\\n            lastmax=extra;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846016,
                "title": "java-dynamic-programming-easy-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        // edge cases:\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0], nums[1]);\\n        for (int i=2; i<nums.length; i++)\\n            dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        // edge cases:\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0], nums[1]);\\n        for (int i=2; i<nums.length; i++)\\n            dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846011,
                "title": "c-dynamic-programming-short-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733107,
                "title": "python3-dp-top-down-bottom-up",
                "content": "Define `fn(i)` as the maximum amount of money after robbing `i`th house. Then, below recursive relation holds \\n\\n`fn(i) = max(fn(i-1), fn(i-2) + nums[i])` for `i >= 0` and `fn(i) = 0` for `i < 0`;\\n\\nAs a result, it can be solved using dynamic programming. \\n\\ntop-down implementation (`O(N)` time & `O(N)` space)\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return the maximum amount of money robbing up to ith house.\"\"\"\\n            if i < 0: return 0\\n            return max(fn(i-1), fn(i-2) + nums[i])\\n        \\n        return fn(len(nums)-1)\\n```\\n\\nbottom-up implementation (`O(N)` time & `O(1)` space)\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        f0 = f1 = 0\\n        for x in nums: f0, f1 = f1, max(f1, f0+x)\\n        return f1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return the maximum amount of money robbing up to ith house.\"\"\"\\n            if i < 0: return 0\\n            return max(fn(i-1), fn(i-2) + nums[i])\\n        \\n        return fn(len(nums)-1)\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        f0 = f1 = 0\\n        for x in nums: f0, f1 = f1, max(f1, f0+x)\\n        return f1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512490,
                "title": "python-js-java-go-c-o-n-sol-by-dp-w-visualization",
                "content": "O(n) sol. by dynamic programming.\\n\\n---\\n\\n**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/images/997ee642-7503-434b-be17-cc65e70fca70_1598862172.6326396.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/950de25b-aec2-4ac9-a1f4-8329b64dc3a0_1598862187.8272965.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/b60e468d-fe8f-4ca8-ade7-957840a119f3_1598862199.4649277.png)\\n\\n\\n---\\n\\n**Hint**:\\nThink of the **item value taking optimization** with **Dynamic programming**.\\n\\n---\\n\\n**Algorithm**:\\nSolve by dynamic programming with the **Optimal substructure** (i.e., recurrence relationship) as following:\\n\\nLet **Optimal[i]** denotes the highest value taking, considering from house_#0 to house_#i\\n\\n**Optimal**[ *i* ] \\n= Optimization of ( **Take** house_#*i* , or **Not to take** house_#*i* )\\n= Max( **Optimal**[ *i* - 2 ] + nums[*i*] , **Optimal**[ *i* - 1 ] )\\n\\n---\\n\\n**Implementation** by bottom-up dynamic programming:\\nPython:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        value_dp = [ 0 for _ in range(size) ]\\n        \\n        if size == 0:\\n            # Empty list\\n            return 0\\n        \\n        elif size == 1:\\n            # Only one item\\n            return nums[0]\\n    \\n        else:\\n            # Initialization\\n            value_dp[0] = nums[0]\\n            value_dp[1] = max(nums[0], nums[1])\\n\\n            # General case\\n            for i in range(2, size):\\n                value_dp[i] = max(value_dp[i-2] + nums[i], value_dp[i-1] )\\n\\n            return value_dp[-1]\\n```\\n\\nor\\n\\nwith space-optimization\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        # Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        # refer to dp[i-2]\\n        take_prev_2 = 0\\n        \\n        # refer to dp[i-1]\\n        take_prev_1 = 0\\n        \\n\\t\\tprofit = 0\\n\\t\\t\\n        for number in nums:\\n            \\n            profit = max(take_prev_2 + number, take_prev_1 + 0)\\n            take_prev_2 = take_prev_1\\n            take_prev_1 = profit\\n        \\n      \\n        return profit\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        int take_prev_2 = 0;\\n        \\n        // refer to dp[i-1]\\n        int take_prev_1 = 0;\\n        \\n        int profit = 0;\\n        \\n        for(int value : nums){\\n            \\n            profit = Math.max(take_prev_2 + value, take_prev_1 + 0);\\n            take_prev_2 = take_prev_1;\\n            take_prev_1 = profit;\\n        }\\n      \\n        return profit;\\n    }\\n}\\n```\\n\\n---\\n\\nJavscript:\\n\\n```\\nvar rob = function(nums) {\\n    \\n    size = nums.length;\\n    value = Array(size).fill(0);\\n    \\n    if( size == 0 ){\\n        // empty input\\n        return 0;\\n        \\n    }else if( size == 1 ){\\n        // only one item\\n        return nums[0];\\n    }\\n    \\n    \\n    // initialization\\n    \\n    value[0] = nums[0];\\n    value[1] = Math.max( nums[0], nums[1] );\\n    \\n    // general case\\n    for( let i = 2 ; i < size ; i++){\\n        \\n        value[i] = Math.max( value[i-2] + nums[i],  value[i-1] + 0 );\\n    }\\n    \\n    return value[size-1];\\n};\\n```\\n\\nor\\n\\nwith space-optimization\\n\\n```\\nvar rob = function(nums) {\\n    \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        let take_prev_2 = 0\\n        \\n        // refer to dp[i-1]\\n        let take_prev_1 = 0\\n        \\n        let profit = 0;\\n        \\n        for(const value of nums){\\n            \\n            profit = Math.max(take_prev_2 + value, take_prev_1 + 0);\\n            take_prev_2 = take_prev_1;\\n            take_prev_1 = profit;\\n        }\\n      \\n        return profit\\n\\n};\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        size_t size = nums.size() ;\\n        \\n        // dp table for maximum value\\n        vector<int> value = vector<int>( size );\\n        \\n        \\n        if( size == 0 ){\\n            // empty list\\n            return 0;\\n        }else if( size == 1 ){\\n            // only one item\\n            return nums[0];\\n        }\\n        \\n        // initialization\\n        value[0] = nums[0];\\n        value[1] = max(nums[0], nums[1]);\\n        \\n        // general cases\\n        for( size_t i = 2 ; i < size ; i++){\\n            value[i] = max( value[i-2] + nums[i], value[i-1] + 0 );\\n        }\\n        \\n        return value[size-1];\\n    }\\n};\\n```\\n\\nor\\n\\nwith space-optimization\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        int prev_2 = 0;\\n            \\n        // refer to dp[i-1]\\n        int prev_1 = 0;\\n        \\n        int profit = 0;\\n        \\n        for( const int& value : nums){\\n            \\n            profit = max( prev_2 + value, prev_1 + 0 );\\n            prev_2 = prev_1;\\n            prev_1 = profit;\\n        }\\n        \\n        return profit;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\n\\n// Golang does\\'t have natural built-in max function for integer type\\nfunc max(a, b int) int{\\n    if a >= b{\\n        return a\\n    }else{\\n        return b\\n    }\\n}\\n\\n\\n\\nfunc rob(nums []int) int {\\n    \\n    size := len(nums)\\n    value := make([]int, size)\\n    \\n    if size == 0{\\n        \\n        // empty input\\n        return 0\\n    }else if size == 1{\\n        \\n        // only one item\\n        return nums[0]\\n    }\\n    \\n    // initialization\\n    value[0] = nums[0]\\n    value[1] = max(nums[0], nums[1])\\n    \\n    // general case\\n    for i := 2 ; i < size ; i++ {\\n        value[i] = max( value[i-2] + nums[i], value[i-1] + 0 )\\n    }\\n    \\n    return value[size-1]\\n}\\n```\\n\\nor\\n\\nwith space optimiaztion\\n\\n```\\n\\n// Golang does\\'t have natural built-in max function for integer type\\nfunc max(a, b int) int{\\n    if a >= b{\\n        return a\\n    }else{\\n        return b\\n    }\\n}\\n\\n\\n\\nfunc rob(nums []int) int {\\n    \\n    // Since we only refer to previous two grids, we can carry out space optimization\\n    \\n    // refer to dp[i-2]\\n    prev_2 := 0\\n    \\n    // refer to dp[i-1]\\n    prev_1 := 0\\n    \\n    profit := 0\\n    \\n    for _, value := range nums{\\n        \\n        profit = max( prev_2 + value, prev_1 + 0 )\\n        \\n        prev_2, prev_1 = prev_1, profit\\n    }\\n    \\n    return profit\\n}\\n```\\n\\n---\\n\\n**Implementation** by top-down DP with memoization:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        # DP table\\n        # key: index i \\n        # value: max rob value consider from 0 to i, inclusively\\n        dp = {}\\n\\n        def consider( i ):\\n\\n            # look-up table\\n            if i in dp:\\n                return dp[i]\\n            \\n            # base case\\n            if i == 0:\\n                dp[0] = nums[0]\\n                return dp[0]\\n            \\n            # base case\\n            if i == 1:\\n                dp[1] = max(nums[0], nums[1])\\n                return dp[1]\\n            \\n            # general case\\n            take = nums[i] + consider(i-2)\\n            skip = 0 + consider(i-1)\\n\\n            dp[i] = max( take, skip )\\n            return dp[i]\\n        # ----------------------------------------\\n        last_house = len(nums)-1\\n        return consider(last_house)\\n            \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        value_dp = [ 0 for _ in range(size) ]\\n        \\n        if size == 0:\\n            # Empty list\\n            return 0\\n        \\n        elif size == 1:\\n            # Only one item\\n            return nums[0]\\n    \\n        else:\\n            # Initialization\\n            value_dp[0] = nums[0]\\n            value_dp[1] = max(nums[0], nums[1])\\n\\n            # General case\\n            for i in range(2, size):\\n                value_dp[i] = max(value_dp[i-2] + nums[i], value_dp[i-1] )\\n\\n            return value_dp[-1]\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        # Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        # refer to dp[i-2]\\n        take_prev_2 = 0\\n        \\n        # refer to dp[i-1]\\n        take_prev_1 = 0\\n        \\n\\t\\tprofit = 0\\n\\t\\t\\n        for number in nums:\\n            \\n            profit = max(take_prev_2 + number, take_prev_1 + 0)\\n            take_prev_2 = take_prev_1\\n            take_prev_1 = profit\\n        \\n      \\n        return profit\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        int take_prev_2 = 0;\\n        \\n        // refer to dp[i-1]\\n        int take_prev_1 = 0;\\n        \\n        int profit = 0;\\n        \\n        for(int value : nums){\\n            \\n            profit = Math.max(take_prev_2 + value, take_prev_1 + 0);\\n            take_prev_2 = take_prev_1;\\n            take_prev_1 = profit;\\n        }\\n      \\n        return profit;\\n    }\\n}\\n```\n```\\nvar rob = function(nums) {\\n    \\n    size = nums.length;\\n    value = Array(size).fill(0);\\n    \\n    if( size == 0 ){\\n        // empty input\\n        return 0;\\n        \\n    }else if( size == 1 ){\\n        // only one item\\n        return nums[0];\\n    }\\n    \\n    \\n    // initialization\\n    \\n    value[0] = nums[0];\\n    value[1] = Math.max( nums[0], nums[1] );\\n    \\n    // general case\\n    for( let i = 2 ; i < size ; i++){\\n        \\n        value[i] = Math.max( value[i-2] + nums[i],  value[i-1] + 0 );\\n    }\\n    \\n    return value[size-1];\\n};\\n```\n```\\nvar rob = function(nums) {\\n    \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        let take_prev_2 = 0\\n        \\n        // refer to dp[i-1]\\n        let take_prev_1 = 0\\n        \\n        let profit = 0;\\n        \\n        for(const value of nums){\\n            \\n            profit = Math.max(take_prev_2 + value, take_prev_1 + 0);\\n            take_prev_2 = take_prev_1;\\n            take_prev_1 = profit;\\n        }\\n      \\n        return profit\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        size_t size = nums.size() ;\\n        \\n        // dp table for maximum value\\n        vector<int> value = vector<int>( size );\\n        \\n        \\n        if( size == 0 ){\\n            // empty list\\n            return 0;\\n        }else if( size == 1 ){\\n            // only one item\\n            return nums[0];\\n        }\\n        \\n        // initialization\\n        value[0] = nums[0];\\n        value[1] = max(nums[0], nums[1]);\\n        \\n        // general cases\\n        for( size_t i = 2 ; i < size ; i++){\\n            value[i] = max( value[i-2] + nums[i], value[i-1] + 0 );\\n        }\\n        \\n        return value[size-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        int prev_2 = 0;\\n            \\n        // refer to dp[i-1]\\n        int prev_1 = 0;\\n        \\n        int profit = 0;\\n        \\n        for( const int& value : nums){\\n            \\n            profit = max( prev_2 + value, prev_1 + 0 );\\n            prev_2 = prev_1;\\n            prev_1 = profit;\\n        }\\n        \\n        return profit;\\n        \\n    }\\n};\\n```\n```\\n\\n// Golang does\\'t have natural built-in max function for integer type\\nfunc max(a, b int) int{\\n    if a >= b{\\n        return a\\n    }else{\\n        return b\\n    }\\n}\\n\\n\\n\\nfunc rob(nums []int) int {\\n    \\n    size := len(nums)\\n    value := make([]int, size)\\n    \\n    if size == 0{\\n        \\n        // empty input\\n        return 0\\n    }else if size == 1{\\n        \\n        // only one item\\n        return nums[0]\\n    }\\n    \\n    // initialization\\n    value[0] = nums[0]\\n    value[1] = max(nums[0], nums[1])\\n    \\n    // general case\\n    for i := 2 ; i < size ; i++ {\\n        value[i] = max( value[i-2] + nums[i], value[i-1] + 0 )\\n    }\\n    \\n    return value[size-1]\\n}\\n```\n```\\n\\n// Golang does\\'t have natural built-in max function for integer type\\nfunc max(a, b int) int{\\n    if a >= b{\\n        return a\\n    }else{\\n        return b\\n    }\\n}\\n\\n\\n\\nfunc rob(nums []int) int {\\n    \\n    // Since we only refer to previous two grids, we can carry out space optimization\\n    \\n    // refer to dp[i-2]\\n    prev_2 := 0\\n    \\n    // refer to dp[i-1]\\n    prev_1 := 0\\n    \\n    profit := 0\\n    \\n    for _, value := range nums{\\n        \\n        profit = max( prev_2 + value, prev_1 + 0 )\\n        \\n        prev_2, prev_1 = prev_1, profit\\n    }\\n    \\n    return profit\\n}\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        # DP table\\n        # key: index i \\n        # value: max rob value consider from 0 to i, inclusively\\n        dp = {}\\n\\n        def consider( i ):\\n\\n            # look-up table\\n            if i in dp:\\n                return dp[i]\\n            \\n            # base case\\n            if i == 0:\\n                dp[0] = nums[0]\\n                return dp[0]\\n            \\n            # base case\\n            if i == 1:\\n                dp[1] = max(nums[0], nums[1])\\n                return dp[1]\\n            \\n            # general case\\n            take = nums[i] + consider(i-2)\\n            skip = 0 + consider(i-1)\\n\\n            dp[i] = max( take, skip )\\n            return dp[i]\\n        # ----------------------------------------\\n        last_house = len(nums)-1\\n        return consider(last_house)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 405055,
                "title": "cpp-easy-100-beat-simple-3-line-code",
                "content": "```\\nint rob(vector<int>& nums) {\\n\\tint inc = 0, ex = 0;\\n\\tfor(auto it : nums){\\n\\t// To include current element need to exclude pre element\\n\\t\\tint ninc = ex + it;\\n\\t// to exlucde current we will take max upto previous\\n\\t\\tex = max(inc, ex), inc = ninc;\\n\\t}\\n\\treturn max(inc, ex);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint rob(vector<int>& nums) {\\n\\tint inc = 0, ex = 0;\\n\\tfor(auto it : nums){\\n\\t// To include current element need to exclude pre element\\n\\t\\tint ninc = ex + it;\\n\\t// to exlucde current we will take max upto previous\\n\\t\\tex = max(inc, ex), inc = ninc;\\n\\t}\\n\\treturn max(inc, ex);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 341554,
                "title": "python-dynamic-progranming",
                "content": "Run time O(N), space O(1)\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        nums[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            nums[i] = max((nums[i-2]+nums[i]), nums[i-1])\\n            print(nums)\\n        return nums[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        nums[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            nums[i] = max((nums[i-2]+nums[i]), nums[i-1])\\n            print(nums)\\n        return nums[-1]\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1704140,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1573183,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1570429,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1565038,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1875755,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1716458,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1576563,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1570165,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1565134,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1715861,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1704140,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1573183,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1570429,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1565038,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1875755,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1716458,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1576563,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1570165,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1565134,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1715861,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1715994,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1575589,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1567528,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1569324,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1980936,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1928954,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1716180,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1571419,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 2000829,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1997944,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1990293,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 1575574,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 1571418,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 1571876,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 1576035,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2073860,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2064659,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2063285,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2062784,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2055359,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2055038,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2054888,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2040689,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2039996,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2030878,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2020856,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2017306,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2015736,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2008023,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 1987582,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 1968226,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1965917,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1959854,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1959818,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1943030,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1931031,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1919156,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1913813,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1912791,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1887595,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1870127,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1859163,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1838674,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1827110,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1811514,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1808984,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1808598,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1805070,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1787847,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1771530,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1761746,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1760685,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1756396,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1752299,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1742752,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1740013,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1729489,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1721406,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1717295,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1716624,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1716533,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716245,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716220,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716014,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715955,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715881,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715872,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715756,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1690812,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678679,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]