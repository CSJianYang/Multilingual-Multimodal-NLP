[
    {
        "title": "Linked List Components",
        "question_content": "You are given the head of a linked list containing unique integer values and an integer array nums that is a subset of the linked list values.\nReturn the number of connected components in nums where two values are connected if they appear consecutively in the linked list.\n&nbsp;\nExample 1:\n\nInput: head = [0,1,2,3], nums = [0,1,3]\nOutput: 2\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\n\nExample 2:\n\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\nOutput: 2\nExplanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the linked list is n.\n\t1 <= n <= 104\n\t0 <= Node.val < n\n\tAll the values Node.val are unique.\n\t1 <= nums.length <= n\n\t0 <= nums[i] < n\n\tAll the values of nums are unique.",
        "solutions": [
            {
                "id": 123842,
                "title": "c-java-python-easy-and-concise-solution-with-explanation",
                "content": "Take second example in the description:\\nliked list: `0->1`->2->`3->4`\\nI highlighed the subset G in linked list with color red.\\nThe problem is just to count how many red part there are.\\nOne red part is one connected components.\\nTo do this, we just need to count tails of red parts.\\n\\n**C++:**\\n```\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```\\n**Java:**\\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> setG = new HashSet<>();\\n        for (int i: G) setG.add(i);\\n        int res = 0;\\n        while (head != null) {\\n            if (setG.contains(head.val) && (head.next == null || !setG.contains(head.next.val))) res++;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def numComponents(self, head, G):\\n        setG = set(G)\\n        res = 0\\n        while head:\\n            if head.val in setG and (head.next == None or head.next.val not in setG):\\n                res += 1\\n            head = head.next\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> setG = new HashSet<>();\\n        for (int i: G) setG.add(i);\\n        int res = 0;\\n        while (head != null) {\\n            if (setG.contains(head.val) && (head.next == null || !setG.contains(head.next.val))) res++;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def numComponents(self, head, G):\\n        setG = set(G)\\n        res = 0\\n        while head:\\n            if head.val in setG and (head.next == None or head.next.val not in setG):\\n                res += 1\\n            head = head.next\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 541885,
                "title": "a-thinking-on-how-to-understand-this-problem",
                "content": "The description is not clear, which makes it difficult to understand this problem. \\nOnce you understand this problem it is easy to solve.\\n\\nIf you use the concepts from Union-Find, it becomes easy to understand.\\nG is the initail state of a Union-Find problem, each number in G is a node, every nodes is disjointed from other nodes.\\nWhenever we Union two nodes, components decrease by 1. \\nHow do we know which two nodes to Union?  Description says \"two values are connected if they appear consecutively in the linked list.\" So we traverse the linked list, for each edge, if both vals are in G, we decrease components by 1. \\n\\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : G) set.add(n);\\n        \\n        ListNode cur = head;\\n        int res = set.size();\\n        while (cur.next != null) {\\n            if (set.contains(cur.val) && set.contains(cur.next.val)) res--;\\n            cur = cur.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : G) set.add(n);\\n        \\n        ListNode cur = head;\\n        int res = set.size();\\n        while (cur.next != null) {\\n            if (set.contains(cur.val) && set.contains(cur.next.val)) res--;\\n            cur = cur.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658560,
                "title": "c-easy-and-concise-solution-with-explanation",
                "content": "Our intuition behind this problem is to put the **nums** vector into a hashmap, and then interate over the linked-list and find if any node is in components (side by side) with another, which must be present in the **nums** vector!\\n\\n# Code:-\\n```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode *curr = head;\\n        unordered_map<int, bool> mpp;\\n        for(int i=0; i<nums.size(); i++)\\n            mpp[nums[i]] = true;\\n        int count = 0, streak = 0;\\n        while(curr) {\\n            if(mpp[curr->val]==true) {\\n                streak++;\\n            } else {\\n                if(streak>0) {\\n                    count++;\\n                }\\n                streak = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        if(streak>0) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```\\n\\nAt every position we\\'re taking a **streak** variable which updates and if the value of the Node was not in nums, then we check if the **streak** is greater than 0, if yes we increment the **count(final answer)**, and make the present **streak** back to 0.\\nFinally, we return the **count(ans)**.\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode *curr = head;\\n        unordered_map<int, bool> mpp;\\n        for(int i=0; i<nums.size(); i++)\\n            mpp[nums[i]] = true;\\n        int count = 0, streak = 0;\\n        while(curr) {\\n            if(mpp[curr->val]==true) {\\n                streak++;\\n            } else {\\n                if(streak>0) {\\n                    count++;\\n                }\\n                streak = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        if(streak>0) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123879,
                "title": "single-check-per-element",
                "content": "We increase our counter when we start a new connection:\\n- current item is in the list, and\\n- previous item is not (!connected).\\n\\nNote that this approach allows checking the set just once per an element.\\n\\n**C++**\\n```cpp\\nint numComponents(ListNode* h, vector<int>& nums) {\\n    unordered_set<int> s(begin(nums), end(nums));\\n    int res = 0, connected = 0;\\n    for (; h != nullptr; h = h->next) {\\n        if (s.count(h->val)) {\\n            res += !connected;\\n            connected = true;\\n        }\\n        else\\n            connected = false;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint numComponents(ListNode* h, vector<int>& nums) {\\n    unordered_set<int> s(begin(nums), end(nums));\\n    int res = 0, connected = 0;\\n    for (; h != nullptr; h = h->next) {\\n        if (s.count(h->val)) {\\n            res += !connected;\\n            connected = true;\\n        }\\n        else\\n            connected = false;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123889,
                "title": "python-using-two-pointers",
                "content": "```\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p, prev, count, G = head, False, 0, set(G)\\n        while p:\\n            if p.val in G and not prev:\\n                count += 1\\n            prev, p = p.val in G, p.next;\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p, prev, count, G = head, False, 0, set(G)\\n        while p:\\n            if p.val in G and not prev:\\n                count += 1\\n            prev, p = p.val in G, p.next;\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123918,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : G) {\\n            set.add(i);\\n        }\\n        int count = 0;\\n        while (head != null) {\\n            ListNode cur = head;\\n            boolean found = false;\\n            while (cur != null && set.contains(cur.val)) {\\n                found = true;\\n                cur = cur.next;\\n            }\\n            if (found) {\\n                count++;\\n            }\\n            head = cur == null ? cur : cur.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : G) {\\n            set.add(i);\\n        }\\n        int count = 0;\\n        while (head != null) {\\n            ListNode cur = head;\\n            boolean found = false;\\n            while (cur != null && set.contains(cur.val)) {\\n                found = true;\\n                cur = cur.next;\\n            }\\n            if (found) {\\n                count++;\\n            }\\n            head = cur == null ? cur : cur.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123855,
                "title": "c-one-traversal-using-unordered-set",
                "content": "    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> subset;\\n        int connected_components = 0;\\n        \\n        for(auto n : G)\\n            subset.insert(n);\\n        \\n        while(head) {\\n            if (subset.count(head->val) && (head->next == NULL || !subset.count(head->next->val)))\\n                connected_components++;\\n            head = head->next;\\n        }   \\n        return connected_components;\\n    }",
                "solutionTags": [],
                "code": "    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> subset;\\n        int connected_components = 0;\\n        \\n        for(auto n : G)\\n            subset.insert(n);\\n        \\n        while(head) {\\n            if (subset.count(head->val) && (head->next == NULL || !subset.count(head->next->val)))\\n                connected_components++;\\n            head = head->next;\\n        }   \\n        return connected_components;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2673359,
                "title": "easy-cpp-solution-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        map<int,int> hs ;\\n        \\n        for (auto i :nums)\\n            hs[i]++;\\n        \\n        ListNode* tmp = head;\\n        \\n        int ans = 0;\\n        \\n        while(tmp)\\n        {\\n            if(hs[tmp->val] !=0 )\\n            {\\n                while(tmp->next && hs[tmp->next->val] != 0 )\\n                {\\n                    tmp = tmp->next;\\n                }\\n                ans++;\\n            }\\n            tmp = tmp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        map<int,int> hs ;\\n        \\n        for (auto i :nums)\\n            hs[i]++;\\n        \\n        ListNode* tmp = head;\\n        \\n        int ans = 0;\\n        \\n        while(tmp)\\n        {\\n            if(hs[tmp->val] !=0 )\\n            {\\n                while(tmp->next && hs[tmp->next->val] != 0 )\\n                {\\n                    tmp = tmp->next;\\n                }\\n                ans++;\\n            }\\n            tmp = tmp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659231,
                "title": "java-easy-to-understand",
                "content": "**We\\'re given with**  the `head` of the LinkedList containing unique integer values and an integer `array` nums that is a subset(means all the element of array must be taken from LinkedList) of the linked list values.\\n**We\\'ve to find** the number of connected components in `nums array` where two values are connected if they appear  in the `linked list`.\\n**Understanding** `find` function\\nIt\\'s there to check if  the `ith` value of `nums array` and `LinkedList` are same. If it\\'s same then it will return `true` else `false`.\\n**Understanding** `numComponents` function\\nIn this function we\\'re traversing the entire LinkedList with the `head` node provided to us. While traversing we\\'ll keep on checking if the  `ith` value of `nums array` and `LinkedList` are same using the helper function (named: find). \\nIf we get true from the `find` function  then we will increase the count of `found`  by 1 and then we\\'ve to check if the count of `found` is 1 then it\\'s obvious that we got one connected component because if there will be 1 element then also we\\'ve to return 1 as number of connected components. \\nIf the `ith` value didn\\'t matched with the element of array and LinkedList then we\\'ve to assign 0 to `found counter` because we can\\'t have that answer,  according to the question: we have to return continous connected components but our continuety broke.\\n\\n\\n```\\nclass Solution {\\n    \\n\\t// helper function to check if the element of our LinkedList matches the element in the array\\n    public static boolean find(int[] arr, int target){\\n        for(int i=0; i<arr.length; i++){\\n            if(target == arr[i]){\\n\\t\\t\\t//returning true if it matches\\n                return true;\\n            }\\n        }\\n\\t\\t// returning false if itdoesn\\'t  matches any\\n        return false;\\n    } \\n    // given function\\n    public int numComponents(ListNode head, int[] nums) {\\n        int connected = 0;\\n        int found = 0;\\n\\t\\t\\n\\t\\t//traversing the linkedlist\\n        while(head != null){\\n            if(find(nums, head.val)){\\n\\t\\t\\t// if the element of array matched with LinkedList\\n\\t\\t\\t//then we will increase our found variable by 1\\n                found++;\\n\\t\\t\\t\\t// whenever we increase our found variable for the first time, it means we got atleast one connected item\\n                if(found == 1){\\n                    connected++;\\n                }\\n            }\\n\\t\\t\\t// Assigning found with 0 is imp because if we didn\\'t found any match then our found variable will increase everytime \\n\\t\\t\\t// And this will never allow the connected variable to increase. \\n            else{\\n                found=0;\\n            }\\n            head = head.next;\\n        }\\n\\t\\t//returning the number of count of how many times our found variable increased \\n        return connected;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\t// helper function to check if the element of our LinkedList matches the element in the array\\n    public static boolean find(int[] arr, int target){\\n        for(int i=0; i<arr.length; i++){\\n            if(target == arr[i]){\\n\\t\\t\\t//returning true if it matches\\n                return true;\\n            }\\n        }\\n\\t\\t// returning false if itdoesn\\'t  matches any\\n        return false;\\n    } \\n    // given function\\n    public int numComponents(ListNode head, int[] nums) {\\n        int connected = 0;\\n        int found = 0;\\n\\t\\t\\n\\t\\t//traversing the linkedlist\\n        while(head != null){\\n            if(find(nums, head.val)){\\n\\t\\t\\t// if the element of array matched with LinkedList\\n\\t\\t\\t//then we will increase our found variable by 1\\n                found++;\\n\\t\\t\\t\\t// whenever we increase our found variable for the first time, it means we got atleast one connected item\\n                if(found == 1){\\n                    connected++;\\n                }\\n            }\\n\\t\\t\\t// Assigning found with 0 is imp because if we didn\\'t found any match then our found variable will increase everytime \\n\\t\\t\\t// And this will never allow the connected variable to increase. \\n            else{\\n                found=0;\\n            }\\n            head = head.next;\\n        }\\n\\t\\t//returning the number of count of how many times our found variable increased \\n        return connected;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628700,
                "title": "c-clean-code-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n    if(nums.size()==1) return 1;  \\n    map<int,bool> mp;\\n    \\n    for(int ele : nums)  mp[ele]= true;\\n        \\n       int ans = 0;\\n       bool flag = false;  \\n       ListNode* tmp = head;\\n        \\n      while(tmp){\\n          int x = tmp->val;\\n          if(mp[x]){\\n              if(!flag) {ans++; flag= true;}\\n            }\\n          else flag = false;\\n          tmp = tmp->next;\\n      }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n    if(nums.size()==1) return 1;  \\n    map<int,bool> mp;\\n    \\n    for(int ele : nums)  mp[ele]= true;\\n        \\n       int ans = 0;\\n       bool flag = false;  \\n       ListNode* tmp = head;\\n        \\n      while(tmp){\\n          int x = tmp->val;\\n          if(mp[x]){\\n              if(!flag) {ans++; flag= true;}",
                "codeTag": "Java"
            },
            {
                "id": 1302687,
                "title": "java-5ms-using-hashset-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++) set.add(nums[i]);\\n        \\n        ListNode n=head;\\n        while(n!=null){\\n            if(n.next!=null){\\n                int v=n.next.val;\\n                if(set.contains(v)){\\n                    set.remove(n.val);\\n                }\\n            }\\n            n=n.next;\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++) set.add(nums[i]);\\n        \\n        ListNode n=head;\\n        while(n!=null){\\n            if(n.next!=null){\\n                int v=n.next.val;\\n                if(set.contains(v)){\\n                    set.remove(n.val);\\n                }\\n            }\\n            n=n.next;\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621553,
                "title": "using-unoredred-map-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>map(nums.begin(),nums.end());\\n        int ans = 0;\\n        bool lastMatch = 0;\\n        while(head){\\n            if( map.find(head->val) == map.end() ){\\n                lastMatch=0;\\n            }else{\\n                if(!lastMatch) {\\n                    ans++;\\n                    lastMatch=1;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>map(nums.begin(),nums.end());\\n        int ans = 0;\\n        bool lastMatch = 0;\\n        while(head){\\n            if( map.find(head->val) == map.end() ){\\n                lastMatch=0;\\n            }else{\\n                if(!lastMatch) {\\n                    ans++;\\n                    lastMatch=1;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545830,
                "title": "java-9ms-solution-82-faster-hashset-o-n-time-and-space-solution",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums) set.add(n);\\n        int components = 0, connected = 0;\\n        ListNode temp = head;\\n        \\n        while(temp != null){\\n            if(set.contains(temp.val))\\n               connected++; \\n            else if(connected > 0){\\n                components++;\\n                connected = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        if(connected == 0) return components;\\n        return components+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums) set.add(n);\\n        int components = 0, connected = 0;\\n        ListNode temp = head;\\n        \\n        while(temp != null){\\n            if(set.contains(temp.val))\\n               connected++; \\n            else if(connected > 0){\\n                components++;\\n                connected = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        if(connected == 0) return components;\\n        return components+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311593,
                "title": "c-best-approach-shortest-solution-tc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(),nums.end());\\n        \\n        ListNode*ptr=head;\\n        int count=0;\\n        int res=0;\\n        while(ptr){\\n            count=0;\\n            while(ptr && s.find(ptr->val)!=s.end()){\\n                count++;\\n                ptr=ptr->next;\\n            }\\n            if(count>0){\\n                res+=1;\\n            }\\n            if(ptr)ptr=ptr->next;\\n        }\\n        return res;\\n    }\\n};\\n// UPVOTE IF YOU LIKE : )\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(),nums.end());\\n        \\n        ListNode*ptr=head;\\n        int count=0;\\n        int res=0;\\n        while(ptr){\\n            count=0;\\n            while(ptr && s.find(ptr->val)!=s.end()){\\n                count++;\\n                ptr=ptr->next;\\n            }\\n            if(count>0){\\n                res+=1;\\n            }\\n            if(ptr)ptr=ptr->next;\\n        }\\n        return res;\\n    }\\n};\\n// UPVOTE IF YOU LIKE : )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465771,
                "title": "ez-python-code-using-sets",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        itr=head\\n        c=0\\n        s=set(nums)\\n        while itr:\\n            if itr.val in s and (itr.next==None or itr.next.val not in s):\\n                c+=1\\n            itr=itr.next\\n        return c\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        itr=head\\n        c=0\\n        s=set(nums)\\n        while itr:\\n            if itr.val in s and (itr.next==None or itr.next.val not in s):\\n                c+=1\\n            itr=itr.next\\n        return c\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456660,
                "title": "java-o-n-very-ez-approach-using-hashset",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet();\\n        for (int i = 0; i < nums.length; i ++) {\\n            numSet.add(nums[i]);\\n        }\\n        int count = 0;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            if (numSet.contains(curr.val)) {\\n                while (curr.next != null && numSet.contains(curr.next.val)) {\\n                    curr = curr.next;\\n                }\\n                count ++;\\n            }\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet();\\n        for (int i = 0; i < nums.length; i ++) {\\n            numSet.add(nums[i]);\\n        }\\n        int count = 0;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            if (numSet.contains(curr.val)) {\\n                while (curr.next != null && numSet.contains(curr.next.val)) {\\n                    curr = curr.next;\\n                }\\n                count ++;\\n            }\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933679,
                "title": "python3-counting-end-of-component",
                "content": "Algo \\nSince the problem is to count number of continuous components, one could count the beginning or end of a continuous piece. Here, to count the beginning is more tedious for the singly-linked list. Instead, we count the end of component like below. \\n\\nImplementation \\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gs = set(G)\\n        ans = 0\\n        while head: \\n            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1\\n            head = head.next \\n        return ans \\n```\\n\\nAnalysis\\nTime complexity `O(M+N)` where `M` is length of `G` and `N` is length of linked list\\nSpace complexity `O(M)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gs = set(G)\\n        ans = 0\\n        while head: \\n            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1\\n            head = head.next \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 672843,
                "title": "python3-simple-and-straightforward-o-n-soluiton",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        result = 0\\n        G = set(G)\\n        t = 0\\n        while head:\\n            if head.val in G:\\n                t+=1\\n            else:\\n                if t!=0:\\n                    result+=1\\n                    t = 0\\n            head = head.next\\n        if t!=0:\\n            result+=1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        result = 0\\n        G = set(G)\\n        t = 0\\n        while head:\\n            if head.val in G:\\n                t+=1\\n            else:\\n                if t!=0:\\n                    result+=1\\n                    t = 0\\n            head = head.next\\n        if t!=0:\\n            result+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936452,
                "title": "easy-c-solution-beats-99-users-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& v) {\\n        ListNode* temp=head;\\n        bool component=false;\\n        int counter=0;\\n       while(temp)\\n       {\\n            if(count(v.begin(),v.end(),temp->val)>0&& component==false)\\n            {\\n                counter++;\\n                component =true;\\n            }\\n            else if( !count(v.begin(),v.end(),temp->val))\\n            component=false;\\n           temp=temp->next;\\n       }\\n       return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& v) {\\n        ListNode* temp=head;\\n        bool component=false;\\n        int counter=0;\\n       while(temp)\\n       {\\n            if(count(v.begin(),v.end(),temp->val)>0&& component==false)\\n            {\\n                counter++;\\n                component =true;\\n            }\\n            else if( !count(v.begin(),v.end(),temp->val))\\n            component=false;\\n           temp=temp->next;\\n       }\\n       return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925563,
                "title": "letcode-solution-beats-86-online-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,bool>m;\\n        for(auto it : nums){\\n            m[it] = true;\\n        }\\n        int ct = 0;\\n        ListNode* temp = head;\\n\\n        bool flag = false;\\n\\n        while(temp){\\n            if(m[temp -> val]){\\n                flag = true;\\n            }\\n            else{\\n                if(flag){\\n                    flag = false;\\n                    ct++;\\n                }\\n            }\\n            temp = temp -> next;\\n        }\\n        if(flag) ct++;\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,bool>m;\\n        for(auto it : nums){\\n            m[it] = true;\\n        }\\n        int ct = 0;\\n        ListNode* temp = head;\\n\\n        bool flag = false;\\n\\n        while(temp){\\n            if(m[temp -> val]){\\n                flag = true;\\n            }\\n            else{\\n                if(flag){\\n                    flag = false;\\n                    ct++;\\n                }\\n            }\\n            temp = temp -> next;\\n        }\\n        if(flag) ct++;\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652569,
                "title": "easiest-python-solution",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\t\\n        pointer = head\\n\\t\\t#prev is the pointer that stores boolean value: if the previous node\\'s value exists in the nums list\\n        prev = None\\n        counter = 0\\n        while pointer != None:\\n\\t\\t\\t#check if pointer\\'s value exist in the nums list\\n            if pointer.val in nums:\\n                if not prev:\\n\\t\\t\\t\\t\\t#increase counter if only previous node\\'s value doesn\\'t exist in list,ie, prev=False\\n                    counter += 1\\n\\t\\t\\t\\t#set prev as True for next node\\t\\n                prev = True\\n            else:\\n\\t\\t\\t\\t#set prev as False for next node\\n                prev = False\\n            pointer = pointer.next\\n        return counter\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\t\\n        pointer = head\\n\\t\\t#prev is the pointer that stores boolean value: if the previous node\\'s value exists in the nums list\\n        prev = None\\n        counter = 0\\n        while pointer != None:\\n\\t\\t\\t#check if pointer\\'s value exist in the nums list\\n            if pointer.val in nums:\\n                if not prev:\\n\\t\\t\\t\\t\\t#increase counter if only previous node\\'s value doesn\\'t exist in list,ie, prev=False\\n                    counter += 1\\n\\t\\t\\t\\t#set prev as True for next node\\t\\n                prev = True\\n            else:\\n\\t\\t\\t\\t#set prev as False for next node\\n                prev = False\\n            pointer = pointer.next\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289937,
                "title": "java-easy-set",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        int n = nums.length;\\n        int components = 0;\\n        Set<Integer> numsSet = new HashSet<>();\\n        for(int num : nums) {\\n            numsSet.add(num);\\n        }\\n        \\n        while(head != null) {\\n            boolean isPresentNode = false;\\n            while(head != null && numsSet.contains(head.val)) {\\n                isPresentNode = true;\\n                head = head.next;\\n            }\\n            \\n            if(isPresentNode) {\\n                components++;\\n            } if(head!=null) {\\n                head = head.next;\\n            }\\n        }\\n        \\n        return components;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        int n = nums.length;\\n        int components = 0;\\n        Set<Integer> numsSet = new HashSet<>();\\n        for(int num : nums) {\\n            numsSet.add(num);\\n        }\\n        \\n        while(head != null) {\\n            boolean isPresentNode = false;\\n            while(head != null && numsSet.contains(head.val)) {\\n                isPresentNode = true;\\n                head = head.next;\\n            }\\n            \\n            if(isPresentNode) {\\n                components++;\\n            } if(head!=null) {\\n                head = head.next;\\n            }\\n        }\\n        \\n        return components;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898261,
                "title": "easy-solution-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        vector<int>v(10001,0);\\n        if(!head)\\n            return 0;\\n        for(auto i:nums)\\n        {\\n            v[i]=1;\\n        }\\n        int cnt=0;\\n        while(head)\\n        {\\n            if(v[head->val]==1)\\n            {\\n                while(head and v[head->val]==1)\\n                {\\n                    head=head->next;\\n                } \\n                cnt++;\\n            }\\n            else                \\n                head=head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Upvote if it helped :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        vector<int>v(10001,0);\\n        if(!head)\\n            return 0;\\n        for(auto i:nums)\\n        {\\n            v[i]=1;\\n        }\\n        int cnt=0;\\n        while(head)\\n        {\\n            if(v[head->val]==1)\\n            {\\n                while(head and v[head->val]==1)\\n                {\\n                    head=head->next;\\n                } \\n                cnt++;\\n            }\\n            else                \\n                head=head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695600,
                "title": "c-solution-better-memory-usage-than-99-49",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(!head) return 0;\\n        if(!head->next) return 1;\\n        \\n        int count = 0;\\n        bool consecutive=false;\\n        while(head){\\n            if(find(nums.begin(), nums.end(), head->val) != nums.end()){\\n                if(!consecutive) count++;\\n                consecutive = true;\\n            }else{\\n                consecutive = false;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(!head) return 0;\\n        if(!head->next) return 1;\\n        \\n        int count = 0;\\n        bool consecutive=false;\\n        while(head){\\n            if(find(nums.begin(), nums.end(), head->val) != nums.end()){\\n                if(!consecutive) count++;\\n                consecutive = true;\\n            }else{\\n                consecutive = false;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673692,
                "title": "simple-beginner-s-solution-using-vector-with-comment",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        //Initializing vector\\n        vector<int> v(10001,0);\\n        for(int i=0;i<nums.size();i++){\\n            v[nums[i]]=1;\\n        }\\n        int ans=0;\\n        while(head){ //Iterate linked list\\n            if(v[head->val]){ \\n        //if the val in node is present in nums array checking if the consecutives nodes vals are present in nums.\\n            while(head && v[head->val]){\\n                head=head->next;\\n            }\\n            //For all the consecutive nodes and their val present in nums we increase ans by 1 (1-component).\\n                ans++;\\n            }\\n            if(head && head->next) head=head->next; //Iterating the linked list \\n            else break; //handling null node which we might get from previous while loop\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        //Initializing vector\\n        vector<int> v(10001,0);\\n        for(int i=0;i<nums.size();i++){\\n            v[nums[i]]=1;\\n        }\\n        int ans=0;\\n        while(head){ //Iterate linked list\\n            if(v[head->val]){ \\n        //if the val in node is present in nums array checking if the consecutives nodes vals are present in nums.\\n            while(head && v[head->val]){\\n                head=head->next;\\n            }\\n            //For all the consecutive nodes and their val present in nums we increase ans by 1 (1-component).\\n                ans++;\\n            }\\n            if(head && head->next) head=head->next; //Iterating the linked list \\n            else break; //handling null node which we might get from previous while loop\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236331,
                "title": "this-is-probably-the-most-unclear-question-i-ever-came-across",
                "content": "**First thoughts on the prompt** : We basically have to check if each consecutive nodes possess values that are present in the subset and return the count of such connected components.\\n\\nBut then I look at example 1, which says:\\n```Input: \\nhead: 0->1->2->3\\nnums = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```\\n3 is connected to what? For a moment lets suppose that in such cases the last node would be treated as in individual candidate since it possess a value present in the subset and it connects to **Null**. Cool?\\n\\nExample 2 also complies with our assumption and original prompt.\\n```Input: \\nhead: 0->1->2->3->4\\nnums = [0, 3, 1, 4]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\\n```\\nWhich is clear.\\n\\nTherefore I wrote the code below and checked it against a custom output.\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count, nums, flag = 0, set(nums), 0\\n        while head.next:\\n            if head.val in nums and head.next.val in nums:\\n                count += 1\\n                flag = 1\\n            else:\\n                flag = 0\\n            head = head.next\\n        if flag == 1:\\n            return count\\n        return count+1 if head.val in nums else count\\n```\\nIt passes for all our assumptions but when checked against a custom output, which was:\\n```\\nWrong Answer Runtime: 26 ms\\nYour input\\n[0,1,2]\\n[0,2]\\nOutput\\n1\\nExpected\\n2\\n```\\nWhy does it expect **2** as a result coz it is clear that combining the prompt and assumption, only the last node is eligible to be counted (as an individual node).  \\n  \\nPlease walk me through if I\\'m going wrong.\\n",
                "solutionTags": [],
                "code": "```Input: \\nhead: 0->1->2->3\\nnums = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```\n```Input: \\nhead: 0->1->2->3->4\\nnums = [0, 3, 1, 4]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\\n```\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count, nums, flag = 0, set(nums), 0\\n        while head.next:\\n            if head.val in nums and head.next.val in nums:\\n                count += 1\\n                flag = 1\\n            else:\\n                flag = 0\\n            head = head.next\\n        if flag == 1:\\n            return count\\n        return count+1 if head.val in nums else count\\n```\n```\\nWrong Answer Runtime: 26 ms\\nYour input\\n[0,1,2]\\n[0,2]\\nOutput\\n1\\nExpected\\n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160065,
                "title": "easy-c-approach",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& g) {\\n        if(head==NULL or g.size()<=1) {\\n            return 1;\\n        }\\n        \\n        unordered_set<int> out;\\n        \\n        for(int i=0; i<g.size(); i++) {\\n            out.insert(g[i]);\\n        }\\n        \\n        ListNode*curr = head;\\n        int ans = 0;\\n        \\n        while(curr) {\\n            if(out.count(curr->val)) {\\n                ans++;\\n\\n                while(curr->next and out.count(curr->next->val)) {\\n                    curr = curr->next;\\n                }                \\n            } \\n            curr = curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& g) {\\n        if(head==NULL or g.size()<=1) {\\n            return 1;\\n        }\\n        \\n        unordered_set<int> out;\\n        \\n        for(int i=0; i<g.size(); i++) {\\n            out.insert(g[i]);\\n        }\\n        \\n        ListNode*curr = head;\\n        int ans = 0;\\n        \\n        while(curr) {\\n            if(out.count(curr->val)) {\\n                ans++;\\n\\n                while(curr->next and out.count(curr->next->val)) {\\n                    curr = curr->next;\\n                }                \\n            } \\n            curr = curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606715,
                "title": "my-cpp-soln-using-hasmap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_map<int,int> mp;\\n        int count = 0;\\n        for(auto a:G)\\n        {\\n            mp[a]++;\\n        }\\n        while(head)\\n        {\\n            bool flag = false;\\n            while(mp[head->val]!=0)\\n            {\\n                mp[head->val]--;\\n                head = head->next;\\n                flag = true;\\n                if(!head)\\n                {\\n                    return ++count;\\n                }\\n            }\\n            if(flag) count++;\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_map<int,int> mp;\\n        int count = 0;\\n        for(auto a:G)\\n        {\\n            mp[a]++;\\n        }\\n        while(head)\\n        {\\n            bool flag = false;\\n            while(mp[head->val]!=0)\\n            {\\n                mp[head->val]--;\\n                head = head->next;\\n                flag = true;\\n                if(!head)\\n                {\\n                    return ++count;\\n                }\\n            }\\n            if(flag) count++;\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178928,
                "title": "javascript-solution",
                "content": "The description doesn\\'t explain the problem well, for an explanation of what they\\'re looking click  [here](http://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case/167790). What we\\'re looking for is nodes (or groups of nodes) that are in G but not connected to each other. \\n\\nIn my solution I have a notConnected variable and a counter variable. \\n\\nFor the first node in the linked list that is in G we will increment the counter by one and set notConnected to false. \\n\\nWhen we find a node that is not in G we have found a break in the chain. We set notConnected to true. Now if we find another node that is in G we can increment the counter again.\\n\\n```\\n    let notConnected = true;\\n    let counter = 0;\\n    \\n    while(head){\\n        if (G.includes(head.val) && notConnected){\\n            counter++;\\n            notConnected = false;\\n        } else if (!G.includes(head.val)){\\n            notConnected = true;\\n        }\\n        head = head.next\\n    }\\n    \\n    return counter;\\n```",
                "solutionTags": [],
                "code": "```\\n    let notConnected = true;\\n    let counter = 0;\\n    \\n    while(head){\\n        if (G.includes(head.val) && notConnected){\\n            counter++;\\n            notConnected = false;\\n        } else if (!G.includes(head.val)){\\n            notConnected = true;\\n        }\\n        head = head.next\\n    }\\n    \\n    return counter;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477753,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* cur = head;\\n        int n = 0;\\n        while (cur) {\\n            n++;\\n            cur = cur->next;\\n        }\\n        std::vector<int> found (n);\\n        for (auto& val : nums) {\\n            found[val] = 1;\\n        }\\n        int ans = 0;\\n        cur = head;\\n        bool connected = false;\\n        while (cur) {\\n            if (connected and found[cur->val] == 0) {\\n                ans++;\\n                connected = false;\\n            }\\n            else if (!connected and found[cur->val] == 1) {\\n                connected = true;\\n            }\\n            cur = cur->next;\\n        }\\n        if (connected) {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        numsSet:set = {num for num in nums}\\n        \\n        isInLoop = False\\n        componentsCounter = 0\\n        \\n        while (head != None):\\n            if head.val in numsSet:\\n                isInLoop = True\\n            else:\\n                if isInLoop:\\n                    componentsCounter += 1\\n                    isInLoop = False\\n            head = head.next\\n        \\n        if isInLoop:\\n            return componentsCounter+1\\n        return componentsCounter \\n```\\n\\n```Java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        boolean[] map = new boolean[10001];\\n        for (int num : nums) {\\n            map[num] = true;\\n        }\\n        ListNode it = head;\\n        int counter = 0;\\n        int len = 0;\\n        while (it != null) {\\n            if (map[it.val]) {\\n                len++;\\n            }\\n            else {\\n                if (len != 0) {\\n                    counter++;\\n                }\\n                len = 0;\\n            }\\n            it = it.next;\\n        }\\n        if (len != 0) {\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* cur = head;\\n        int n = 0;\\n        while (cur) {\\n            n++;\\n            cur = cur->next;\\n        }\\n        std::vector<int> found (n);\\n        for (auto& val : nums) {\\n            found[val] = 1;\\n        }\\n        int ans = 0;\\n        cur = head;\\n        bool connected = false;\\n        while (cur) {\\n            if (connected and found[cur->val] == 0) {\\n                ans++;\\n                connected = false;\\n            }\\n            else if (!connected and found[cur->val] == 1) {\\n                connected = true;\\n            }\\n            cur = cur->next;\\n        }\\n        if (connected) {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        numsSet:set = {num for num in nums}\\n        \\n        isInLoop = False\\n        componentsCounter = 0\\n        \\n        while (head != None):\\n            if head.val in numsSet:\\n                isInLoop = True\\n            else:\\n                if isInLoop:\\n                    componentsCounter += 1\\n                    isInLoop = False\\n            head = head.next\\n        \\n        if isInLoop:\\n            return componentsCounter+1\\n        return componentsCounter \\n```\n```Java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        boolean[] map = new boolean[10001];\\n        for (int num : nums) {\\n            map[num] = true;\\n        }\\n        ListNode it = head;\\n        int counter = 0;\\n        int len = 0;\\n        while (it != null) {\\n            if (map[it.val]) {\\n                len++;\\n            }\\n            else {\\n                if (len != 0) {\\n                    counter++;\\n                }\\n                len = 0;\\n            }\\n            it = it.next;\\n        }\\n        if (len != 0) {\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446312,
                "title": "0-n-simple-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        ListNode parent = null;\\n        int count=0;\\n        Set<Integer> hashset = new HashSet<Integer>();\\n\\n        for(int i : nums){\\n            hashset.add(i);\\n        }\\n\\n        while(curr!=null){\\n\\n            if(parent==null && curr!=null){\\n                if(hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n            else{\\n                if(!hashset.contains(parent.val) && hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n\\n            parent = curr;\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        ListNode parent = null;\\n        int count=0;\\n        Set<Integer> hashset = new HashSet<Integer>();\\n\\n        for(int i : nums){\\n            hashset.add(i);\\n        }\\n\\n        while(curr!=null){\\n\\n            if(parent==null && curr!=null){\\n                if(hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n            else{\\n                if(!hashset.contains(parent.val) && hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n\\n            parent = curr;\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323499,
                "title": "c-easy-intermidate-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(auto it: nums) s.insert(it);\\n        bool conn=false;\\n        int total=0;\\n        while(head){\\n            int val= head->val;\\n            if(s.count(val)&& conn==false){\\n                conn=true;\\n                total++;\\n            }\\n            else if(s.count(val)==0&& conn==true)conn=false;\\n            head=head->next;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(auto it: nums) s.insert(it);\\n        bool conn=false;\\n        int total=0;\\n        while(head){\\n            int val= head->val;\\n            if(s.count(val)&& conn==false){\\n                conn=true;\\n                total++;\\n            }\\n            else if(s.count(val)==0&& conn==true)conn=false;\\n            head=head->next;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302514,
                "title": "easy-solution-o-n-space-and-time-complexity",
                "content": "\\n> # Approach\\nWe need to find number of contigious subsequent element in the linked list which are exist in the array.To check the element exist in the array or not on O(1) time complexity ,hashing is the better way for that so i have created a hashset and add all array elements into it.Now by traversing the linked list ones we can find the number of continious sequence of elements easily.\\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hash = new HashSet<>();\\n        for(int itr : nums){\\n            hash.add(itr);\\n        }\\n        int common = 0;\\n        int size = 0;\\n        while(head!=null){\\n            if(hash.contains(head.val)){\\n                size++;\\n            }\\n            else{\\n                if(size>0){\\n                    common++;\\n                }\\n                size=0;\\n            }\\n            head=head.next;\\n        }\\n        if(size>0){\\n            common+=1;\\n        }\\n        return common;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hash = new HashSet<>();\\n        for(int itr : nums){\\n            hash.add(itr);\\n        }\\n        int common = 0;\\n        int size = 0;\\n        while(head!=null){\\n            if(hash.contains(head.val)){\\n                size++;\\n            }\\n            else{\\n                if(size>0){\\n                    common++;\\n                }\\n                size=0;\\n            }\\n            head=head.next;\\n        }\\n        if(size>0){\\n            common+=1;\\n        }\\n        return common;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094168,
                "title": "java-using-hashset-easy-and-explained-beats-95",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        // Using Set to store the nums values\\n        HashSet<Integer> set = new HashSet<>();\\n    \\n        int count =0;\\n        for(int num: nums)\\n        {\\n            set.add(num);\\n        }\\n        boolean flag = false;\\n        \\n        // we just check if the value occurs in the set and keep it flowing till we dont find the value in the set \\n        \\n        while(curr!=null)\\n        {\\n            while(curr!=null && set.contains(curr.val))\\n            {\\n                flag = true;\\n                curr = curr.next;\\n            }\\n            \\n            \\n            if(flag == true)\\n                count++;\\n           \\n            // reseting the flag \\n            flag = false;\\n            \\n        \\n            if(curr!=null)\\n            curr = curr.next;\\n            \\n        }\\n\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        // Using Set to store the nums values\\n        HashSet<Integer> set = new HashSet<>();\\n    \\n        int count =0;\\n        for(int num: nums)\\n        {\\n            set.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3035281,
                "title": "c-beginner-friendly-map",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for(auto x : nums) seen.insert(x);\\n\\n        int answer = 0, cnt = 0;\\n        while(head) {\\n            if(seen.count(head->val)) cnt++;\\n            else {\\n                if(cnt) answer++;\\n                cnt = 0;\\n            }\\n            head = head -> next;\\n        }\\n        if(cnt) answer++;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for(auto x : nums) seen.insert(x);\\n\\n        int answer = 0, cnt = 0;\\n        while(head) {\\n            if(seen.count(head->val)) cnt++;\\n            else {\\n                if(cnt) answer++;\\n                cnt = 0;\\n            }\\n            head = head -> next;\\n        }\\n        if(cnt) answer++;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975596,
                "title": "c-faster-than-90-hashing-easy-implementation-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n\\n       unordered_map<int,bool>mpp;\\n\\n       for(auto &it : nums) mpp[it] = true;\\n\\n       int res = nums.size();\\n       int cnt = 0;\\n\\n       while(head != NULL)\\n       {\\n           if(mpp[head->val] == true) cnt++;\\n\\n           else\\n           {\\n             if(cnt > 1) res -= cnt - 1;\\n             cnt = 0;   \\n           }\\n           head = head->next;\\n       } \\n\\n       if(cnt > 1) res -= cnt - 1;\\n\\n       return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n\\n       unordered_map<int,bool>mpp;\\n\\n       for(auto &it : nums) mpp[it] = true;\\n\\n       int res = nums.size();\\n       int cnt = 0;\\n\\n       while(head != NULL)\\n       {\\n           if(mpp[head->val] == true) cnt++;\\n\\n           else\\n           {\\n             if(cnt > 1) res -= cnt - 1;\\n             cnt = 0;   \\n           }\\n           head = head->next;\\n       } \\n\\n       if(cnt > 1) res -= cnt - 1;\\n\\n       return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741690,
                "title": "java-1ms-runtime-faster-than-100",
                "content": "``` java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        // finding max element\\n        int max=0;\\n        for(int x:nums){\\n            max= Math.max(max,x);\\n        }\\n        // Create an array to check whether the element is present in nums or not or we can use HashSet\\n        boolean[] isPresent = new boolean[max+1];\\n        \\n        for(int x:nums)\\n            isPresent[x]=true;\\n        \\n        int count=0, components=0;\\n    \\n        // Traverse the linked list\\n        while(head!=null)\\n        {\\n            // Increase counter if the current value is present in nums array\\n            if(head.val<=max && isPresent[head.val]){\\n                count++;\\n            }\\n            else{\\n                // If there are more than one adjacent element in a component, Increase component count and reset counter.\\n                if(count>0){\\n                    components++; \\n                    count=0;\\n                }\\n            }\\n            head=head.next;\\n        }\\n        // Check if there is any remaining component at the end of the linked list\\n        if(count>0)\\n            components++;\\n        return components;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        // finding max element\\n        int max=0;\\n        for(int x:nums){\\n            max= Math.max(max,x);\\n        }\\n        // Create an array to check whether the element is present in nums or not or we can use HashSet\\n        boolean[] isPresent = new boolean[max+1];\\n        \\n        for(int x:nums)\\n            isPresent[x]=true;\\n        \\n        int count=0, components=0;\\n    \\n        // Traverse the linked list\\n        while(head!=null)\\n        {\\n            // Increase counter if the current value is present in nums array\\n            if(head.val<=max && isPresent[head.val]){\\n                count++;\\n            }\\n            else{\\n                // If there are more than one adjacent element in a component, Increase component count and reset counter.\\n                if(count>0){\\n                    components++; \\n                    count=0;\\n                }\\n            }\\n            head=head.next;\\n        }\\n        // Check if there is any remaining component at the end of the linked list\\n        if(count>0)\\n            components++;\\n        return components;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542916,
                "title": "89-tc-and-77-sc-easy-python-solution",
                "content": "```\\ndef numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\tcurr = head\\n\\tans = 0\\n\\ts = set(nums)\\n\\twhile(curr):\\n\\t\\tif(curr.val in s and not(curr.next and curr.next.val in s)):\\n\\t\\t\\tans += 1\\n\\t\\tcurr = curr.next\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\ndef numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\tcurr = head\\n\\tans = 0\\n\\ts = set(nums)\\n\\twhile(curr):\\n\\t\\tif(curr.val in s and not(curr.next and curr.next.val in s)):\\n\\t\\t\\tans += 1\\n\\t\\tcurr = curr.next\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2334662,
                "title": "java-o-n-hashset-easy-understanding",
                "content": "\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int ans = 0;\\n\\n        while (head != null) {\\n            if (set.contains(head.val)){\\n                ans++;\\n                while (head != null && set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            } else {\\n                while (head != null && !set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int ans = 0;\\n\\n        while (head != null) {\\n            if (set.contains(head.val)){\\n                ans++;\\n                while (head != null && set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            } else {\\n                while (head != null && !set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1946978,
                "title": "intuitive-and-consice-python-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        nums = set(nums)\\n        cur = head\\n        res = 0\\n        connected = False\\n        \\n        while cur:\\n            if cur.val in nums:\\n                if not connected:\\n                    res += 1\\n                    connected = True\\n            else:\\n                connected = False\\n            cur = cur.next\\n            \\n        return(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        nums = set(nums)\\n        cur = head\\n        res = 0\\n        connected = False\\n        \\n        while cur:\\n            if cur.val in nums:\\n                if not connected:\\n                    res += 1\\n                    connected = True\\n            else:\\n                connected = False\\n            cur = cur.next\\n            \\n        return(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829845,
                "title": "linked-list-easy-code",
                "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        if(head == NULL) return false ;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow==fast) return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        if(head == NULL) return false ;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow==fast) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1689039,
                "title": "c-solution",
                "content": "Map the componets to get if numbers present in array.\\nTraverse Linked List, and keep updating count accordingly.\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i: nums)\\n            mp[i]++;\\n        int count=0;\\n        ListNode* tmp = head;\\n        int prev=0;\\n        while(tmp!=NULL)\\n        {\\n            if(mp[tmp->val]!=0)\\n            {\\n                if(prev==0)\\n                    prev=1,count++;\\n            }\\n            else\\n                prev=0;\\n            tmp=tmp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i: nums)\\n            mp[i]++;\\n        int count=0;\\n        ListNode* tmp = head;\\n        int prev=0;\\n        while(tmp!=NULL)\\n        {\\n            if(mp[tmp->val]!=0)\\n            {\\n                if(prev==0)\\n                    prev=1,count++;\\n            }\\n            else\\n                prev=0;\\n            tmp=tmp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628810,
                "title": "new-approach-and-easy-using-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans = 0;\\n\\t\\t\\n        unordered_set<int> st(nums.begin(),nums.end()); \\n\\t\\t\\n        for(ListNode * i = head;i != NULL;i = i->next){\\n\\t\\t\\n            //check last node for all possible components \\n            //so increse ans if node is last or next node of the current node is not present in nums vector\\n            if(st.count(i->val) and (!i->next or !st.count(i->next->val)))\\n                ans++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans = 0;\\n\\t\\t\\n        unordered_set<int> st(nums.begin(),nums.end()); \\n\\t\\t\\n        for(ListNode * i = head;i != NULL;i = i->next){\\n\\t\\t\\n            //check last node for all possible components \\n            //so increse ans if node is last or next node of the current node is not present in nums vector\\n            if(st.count(i->val) and (!i->next or !st.count(i->next->val)))\\n                ans++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584918,
                "title": "c-solution-using-hashmap",
                "content": "```\\n int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto &i:nums){\\n            mp[i]++;\\n        }\\n        int count=0;\\n        while(head!=NULL){\\n            if(mp[head->val]!=0){\\n                while(head!=NULL && mp[head->val]!=0){\\n                    head=head->next;\\n                }\\n                count++;\\n            }\\n            else{\\n                head=head->next;\\n            }\\n        }\\n        return count;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto &i:nums){\\n            mp[i]++;\\n        }\\n        int count=0;\\n        while(head!=NULL){\\n            if(mp[head->val]!=0){\\n                while(head!=NULL && mp[head->val]!=0){\\n                    head=head->next;\\n                }\\n                count++;\\n            }\\n            else{\\n                head=head->next;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312496,
                "title": "c-simple-single-pass",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n         int ans=0;\\n        unordered_set<int>st;\\n        for(auto & i:nums)\\n            st.insert(i);\\n        while(head)\\n        {\\n            if(st.find(head->val)!=st.end())\\n            {\\n                ans++;\\n                while( head && st.find(head->val)!=st.end())\\n                    head=head->next;\\n            }\\n            else\\n                head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo UPVOTE if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n         int ans=0;\\n        unordered_set<int>st;\\n        for(auto & i:nums)\\n            st.insert(i);\\n        while(head)\\n        {\\n            if(st.find(head->val)!=st.end())\\n            {\\n                ans++;\\n                while( head && st.find(head->val)!=st.end())\\n                    head=head->next;\\n            }\\n            else\\n                head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214392,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        int ctr=0;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int n : G){\\n            set.add(n);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                ctr++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return ctr;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        int ctr=0;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int n : G){\\n            set.add(n);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                ctr++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return ctr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200557,
                "title": "c-simple-easy-to-understand-solution-o-n",
                "content": "* We use unordered_set so that the searching of element takes constant (O(1)) time.\\n* Then we traverse over the list, and if the current element is present in the set then we make our check variable (x), 1, otherwise, we can increase our result variable based on the condition that whether we found the previous element in the set or not.\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        \\n        int res = 0, x = 0;\\n        for(auto p = head; p; p = p->next) {\\n            bool check = s.find(p->val) != s.end();\\n            if(x == 1 || check)\\n                check ? x = 1 : (res++, x = 0);\\n        }\\n        return res + (x == 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        \\n        int res = 0, x = 0;\\n        for(auto p = head; p; p = p->next) {\\n            bool check = s.find(p->val) != s.end();\\n            if(x == 1 || check)\\n                check ? x = 1 : (res++, x = 0);\\n        }\\n        return res + (x == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820313,
                "title": "c-95-87-easy-to-understand",
                "content": "***Runtime: 52 ms, faster than 95.87% of C++ online submissions for Linked List Components.\\nMemory Usage: 21.4 MB, less than 80.14% of C++ online submissions for Linked List Components.***\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> elements(G.begin(), G.end());\\n        int result = 0;\\n        while(head){\\n            if(elements.count(head->val)){\\n                result++;\\n                while(head->next && elements.count(head->next->val)){\\n                   head = head->next; \\n                }\\n            }\\n            head = head->next; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> elements(G.begin(), G.end());\\n        int result = 0;\\n        while(head){\\n            if(elements.count(head->val)){\\n                result++;\\n                while(head->next && elements.count(head->next->val)){\\n                   head = head->next; \\n                }\\n            }\\n            head = head->next; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764360,
                "title": "c-clean-readable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> lookup(begin(G), end(G));\\n        int count = 0;\\n        auto curNode = head;\\n        \\n        while (curNode) {\\n            auto nextNode = curNode->next;\\n            \\n            if (lookup.count(curNode->val))\\n                if (!nextNode or !lookup.count(nextNode->val))\\n                    count++;\\n            \\n            curNode = nextNode;\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> lookup(begin(G), end(G));\\n        int count = 0;\\n        auto curNode = head;\\n        \\n        while (curNode) {\\n            auto nextNode = curNode->next;\\n            \\n            if (lookup.count(curNode->val))\\n                if (!nextNode or !lookup.count(nextNode->val))\\n                    count++;\\n            \\n            curNode = nextNode;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 645465,
                "title": "c-clean-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        \\n        ListNode* r = head;\\n        unordered_set<int>s(G.begin(), G.end());\\n        int count = 0;\\n        while (r) {\\n            if (s.find(r->val) != s.end() && (r->next == NULL || s.find(r->next->val) == s.end()))\\n                count++;\\n            r = r->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        \\n        ListNode* r = head;\\n        unordered_set<int>s(G.begin(), G.end());\\n        int count = 0;\\n        while (r) {\\n            if (s.find(r->val) != s.end() && (r->next == NULL || s.find(r->next->val) == s.end()))\\n                count++;\\n            r = r->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468700,
                "title": "python-3-three-lines-108-ms",
                "content": "```\\nclass Solution:\\n    def numComponents(self, H: ListNode, G: List[int]) -> int:\\n        S, c = set(G), 0\\n        while H != None: c, H = c + (H.val in S and (H.next == None or H.next.val not in S)), H.next\\n        return c\\n\\t\\t\\n\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, H: ListNode, G: List[int]) -> int:\\n        S, c = set(G), 0\\n        while H != None: c, H = c + (H.val in S and (H.next == None or H.next.val not in S)), H.next\\n        return c\\n\\t\\t\\n\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 452897,
                "title": "single-traversal-constant-space-easy-and-concise",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n  if(!head) return null;\\n  let GSet = new Set(G);  \\n  let ret = 0, series = 0;\\n  while(head) {\\n    series = GSet.has(head.val) ? series + 1 : 0;\\n    if(series == 1)\\n      ret += 1;\\n    head = head.next;\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n  if(!head) return null;\\n  let GSet = new Set(G);  \\n  let ret = 0, series = 0;\\n  while(head) {\\n    series = GSet.has(head.val) ? series + 1 : 0;\\n    if(series == 1)\\n      ret += 1;\\n    head = head.next;\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399773,
                "title": "go-golang",
                "content": "```\\n/**\\n * Approach: Count The End Node of Component\\n * Intuition\\n * Instead of thinking about connected components in G, think about them in the linked list.\\n * Connected components in G must occur consecutively in the linked list.\\n * \\n * Algorithm\\n * Scanning through the list, if node.val is in G and node.next.val isn\\'t in G (including if node.next is null),\\n * then this must be the end of a connected component.\\n * For example, if the list is 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7, and G = [0, 2, 3, 5, 7],\\n * then when scanning through the list, we fulfill the above condition at 0, 3, 5, 7, for a total answer of 4.\\n * \\n * Complexity Analysis\\n * Time Complexity : O(N+G.length), where N is the length of the linked list with root node head.\\n * Space Complexity: O(G.length), to store gMap.\\n */\\n \\nfunc numComponents(head *ListNode, G []int) int {\\n    var ans int\\n\\t\\n    var gMap = make(map[int]bool, len(G))\\n    for i := range G {\\n    \\tgMap[G[i]] = true\\n    }\\n\\n    for curr, i := head, 0; curr != nil; curr, i = curr.Next, i+1 {    \\t\\n        if _, ok := gMap[curr.Val]; !ok {\\n            continue\\n        }\\n        \\n        if curr.Next == nil {\\n            ans++\\n            continue\\n        }\\n\\n        if _, ok := gMap[curr.Next.Val]; !ok {\\n            ans++\\n        }\\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Approach: Count The End Node of Component\\n * Intuition\\n * Instead of thinking about connected components in G, think about them in the linked list.\\n * Connected components in G must occur consecutively in the linked list.\\n * \\n * Algorithm\\n * Scanning through the list, if node.val is in G and node.next.val isn\\'t in G (including if node.next is null),\\n * then this must be the end of a connected component.\\n * For example, if the list is 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7, and G = [0, 2, 3, 5, 7],\\n * then when scanning through the list, we fulfill the above condition at 0, 3, 5, 7, for a total answer of 4.\\n * \\n * Complexity Analysis\\n * Time Complexity : O(N+G.length), where N is the length of the linked list with root node head.\\n * Space Complexity: O(G.length), to store gMap.\\n */\\n \\nfunc numComponents(head *ListNode, G []int) int {\\n    var ans int\\n\\t\\n    var gMap = make(map[int]bool, len(G))\\n    for i := range G {\\n    \\tgMap[G[i]] = true\\n    }\\n\\n    for curr, i := head, 0; curr != nil; curr, i = curr.Next, i+1 {    \\t\\n        if _, ok := gMap[curr.Val]; !ok {\\n            continue\\n        }\\n        \\n        if curr.Next == nil {\\n            ans++\\n            continue\\n        }\\n\\n        if _, ok := gMap[curr.Next.Val]; !ok {\\n            ans++\\n        }\\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311872,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n    let map=new Map();\\n    G.map((item)=>{\\n        map.set(item,!0);\\n    });\\n    let c=0;\\n    while(head){\\n        if(map.has(head.val)){\\n\\t\\twhile(head&&map.has(head.val))\\n\\t\\thead=head.next;\\n\\t\\tc++;    \\n        }             \\n        if(head)\\n        head=head.next;\\n    }\\n    return c;  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n    let map=new Map();\\n    G.map((item)=>{\\n        map.set(item,!0);\\n    });\\n    let c=0;\\n    while(head){\\n        if(map.has(head.val)){\\n\\t\\twhile(head&&map.has(head.val))\\n\\t\\thead=head.next;\\n\\t\\tc++;    \\n        }             \\n        if(head)\\n        head=head.next;\\n    }\\n    return c;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123826,
                "title": "simple-java-solution-using-set",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head == null) return 0;\\n        int res = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        for(int n:G)\\n            hs.add(n);        \\n        ListNode curr = head;\\n        while(curr != null){\\n            int val = curr.val;\\n            if(!hs.contains(val)){\\n                curr = curr.next;\\n            }else{\\n                res++;\\n                while(curr != null && hs.contains(val)){\\n                    curr = curr.next;\\n                    if(curr != null)\\n                        val = curr.val;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head == null) return 0;\\n        int res = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        for(int n:G)\\n            hs.add(n);        \\n        ListNode curr = head;\\n        while(curr != null){\\n            int val = curr.val;\\n            if(!hs.contains(val)){\\n                curr = curr.next;\\n            }else{\\n                res++;\\n                while(curr != null && hs.contains(val)){\\n                    curr = curr.next;\\n                    if(curr != null)\\n                        val = curr.val;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010854,
                "title": "java-solution-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int count = 1;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            hs.add(nums[i]);\\n\\n        boolean bool = true;\\n        boolean bool1 = true;\\n\\n        while(head != null){\\n            if(!hs.contains(head.val) && bool){\\n                count++;\\n                bool = false;\\n            }\\n            else if(hs.contains(head.val))\\n                bool = true;\\n\\n            if(head.next == null && !hs.contains(head.val))\\n                count--;\\n\\n            if(bool1 && !hs.contains(head.val))\\n                count--;\\n\\n            bool1 = false;\\n\\n            head = head.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int count = 1;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            hs.add(nums[i]);\\n\\n        boolean bool = true;\\n        boolean bool1 = true;\\n\\n        while(head != null){\\n            if(!hs.contains(head.val) && bool){\\n                count++;\\n                bool = false;\\n            }\\n            else if(hs.contains(head.val))\\n                bool = true;\\n\\n            if(head.next == null && !hs.contains(head.val))\\n                count--;\\n\\n            if(bool1 && !hs.contains(head.val))\\n                count--;\\n\\n            bool1 = false;\\n\\n            head = head.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802854,
                "title": "easiest-solution-using-loops-without-using-hashset-for-begginers",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public boolean find(int[] nums, int target){\\n        for(int i = 0; i<nums.length; i++){\\n            if(target == nums[i]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    public int numComponents(ListNode head, int[] nums) {\\n        int comp = 0;\\n        int found = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            if(find(nums, curr.val)){\\n                found++;\\n                if(found == 1){\\n                    comp++;\\n                }\\n            }else{\\n                found = 0;\\n            }\\n            curr = curr.next;\\n        }\\n        return comp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public boolean find(int[] nums, int target){\\n        for(int i = 0; i<nums.length; i++){\\n            if(target == nums[i]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    public int numComponents(ListNode head, int[] nums) {\\n        int comp = 0;\\n        int found = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            if(find(nums, curr.val)){\\n                found++;\\n                if(found == 1){\\n                    comp++;\\n                }\\n            }else{\\n                found = 0;\\n            }\\n            curr = curr.next;\\n        }\\n        return comp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769418,
                "title": "simple-and-easy-solution-c-linked-list-undordered-map",
                "content": "\\n\\n    class Solution {\\n    public:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        int cnt=0;\\n        while(head!=NULL){\\n            if(mp.find(head->val)!=mp.end()){\\n                while(head!=NULL and mp.find(head->val)!=mp.end()){\\n                    head=head->next;\\n                }\\n                cnt++;\\n            }\\n            if(head!=NULL){\\n                head=head->next;\\n            }\\n        }\\n        return cnt;\\n       }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3698720,
                "title": "o-n-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(head==nullptr)\\n            return 0;\\n        unordered_set<int> s{nums.begin(),nums.end()};\\n        int count=0;\\n        while(head!=nullptr){\\n            if(s.find(head->val)!=s.end()){\\n                count++;\\n                while(head->next!=nullptr && s.find(head->next->val)  !=s.end())\\n            head=head->next;\\n            }\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(head==nullptr)\\n            return 0;\\n        unordered_set<int> s{nums.begin(),nums.end()};\\n        int count=0;\\n        while(head!=nullptr){\\n            if(s.find(head->val)!=s.end()){\\n                count++;\\n                while(head->next!=nullptr && s.find(head->next->val)  !=s.end())\\n            head=head->next;\\n            }\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545163,
                "title": "clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n       unordered_set<int> s (nums.begin(),nums.end());\\n       int  res = 0; \\n       ListNode* temp = head; \\n       int prev = head->val; \\n\\n       while(temp!=NULL)\\n       {\\n         if(s.find(temp->val)==s.end() && temp!=head && s.find(prev)!=s.end()) // if this node is not in array but prev node was there in array \\n// suppose this node and prev node both are not in set we don,t count them\\n         res++;\\n         prev = temp->val;\\n         temp = temp->next;\\n       }\\n       if(s.find(prev)!=s.end()) // for last node\\n       res++;\\n        \\n       return res;\\n       \\n\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n       unordered_set<int> s (nums.begin(),nums.end());\\n       int  res = 0; \\n       ListNode* temp = head; \\n       int prev = head->val; \\n\\n       while(temp!=NULL)\\n       {\\n         if(s.find(temp->val)==s.end() && temp!=head && s.find(prev)!=s.end()) // if this node is not in array but prev node was there in array \\n// suppose this node and prev node both are not in set we don,t count them\\n         res++;\\n         prev = temp->val;\\n         temp = temp->next;\\n       }\\n       if(s.find(prev)!=s.end()) // for last node\\n       res++;\\n        \\n       return res;\\n       \\n\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535221,
                "title": "c-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterate over the consecutively connected nodes of the linked list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart from the head and traverse the current consecutively connected nodes and increment `component` by `1`.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int components = 0;\\n        \\n        while(head)\\n        {\\n            if(s.count(head->val))\\n            {\\n                while(head && s.count(head->val))\\n                    head = head->next;\\n                components ++;\\n            }\\n            if(head)\\n                head = head->next;\\n        }\\n        return components;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int components = 0;\\n        \\n        while(head)\\n        {\\n            if(s.count(head->val))\\n            {\\n                while(head && s.count(head->val))\\n                    head = head->next;\\n                components ++;\\n            }\\n            if(head)\\n                head = head->next;\\n        }\\n        return components;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165971,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> set(nums.begin(),nums.end());\\n        unordered_set<int> parents;\\n        \\n        int par= head->val;\\n        while(head){\\n            if(set.count(head->val)){\\n                parents.insert(par);\\n                head= head->next;\\n            }\\n            else{\\n                while(head && set.count(head->val)==0) head= head->next;\\n                if(!head) break;\\n                par= head->val;\\n            }\\n        }\\n        \\n        return parents.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> set(nums.begin(),nums.end());\\n        unordered_set<int> parents;\\n        \\n        int par= head->val;\\n        while(head){\\n            if(set.count(head->val)){\\n                parents.insert(par);\\n                head= head->next;\\n            }\\n            else{\\n                while(head && set.count(head->val)==0) head= head->next;\\n                if(!head) break;\\n                par= head->val;\\n            }\\n        }\\n        \\n        return parents.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068232,
                "title": "fully-commented-easy-o-n-solution",
                "content": "\\n# Approach\\n\\nTo approach this question, first of all think , when we have to increment our component count and when not?\\n\\n- We will not increment our count when we conme to know that the element is a part of our previous chain and increment it when it is not.\\n- Then how we get to know that element is part of chain or not??\\n- Simple,maintain your flag variable...but how??\\n- See first we will initialize our flag as true and then traverse our whole ll until the head is null to check that whether head->val is in the nums array or not..(so to check this, should we have to traverse the whole nums??..No,No..do it in constant time using map :) \\n- Now,if the element in ll is found in map and flag is true(it means elemnt is not part of any chain),increment count and set flag as false(so that futher elements in ll who is part of chain do not contribute to the component count).\\n- if element is not found in map,set flag as true so that incase we will find some element which is in map, we can increment our count.\\n\\n# Complexity\\n- Time complexity:\\nAs we are traversing our linked list only once, so time complexity is **O(n)**\\n\\n- Space complexity:\\nHere we are using unordered map to store the elements of nums array ,thus S.C is also **O(n)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        // traversing the nums array and mapping the elements \\n        for(auto e:nums){\\n            mp[e]++;\\n        }\\n        \\n        int count=0;\\n        bool flag=true;  //flag variable to keep a check if element belongs to the connected chain or not\\n        \\n        while(head){\\n           // if found the element in map and flag is true---\\n            // it means the element does not belong to any previous chain in ll thus increment the count variable and change flag to false\\n          if(mp.find(head->val)!=mp.end() && flag){\\n               count++;\\n               flag=false;\\n           } \\n         // if element is not in map then reset flag as true so that incase we will find some element which is in map, we can increment count\\n        else if(mp.find(head->val)==mp.end()) flag=true;\\n        head=head->next;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        // traversing the nums array and mapping the elements \\n        for(auto e:nums){\\n            mp[e]++;\\n        }\\n        \\n        int count=0;\\n        bool flag=true;  //flag variable to keep a check if element belongs to the connected chain or not\\n        \\n        while(head){\\n           // if found the element in map and flag is true---\\n            // it means the element does not belong to any previous chain in ll thus increment the count variable and change flag to false\\n          if(mp.find(head->val)!=mp.end() && flag){\\n               count++;\\n               flag=false;\\n           } \\n         // if element is not in map then reset flag as true so that incase we will find some element which is in map, we can increment count\\n        else if(mp.find(head->val)==mp.end()) flag=true;\\n        head=head->next;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960162,
                "title": "simple-linked-list-traversal-beats-99-python-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        my=set([])\\n        for i in nums:\\n            my.add(i)\\n        curr=head\\n        # flag=False\\n        count=0\\n        while curr!=None:\\n            flag=False\\n            while curr!=None and curr.val in my:\\n                flag=True\\n                curr=curr.next\\n            if flag==True:\\n                count+=1\\n            if curr!=None and curr.next!=None:\\n                curr=curr.next\\n            else:\\n                break\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        my=set([])\\n        for i in nums:\\n            my.add(i)\\n        curr=head\\n        # flag=False\\n        count=0\\n        while curr!=None:\\n            flag=False\\n            while curr!=None and curr.val in my:\\n                flag=True\\n                curr=curr.next\\n            if flag==True:\\n                count+=1\\n            if curr!=None and curr.next!=None:\\n                curr=curr.next\\n            else:\\n                break\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883410,
                "title": "c",
                "content": "```\\nint depth(struct ListNode* head){\\n    if(head == NULL)\\n        return 0;\\n    else\\n        return 1 + depth(head->next);\\n}\\nint numComponents(struct ListNode* head, int* nums, int numsSize){\\n    int n = depth(head);\\n    bool* exist = calloc(n , sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        exist[nums[i]] = true;\\n    }\\n    int ans = 0;\\n    struct ListNode* tmp = head;\\n    int cn = 0;\\n    while(tmp){\\n        if(exist[tmp->val]){\\n            cn++;\\n        }\\n        else{\\n            if(cn)\\n                ans++;\\n            cn = 0;\\n        }\\n        tmp = tmp->next;\\n    }\\n    if(cn)\\n        ans++;\\n    free(exist);\\n    return ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint depth(struct ListNode* head){\\n    if(head == NULL)\\n        return 0;\\n    else\\n        return 1 + depth(head->next);\\n}\\nint numComponents(struct ListNode* head, int* nums, int numsSize){\\n    int n = depth(head);\\n    bool* exist = calloc(n , sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        exist[nums[i]] = true;\\n    }\\n    int ans = 0;\\n    struct ListNode* tmp = head;\\n    int cn = 0;\\n    while(tmp){\\n        if(exist[tmp->val]){\\n            cn++;\\n        }\\n        else{\\n            if(cn)\\n                ans++;\\n            cn = 0;\\n        }\\n        tmp = tmp->next;\\n    }\\n    if(cn)\\n        ans++;\\n    free(exist);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2843145,
                "title": "c-easy-understandable-code",
                "content": "What we use is unordered_set just because we have to see whether the element is eligible to become a component and we cannot apply .find function on vector so what we done we define a set and assign vector values to it.\\nAfter that we traverse the whole linked list if we found a non component element we simply update our result with the flag value.\\nAnd the last condition is for remaining component if left over then for that consideration we done that if part\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>set;\\n        for(int i:nums){\\n            set.insert(i);\\n        }\\n        int res=0,flag=0;\\n        while(head){\\n            \\n            if(set.find(head->val)!=set.end()){\\n                flag=1;\\n            }\\n            else{\\n                res+=flag;\\n                flag=0;\\n            }\\n            head=head->next;\\n        }\\n        if(flag==1)res++;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>set;\\n        for(int i:nums){\\n            set.insert(i);\\n        }\\n        int res=0,flag=0;\\n        while(head){\\n            \\n            if(set.find(head->val)!=set.end()){\\n                flag=1;\\n            }\\n            else{\\n                res+=flag;\\n                flag=0;\\n            }\\n            head=head->next;\\n        }\\n        if(flag==1)res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261733,
                "title": "python-o-1-solution-without-hash-set",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        if not head:\\n            return 0\\n        \\n        connected_component = 0\\n        total = 0\\n        \\n        while head:\\n            if head.val in nums:\\n                connected_component+=1\\n            else:\\n                if connected_component > 0:\\n                    total+=1\\n                    connected_component = 0\\n            head = head.next\\n            \\n        if connected_component > 0:\\n            total+=1\\n            connected_component = 0\\n\\n        return total\\n                    \\n                \\n                \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        if not head:\\n            return 0\\n        \\n        connected_component = 0\\n        total = 0\\n        \\n        while head:\\n            if head.val in nums:\\n                connected_component+=1\\n            else:\\n                if connected_component > 0:\\n                    total+=1\\n                    connected_component = 0\\n            head = head.next\\n            \\n        if connected_component > 0:\\n            total+=1\\n            connected_component = 0\\n\\n        return total\\n                    \\n                \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230598,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        if(head == NULL) return 0;\\n        \\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        auto it = m.begin();\\n        int count = 0, flag = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            m[nums[i]] = 1;\\n        }\\n        \\n        while(head != NULL)\\n        {\\n            it = m.find(head->val);\\n            if(it != m.end() && (*it).second == 1)\\n            {\\n                it = m.find(head->val);\\n                v.push_back(1);\\n            }\\n            else\\n            {\\n                v.push_back(0);\\n            }\\n            head = head->next;\\n        }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            if(flag != v[i])\\n            {\\n                if(v[i] == 1)\\n                {\\n                    count++;\\n                }\\n                flag = v[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        if(head == NULL) return 0;\\n        \\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        auto it = m.begin();\\n        int count = 0, flag = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            m[nums[i]] = 1;\\n        }\\n        \\n        while(head != NULL)\\n        {\\n            it = m.find(head->val);\\n            if(it != m.end() && (*it).second == 1)\\n            {\\n                it = m.find(head->val);\\n                v.push_back(1);\\n            }\\n            else\\n            {\\n                v.push_back(0);\\n            }\\n            head = head->next;\\n        }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            if(flag != v[i])\\n            {\\n                if(v[i] == 1)\\n                {\\n                    count++;\\n                }\\n                flag = v[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186950,
                "title": "c-few-lines-of-code-set-hashing",
                "content": "```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> s;\\n        //storing every lement of nums in set\\n        for(auto i:nums) s.insert(i);\\n        ListNode* temp=head;\\n        while(temp->next!=NULL and temp!=NULL){\\n            //if the value next to temp pointer is  present in set than it forms a connected component\\n            if(s.find(temp->next->val)!=s.end()){\\n                //removing current node from set so that only one node from each connected component will\\n                //be present in set\\n                s.erase(temp->val);\\n            }\\n            temp=temp->next;\\n        }\\n        return s.size();\\n    }\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> s;\\n        //storing every lement of nums in set\\n        for(auto i:nums) s.insert(i);\\n        ListNode* temp=head;\\n        while(temp->next!=NULL and temp!=NULL){\\n            //if the value next to temp pointer is  present in set than it forms a connected component\\n            if(s.find(temp->next->val)!=s.end()){\\n                //removing current node from set so that only one node from each connected component will\\n                //be present in set\\n                s.erase(temp->val);\\n            }\\n            temp=temp->next;\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2160518,
                "title": "easy-explanation-using-hashset-o-n-with-comments",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> st;  // save all values of nums in hashset\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        if(head->next==NULL){             // check for edge case , if theirs only one node \\n            if(st.find(head->val)!=st.end()){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int count=0;\\n\\n        while(head){\\n            \\n            if(st.find(head->val)!=st.end()){ // if head->val is present in set\\n                \\n            while(st.find(head->val)!=st.end() && head && head->next){ \\n// since we need connected components we keep incrementing our pointer untill its val is present in set\\n                head=head->next;\\n            }\\n// as we get out of the while loop we increment our counter- meaning 1 component is added \\n            count++;\\n            }\\n// if head->val not in set , we simply increment our pointer to check for next node\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> st;  // save all values of nums in hashset\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        if(head->next==NULL){             // check for edge case , if theirs only one node \\n            if(st.find(head->val)!=st.end()){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int count=0;\\n\\n        while(head){\\n            \\n            if(st.find(head->val)!=st.end()){ // if head->val is present in set\\n                \\n            while(st.find(head->val)!=st.end() && head && head->next){ \\n// since we need connected components we keep incrementing our pointer untill its val is present in set\\n                head=head->next;\\n            }\\n// as we get out of the while loop we increment our counter- meaning 1 component is added \\n            count++;\\n            }\\n// if head->val not in set , we simply increment our pointer to check for next node\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093002,
                "title": "simple-logical-c-code-83-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int> components;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            components[nums[i]]++;\\n        }\\n        int cnt = 0;\\n        bool breakpoint = false;\\n        while(head)\\n        {\\n            if(!components.count(head->val))\\n            {\\n                breakpoint = false;\\n            }\\n            else if(components.count(head->val) && !breakpoint)\\n            {\\n                cnt++;\\n                breakpoint = true;\\n            }\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int> components;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            components[nums[i]]++;\\n        }\\n        int cnt = 0;\\n        bool breakpoint = false;\\n        while(head)\\n        {\\n            if(!components.count(head->val))\\n            {\\n                breakpoint = false;\\n            }\\n            else if(components.count(head->val) && !breakpoint)\\n            {\\n                cnt++;\\n                breakpoint = true;\\n            }\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941599,
                "title": "java-solution-fastser-than-90-percent-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int entry:nums){\\n            set.add(entry);\\n        }\\n        int count =0;\\n        boolean  isconnected =false;\\n        ListNode temp = head;\\n        \\n        while( temp !=null){\\n            \\n            if(set.contains(temp.val)){\\n                if(isconnected==false){\\n                    isconnected = true;\\n                    count++;\\n                }\\n            }\\n            else{\\n                isconnected = false;\\n            }\\n            temp = temp.next;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int entry:nums){\\n            set.add(entry);\\n        }\\n        int count =0;\\n        boolean  isconnected =false;\\n        ListNode temp = head;\\n        \\n        while( temp !=null){\\n            \\n            if(set.contains(temp.val)){\\n                if(isconnected==false){\\n                    isconnected = true;\\n                    count++;\\n                }\\n            }\\n            else{\\n                isconnected = false;\\n            }\\n            temp = temp.next;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908379,
                "title": "easy-java-soln",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            numSet.add(nums[i]);\\n        }\\n        \\n        int sequences = 0;\\n        \\n        \\n        boolean inASequence = false;\\n        \\n        while(head != null) {\\n            \\n            if(inASequence) {\\n                if(numSet.contains(head.val)){ // If we are in a sequence and we encounter something part of array just continue.\\n                    head = head.next;\\n                    continue;\\n                } \\n                inASequence = false;\\n                head = head.next;\\n            } else { // If we are not in a sequence and a Sequence starts then increase sequence count and set flag to true.\\n                if(numSet.contains(head.val)) {\\n                    inASequence = true;\\n                    sequences++;\\n                }\\n                head = head.next;   \\n            }\\n        }\\n        return sequences;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            numSet.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1899949,
                "title": "linked-list-components",
                "content": "\\t\\tcount=0\\n        seen=set(nums)\\n        prev=None\\n        while(head):\\n            if(head.val in seen and prev not in seen):\\n                count+=1\\n            prev,head=head.val,head.next\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tcount=0\\n        seen=set(nums)\\n        prev=None\\n        while(head):\\n            if(head.val in seen and prev not in seen):\\n                count+=1\\n            prev,head=head.val,head.next\\n        return count",
                "codeTag": "Unknown"
            },
            {
                "id": 1897485,
                "title": "easy-c-solution-better-runtime-than-99-86-and-better-memory-usage-than-81-48",
                "content": "The approach is simple. We first use a boolean vector to store if the elements are present or not. Then we start iterating the linked list and for each connected component, we increment the ans by 1. \\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        vector<bool> subsetNodesTrack(10000,0);\\n        for(int num:nums) subsetNodesTrack[num]=1;\\n        ListNode* curr=head;\\n        int ans=0;\\n        while(curr){\\n            if(subsetNodesTrack[curr->val]) {\\n                while(curr && subsetNodesTrack[curr->val]) curr=curr->next;\\n                ans++;\\n            }\\n            else curr=curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        vector<bool> subsetNodesTrack(10000,0);\\n        for(int num:nums) subsetNodesTrack[num]=1;\\n        ListNode* curr=head;\\n        int ans=0;\\n        while(curr){\\n            if(subsetNodesTrack[curr->val]) {\\n                while(curr && subsetNodesTrack[curr->val]) curr=curr->next;\\n                ans++;\\n            }\\n            else curr=curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883418,
                "title": "c-without-extra-memory-clean-concise-code",
                "content": "**Liked the code? Please do upvote it :)**\\n\\n```\\nclass Solution{\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        int cnt = 0, connect = 0, last = 0;\\n        \\n        while(head != NULL)\\n        {\\n            connect = (find(nums.begin(), nums.end(), head->val) != nums.end());\\n            \\n            if(last == 1 and connect == 0)\\n                ++cnt;\\n            \\n            last = connect;\\n            head = head->next;\\n        }\\n        \\n        cnt += (connect == 1);\\n        return cnt;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        int cnt = 0, connect = 0, last = 0;\\n        \\n        while(head != NULL)\\n        {\\n            connect = (find(nums.begin(), nums.end(), head->val) != nums.end());\\n            \\n            if(last == 1 and connect == 0)\\n                ++cnt;\\n            \\n            last = connect;\\n            head = head->next;\\n        }\\n        \\n        cnt += (connect == 1);\\n        return cnt;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879178,
                "title": "easy-c-sol",
                "content": "int numComponents(struct ListNode* head, int* nums, int numsSize){\\n\\n    int c[10000]={0};\\n    for(int i=0;i<numsSize;i++)\\n        c[nums[i]]++;\\n    \\n    struct ListNode* next= head;\\n    \\n    int z=0;\\n    \\n    while(next!=NULL){\\n        if(next!=NULL && c[next->val]==1){\\n            while(next!=NULL && c[next->val]==1){\\n                next=next->next;\\n            }\\n            z++;\\n        }\\n        else next=next->next;\\n    }\\n    \\n    return z;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "int numComponents(struct ListNode* head, int* nums, int numsSize){\\n\\n    int c[10000]={0};\\n    for(int i=0;i<numsSize;i++)\\n        c[nums[i]]++;\\n    \\n    struct ListNode* next= head;\\n    \\n    int z=0;\\n    \\n    while(next!=NULL){\\n        if(next!=NULL && c[next->val]==1){\\n            while(next!=NULL && c[next->val]==1){\\n                next=next->next;\\n            }\\n            z++;\\n        }\\n        else next=next->next;\\n    }\\n    \\n    return z;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1837296,
                "title": "jave-hashset-o-n",
                "content": "```\\npublic int numComponents(ListNode head, int[] nums) {\\n        // Put all elements into a set.\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            set.add(i);\\n        }\\n        \\n        // Initialize a pointer going through the list.\\n        ListNode curr = head;       \\n        // Initialize a flag, set to true when seeing set element in linkedlist.\\n        boolean flag = false;        \\n        // Initialize result variable.\\n        int res = 0;\\n        \\n        while (curr != null) {\\n            if (set.contains(curr.val)) {\\n                // No need to count res for connected element in linkedlist.\\n                if (!flag) {\\n                    res++;\\n                }\\n                flag = true;   \\n            } else {\\n                flag = false;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numComponents(ListNode head, int[] nums) {\\n        // Put all elements into a set.\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            set.add(i);\\n        }\\n        \\n        // Initialize a pointer going through the list.\\n        ListNode curr = head;       \\n        // Initialize a flag, set to true when seeing set element in linkedlist.\\n        boolean flag = false;        \\n        // Initialize result variable.\\n        int res = 0;\\n        \\n        while (curr != null) {\\n            if (set.contains(curr.val)) {\\n                // No need to count res for connected element in linkedlist.\\n                if (!flag) {\\n                    res++;\\n                }\\n                flag = true;   \\n            } else {\\n                flag = false;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805625,
                "title": "c-leetcode-817-simple-hashing-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        for(int x : arr)m[x]++;\\n        int count = 0;\\n        ListNode* node = head;\\n        while(node!=NULL){\\n            int done = 0;\\n            while(node!=NULL && m[node->val]>0){\\n                node=node->next;\\n                done = 1;\\n            }\\n            if(done)count++;\\n            while(node!=NULL && m[node->val]==0){\\n                node=node->next;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        for(int x : arr)m[x]++;\\n        int count = 0;\\n        ListNode* node = head;\\n        while(node!=NULL){\\n            int done = 0;\\n            while(node!=NULL && m[node->val]>0){\\n                node=node->next;\\n                done = 1;\\n            }\\n            if(done)count++;\\n            while(node!=NULL && m[node->val]==0){\\n                node=node->next;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787773,
                "title": "java-o-n-using-hashset",
                "content": "```\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i : nums) set.add(i);\\n        \\n        int ans = 0;\\n        while(head != null){\\n            boolean count = true;\\n            while(set.contains(head.val)){\\n                if(count) ans++;\\n                count = false;\\n                if(head.next != null) head = head.next;\\n                else break;\\n            }\\n\\n            head = head.next;\\n            \\n        }\\n        return ans;\\n    }\\n\\t```\\n\\t\\n\\tvery ez understandble solution using a hashset to store the num array for fast lookup.\\n\\t\\n\\tTime : O(n)\\n\\tSpace : O( size of nums[] ) or O( nums.length )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i : nums) set.add(i);\\n        \\n        int ans = 0;\\n        while(head != null){\\n            boolean count = true;\\n            while(set.contains(head.val)){\\n                if(count) ans++;\\n                count = false;\\n                if(head.next != null) head = head.next;\\n                else break;\\n            }\\n\\n            head = head.next;\\n            \\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732435,
                "title": "didn-t-understand-the-test-case",
                "content": "Please explain me this test case, \\n```\\nInput: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nInput: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1669475,
                "title": "python-faster-than-95",
                "content": "```\\nhashed = {}\\nfor n in nums:\\n\\thashed[n] = 0\\ncomponents = 0\\nprev_in_comp = in_comp = False\\nwhile head:\\n\\tprev_in_comp = in_comp\\n\\tif head.val in hashed:\\n\\t\\tin_comp = True\\n\\telse:\\n\\t\\tin_comp = False\\n\\tif not prev_in_comp and in_comp:\\n\\t\\tcomponents += 1\\n\\thead = head.next\\nreturn components\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nhashed = {}\\nfor n in nums:\\n\\thashed[n] = 0\\ncomponents = 0\\nprev_in_comp = in_comp = False\\nwhile head:\\n\\tprev_in_comp = in_comp\\n\\tif head.val in hashed:\\n\\t\\tin_comp = True\\n\\telse:\\n\\t\\tin_comp = False\\n\\tif not prev_in_comp and in_comp:\\n\\t\\tcomponents += 1\\n\\thead = head.next\\nreturn components\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1654638,
                "title": "java-easy-solution",
                "content": "```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i:nums) set.add(i);\\n        int result=0;\\n        while(head!=null){\\n            if(set.contains(head.val)){\\n                while(head!=null&&set.contains(head.val))\\n                    head=head.next;\\n                result++;\\n            }\\n            else\\n                head=head.next;\\n        }\\n        \\n       \\n        return result;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i:nums) set.add(i);\\n        int result=0;\\n        while(head!=null){\\n            if(set.contains(head.val)){\\n                while(head!=null&&set.contains(head.val))\\n                    head=head.next;\\n                result++;\\n            }\\n            else\\n                head=head.next;\\n        }\\n        \\n       \\n        return result;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594482,
                "title": "python-solution-simple-one-pass-time-o-n-2-space-o-1",
                "content": "```\\n        res = 0\\n        hasConnection = False\\n        while head:\\n            if head.val in nums:\\n                hasConnection = True\\n            elif hasConnection:\\n                res += 1\\n                hasConnection = False\\n            head = head.next\\n        if hasConnection:\\n            res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n        res = 0\\n        hasConnection = False\\n        while head:\\n            if head.val in nums:\\n                hasConnection = True\\n            elif hasConnection:\\n                res += 1\\n                hasConnection = False\\n            head = head.next\\n        if hasConnection:\\n            res += 1\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578443,
                "title": "python3-solution-with-using-hashset",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        s = set(G)\\n        res = 0\\n        \\n        while head:\\n            if head.val in s and (head.next == None or head.next.val not in s):\\n                res += 1\\n        \\n            head = head.next\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        s = set(G)\\n        res = 0\\n        \\n        while head:\\n            if head.val in s and (head.next == None or head.next.val not in s):\\n                res += 1\\n        \\n            head = head.next\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536475,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        \\n        nums = set(nums)\\n        curr = False\\n        count = 0\\n        \\n        while head :\\n            top = head.val\\n            if top in nums :\\n                if not curr :\\n                    count += 1\\n                    curr = True       \\n            else :\\n                curr = False\\n            head = head.next\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        \\n        nums = set(nums)\\n        curr = False\\n        count = 0\\n        \\n        while head :\\n            top = head.val\\n            if top in nums :\\n                if not curr :\\n                    count += 1\\n                    curr = True       \\n            else :\\n                curr = False\\n            head = head.next\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496457,
                "title": "rust-4ms-iterator-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\npub fn num_components(head: Option<Box<ListNode>>, nums: Vec<i32>) -> i32 {\\n    let nums: HashSet<_> = nums.into_iter().collect();\\n    (0..).scan(&head, |node, _| node.as_deref().map(|ListNode { val, next }| {\\n            *node = next;\\n            nums.contains(&val)\\n        })).fuse()\\n        .fold((0, false), |(cnt, pre), b| (i32::from(b && !pre) + cnt, b)).0\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\npub fn num_components(head: Option<Box<ListNode>>, nums: Vec<i32>) -> i32 {\\n    let nums: HashSet<_> = nums.into_iter().collect();\\n    (0..).scan(&head, |node, _| node.as_deref().map(|ListNode { val, next }| {\\n            *node = next;\\n            nums.contains(&val)\\n        })).fuse()\\n        .fold((0, false), |(cnt, pre), b| (i32::from(b && !pre) + cnt, b)).0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1493468,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        int size = 0;\\n        while(head != null){\\n            if(set.contains(head.val)){\\n                size++;\\n                while(head.next != null && set.contains(head.next.val)){\\n                    head = head.next;\\n                }\\n            }\\n            head = head.next;\\n        }\\n        \\n        return size;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            set.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1428337,
                "title": "simple-solution-using-a-set",
                "content": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int result = 0;\\n        \\n        for(int num : nums)\\n            set.add(num);\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null) {\\n            if(set.contains(curr.val) && (curr.next == null || !set.contains(curr.next.val)))\\n                result++;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int result = 0;\\n        \\n        for(int num : nums)\\n            set.add(num);\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null) {\\n            if(set.contains(curr.val) && (curr.next == null || !set.contains(curr.next.val)))\\n                result++;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423495,
                "title": "hashset-hashmap-c-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans=0;\\n        auto p = head;\\n        map<int,int> m;\\n        set<int> s;\\n        for(auto x:nums) s.insert(x);\\n        while(p!=NULL && p->next!=NULL){\\n            int a = p->val;\\n            m[a]=p->next->val;\\n            p=p->next;\\n        }\\n        m[p->val]=-1;\\n        for(auto x:nums){\\n            if(s.find(m[x])!=s.end()) continue;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans=0;\\n        auto p = head;\\n        map<int,int> m;\\n        set<int> s;\\n        for(auto x:nums) s.insert(x);\\n        while(p!=NULL && p->next!=NULL){\\n            int a = p->val;\\n            m[a]=p->next->val;\\n            p=p->next;\\n        }\\n        m[p->val]=-1;\\n        for(auto x:nums){\\n            if(s.find(m[x])!=s.end()) continue;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391515,
                "title": "python3-simple-hashmap-solution",
                "content": "```\\n#TIME COMPLEXITY - O(len(nums)+N)\\n#SPACE COMPLEXITY - O(len(nums))\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        hmap={}\\n        for i in range(len(nums)):\\n            if nums[i] not in hmap:\\n                hmap[nums[i]]=1\\n            else:\\n                hmap[nums[i]]+=1\\n        temp=head\\n        cnt=0\\n        while temp:\\n            if temp.val in hmap:\\n                curr=temp\\n                while curr and curr.val in hmap:\\n                    curr=curr.next\\n                temp=curr\\n                cnt+=1\\n            else:\\n                temp=temp.next\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#TIME COMPLEXITY - O(len(nums)+N)\\n#SPACE COMPLEXITY - O(len(nums))\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        hmap={}\\n        for i in range(len(nums)):\\n            if nums[i] not in hmap:\\n                hmap[nums[i]]=1\\n            else:\\n                hmap[nums[i]]+=1\\n        temp=head\\n        cnt=0\\n        while temp:\\n            if temp.val in hmap:\\n                curr=temp\\n                while curr and curr.val in hmap:\\n                    curr=curr.next\\n                temp=curr\\n                cnt+=1\\n            else:\\n                temp=temp.next\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391309,
                "title": "c-easy-solution-all-methods-faster-than-90",
                "content": "METHOD1: Using sorting and binary search (T(n) = O(nlgn) and S(n) = O(1))\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val)) {\\n                head = head->next;\\n                while (head and binary_search(nums.begin(), nums.end(), head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD2: Variant of Method1;\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val) and (!head->next or !binary_search(nums.begin(), nums.end(), head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD3 : using set (T(n) = S(n) = O(n))\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val)) {\\n                head = head->next;\\n                while (head and numbers.count(head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD4: Variant of Method3;\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val) and (!head->next or !numbers.count(head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val)) {\\n                head = head->next;\\n                while (head and binary_search(nums.begin(), nums.end(), head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val) and (!head->next or !binary_search(nums.begin(), nums.end(), head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val)) {\\n                head = head->next;\\n                while (head and numbers.count(head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val) and (!head->next or !numbers.count(head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337700,
                "title": "runtime-24ms-faster-than-98-c-solution",
                "content": "```\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++) s.insert(nums[i]);\\n        int c=0,f=0;\\n        while(head!=NULL){\\n            if(s.find(head->val)!=s.end()){\\n                if(!f)\\n                    f=1;\\n            }\\n            else{\\n                if(f){\\n                    c++;\\n                    f=0;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        if(f)\\n            c++;\\n        return c;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++) s.insert(nums[i]);\\n        int c=0,f=0;\\n        while(head!=NULL){\\n            if(s.find(head->val)!=s.end()){\\n                if(!f)\\n                    f=1;\\n            }\\n            else{\\n                if(f){\\n                    c++;\\n                    f=0;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        if(f)\\n            c++;\\n        return c;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1329190,
                "title": "c-solution-with-proper-explanation",
                "content": "Need to find the connected components ;\\nConditions :-\\n   1 . If there is a set of elements in nums (subset provided) is a connected sub-list in LinkedList then count it as 1.\\n   2. Count the remaining elements in nums (subset provided) which are in Linked-List as 1 for each.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> st(nums.begin(), nums.end());\\n        \\n        int count = 0;\\n        \\n        while(head!=NULL)\\n        {\\n            if(st.count(head->val))   //If an ele from num present in LinkedList\\n            {\\n                count++;     //Increase count by 1\\n                while(head!=NULL && st.count(head->val)) head = head->next;   // move all the connected elements to include in one set if available\\n            }\\n            else\\n                head = head->next;  //else simply move forward\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\nPlease Upvote if it helps you. Thanks !",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> st(nums.begin(), nums.end());\\n        \\n        int count = 0;\\n        \\n        while(head!=NULL)\\n        {\\n            if(st.count(head->val))   //If an ele from num present in LinkedList\\n            {\\n                count++;     //Increase count by 1\\n                while(head!=NULL && st.count(head->val)) head = head->next;   // move all the connected elements to include in one set if available\\n            }\\n            else\\n                head = head->next;  //else simply move forward\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294811,
                "title": "python-simple-solution",
                "content": "```\\ndef numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        d = set(nums)\\n        count = 0\\n        c = 0\\n        temp = head\\n        while temp:\\n            if temp.val in d:\\n                c=1\\n            else:\\n                count+=c\\n                c=0\\n            temp= temp.next\\n        return count+c",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\ndef numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        d = set(nums)\\n        count = 0\\n        c = 0\\n        temp = head\\n        while temp:\\n            if temp.val in d:\\n                c=1\\n            else:\\n                count+=c\\n                c=0\\n            temp= temp.next\\n        return count+c",
                "codeTag": "Python3"
            },
            {
                "id": 1266940,
                "title": "easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        int count=0,flag=0;\\n        while(head!=NULL)\\n             {\\n             auto it=find(G.begin(),G.end(),head->val);\\n             if(it!=G.end()&&flag==0)\\n             {\\n                 count++;\\n                 flag=1;\\n             }\\n             else if(it==G.end())\\n                 flag=0;\\n        head=head->next;\\n         }\\n        return count;\\n    } \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        int count=0,flag=0;\\n        while(head!=NULL)\\n             {\\n             auto it=find(G.begin(),G.end(),head->val);\\n             if(it!=G.end()&&flag==0)\\n             {\\n                 count++;\\n                 flag=1;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1266023,
                "title": "struggling-with-explanation",
                "content": "Explanation is really bad, you can see this post for explaination (in comments) : https://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case\\nOne You get the point, Question is really simple...\\n```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n     \\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            hs.add(nums[i]);\\n        }\\n        \\n        int flag = 0,ans = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            if(flag == 0 && hs.contains(temp.val)){\\n                ans++;\\n                flag = 1; \\n            }\\n            else if(!hs.contains(temp.val)){\\n                flag = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n     \\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            hs.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1241184,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G)\\n    {\\n        int count=0;\\n        unordered_set<int>s(G.begin(),G.end());\\n        while(head!=NULL)\\n        {\\n            int f=0;\\n            while(head!=NULL&&s.find(head->val)!=s.end())\\n            {\\n                f=1;\\n                head=head->next;\\n            }\\n            if(f)\\n            count++;\\n            if(head!=NULL)\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G)\\n    {\\n        int count=0;\\n        unordered_set<int>s(G.begin(),G.end());\\n        while(head!=NULL)\\n        {\\n            int f=0;\\n            while(head!=NULL&&s.find(head->val)!=s.end())\\n            {\\n                f=1;\\n                head=head->next;\\n            }\\n            if(f)\\n            count++;\\n            if(head!=NULL)\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231068,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      if(!head) return 0;\\n      \\n      int n = nums.size();\\n      \\n      if(n == 0) return 0;\\n      \\n      map<int,bool> vals;\\n      \\n      for(int i = 0; i < n; ++i) {\\n        vals[nums[i]] = true;\\n      }\\n      \\n      int noOfComponents = 0;\\n      \\n      for(ListNode* ptr = head; ptr != nullptr; ptr = ptr->next) {\\n        if(vals.find(ptr->val) != vals.end()) {\\n          while(ptr && vals.find(ptr->val) != vals.end()) {\\n            ptr = ptr->next;\\n          }\\n          ++noOfComponents;\\n        }\\n        if(!ptr) break;\\n      }\\n      \\n      return noOfComponents;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      if(!head) return 0;\\n      \\n      int n = nums.size();\\n      \\n      if(n == 0) return 0;\\n      \\n      map<int,bool> vals;\\n      \\n      for(int i = 0; i < n; ++i) {\\n        vals[nums[i]] = true;\\n      }\\n      \\n      int noOfComponents = 0;\\n      \\n      for(ListNode* ptr = head; ptr != nullptr; ptr = ptr->next) {\\n        if(vals.find(ptr->val) != vals.end()) {\\n          while(ptr && vals.find(ptr->val) != vals.end()) {\\n            ptr = ptr->next;\\n          }\\n          ++noOfComponents;\\n        }\\n        if(!ptr) break;\\n      }\\n      \\n      return noOfComponents;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222007,
                "title": "simple-and-easy-python",
                "content": "As long as the head.next.val is in the nums we continue without increasing the count. \\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count = 0\\n        num = set(nums)\\n        while head:\\n            if head.val in num and (head.next==None or head.next.val not in num):\\n                count+=1\\n            head = head.next\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count = 0\\n        num = set(nums)\\n        while head:\\n            if head.val in num and (head.next==None or head.next.val not in num):\\n                count+=1\\n            head = head.next\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169662,
                "title": "java-solution",
                "content": "Scanning through head.value is present in G and head.next.val is not or including head.next==null. \\n\\n```\\npublic int numComponents(ListNode head, int[] G) {\\n        int result =0;\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<G.length;i++){\\n            set.add(G[i]);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                result++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numComponents(ListNode head, int[] G) {\\n        int result =0;\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<G.length;i++){\\n            set.add(G[i]);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                result++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132678,
                "title": "java-easy-solution-hashset",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] arr) {\\n      ListNode node=head;\\n      Set<Integer> set=new HashSet<>();\\n      for(int val:arr) set.add(val);\\n    \\n      int ans=0;\\n     \\n      while(node!=null){\\n        if(set.contains(node.val) && (node.next==null ||  !set.contains(node.next.val))){\\n           ans++;\\n        }\\n        node=node.next;\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] arr) {\\n      ListNode node=head;\\n      Set<Integer> set=new HashSet<>();\\n      for(int val:arr) set.add(val);\\n    \\n      int ans=0;\\n     \\n      while(node!=null){\\n        if(set.contains(node.val) && (node.next==null ||  !set.contains(node.next.val))){\\n           ans++;\\n        }\\n        node=node.next;\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095530,
                "title": "simple-java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> hash=new HashSet<Integer>();\\n        \\n        for(int i=0;i<G.length;i++){\\n            hash.add(G[i]);\\n        }\\n        \\n        ListNode parent=null;\\n        ListNode current=head;\\n        int numOfComponents=0;\\n        \\n        while(current != null){\\n            if(parent == null){\\n                if(hash.contains(current.val))\\n                {\\n                    numOfComponents++;\\n                }\\n            }else{\\n                if(!hash.contains(parent.val) && hash.contains(current.val)){\\n                    numOfComponents++;\\n                }\\n            }\\n            parent=current;\\n            current=current.next;\\n        }\\n        return numOfComponents;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> hash=new HashSet<Integer>();\\n        \\n        for(int i=0;i<G.length;i++){\\n            hash.add(G[i]);\\n        }\\n        \\n        ListNode parent=null;\\n        ListNode current=head;\\n        int numOfComponents=0;\\n        \\n        while(current != null){\\n            if(parent == null){\\n                if(hash.contains(current.val))\\n                {\\n                    numOfComponents++;\\n                }\\n            }else{\\n                if(!hash.contains(parent.val) && hash.contains(current.val)){\\n                    numOfComponents++;\\n                }\\n            }\\n            parent=current;\\n            current=current.next;\\n        }\\n        return numOfComponents;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072342,
                "title": "java-simpple-solution-faster-than-95",
                "content": "JAVA CODE IS:\\n#    \\n```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int v : G)\\n            set.add(v);\\n       boolean t=false;\\n        int count=0;\\n        while(head!=null){\\n          if(set.contains(head.val))\\n             t=true;\\n          else{\\n              count+=t==true ? 1 : 0;\\n              t=false;\\n          }   \\n            head=head.next;\\n        }\\n        count+=t==true ? 1 : 0;\\n        return count;\\n    }\\n}\\n```\\nTime : O(N)\\nSpace : O(N)\\n***PLEASE,UPVOTE IF THIS IS REALLY HELPFUL FOR YOU***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int v : G)\\n            set.add(v);\\n       boolean t=false;\\n        int count=0;\\n        while(head!=null){\\n          if(set.contains(head.val))\\n             t=true;\\n          else{\\n              count+=t==true ? 1 : 0;\\n              t=false;\\n          }   \\n            head=head.next;\\n        }\\n        count+=t==true ? 1 : 0;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018853,
                "title": "python",
                "content": "```\\n\\tdef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        flag = False\\n        cnt = 0\\n        nums = set(G)\\n        \\n        while head:\\n            if head.val in nums and not flag:\\n                flag = True\\n                cnt += 1\\n            elif head.val not in nums:\\n                flag = False\\n            head = head.next\\n            \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        flag = False\\n        cnt = 0\\n        nums = set(G)\\n        \\n        while head:\\n            if head.val in nums and not flag:\\n                flag = True\\n                cnt += 1\\n            elif head.val not in nums:\\n                flag = False\\n            head = head.next\\n            \\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1016745,
                "title": "c-100-time-and-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if (G.size() == 0) {\\n            return 0;\\n        }\\n        sort(G.begin(), G.end()); // O(G * log(G))\\n        int count = 0;\\n        bool connecting = false;\\n        \\n        // O(linked_list_length)\\n        while (head != nullptr) {\\n            \\n            // O(log(G))\\n            if (binary_search(G.begin(), G.end(), head->val)) {\\n                if (!connecting) {\\n                    connecting = true;\\n                    count++;\\n                }\\n            } else if (connecting) {\\n                connecting = false;\\n            }\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if (G.size() == 0) {\\n            return 0;\\n        }\\n        sort(G.begin(), G.end()); // O(G * log(G))\\n        int count = 0;\\n        bool connecting = false;\\n        \\n        // O(linked_list_length)\\n        while (head != nullptr) {\\n            \\n            // O(log(G))\\n            if (binary_search(G.begin(), G.end(), head->val)) {\\n                if (!connecting) {\\n                    connecting = true;\\n                    count++;\\n                }\\n            } else if (connecting) {\\n                connecting = false;\\n            }\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928075,
                "title": "simple-python-solution-beat-96",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]):\\n        current = head\\n        S = set(G)\\n        res = 0\\n        \\n        while current:\\n            if current.val in S and current.next is None:\\n                res += 1\\n                \\n            elif current.val in S and current.next.val not in S:\\n                res += 1\\n                \\n            current = current.next\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]):\\n        current = head\\n        S = set(G)\\n        res = 0\\n        \\n        while current:\\n            if current.val in S and current.next is None:\\n                res += 1\\n                \\n            elif current.val in S and current.next.val not in S:\\n                res += 1\\n                \\n            current = current.next\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 914427,
                "title": "swift-simple-100",
                "content": "```\\n    func numComponents(_ head: ListNode?, _ G: [Int]) -> Int {\\n        let set = Set(G)\\n        var total = 0\\n        var connected = false\\n        var cur = head\\n        \\n        while cur != nil {\\n            \\n            //If number in subset found and it is not connected to another \\n            //number in the subset, we increase the component count by one\\n            if set.contains(cur!.val) {\\n                if connected == false { \\n                    connected = true\\n                    total += 1\\n                }\\n            }else {\\n                //Number not in subset, break connected streak\\n                connected = false\\n            } \\n            \\n            cur = cur?.next\\n        }\\n        \\n        return total\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func numComponents(_ head: ListNode?, _ G: [Int]) -> Int {\\n        let set = Set(G)\\n        var total = 0\\n        var connected = false\\n        var cur = head\\n        \\n        while cur != nil {\\n            \\n            //If number in subset found and it is not connected to another \\n            //number in the subset, we increase the component count by one\\n            if set.contains(cur!.val) {\\n                if connected == false { \\n                    connected = true\\n                    total += 1\\n                }\\n            }else {\\n                //Number not in subset, break connected streak\\n                connected = false\\n            } \\n            \\n            cur = cur?.next\\n        }\\n        \\n        return total\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 873910,
                "title": "java-1ms-100-with-comments",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        boolean[] map = new boolean[10001];\\n        for(int num : G) {\\n            map[num] = true;\\n        }\\n        \\n        if(head == null) {\\n            return 0;\\n        }\\n        \\n        ListNode runner = head;\\n        \\n        // slide runner to the next possible component\\n        while(runner != null && !map[runner.val]) {\\n            runner = runner.next;\\n        }\\n        \\n        // no connected components\\n        if(runner == null) {\\n            return 0;\\n        }\\n        \\n        int connected = 1;\\n        while(runner != null) {\\n            if(!map[runner.val]) {\\n                // slide runner to the next possible component\\n                while(runner != null && !map[runner.val]) {\\n                    runner = runner.next;\\n                }\\n                \\n                // increase component count if we did not reach to the end\\n                // of the linked list\\n                if(runner != null) {                    \\n                    connected++;\\n                }\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        \\n        return connected;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        boolean[] map = new boolean[10001];\\n        for(int num : G) {\\n            map[num] = true;\\n        }\\n        \\n        if(head == null) {\\n            return 0;\\n        }\\n        \\n        ListNode runner = head;\\n        \\n        // slide runner to the next possible component\\n        while(runner != null && !map[runner.val]) {\\n            runner = runner.next;\\n        }\\n        \\n        // no connected components\\n        if(runner == null) {\\n            return 0;\\n        }\\n        \\n        int connected = 1;\\n        while(runner != null) {\\n            if(!map[runner.val]) {\\n                // slide runner to the next possible component\\n                while(runner != null && !map[runner.val]) {\\n                    runner = runner.next;\\n                }\\n                \\n                // increase component count if we did not reach to the end\\n                // of the linked list\\n                if(runner != null) {                    \\n                    connected++;\\n                }\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        \\n        return connected;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849185,
                "title": "can-someone-explain-this-test-case",
                "content": "```\\n0->1->2\\nG= [0,2]\\n```\\n\\n`Output : 2`\\nShouldn\\'t the output be 1 when I consider the fact that only ```2 ```from the Linekd list will be counted?",
                "solutionTags": [],
                "code": "```\\n0->1->2\\nG= [0,2]\\n```\n```2 ```",
                "codeTag": "Unknown"
            },
            {
                "id": 839426,
                "title": "binary-search-solution-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool binarysearch(vector<int> &G,int k){\\n        int si = 0;\\n        int ei = G.size()-1;\\n        while(si<=ei){\\n            int mid = (si+ei)/2;\\n            if(G[mid]==k) return true;\\n            else if(G[mid]<k) si=mid+1;\\n            else ei = mid-1;\\n        }\\n        return false;\\n    }\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        sort(G.begin(),G.end());\\n        ListNode *temp = head;\\n        int components = 0;\\n        int currsize = 0;\\n        while(temp){\\n            int val = temp->val;\\n            bool b = binarysearch(G,val);\\n            if(b){\\n               currsize++; \\n            }else{\\n                if(currsize) components++;\\n                currsize = 0;\\n            }\\n            temp = temp->next;\\n        }\\n        if(currsize) components++;\\n        return components;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binarysearch(vector<int> &G,int k){\\n        int si = 0;\\n        int ei = G.size()-1;\\n        while(si<=ei){\\n            int mid = (si+ei)/2;\\n            if(G[mid]==k) return true;\\n            else if(G[mid]<k) si=mid+1;\\n            else ei = mid-1;\\n        }\\n        return false;\\n    }\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        sort(G.begin(),G.end());\\n        ListNode *temp = head;\\n        int components = 0;\\n        int currsize = 0;\\n        while(temp){\\n            int val = temp->val;\\n            bool b = binarysearch(G,val);\\n            if(b){\\n               currsize++; \\n            }else{\\n                if(currsize) components++;\\n                currsize = 0;\\n            }\\n            temp = temp->next;\\n        }\\n        if(currsize) components++;\\n        return components;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718172,
                "title": "simple-python-no-getattr",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        graph = set(G)\\n        components = 0\\n        while head:\\n            if head.val in graph and (not head.next or head.next.val not in graph):\\n                components += 1\\n            head = head.next\\n        return components\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        graph = set(G)\\n        components = 0\\n        while head:\\n            if head.val in graph and (not head.next or head.next.val not in graph):\\n                components += 1\\n            head = head.next\\n        return components\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668565,
                "title": "python-o-n-solution-easy-to-understand",
                "content": "We use a set so we can search element in O(1)\\nNow we traverse linked list and keep track of connected elements we have seen so far.\\nIncrement when connectivity is lost.\\n```\\ndef numComponents(self, head, G):\\n        subsetVals = set(G)\\n        current = head\\n        comps = 0\\n        elementsInComp = 0\\n        while current != None:\\n            curVal = current.val\\n            if curVal in subsetVals:\\n                elementsInComp += 1\\n            else:\\n                if elementsInComp > 0:\\n                    elementsInComp = 0\\n                    comps += 1\\n            current = current.next\\n        if elementsInComp > 0:\\n            comps += 1\\n        return comps\\n```",
                "solutionTags": [],
                "code": "```\\ndef numComponents(self, head, G):\\n        subsetVals = set(G)\\n        current = head\\n        comps = 0\\n        elementsInComp = 0\\n        while current != None:\\n            curVal = current.val\\n            if curVal in subsetVals:\\n                elementsInComp += 1\\n            else:\\n                if elementsInComp > 0:\\n                    elementsInComp = 0\\n                    comps += 1\\n            current = current.next\\n        if elementsInComp > 0:\\n            comps += 1\\n        return comps\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 661254,
                "title": "python-3-two-pointer",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count = 0\\n        p1, p2 = head, head\\n        while p2:\\n            if p1.val in G:\\n                p2 = p1.next\\n                p1 = p2\\n                if not p2 or p2.val not in G:\\n                    count+=1\\n            else:\\n                p1 = p2.next\\n                p2 = p1\\n        return count\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count = 0\\n        p1, p2 = head, head\\n        while p2:\\n            if p1.val in G:\\n                p2 = p1.next\\n                p1 = p2\\n                if not p2 or p2.val not in G:\\n                    count+=1\\n            else:\\n                p1 = p2.next\\n                p2 = p1\\n        return count\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 622539,
                "title": "java-simple-easy-solution-using-hashset",
                "content": "Java\\n\\n```\\n\\nThe problem has straight solution which are as follows:-\\n\\n1. First Move all  element of G  into a another datastruture which can be used to detect the presence of element of G. \\n2. This can be achieved by using creating a HashSet or by creating the array of size the max element. then putting the element in its proper position.\\n3. Then simply traverse the LinkedList and check the element present in HashSet.\\n4. If It is present in the HashSet, the simply **set = 1**. if it is not present then check set = 1 , and increment the count.\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> h = new HashSet<>();\\n        for(int num : G) {\\n            h.add(num);\\n        }\\n        int count = 0,set = 0;\\n        while(head != null) {\\n            if(h.contains(head.val)) {\\n                set = 1;\\n            }else if(set == 1) {\\n                count++;\\n                set = 0;\\n            }\\n            head = head.next;\\n        }\\n        return set==1?count+1:count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nThe problem has straight solution which are as follows:-\\n\\n1. First Move all  element of G  into a another datastruture which can be used to detect the presence of element of G. \\n2. This can be achieved by using creating a HashSet or by creating the array of size the max element. then putting the element in its proper position.\\n3. Then simply traverse the LinkedList and check the element present in HashSet.\\n4. If It is present in the HashSet, the simply **set = 1**. if it is not present then check set = 1 , and increment the count.\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> h = new HashSet<>();\\n        for(int num : G) {\\n            h.add(num);\\n        }\\n        int count = 0,set = 0;\\n        while(head != null) {\\n            if(h.contains(head.val)) {\\n                set = 1;\\n            }else if(set == 1) {\\n                count++;\\n                set = 0;\\n            }\\n            head = head.next;\\n        }\\n        return set==1?count+1:count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617824,
                "title": "javascript-100-mem-95-faster",
                "content": "```\\nvar numComponents = function(head, G) {\\n    const set = new Set(G);\\n    let count = 0, prevConn = false;\\n    while(head) {\\n       const hasCon = set.has(head.val);\\n       if (!prevConn && hasCon) {\\n           count++;\\n       }\\n        prevConn = hasCon;\\n        head = head.next;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numComponents = function(head, G) {\\n    const set = new Set(G);\\n    let count = 0, prevConn = false;\\n    while(head) {\\n       const hasCon = set.has(head.val);\\n       if (!prevConn && hasCon) {\\n           count++;\\n       }\\n        prevConn = hasCon;\\n        head = head.next;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594744,
                "title": "100-space-and-time-super-simple-explanation",
                "content": "```\\nstatic int x = [](){ios::sync_with_stdio(false), cin.tie(NULL); return 0;}();\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& a) {\\n        \\n        bool s[10001]={};\\n        for(auto i:a)   s[i]=true;     //make hash to denote what all elements has been exists in array\\n        \\n        int ct=0;\\n        while(head)\\n        {\\n            bool b = false;\\n             while(head and s[head->val] )   // while connected \\n                   head = head->next , b = true;\\n            ct+=b;\\n            if(head)\\n                head = head->next;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int x = [](){ios::sync_with_stdio(false), cin.tie(NULL); return 0;}();\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& a) {\\n        \\n        bool s[10001]={};\\n        for(auto i:a)   s[i]=true;     //make hash to denote what all elements has been exists in array\\n        \\n        int ct=0;\\n        while(head)\\n        {\\n            bool b = false;\\n             while(head and s[head->val] )   // while connected \\n                   head = head->next , b = true;\\n            ct+=b;\\n            if(head)\\n                head = head->next;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556357,
                "title": "c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 536427,
                "title": "easy-c-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if(head == NULL || G.size() == 0) return 0;\\n        unordered_set<int> hash;\\n        for(int i : G)\\n            hash.insert(i);\\n        ListNode* curr = head;\\n        int count = 0, res = 0;\\n        while(curr != NULL){\\n            if(hash.count(curr->val))\\n                count = 1;\\n            else if(!hash.count(curr->val) && count > 0){\\n                res++;\\n                count = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        return count > 0 ? res + 1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if(head == NULL || G.size() == 0) return 0;\\n        unordered_set<int> hash;\\n        for(int i : G)\\n            hash.insert(i);\\n        ListNode* curr = head;\\n        int count = 0, res = 0;\\n        while(curr != NULL){\\n            if(hash.count(curr->val))\\n                count = 1;\\n            else if(!hash.count(curr->val) && count > 0){\\n                res++;\\n                count = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        return count > 0 ? res + 1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498357,
                "title": "python3-93-14",
                "content": "```\\ndef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        if not head:\\n            return 0\\n        A = set(G)\\n        total = 0\\n        while head:\\n            if head.val in A:\\n                while head.next and head.next.val in A:\\n                    head = head.next\\n                total += 1\\n            head = head.next\\n        return total\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\ndef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        if not head:\\n            return 0\\n        A = set(G)\\n        total = 0\\n        while head:\\n            if head.val in A:\\n                while head.next and head.next.val in A:\\n                    head = head.next\\n                total += 1\\n            head = head.next\\n        return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444135,
                "title": "python-expand-this-idea-to-tree-s-connected-components",
                "content": "**Approach 1(TLE):**\\n\\nIntital thoughts: In a linked list, a node\\'s connected components are its previous node and next node. First, we need to loop through the list to save all the tuples of node and its neighbors in a dictionary. \\n\\nThen we check every pairs of nodes (a, b) in G, to see if b is a neighbor of a; if so, we decrement the number of connected components, which is initailly set as the number of nodes in the original list, by 1.\\n\\nComplexity: \\n* Time: O(N + M choose 2 ) where N is the length of list and M is the length of G.\\n* Space: O(N) for the dictionary\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        d = collections.defaultdict(set)\\n        prev = dummy = ListNode(-1)\\n        dummy.next = head\\n\\t\\t\\n        p, nxt = head, head.next\\n        while p:\\n            d[p.val].add(prev.val) if prev else -1\\n            d[p.val].add(nxt.val) if nxt else -1\\n            if not p.next: break\\n            prev = p\\n            p = p.next\\n            nxt = nxt.next\\n            \\n        connNum = len(G)\\n        for a, b in itertools.combinations(G, 2):\\n            if b in d[a]:\\n                connNum -= 1\\n        return connNum\\n```\\n\\n**Approach 2:**\\nInstead of looking at two directions in the original list, we can just iterate through the list and look at the next node of the current node (`nxt`). If `cur` in G and `nxt` is not in G, it indicates that the current node itself is an isolate connected component; otherwise, current node and `nxt` are in the same connected component.\\n\\nComplexity: \\n* Time: O(N + M)\\n* Space: O(M) for the `Gset`\\n\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset = set(G)\\n        cur = head\\n        ans = 0\\n        while cur:\\n            if cur.val in Gset and getattr(cur.next, \\'val\\', None) not in Gset:\\n                ans += 1\\n            cur = cur.next\\n        return ans\\n```\\n\\n```\\n\\n```\\n-----------\\n**Possible Follow-up: What if the given input is the a tree and G contains TreeNodes?  Find the number of connected components in this tree**\\n\\n\\nAlgorithm:\\n* We can recursively find the number of connected components in the left subtree and the right subtree, namely, `ccLeft` and `ccRight`.\\n* Then the number of connected component in the current tree is the sum of `ccLeft` and `ccRight` and `X`, where `X` can be calculated using the concept in **the originaly problem:** If current node is in G and its sucessor is not, we increment number of connected components by 1. \\n\\t* Thus, if current is in G and only one child is in G, we don\\'t increment `temp` \\n\\t   \\t```\\n\\t\\t\\t o\\t\\t   o\\t      o\\n\\t\\t\\t/ \\\\\\t\\t  / \\\\        / \\\\\\t\\n\\t\\t   o   x     o   x      x   o \\n\\t\\t```\\n\\t    If current is in G and two child in G, in this special case, we increment `temp` by 1 .\\n\\t\\t```\\n\\t\\t\\t\\t o\\t\\n\\t\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t\\t   o   o  \\n\\t    ``` \\n\\t\\t**if current is in G and none if its children is in G, we increment `temp` by 1.**\\n\\t   \\t```\\n\\t\\t\\t o\\t\\t \\n\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t   x   x     \\n\\t\\t```\\n\\n\\nExample:\\n\\n```\\n\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   2    3\\n\\t\\t\\t\\t  / \\\\  /\\n\\t\\t\\t\\t 4  5  6\\n\\t\\t\\t    /\\\\     /\\\\\\n\\t\\t\\t   7  8   9 10\\n\\t\\t\\t  / \\\\\\n\\t\\t\\t 11 12\\n\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t   13 14\\n\\t\\t\\t\\t  / \\\\\\n\\t\\t\\t\\t 15 16\\n\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t\\t17    18\\n\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tans = 6\\n```\\n```\\nimport collections\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\nclass findComponentsInTree:\\n\\tdef __init__(self, G):\\n\\t\\tself.G = set(G)\\n\\n\\tdef numComponents(self, node):\\n\\t\\tprint(node.val if node else node)\\n\\t\\tif not node: return 0\\n\\t\\tcount = self.numComponents(node.left) + self.numComponents(node.right) + self.AdjustByShape(node)\\n\\t\\t#print(\"ajusted: \", node.val, self.AdjustByShape(node), count)\\n\\t\\treturn count\\n\\t\\n\\tdef AdjustByShape(self, node):\\n\\t\\tif node.val in self.G:\\n\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif not node.left:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.right)\\n\\t\\t\\telif not node.right:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.left)\\n\\t\\t\\telif node.left.val in self.G and node.right.val in self.G:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif node.left.val in self.G or node.right.val in self.G:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\nif __name__ == \"__main__\":\\n\\t# construct a tree example\\n\\troot = TreeNode(1)\\n\\troot.left, root.right = TreeNode(2), TreeNode(3)\\n\\tp, q = root.left, root.right\\n\\tp.left, p.right = TreeNode(4), TreeNode(5)\\n\\tq.left, q.right = TreeNode(6), None\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(7), TreeNode(8)\\n\\tq = q.left\\n\\tq.left, q.right = TreeNode(9), TreeNode(10)\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(11), TreeNode(12)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(13), TreeNode(14)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(15), TreeNode(16)\\n\\tp, q = p.left, p.right\\n\\tp.left, p.right = TreeNode(17), None\\n\\tq.left, q.right = None, TreeNode(18)\\n\\t\\'\\'\\'\\n\\tdef printTreeByLevel(root):\\n\\t\\tlevels = []\\n\\t\\tqueue = collections.deque([root])\\n\\t\\twhile queue:\\n\\t\\t\\tlevel = []\\n\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\tlevel.append(node.val) \\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\t\\tlevels.append(level)\\n\\t\\tprint(levels)\\n\\n\\tprintTreeByLevel(root)\\n\\t\\'\\'\\'\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tsol = findComponentsInTree(G)\\n\\tprint(\"ans: \", sol.numComponents(root))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        d = collections.defaultdict(set)\\n        prev = dummy = ListNode(-1)\\n        dummy.next = head\\n\\t\\t\\n        p, nxt = head, head.next\\n        while p:\\n            d[p.val].add(prev.val) if prev else -1\\n            d[p.val].add(nxt.val) if nxt else -1\\n            if not p.next: break\\n            prev = p\\n            p = p.next\\n            nxt = nxt.next\\n            \\n        connNum = len(G)\\n        for a, b in itertools.combinations(G, 2):\\n            if b in d[a]:\\n                connNum -= 1\\n        return connNum\\n```\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset = set(G)\\n        cur = head\\n        ans = 0\\n        while cur:\\n            if cur.val in Gset and getattr(cur.next, \\'val\\', None) not in Gset:\\n                ans += 1\\n            cur = cur.next\\n        return ans\\n```\n```\\n\\n```\n```\\n\\t\\t\\t o\\t\\t   o\\t      o\\n\\t\\t\\t/ \\\\\\t\\t  / \\\\        / \\\\\\t\\n\\t\\t   o   x     o   x      x   o \\n\\t\\t```\n```\\n\\t\\t\\t\\t o\\t\\n\\t\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t\\t   o   o  \\n\\t    ```\n```\\n\\t\\t\\t o\\t\\t \\n\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t   x   x     \\n\\t\\t```\n```\\n\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   2    3\\n\\t\\t\\t\\t  / \\\\  /\\n\\t\\t\\t\\t 4  5  6\\n\\t\\t\\t    /\\\\     /\\\\\\n\\t\\t\\t   7  8   9 10\\n\\t\\t\\t  / \\\\\\n\\t\\t\\t 11 12\\n\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t   13 14\\n\\t\\t\\t\\t  / \\\\\\n\\t\\t\\t\\t 15 16\\n\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t\\t17    18\\n\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tans = 6\\n```\n```\\nimport collections\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\nclass findComponentsInTree:\\n\\tdef __init__(self, G):\\n\\t\\tself.G = set(G)\\n\\n\\tdef numComponents(self, node):\\n\\t\\tprint(node.val if node else node)\\n\\t\\tif not node: return 0\\n\\t\\tcount = self.numComponents(node.left) + self.numComponents(node.right) + self.AdjustByShape(node)\\n\\t\\t#print(\"ajusted: \", node.val, self.AdjustByShape(node), count)\\n\\t\\treturn count\\n\\t\\n\\tdef AdjustByShape(self, node):\\n\\t\\tif node.val in self.G:\\n\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif not node.left:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.right)\\n\\t\\t\\telif not node.right:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.left)\\n\\t\\t\\telif node.left.val in self.G and node.right.val in self.G:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif node.left.val in self.G or node.right.val in self.G:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\nif __name__ == \"__main__\":\\n\\t# construct a tree example\\n\\troot = TreeNode(1)\\n\\troot.left, root.right = TreeNode(2), TreeNode(3)\\n\\tp, q = root.left, root.right\\n\\tp.left, p.right = TreeNode(4), TreeNode(5)\\n\\tq.left, q.right = TreeNode(6), None\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(7), TreeNode(8)\\n\\tq = q.left\\n\\tq.left, q.right = TreeNode(9), TreeNode(10)\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(11), TreeNode(12)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(13), TreeNode(14)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(15), TreeNode(16)\\n\\tp, q = p.left, p.right\\n\\tp.left, p.right = TreeNode(17), None\\n\\tq.left, q.right = None, TreeNode(18)\\n\\t\\'\\'\\'\\n\\tdef printTreeByLevel(root):\\n\\t\\tlevels = []\\n\\t\\tqueue = collections.deque([root])\\n\\t\\twhile queue:\\n\\t\\t\\tlevel = []\\n\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\tlevel.append(node.val) \\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\t\\tlevels.append(level)\\n\\t\\tprint(levels)\\n\\n\\tprintTreeByLevel(root)\\n\\t\\'\\'\\'\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tsol = findComponentsInTree(G)\\n\\tprint(\"ans: \", sol.numComponents(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436589,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset= set()\\n        \\n        for g in G:\\n            Gset.add(g)\\n        \\n        result=0\\n        \\n        while(head and head.val not in Gset):\\n            head= head.next\\n        prev= None\\n        while(head):\\n            if head.val not in Gset:\\n                result+=1\\n                while(head and head.val not in Gset):\\n                    prev= head\\n                    head= head.next\\n            else:\\n                prev= head\\n                head= head.next\\n        if prev and prev.val in Gset:\\n            result+=1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset= set()\\n        \\n        for g in G:\\n            Gset.add(g)\\n        \\n        result=0\\n        \\n        while(head and head.val not in Gset):\\n            head= head.next\\n        prev= None\\n        while(head):\\n            if head.val not in Gset:\\n                result+=1\\n                while(head and head.val not in Gset):\\n                    prev= head\\n                    head= head.next\\n            else:\\n                prev= head\\n                head= head.next\\n        if prev and prev.val in Gset:\\n            result+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412720,
                "title": "c-concise-solution",
                "content": "Delete the node if it is not the last one for each groups. \\nAt the end, HashSet contains only 1 node per each group.\\n\\n```\\npublic class Solution {\\n    public int NumComponents(ListNode head, int[] G) {\\n        HashSet<int> hash = new HashSet<int>();\\n        foreach(int x in G)\\n            hash.Add(x);\\n        \\n        while(head != null)\\n        {\\n            if(head.next != null && hash.Contains(head.next.val))\\n                hash.Remove(head.val);\\n            head = head.next;\\n        }\\n        \\n        return hash.Count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumComponents(ListNode head, int[] G) {\\n        HashSet<int> hash = new HashSet<int>();\\n        foreach(int x in G)\\n            hash.Add(x);\\n        \\n        while(head != null)\\n        {\\n            if(head.next != null && hash.Contains(head.next.val))\\n                hash.Remove(head.val);\\n            head = head.next;\\n        }\\n        \\n        return hash.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400359,
                "title": "javascript-64ms-faster-than-90",
                "content": "```js\\nconst numComponents = (head, G) => {\\n    const set = new Set(G);\\n    let pointer = head,\\n\\t\\tstack = [],\\n\\t\\tans = 0;\\n\\t\\n    while (pointer) {\\n\\t\\t// If there\\'s overlapped number, push to stack  \\n        if (set.has(pointer.val)) {\\n            stack.push(pointer.val);\\n        } else {\\n\\t\\t\\t// Once the continuous stopped and there\\'s something in the stack, ans++  \\n            if (stack.length) {\\n                ans++;\\n                stack = [];\\n            }\\n        }\\n        pointer = pointer.next;\\n    }\\n\\t\\n\\t// Check if there\\'s numbers left in stack\\n    return (stack.length) ? ans + 1 : ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst numComponents = (head, G) => {\\n    const set = new Set(G);\\n    let pointer = head,\\n\\t\\tstack = [],\\n\\t\\tans = 0;\\n\\t\\n    while (pointer) {\\n\\t\\t// If there\\'s overlapped number, push to stack  \\n        if (set.has(pointer.val)) {\\n            stack.push(pointer.val);\\n        } else {\\n\\t\\t\\t// Once the continuous stopped and there\\'s something in the stack, ans++  \\n            if (stack.length) {\\n                ans++;\\n                stack = [];\\n            }\\n        }\\n        pointer = pointer.next;\\n    }\\n\\t\\n\\t// Check if there\\'s numbers left in stack\\n    return (stack.length) ? ans + 1 : ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342745,
                "title": "why-so-many-dislikes-to-this-question",
                "content": "I mean the question is not tough but is there a reason behind so many dislikes to this question?\\nThe solution is pretty staight forward with no edge cases. What am I missing?\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> set;\\n        for(int & v : G)\\n            set.insert(v);\\n        int ans = 0;\\n        ListNode * ptr = head;\\n        while(ptr)\\n        {\\n            if(set.count(ptr -> val))\\n            {\\n                ++ans;\\n                while(ptr && set.count(ptr -> val))\\n                    ptr = ptr -> next;\\n            }\\n            else ptr = ptr -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> set;\\n        for(int & v : G)\\n            set.insert(v);\\n        int ans = 0;\\n        ListNode * ptr = head;\\n        while(ptr)\\n        {\\n            if(set.count(ptr -> val))\\n            {\\n                ++ans;\\n                while(ptr && set.count(ptr -> val))\\n                    ptr = ptr -> next;\\n            }\\n            else ptr = ptr -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342550,
                "title": "c-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\tint numComponents(ListNode* head, vector<int>& G) {\\n\\t\\tbool arr[10000] = { false };\\n\\t\\tfor (int i = 0; i < G.size(); i++) arr[G[i]] = true;\\n\\t\\tListNode *p = head;\\n\\t\\tint count = 0;\\n\\t\\twhile (p!= NULL) {\\n\\t\\t\\tif (arr[p->val]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\twhile (p!=NULL&&arr[p->val]) p = p->next;\\n\\t\\t\\t}\\n\\t\\t\\telse p = p->next;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\tint numComponents(ListNode* head, vector<int>& G) {\\n\\t\\tbool arr[10000] = { false };\\n\\t\\tfor (int i = 0; i < G.size(); i++) arr[G[i]] = true;\\n\\t\\tListNode *p = head;\\n\\t\\tint count = 0;\\n\\t\\twhile (p!= NULL) {\\n\\t\\t\\tif (arr[p->val]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\twhile (p!=NULL&&arr[p->val]) p = p->next;\\n\\t\\t\\t}\\n\\t\\t\\telse p = p->next;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340145,
                "title": "python3-solution-single-pass",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count=0\\n        i=head\\n        while i:\\n            if i.val in G:\\n                count+=1\\n                while i and i.val in G:\\n                    i=i.next\\n            else :i=i.next\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count=0\\n        i=head\\n        while i:\\n            if i.val in G:\\n                count+=1\\n                while i and i.val in G:\\n                    i=i.next\\n            else :i=i.next\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334107,
                "title": "c-9x-solution",
                "content": "It is hard to say this is a linked list problem.\\n```cpp\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        bool found = false;\\n        int n = 0;\\n        while (head != nullptr) {\\n            if (s.count(head->val)) {\\n                if (!found) {\\n                    found = true;  \\n                    n++;\\n                } \\n            } else {\\n                found = false;\\n            }\\n            head = head->next;\\n        }\\n        return n;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        bool found = false;\\n        int n = 0;\\n        while (head != nullptr) {\\n            if (s.count(head->val)) {\\n                if (!found) {\\n                    found = true;  \\n                    n++;\\n                } \\n            } else {\\n                found = false;\\n            }\\n            head = head->next;\\n        }\\n        return n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326995,
                "title": "python-union-find",
                "content": "My solution is convoluted compared to the concise solutions that others shared here, but wanted to share that it is possible to solve the problem using Disjoint Set (Union Find).\\n\\nThe idea is to perform `union` when both the current node and next node exist in `G`, and then count total number of unique items from the disjoint set.\\n\\n```py\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        self.parent[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        def length(head):\\n            cnt = 0\\n            if not head:\\n                return 0\\n            tmp = head\\n            while tmp:\\n                tmp = tmp.next\\n                cnt += 1\\n            return cnt\\n        \\n        n = length(head)\\n        uf = UnionFind(n)\\n        tmp = head\\n        subset = set(G)\\n        while tmp:\\n            if tmp.val in subset and tmp.next and tmp.next.val in subset:\\n                uf.union(tmp.val, tmp.next.val)\\n            tmp = tmp.next\\n        \\n        unique_count = len(set(uf.find(x) for x in G))\\n        return unique_count\\n```",
                "solutionTags": [],
                "code": "```py\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        self.parent[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        def length(head):\\n            cnt = 0\\n            if not head:\\n                return 0\\n            tmp = head\\n            while tmp:\\n                tmp = tmp.next\\n                cnt += 1\\n            return cnt\\n        \\n        n = length(head)\\n        uf = UnionFind(n)\\n        tmp = head\\n        subset = set(G)\\n        while tmp:\\n            if tmp.val in subset and tmp.next and tmp.next.val in subset:\\n                uf.union(tmp.val, tmp.next.val)\\n            tmp = tmp.next\\n        \\n        unique_count = len(set(uf.find(x) for x in G))\\n        return unique_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300450,
                "title": "python-with-explanation",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # How many different case will end up to be different component:\\n        # 1. the next of curr is not in G, then the prev one will be component \\n        # 2. Once again one node in G, it will start another component\\n        # 3. Exit, reach the end.\\n        setG = set(G)\\n        count = 0\\n\\n        while head:\\n            # process curr node:\\n            if head.val in setG:\\n                count += 1\\n                while head.next:\\n                    # if we find a component, we keep moving head until the first item not in setG\\n                    if head.val in setG:\\n                        head = head.next \\n                    else:\\n                        # e.g point stoped at 2\\n                        break\\n            \\n            head = head.next\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # How many different case will end up to be different component:\\n        # 1. the next of curr is not in G, then the prev one will be component \\n        # 2. Once again one node in G, it will start another component\\n        # 3. Exit, reach the end.\\n        setG = set(G)\\n        count = 0\\n\\n        while head:\\n            # process curr node:\\n            if head.val in setG:\\n                count += 1\\n                while head.next:\\n                    # if we find a component, we keep moving head until the first item not in setG\\n                    if head.val in setG:\\n                        head = head.next \\n                    else:\\n                        # e.g point stoped at 2\\n                        break\\n            \\n            head = head.next\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282708,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nBasically counting all the starting points of the chains. First while loop gets you to start of the chain, next while loop gets you to a node just past the end of the chain.\\n\\n```\\npublic int numComponents(ListNode head, int[] g) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : g)\\n            set.add(i);\\n        int count = 0;\\n        while(head != null){\\n            while(head != null && !set.contains(head.val)){\\n                head = head.next;\\n            }\\n            //new chain starting point\\n            if(head != null) ++count;\\n            while(head != null && set.contains(head.val)){\\n                set.remove(head.val);\\n                head = head.next;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numComponents(ListNode head, int[] g) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : g)\\n            set.add(i);\\n        int count = 0;\\n        while(head != null){\\n            while(head != null && !set.contains(head.val)){\\n                head = head.next;\\n            }\\n            //new chain starting point\\n            if(head != null) ++count;\\n            while(head != null && set.contains(head.val)){\\n                set.remove(head.val);\\n                head = head.next;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 228340,
                "title": "java-a-little-different-approach",
                "content": "After I submitted my solution, I looked at the official answer, and the Set approach is very clear and simple.  Well, I didn\\'t think of that on my own.  I used a method with some Maps.  This isn\\'t better, but it\\'s an alternate approach you might find interesting:\\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        int components=0;\\n        Map<Integer,ListNode> unseenNodes = new HashMap<Integer,ListNode>();\\n        Map<Integer,ListNode> seenNodes = new HashMap<Integer,ListNode>();\\n        for( ListNode cur=head; cur!=null; cur=cur.next ) unseenNodes.put( cur.val, cur );\\n        \\n        for( int val : G ) {\\n            ListNode cur=unseenNodes.get(val);\\n            if( cur==null ) cur=seenNodes.get(val); else components++;\\n            unseenNodes.remove(val);\\n            \\n            if( cur.next!=null ) {\\n                if( unseenNodes.remove(cur.next.val)==null ) components--;\\n                seenNodes.put( cur.next.val, cur.next );\\n            }\\n        }\\n        \\n        return components;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numComponents(ListNode head, int[] G) {\\n        int components=0;\\n        Map<Integer,ListNode> unseenNodes = new HashMap<Integer,ListNode>();\\n        Map<Integer,ListNode> seenNodes = new HashMap<Integer,ListNode>();\\n        for( ListNode cur=head; cur!=null; cur=cur.next ) unseenNodes.put( cur.val, cur );\\n        \\n        for( int val : G ) {\\n            ListNode cur=unseenNodes.get(val);\\n            if( cur==null ) cur=seenNodes.get(val); else components++;\\n            unseenNodes.remove(val);\\n            \\n            if( cur.next!=null ) {\\n                if( unseenNodes.remove(cur.next.val)==null ) components--;\\n                seenNodes.put( cur.next.val, cur.next );\\n            }\\n        }\\n        \\n        return components;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213046,
                "title": "simple-solution-for-beginners-in-c",
                "content": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        set<int> s;\\n        for (auto t: G) s.insert(t);\\n        int ans = 0;\\n    \\tint ok = 0;\\n        int j=0;\\n        auto p=s.find(7);\\n        cout<<*p;\\n        while (head != NULL){\\n        \\tif (s.find(head->val) != s.end()){\\n        \\t\\tif (!ok){\\n        \\t\\t\\tok = 1;\\n        \\t\\t\\tans ++;\\n        \\t\\t}\\n                \\n        \\t}\\n        \\t else {ok = 0;\\n                   \\n                   j++;\\n                   //cout<<head->val;\\n                  }\\n        \\thead = head->next;\\n        }\\t\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        set<int> s;\\n        for (auto t: G) s.insert(t);\\n        int ans = 0;\\n    \\tint ok = 0;\\n        int j=0;\\n        auto p=s.find(7);\\n        cout<<*p;\\n        while (head != NULL){\\n        \\tif (s.find(head->val) != s.end()){\\n        \\t\\tif (!ok){\\n        \\t\\t\\tok = 1;\\n        \\t\\t\\tans ++;\\n        \\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 190637,
                "title": "javascript",
                "content": "```\nvar numComponents = function(head, G) {\n    let result = 0;\n    let mark = false;\n    let i = 0;\n    while(head != null && i != G.length) {\n        if(G.indexOf(head.val) == -1) {\n            head = head.next;\n            mark = false;\n            continue;\n        }\n        if(mark) {\n            head = head.next;\n        } else {\n            mark = true;\n            result++;\n            head = head.next;\n        }\n        i++;\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar numComponents = function(head, G) {\n    let result = 0;\n    let mark = false;\n    let i = 0;\n    while(head != null && i != G.length) {\n        if(G.indexOf(head.val) == -1) {\n            head = head.next;\n            mark = false;\n            continue;\n        }\n        if(mark) {\n            head = head.next;\n        } else {\n            mark = true;\n            result++;\n            head = head.next;\n        }\n        i++;\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182578,
                "title": "c-solution",
                "content": "```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int numComponents(ListNode* head, vector<int>& G) {\n        set<int> myset;\n        set<int>::iterator it;\n        for (int i = 0; i < G.size(); i++) {\n            myset.insert(G[i]);\n        }\n        int count = 0;\n        bool flag = false;\n        ListNode* tmp = head;\n        while(tmp != nullptr) {\n            int val = tmp->val;\n            it = myset.find(val);\n            if (it != myset.end()) {\n                flag = true;\n            } else {\n                if (flag == true) {\n                    count++;\n                }\n                flag = false;\n            }\n            tmp = tmp->next;\n        }\n        if (flag == true) {\n            count++;\n        }\n        return count;\n        \n    }\n};\n```",
                "solutionTags": [],
                "code": "```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int numComponents(ListNode* head, vector<int>& G) {\n        set<int> myset;\n        set<int>::iterator it;\n        for (int i = 0; i < G.size(); i++) {\n            myset.insert(G[i]);\n        }\n        int count = 0;\n        bool flag = false;\n        ListNode* tmp = head;\n        while(tmp != nullptr) {\n            int val = tmp->val;\n            it = myset.find(val);\n            if (it != myset.end()) {\n                flag = true;\n            } else {\n                if (flag == true) {\n                    count++;\n                }\n                flag = false;\n            }\n            tmp = tmp->next;\n        }\n        if (flag == true) {\n            count++;\n        }\n        return count;\n        \n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 178709,
                "title": "c-easy-to-understand-solution-with-reading-notes",
                "content": "```\\n    //\\n    // PROBLEM DESCRIPTION: https://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case\\n    //  also note that the linked list nodes may not be in sorted order, although every test case depicts them to be as such.\\n    //\\n    \\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> gSet(G.begin(), G.end());\\n        \\n        int count = 0;\\n        ListNode* n = head;\\n        while (n != NULL)\\n        {\\n            if (gSet.find(n->val) != gSet.end())\\n            {\\n                count++;\\n                \\n                do \\n                {\\n                    n = n->next;\\n                } while(n != NULL && gSet.find(n->val) != gSet.end());\\n            }\\n            \\n            if (n != NULL)\\n                n = n->next;\\n        }\\n        \\n        return count;\\n        \\n    }\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    //\\n    // PROBLEM DESCRIPTION: https://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case\\n    //  also note that the linked list nodes may not be in sorted order, although every test case depicts them to be as such.\\n    //\\n    \\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> gSet(G.begin(), G.end());\\n        \\n        int count = 0;\\n        ListNode* n = head;\\n        while (n != NULL)\\n        {\\n            if (gSet.find(n->val) != gSet.end())\\n            {\\n                count++;\\n                \\n                do \\n                {\\n                    n = n->next;\\n                } while(n != NULL && gSet.find(n->val) != gSet.end());\\n            }\\n            \\n            if (n != NULL)\\n                n = n->next;\\n        }\\n        \\n        return count;\\n        \\n    }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142854,
                "title": "java-easy-solution-time-o-n-space-o-size-of-g",
                "content": "Steps:\\n1. Add all the integer array elements to a HashSet (for easy O(1) access).\\n2. Traverse the Linked List. Check if an element exists in the hashset.\\n3. If it does exist: If not counted previuosly, Assign prev_counted to true now and increse your counter (res). \\n4. If it doesn\\'t exist, change it back to false (Starting fresh).\\n5. Keep traversing until the end of the Linked List.\\n6. Return the result (res).\\n\\n\\n```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head==null) return 0;\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        int res=0;\\n        boolean prev_counted=false;\\n        for(int num:G) hs.add(num);\\n        \\n        ListNode curr=head;\\n        while(curr!=null)\\n        {\\n            int val=curr.val;\\n            if(hs.contains(val))\\n            {\\n                if(!prev_counted) \\n                {\\n                   res++;\\n                   prev_counted=true;\\n                }\\n            }\\n            else\\n            {\\n                prev_counted=false;\\n            }\\n            curr=curr.next;\\n        }\\n        return res;  \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head==null) return 0;\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        int res=0;\\n        boolean prev_counted=false;\\n        for(int num:G) hs.add(num);\\n        \\n        ListNode curr=head;\\n        while(curr!=null)\\n        {\\n            int val=curr.val;\\n            if(hs.contains(val))\\n            {\\n                if(!prev_counted) \\n                {\\n                   res++;\\n                   prev_counted=true;\\n                }\\n            }\\n            else\\n            {\\n                prev_counted=false;\\n            }\\n            curr=curr.next;\\n        }\\n        return res;  \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126768,
                "title": "c-o-n-g-solution",
                "content": "```\\nint numComponents(ListNode* head, vector<int>& G) \\n    {\\n        auto gSet = unordered_set<int>{begin(G),end(G)};\\n        \\n        int maxSize = 0;\\n        bool groupStart = false;\\n        \\n        while(head!=nullptr)\\n        {\\n            if(gSet.find(head->val) != gSet.end())\\n            {\\n                if(!groupStart)\\n                {\\n                    maxSize++;\\n                    groupStart = true;\\n                }                    \\n            }\\n            else groupStart = false;\\n            head = head->next;   \\n        }\\n        return maxSize;\\n    }",
                "solutionTags": [],
                "code": "```\\nint numComponents(ListNode* head, vector<int>& G) \\n    {\\n        auto gSet = unordered_set<int>{begin(G),end(G)};\\n        \\n        int maxSize = 0;\\n        bool groupStart = false;\\n        \\n        while(head!=nullptr)\\n        {\\n            if(gSet.find(head->val) != gSet.end())\\n            {\\n                if(!groupStart)\\n                {\\n                    maxSize++;\\n                    groupStart = true;\\n                }                    \\n            }\\n            else groupStart = false;\\n            head = head->next;   \\n        }\\n        return maxSize;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 123933,
                "title": "c-13ms-linear-time-without-hash-map",
                "content": "Most solutions posted here use a hash map, which means that the linear running time is only expected. Here is a linear-time solution that does not use a hash map. It is important to exploit the fact that the list is a permutation of `[0, N - 1]`. Therefore, we can build a mask to efficiently look up whether an element belongs to `G`.\\n\\n```\\nclass Solution\\n{\\n  private:\\n    vector<bool> build_mask(size_t n, const vector<int> & G)\\n    {\\n        vector<bool> mask(n, false);\\n        \\n        for (int i : G)\\n            mask[i] = true;\\n        \\n        return mask;\\n    }\\n    \\n    size_t length(ListNode * node)\\n    {\\n        if (! node)\\n            return 0;\\n        \\n        return 1 + length(node->next);\\n    }\\n    \\n  public:\\n    int numComponents(ListNode * head, vector<int> & G)\\n    {\\n        size_t n = length(head);\\n        \\n        vector<bool> mask = build_mask(n + 1, G);\\n        \\n        static ListNode * _head = new ListNode(n);\\n        _head->val = n;\\n        _head->next = head;\\n        \\n        int c = 0;\\n        \\n        for (ListNode * node = _head; node->next; node = node->next)\\n        {\\n            if (! mask[node->val] && mask[node->next->val])\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n  private:\\n    vector<bool> build_mask(size_t n, const vector<int> & G)\\n    {\\n        vector<bool> mask(n, false);\\n        \\n        for (int i : G)\\n            mask[i] = true;\\n        \\n        return mask;\\n    }\\n    \\n    size_t length(ListNode * node)\\n    {\\n        if (! node)\\n            return 0;\\n        \\n        return 1 + length(node->next);\\n    }\\n    \\n  public:\\n    int numComponents(ListNode * head, vector<int> & G)\\n    {\\n        size_t n = length(head);\\n        \\n        vector<bool> mask = build_mask(n + 1, G);\\n        \\n        static ListNode * _head = new ListNode(n);\\n        _head->val = n;\\n        _head->next = head;\\n        \\n        int c = 0;\\n        \\n        for (ListNode * node = _head; node->next; node = node->next)\\n        {\\n            if (! mask[node->val] && mask[node->next->val])\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123824,
                "title": "c-very-simple-solution",
                "content": "````\\n// General idea:\\n// - iterate through the linked-list and keep track of when you are in/out of component\\n// - every time you EXIT a component, increment your count (ans)\\n// - make sure to check if you finished the list in a component\\n\\nbool in = false;\\nint ans = 0;\\n\\nint numComponents(ListNode* head, vector<int>& G) \\n{\\n    unordered_set<int> v (G.begin (), G.end ());\\n\\n    while (head) \\n    {\\n        if (v.count (head->val)) in = true;\\n        else if (in) ans++, in = false;\\n\\n        head = head->next;\\n    }\\n\\n    if (in) ans++;\\n\\n    return ans;\\n}",
                "solutionTags": [],
                "code": "````\\n// General idea:\\n// - iterate through the linked-list and keep track of when you are in/out of component\\n// - every time you EXIT a component, increment your count (ans)\\n// - make sure to check if you finished the list in a component\\n\\nbool in = false;\\nint ans = 0;\\n\\nint numComponents(ListNode* head, vector<int>& G) \\n{\\n    unordered_set<int> v (G.begin (), G.end ());\\n\\n    while (head) \\n    {\\n        if (v.count (head->val)) in = true;\\n        else if (in) ans++, in = false;\\n\\n        head = head->next;\\n    }\\n\\n    if (in) ans++;\\n\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4100244,
                "title": "cpp-sol",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n) where n is no. of nodes\\n\\n- Space complexity:\\nO(m) for unordered set\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numSet(nums.begin(), nums.end());\\n        ListNode* current = head;\\n        int numCount = 0;\\n        bool inComponent = false;\\n\\n        while (current != nullptr) {\\n            if (numSet.count(current->val)) {\\n                if (!inComponent) {\\n                    numCount++;\\n                    inComponent = true;\\n                }\\n            } else {\\n                inComponent = false;\\n            }\\n            current = current->next;\\n        }\\n\\n        return numCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numSet(nums.begin(), nums.end());\\n        ListNode* current = head;\\n        int numCount = 0;\\n        bool inComponent = false;\\n\\n        while (current != nullptr) {\\n            if (numSet.count(current->val)) {\\n                if (!inComponent) {\\n                    numCount++;\\n                    inComponent = true;\\n                }\\n            } else {\\n                inComponent = false;\\n            }\\n            current = current->next;\\n        }\\n\\n        return numCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089467,
                "title": "java-hashset",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i : nums){\\n            hs.add(i);\\n        }\\n        int ans = 0;\\n        boolean prev = false;\\n        while(head != null){\\n            int a = head.val;\\n            if(hs.contains(a)){\\n                if(!prev){\\n                    ans++;\\n                    prev = true;\\n                }\\n            }else{\\n                prev = false;\\n            }\\n            head = head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i : nums){\\n            hs.add(i);\\n        }\\n        int ans = 0;\\n        boolean prev = false;\\n        while(head != null){\\n            int a = head.val;\\n            if(hs.contains(a)){\\n                if(!prev){\\n                    ans++;\\n                    prev = true;\\n                }\\n            }else{\\n                prev = false;\\n            }\\n            head = head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081394,
                "title": "my-approach-easy-solution-in-python",
                "content": "class Solution(object):\\n    def numComponents(self, head, nums):\\n        count = 0\\n        d = {}\\n        val = head.val  # Assuming head is the head node of your linked list\\n        curr = head  # Assuming curr starts at the head node\\n        while curr:\\n            if curr.val in nums:\\n                count = 1\\n                d[val] = count\\n            else:\\n                d[curr.val] = None\\n                count = 0\\n                if curr.next:\\n                    val = curr.next.val  # Assuming curr.next is the next node in the linked list\\n            curr = curr.next  # Move to the next node in the linked list\\n        print(d)\\n        sum_of_values = sum(value for value in d.values() if value is not None)\\n        return sum_of_values",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numComponents(self, head, nums):\\n        count = 0\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 4077970,
                "title": "easy-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing a dictionary wheather the value is in nums.For this u have to convert this nums array into dictionary..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.At first check the length of head and nums  are same .If same then the answer is 1!!!(Because all values are eventually connected with each other).\\n2.If the first condition is False then check the consecutive values  in head are present in new_nums(dictionary) using while loop .While consecutive values are present in dictionary then head pointer is increased by head.next .Else increse count value by one.\\n3.Increment head pointer \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n).Head counter will go to the last node !!!\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        new_nums={}\\n        for value in nums:\\n            if value not in new_nums:\\n                new_nums[value]=1\\n        count=0\\n        total=0\\n        new_head=head\\n        while new_head:\\n            total+=1\\n            new_head=new_head.next\\n        while head:\\n            if head.val in new_nums:\\n                if total==len(nums):\\n                    return 1\\n                while head.next is not None and head.next.val in new_nums:\\n                    head=head.next\\n                count+=1                \\n            head=head.next\\n        return count \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        new_nums={}\\n        for value in nums:\\n            if value not in new_nums:\\n                new_nums[value]=1\\n        count=0\\n        total=0\\n        new_head=head\\n        while new_head:\\n            total+=1\\n            new_head=new_head.next\\n        while head:\\n            if head.val in new_nums:\\n                if total==len(nums):\\n                    return 1\\n                while head.next is not None and head.next.val in new_nums:\\n                    head=head.next\\n                count+=1                \\n            head=head.next\\n        return count \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061269,
                "title": "easy-python-solution-in-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\n        temp = head\\n        count = 0\\n\\n        connected = False  \\n\\n        while(temp):\\n            if(temp.val in nums):\\n                if(connected == False):\\n                    connected = True\\n                    count += 1\\n            else:\\n                connected = False\\n\\n            temp = temp.next\\n\\n        return count\\n```\\n\\n# Explanation\\n\\n1) Traverse the linked list while keeping track of whether you are within a connected component (in this case, a connected component means a sequence of nodes with values in nums that appear consecutively).\\n\\n2) When you encounter a node with a value in nums, start or continue a connected component.\\n\\n3) When you encounter a node with a value not in nums, end the current connected component.\\n\\n4) Count the number of connected components as you traverse the linked list.\\n\\n\\n\\n##### If you find my solution helpful and worthy, please consider upvoting my solution. Upvotes play a crucial role in ensuring that this valuable content reaches others and helps them as well.\\n\\n##### Only your support motivates me to continue contributing more solutions and assisting the community further.\\n\\n##### Thank You for spending your valuable time.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\n        temp = head\\n        count = 0\\n\\n        connected = False  \\n\\n        while(temp):\\n            if(temp.val in nums):\\n                if(connected == False):\\n                    connected = True\\n                    count += 1\\n            else:\\n                connected = False\\n\\n            temp = temp.next\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060779,
                "title": "c-simple-observation-and-hashing",
                "content": "# Intuition\\nit is stated the we can connect consecutive number from the arrays and make one component so we will check if all the consective number can be a part of our result or not  For ex 0,1,2,3 :: 0 and 1 are part of subset nums also so will keep goind and include them in one subset and stop wehenever the condition is not true \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int>st(nums.begin(),nums.end());\\n         vector<int>v;\\n         while(head!=NULL)\\n          v.push_back(head->val),head=head->next;\\n          int comp=0;\\n          int sz=v.size();\\n          for(int i=0;i<sz;i++)\\n           {\\n             int j=i;\\n              while(j<sz and st.find(v[j])!=st.end())\\n                {\\n                    //one component \\n                    \\n                      j++;\\n                }\\n               \\n                if(i!=j)\\n                 comp++,i=j;\\n                  \\n           }\\n           return comp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int>st(nums.begin(),nums.end());\\n         vector<int>v;\\n         while(head!=NULL)\\n          v.push_back(head->val),head=head->next;\\n          int comp=0;\\n          int sz=v.size();\\n          for(int i=0;i<sz;i++)\\n           {\\n             int j=i;\\n              while(j<sz and st.find(v[j])!=st.end())\\n                {\\n                    //one component \\n                    \\n                      j++;\\n                }\\n               \\n                if(i!=j)\\n                 comp++,i=j;\\n                  \\n           }\\n           return comp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056832,
                "title": "go-easy",
                "content": "```\\nfunc numComponents(head *ListNode, nums []int) int {\\n    targets := make(map[int]bool)\\n\\n    for _, num := range nums {\\n        targets[num] = true\\n    }\\n\\n    components := 0\\n    var prev *ListNode\\n\\n    for cur := head; cur != nil; cur = cur.Next {\\n        if prev != nil {\\n            if !targets[prev.Val] && targets[cur.Val] {\\n                components++\\n            }\\n        } else {\\n            if targets[cur.Val] {\\n                components++\\n            }\\n        }\\n        prev = cur\\n    }\\n\\n    return components\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numComponents(head *ListNode, nums []int) int {\\n    targets := make(map[int]bool)\\n\\n    for _, num := range nums {\\n        targets[num] = true\\n    }\\n\\n    components := 0\\n    var prev *ListNode\\n\\n    for cur := head; cur != nil; cur = cur.Next {\\n        if prev != nil {\\n            if !targets[prev.Val] && targets[cur.Val] {\\n                components++\\n            }\\n        } else {\\n            if targets[cur.Val] {\\n                components++\\n            }\\n        }\\n        prev = cur\\n    }\\n\\n    return components\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055545,
                "title": "self-explanatory-comments-using-set-hash-table-best-ever-c-solution",
                "content": "~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63 \\uD83D\\uDE0A\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHer There! Its Easy Just Take A Look At The Code And Comments Within It, You\\'ll Get It.\\nStill Have Doubts! Feel Free To Comment, I\\'ll Definitely Reply!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Unordered-Set (Accepted)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Program to find the number of connected components in \"nums\" where two values are connected if they appear consecutively in the linked list ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <unordered_set>\\n\\n// List template\\nstruct Node {\\n    int val;\\n    Node* next;\\n\\n    // Init constructor\\n    Node(int val, Node* next = nullptr)\\n    :\\n    val(val), next(next) {}\\n\\n    // Init destructor\\n    ~Node() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Method to find the number of connected components - O(N) & O(N) : Where N is the total number of nodes of the list\\nint numComponents(Node* head, std::vector<int> nums) {\\n    std::unordered_set<int> set(begin(nums), end(nums));\\n\\n    // Require to store the number of connected components (resultant value)\\n    int count = 0;\\n\\n    while(head) {\\n        // Increment the count if its the beginning of a new component\\n        if(set.count(head->val)) {\\n            count++;\\n            // Skip the consecutive nodes of the current component\\n            while(head && set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n        // Else, skip the non-component nodes until a potential component node is found\\n        else {\\n            while(head && !set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n// Note: There are also multiple solutions of this problem, do check it out.\\n\\n// Method to print the list using recursion\\nvoid printList(Node* head) {\\n    if(head) {\\n        std::cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating, connecting nodes and initializing their data\\n    Node* head = new Node(0, new Node(1, new Node(2, new Node(3))));\\n\\n    // Print call\\n    printList(head);\\n\\n    // Call to find the number of connected components\\n    int count = numComponents(head, {0,1,3});\\n    std::cout<<\"\\\\nThe number of connected components is : \"<<count;\\n\\n    // Deletion call\\n    delete head;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-components/description/\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n// Program to find the number of connected components in \"nums\" where two values are connected if they appear consecutively in the linked list ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <unordered_set>\\n\\n// List template\\nstruct Node {\\n    int val;\\n    Node* next;\\n\\n    // Init constructor\\n    Node(int val, Node* next = nullptr)\\n    :\\n    val(val), next(next) {}\\n\\n    // Init destructor\\n    ~Node() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Method to find the number of connected components - O(N) & O(N) : Where N is the total number of nodes of the list\\nint numComponents(Node* head, std::vector<int> nums) {\\n    std::unordered_set<int> set(begin(nums), end(nums));\\n\\n    // Require to store the number of connected components (resultant value)\\n    int count = 0;\\n\\n    while(head) {\\n        // Increment the count if its the beginning of a new component\\n        if(set.count(head->val)) {\\n            count++;\\n            // Skip the consecutive nodes of the current component\\n            while(head && set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n        // Else, skip the non-component nodes until a potential component node is found\\n        else {\\n            while(head && !set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n// Note: There are also multiple solutions of this problem, do check it out.\\n\\n// Method to print the list using recursion\\nvoid printList(Node* head) {\\n    if(head) {\\n        std::cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating, connecting nodes and initializing their data\\n    Node* head = new Node(0, new Node(1, new Node(2, new Node(3))));\\n\\n    // Print call\\n    printList(head);\\n\\n    // Call to find the number of connected components\\n    int count = numComponents(head, {0,1,3});\\n    std::cout<<\"\\\\nThe number of connected components is : \"<<count;\\n\\n    // Deletion call\\n    delete head;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-components/description/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4051027,
                "title": "python-my-approach",
                "content": "# Intuition\\n  use a current pointer to traverse the linked list\\n  fill the stack if you find a element common in linked list and array\\n  when you dont find a common element clear the stack and update count by +1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        curr = head \\n        stack=[]\\n        count=0\\n        while curr:\\n            if curr.val in nums :\\n                stack.append(curr.val)\\n                curr=curr.next\\n                continue\\n            if curr.val not in nums :\\n                if stack :\\n                    stack=[]\\n                    count+=1\\n                curr=curr.next\\n                continue\\n        if stack :\\n            return count+1\\n        else :\\n            return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        curr = head \\n        stack=[]\\n        count=0\\n        while curr:\\n            if curr.val in nums :\\n                stack.append(curr.val)\\n                curr=curr.next\\n                continue\\n            if curr.val not in nums :\\n                if stack :\\n                    stack=[]\\n                    count+=1\\n                curr=curr.next\\n                continue\\n        if stack :\\n            return count+1\\n        else :\\n            return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045418,
                "title": "beats-96-efficient-solution-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* temp=head;\\n        unordered_set<int> uSet;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) uSet.insert(nums[i]);\\n        bool flag=false;\\n        int count=0;\\n        while(temp){\\n            if(!flag && uSet.find(temp->val)!=uSet.end()){\\n                flag=true;\\n                count++;\\n            }\\n            else if(flag && uSet.find(temp->val)==uSet.end())\\n                flag=false;\\n            temp=temp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* temp=head;\\n        unordered_set<int> uSet;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) uSet.insert(nums[i]);\\n        bool flag=false;\\n        int count=0;\\n        while(temp){\\n            if(!flag && uSet.find(temp->val)!=uSet.end()){\\n                flag=true;\\n                count++;\\n            }\\n            else if(flag && uSet.find(temp->val)==uSet.end())\\n                flag=false;\\n            temp=temp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1565358,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1566275,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1898825,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1570334,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1575123,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1567375,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1994891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1749328,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1571914,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1564891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1565358,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1566275,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1898825,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1570334,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1575123,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1567375,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1994891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1749328,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1571914,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1572098,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1821404,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1643292,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1627810,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1575080,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2052109,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2043669,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2014648,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2005726,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1967090,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            }
        ]
    }
]