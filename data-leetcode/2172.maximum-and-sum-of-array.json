[
    {
        "title": "Maximum AND Sum of Array",
        "question_content": "You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots.\nYou have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number.\n\n\tFor example, the AND sum of placing the numbers [1, 3] into slot 1 and [4, 6] into slot 2 is equal to (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4.\n\nReturn the maximum possible AND sum of nums given numSlots slots.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,4,5,6], numSlots = 3\nOutput: 9\nExplanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3. \nThis gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.\n\nExample 2:\n\nInput: nums = [1,3,10,4,7,1], numSlots = 9\nOutput: 24\nExplanation: One possible placement is [1, 1] into slot 1, [3] into slot 3, [4] into slot 4, [7] into slot 7, and [10] into slot 9.\nThis gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.\nNote that slots 2, 5, 6, and 8 are empty which is permitted.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t1 <= numSlots <= 9\n\t1 <= n <= 2 * numSlots\n\t1 <= nums[i] <= 15",
        "solutions": [
            {
                "id": 1766824,
                "title": "java-c-python-dp-solution",
                "content": "Watching Beijing Olympics game,\\nyou will be encouraged and have better performance on LeetCode.\\n\\n# **Intuition**\\nDP solution, but need to figure out how to define bit mask.\\n\\nI considered two options\\n1) Use a mask on base-3\\n2) Use a mask on base-2, and each slot takes two bits.\\n\\nI feel no big difference on code length,\\nand base-3 has slightly better complexity.\\n<br>\\n\\n# **Optimization**\\nUsually the bitmask dp will be in format of `dp(i, mask) = max(current, dp(i, mask - bit) + value)`\\nand we memorized `dp(i, mask)`.\\nActually in this problem, I only memorized `mask`, without caring about `i`.\\nSince `mask` has the information of the `slots` used\\n<br>\\n\\n# **Explanation**\\nWe recursively check `dp(i, mask)`,\\nmeanning we are going to assign `A[i]` with current bitmask `mask`.\\n`dp(i, mask)` is the biggest AND sum we can get, by assign `A[0]` to `A[i]` into the remaining slots.\\n\\nWe iterate all slots, the corresponding `bit = 3 ** (slot - 1)`.\\nTher check if this `slot` is availble.\\nIf it\\'s available, we take it and recursively check `dp(i - 1, mask - bit)`.\\n<br>\\n\\n# **Complexity**\\nTime `O(ns * 3^ns)`\\nSpace `O(3^ns)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximumANDSum(int[] A, int ns) {\\n        int mask = (int)Math.pow(3, ns) - 1;\\n        int[] memo = new int[mask + 1];\\n        return dp(A.length - 1, mask, ns, memo, A);\\n    }\\n    \\n    private int dp(int i, int mask, int ns, int[] memo, int[] A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i < 0) return 0;\\n        for (int slot = 1, bit = 1; slot <= ns; ++slot, bit*= 3)\\n            if (mask / bit % 3 > 0)\\n                memo[mask] = Math.max(memo[mask], (A[i] & slot) + dp(i - 1, mask - bit, ns, memo, A));\\n        return memo[mask];\\n    }\\n```\\n\\n**C++**\\nUsing helper function\\n```cpp\\n    int maximumANDSum(vector<int>& A, int ns) {\\n        int mask = pow(3, ns) - 1;\\n        vector<int> memo(mask + 1, 0);\\n        return dp(A.size() - 1, mask, ns, memo, A);\\n    }\\n    \\n    int dp(int i, int mask, int ns, vector<int>& memo, vector<int>& A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i < 0) return 0;\\n        for (int slot = 1, bit = 1; slot <= ns; ++slot, bit*= 3)\\n            if (mask / bit % 3 > 0)\\n                memo[mask] = max(memo[mask], (A[i] & slot) + dp(i - 1, mask - bit, ns, memo, A));\\n        return memo[mask];\\n    }\\n```\\n\\n**C++**\\nusing lambda function\\n```cpp\\n    int maximumANDSum(vector<int>& A, int ns) {\\n        int mask = pow(3, ns) - 1;\\n        vector<int> memo(mask + 1, 0);\\n\\n        function<int(int, int)> dp =\\n        [&](int i, int mask) {\\n            int& res = memo[mask];\\n            if (res > 0) return res;\\n            if (i < 0) return 0;\\n            for (int slot = 1, bit = 1; slot <= ns; ++slot, bit *= 3)\\n                if (mask / bit % 3 > 0)\\n                    res = max(res, (A[i] & slot) + dp(i - 1, mask - bit));\\n            return res;\\n        };\\n\\n        return dp(A.size() - 1, mask);\\n    }\\n```\\n**Python3**\\n```py\\n    def maximumANDSum(self, A, ns):\\n        @lru_cache(None)\\n        def dp(i, mask):\\n            res = 0\\n            if i == len(A): return 0\\n            for slot in range(1, ns + 1):\\n                b = 3 ** (slot - 1)\\n                if mask // b % 3 > 0:\\n                    res = max(res, (A[i] & slot) + dp(i + 1, mask - b))\\n            return res\\n        \\n        return dp(0, 3 ** ns - 1)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java\\n    public int maximumANDSum(int[] A, int ns) {\\n        int mask = (int)Math.pow(3, ns) - 1;\\n        int[] memo = new int[mask + 1];\\n        return dp(A.length - 1, mask, ns, memo, A);\\n    }\\n    \\n    private int dp(int i, int mask, int ns, int[] memo, int[] A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i < 0) return 0;\\n        for (int slot = 1, bit = 1; slot <= ns; ++slot, bit*= 3)\\n            if (mask / bit % 3 > 0)\\n                memo[mask] = Math.max(memo[mask], (A[i] & slot) + dp(i - 1, mask - bit, ns, memo, A));\\n        return memo[mask];\\n    }\\n```\n```cpp\\n    int maximumANDSum(vector<int>& A, int ns) {\\n        int mask = pow(3, ns) - 1;\\n        vector<int> memo(mask + 1, 0);\\n        return dp(A.size() - 1, mask, ns, memo, A);\\n    }\\n    \\n    int dp(int i, int mask, int ns, vector<int>& memo, vector<int>& A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i < 0) return 0;\\n        for (int slot = 1, bit = 1; slot <= ns; ++slot, bit*= 3)\\n            if (mask / bit % 3 > 0)\\n                memo[mask] = max(memo[mask], (A[i] & slot) + dp(i - 1, mask - bit, ns, memo, A));\\n        return memo[mask];\\n    }\\n```\n```cpp\\n    int maximumANDSum(vector<int>& A, int ns) {\\n        int mask = pow(3, ns) - 1;\\n        vector<int> memo(mask + 1, 0);\\n\\n        function<int(int, int)> dp =\\n        [&](int i, int mask) {\\n            int& res = memo[mask];\\n            if (res > 0) return res;\\n            if (i < 0) return 0;\\n            for (int slot = 1, bit = 1; slot <= ns; ++slot, bit *= 3)\\n                if (mask / bit % 3 > 0)\\n                    res = max(res, (A[i] & slot) + dp(i - 1, mask - bit));\\n            return res;\\n        };\\n\\n        return dp(A.size() - 1, mask);\\n    }\\n```\n```py\\n    def maximumANDSum(self, A, ns):\\n        @lru_cache(None)\\n        def dp(i, mask):\\n            res = 0\\n            if i == len(A): return 0\\n            for slot in range(1, ns + 1):\\n                b = 3 ** (slot - 1)\\n                if mask // b % 3 > 0:\\n                    res = max(res, (A[i] & slot) + dp(i + 1, mask - b))\\n            return res\\n        \\n        return dp(0, 3 ** ns - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1766743,
                "title": "c-short-bitmask-dp",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Bitmask DP\\n\\n**Intuition**:\\n\\nIf we permuate the numbers and assign them to the slots sequentially (`A[0]` and `A[1]` into slot `1`, `A[2]` and `A[3]` into slot `2`, ...), we need to go over at most `18!` permutations which will result in TLE.\\n\\nIt\\'s wasting computation because it computes the same subproblem over and over again. For example, assume we assigned `A[0] to A[9]` 10 elements to the first `5` slots. For the first element in slot `6`, we have `A[10] to A[17]` 8 options. But no matter which one we choose, the best arrangment for the first 10 elements is fixed. Instead of computing it `8` times, we can just compute it once and reuse it later. This leads to a DP solution.\\n\\nThe DP idea is that we use bitmask `m` to represent which elements are selected, and try picking each one of them as the last element and assign it to `(bitCount(m) + 1) / 2`-th slot. The state transition is `dp[m - (1 << i)] -> dp[m]` where `m`\\'s `i`-th bit is `1`.\\n\\n![image](https://assets.leetcode.com/users/images/9567be24-0221-4957-84d6-298cd766e051_1645012100.6043077.png)\\n\\n![image](https://assets.leetcode.com/users/images/59c41083-3973-4f1c-b66a-4b2ba30452bc_1645012105.4628053.png)\\n\\n\\n**Algorithm**:\\n\\nAppend `0`s to make sure the length of `A` is `2 * numSlots`.\\n\\nLet `dp[m]` be the maximum score given a bitmask `m` representing the selected numbers. The final answer is `dp[(1 << N) - 1]`.\\n\\nAssume `m`\\'s `i`-th bit is `1`, we have the following formula:\\n\\n```\\ndp[m] = max( dp[m - (1 << i)] + (slotNumber & A[i]) | m\\'s i-th bit is 1 )\\n                        where slotNumber = (cnt + 1) / 2 and cnt = bitCount(m)\\n```\\n\\nThe key is that we always make this picked `A[i]` as the last element of all elements in `m` and assign it to `slotNumber`-th slot, and `slotNumber` is a constant given `m`.\\n\\n**Why `slotNumber = (cnt + 1) / 2`?**\\n* If `cnt = 1`, we put this first element at slot `1`.\\n* If `cnt = 2` meaning two elements are selected, we pick one of them as the last element and put it in slot `1`.\\n* If `cnt = 3` meaning three elements are seledted, we pick one of them as the last element and put it in slot `2`.\\n* ans so on...\\n\\nSo the `cnt` to `slotNumber` mapping is `1 or 2 -> 1`, `3 or 4 -> 2`, ... i.e. `slotNumber = (cnt + 1) / 2`.\\n\\n**Example of State Transition**:\\n\\nAssume `m = 1101`, we\\'ll assign `A[i]` to slot `(bitCount(m) + 1) / 2 = (3 + 1) / 2 = 2`:\\n* If `i = 0`, `dp[1101] = dp[1100] + (2 & A[0])`\\n* If `i = 2`, `dp[1101] = dp[1001] + (2 & A[2])`\\n* If `i = 3`, `dp[1101] = dp[0101] + (2 & A[3])`.\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-280/problems/maximum-and-sum-of-array/\\n// Author: github.com/lzl124631x\\n// Time: O(2^(2*numSlots) * numSlots)\\n// Space: O(2^(2*numSlots))\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& A, int numSlots) {\\n        A.resize(2 * numSlots); // append 0s to make sure the length of `A` is `2 * numSlots`\\n        int N = A.size();\\n        vector<int> dp(1 << N);\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int cnt = __builtin_popcount(m), slot = (cnt + 1) / 2; \\n            for (int i = 0; i < N; ++i) {\\n                if (m >> i & 1) { // we assign A[i] to `slot`-th slot\\n                    dp[m] = max(dp[m], dp[m ^ (1 << i)] + (slot & A[i]));\\n                }\\n            }\\n        }\\n        return dp[(1 << N) - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[m] = max( dp[m - (1 << i)] + (slotNumber & A[i]) | m\\'s i-th bit is 1 )\\n                        where slotNumber = (cnt + 1) / 2 and cnt = bitCount(m)\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-280/problems/maximum-and-sum-of-array/\\n// Author: github.com/lzl124631x\\n// Time: O(2^(2*numSlots) * numSlots)\\n// Space: O(2^(2*numSlots))\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& A, int numSlots) {\\n        A.resize(2 * numSlots); // append 0s to make sure the length of `A` is `2 * numSlots`\\n        int N = A.size();\\n        vector<int> dp(1 << N);\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int cnt = __builtin_popcount(m), slot = (cnt + 1) / 2; \\n            for (int i = 0; i < N; ++i) {\\n                if (m >> i & 1) { // we assign A[i] to `slot`-th slot\\n                    dp[m] = max(dp[m], dp[m ^ (1 << i)] + (slot & A[i]));\\n                }\\n            }\\n        }\\n        return dp[(1 << N) - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769139,
                "title": "python-simple-dp-solution-without-bitmask-with-explanation",
                "content": "This is a simplified version of Master Lee solution: https://leetcode.com/problems/maximum-and-sum-of-array/discuss/1766824/JavaC%2B%2BPython-DP-Solution\\n\\nInitially each slot has room for 2 items. Lets say for 5 slots we encode it into a string \\'22222\\'. For performance reasons, lets convert it into a number 22222 and call it \\'```room```\\'.\\n\\nIf we pretend that we put a number into the middle slot (slot==3), \\'```room```\\' becomes 22122, if we put another number into the middle slot \\'```room```\\' will become 22022.\\n\\nSo, each time we use a space in slot==3, \\'```room```\\' is decreased by 100. Lets call this number 100 as \\'```base```\\'. It is found like this: ```base = 10 ** (slot-1)``` = 100\\n\\nHow can we know the amount of space available at position 3 (slot==3) ? We divide 22122 by 100 to get 221. Remember, we already found the 100 and called it \\'```base```\\'.  To remove from 221 everything except the last digit: use modulo % 10, so 221 % 10 becomes 1 (lets call it \\'```left```\\'). Therefore, in code: ```left = room // base % 10``` = 1\\n\\nIf there is no space in slot 3, we cannot use the slot anymore.\\nHowever, there are other slots, so we check which of them has room in a loop for the current number nums[pos]:\\n\\n```\\nfor slot in range(1, numSlots+1):\\n    base = 10 ** (slot-1)\\n    left = room // base % 10\\n    if left > 0:\\n\\t   ...\\n```\\n\\nThen we pretend that we put the current element ```nums[pos]``` into each non-empty slot. If the state \\'room\\' was 22122 it becomes 22022. In code: ```room - base```.\\nThe we recurse the search trying to put the next number using new state of \\'room\\':\\n```dp(pos+1, room - base)```.\\nBTW, when we put nums[pos] into the slot, we get value: ```(nums[pos]&slot)```\\n\\nTo summarize: we pretend we put the first number ```nums[0]``` into every possible slot and make state variable \\'room\\' reflect the fact that we used one space in the chosen slot.\\nThen we recurse to put the next number from nums to every possible slot and etc.\\n\\nThe original solution of Master Lee uses 3 instead of 10 everythere in the code for space optimization, as we never use numbers 3-9 in \\'room\\' variable.\\n\\nLee\\'s starting number is ```3 ** ns - 1``` instead of ```\\'2\\' * numSlots```. The idea is the same as this: if we need to build number 999999, it is equal to 1000000-1 or 10 ** 6 - 1. But Lee uses base-3, so it is ```3 ** numSlots -1```. \\n\\n```\\ndef maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n\\n\\t@lru_cache(None)\\n\\tdef dp(pos, room):\\n\\t\\tif pos == len(nums): return 0\\n\\n\\t\\tres = 0\\n\\t\\tfor slot in range(1, numSlots+1):\\n\\t\\t\\t# if slot is 3, then 1 item in it worth 100 = 10 ** 2\\n\\t\\t\\tbase = 10 ** (slot-1) # value of 1 item of this slot\\n\\n\\t\\t\\t# how many spots are available in this slot.\\n\\t\\t\\t# if we had room encoded as 1211,\\n\\t\\t\\t# and we want to see how much room is available in slot 3:\\n\\t\\t\\t# then base = 10 * (slot-1) = 100\\n\\t\\t\\t# then left = 1211 // base % 10 = 1211 // 100 %12 = 12 % 10 = 2\\n\\t\\t\\tleft = room // base % 10\\n\\t\\t\\tif left > 0:\\n\\t\\t\\t\\tres = max(res, (nums[pos]&slot) + dp(pos+1, room - base))\\n\\t\\treturn res\\n\\n\\t# initially every slot has room for 2 items. for example:\\n\\t# if we have 3 slots we make string \\'222\\' converted to int: 222\\n\\treturn dp(0, int(\\'2\\'*numSlots))\\n```\\n",
                "solutionTags": [],
                "code": "```room```\n```room```\n```room```\n```room```\n```base```\n```base = 10 ** (slot-1)```\n```base```\n```left```\n```left = room // base % 10```\n```\\nfor slot in range(1, numSlots+1):\\n    base = 10 ** (slot-1)\\n    left = room // base % 10\\n    if left > 0:\\n\\t   ...\\n```\n```nums[pos]```\n```room - base```\n```dp(pos+1, room - base)```\n```(nums[pos]&slot)```\n```nums[0]```\n```3 ** ns - 1```\n```\\'2\\' * numSlots```\n```3 ** numSlots -1```\n```\\ndef maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n\\n\\t@lru_cache(None)\\n\\tdef dp(pos, room):\\n\\t\\tif pos == len(nums): return 0\\n\\n\\t\\tres = 0\\n\\t\\tfor slot in range(1, numSlots+1):\\n\\t\\t\\t# if slot is 3, then 1 item in it worth 100 = 10 ** 2\\n\\t\\t\\tbase = 10 ** (slot-1) # value of 1 item of this slot\\n\\n\\t\\t\\t# how many spots are available in this slot.\\n\\t\\t\\t# if we had room encoded as 1211,\\n\\t\\t\\t# and we want to see how much room is available in slot 3:\\n\\t\\t\\t# then base = 10 * (slot-1) = 100\\n\\t\\t\\t# then left = 1211 // base % 10 = 1211 // 100 %12 = 12 % 10 = 2\\n\\t\\t\\tleft = room // base % 10\\n\\t\\t\\tif left > 0:\\n\\t\\t\\t\\tres = max(res, (nums[pos]&slot) + dp(pos+1, room - base))\\n\\t\\treturn res\\n\\n\\t# initially every slot has room for 2 items. for example:\\n\\t# if we have 3 slots we make string \\'222\\' converted to int: 222\\n\\treturn dp(0, int(\\'2\\'*numSlots))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1766744,
                "title": "python-super-easy-greedy-random-solution-just-for-fun",
                "content": "It is **NOT** a formal solution, just for fun. Don\\'t take it seriously\\n\\nThe intuition is put each number into the slots one by one. For each number, we just greedily find the slot which is not full yet and can give us the greatest point for this number.\\n\\nHowever, the problem is how to find the correct order of numbers which can maximize our total points?\\n\\nActually, the greedy part is very powerful and many different orders would give us the same best solution, moreover, since the `N` is pretty small, which gives us room for just **guess the order randomly**, if we try enough times, there is a pretty good chance that we can find at least one of the orders which gives us the greatest points. And, BOOM! IT WORKS!.\\n\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        ans = 0\\n        for i in range(5000): # guess enough times\\n            random.shuffle(nums) # try different orders randomly\\n            cur = 0\\n            counter = defaultdict(int)\\n            for n in nums:\\n                j = 0\\n                for i in range(1, numSlots+1):\\n                    if counter[i] < 2 and n & i > n & j: # Greedy\\n                        j = i\\n                counter[j] += 1\\n                cur += n & j\\n            ans = max(ans, cur)\\n    \\n        return ans    \\n```\\n\\nPS:\\n\\nAfter the contest, I did some more tests and found out that the chance of finding an order which can give us the best solution is around 10~20% even for the most tricky cases which I could find at the Leetcode platform. (100% for easy cases). So, if it is true, the chance of **not** finding the best solution after trying `1000` times is lower than `1.7e-46` (0.9^1000), almost ignorable. \\n\\nMaybe we can mathematically prove that this can work no matter which test cases it is (The probability of failure is ignorable), but it\\'s not my specialty and I don\\'t know how to do it.\\n\\nPS2:\\n\\nThanks @hqztrue for giving us a great testcase\\n```\\nnums = [1, 7, 4, 3, 11, 14, 1, 9, 14, 8, 12, 7, 14, 12, 9, 13, 7, 3]\\nnumSlots = 9\\n```\\n\\nIn this case, we only have around 0.1% rate to get best solution. So we need at least `5000` tries to make sure the probability of failure under `1%` and not getting TLE.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        ans = 0\\n        for i in range(5000): # guess enough times\\n            random.shuffle(nums) # try different orders randomly\\n            cur = 0\\n            counter = defaultdict(int)\\n            for n in nums:\\n                j = 0\\n                for i in range(1, numSlots+1):\\n                    if counter[i] < 2 and n & i > n & j: # Greedy\\n                        j = i\\n                counter[j] += 1\\n                cur += n & j\\n            ans = max(ans, cur)\\n    \\n        return ans    \\n```\n```\\nnums = [1, 7, 4, 3, 11, 14, 1, 9, 14, 8, 12, 7, 14, 12, 9, 13, 7, 3]\\nnumSlots = 9\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767788,
                "title": "python-2-lines-solution-using-hungarian-algorithm-explained",
                "content": "There is polynomial time solution, using hungarian algorithm! Imagine that we have `3` slots, then create numbers `1, 2, 3, 1, 2, 3` for them and imagine also that we have `5` values `1, 4, 2, 8, 5`. Then add `0` to them and we have `1, 4, 2, 8, 5, 0`. Now, we need to choose `6` elements such that no two cells are on the same row or column. Hopefully there is implementation in python already! For more details look https://en.wikipedia.org/wiki/Hungarian_algorithm\\n\\n#### Complexity\\nIt is `O(t^3)` for time and `O(t^2)` for space.\\n\\n#### Code\\n```python\\nfrom scipy.optimize import linear_sum_assignment as LA\\n\\nclass Solution:\\n    def maximumANDSum(self, nums, t):\\n        cost = [[-(x&y) for y in list(range(1, t+1)) * 2] for x in nums + [0]*(2*t - len(nums))]\\n        return -sum(cost[r][c] for r, c in zip(*LA(cost)))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nfrom scipy.optimize import linear_sum_assignment as LA\\n\\nclass Solution:\\n    def maximumANDSum(self, nums, t):\\n        cost = [[-(x&y) for y in list(range(1, t+1)) * 2] for x in nums + [0]*(2*t - len(nums))]\\n        return -sum(cost[r][c] for r, c in zip(*LA(cost)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766768,
                "title": "c-dp-with-ternary-digit-mask",
                "content": "- Definition\\n\\t- Let `n` denotes the size of `nums`.\\n\\t- Let `k` denotes the number of slots (which is `numSlots` in the original description).\\n- Hint\\n\\t- Think about how to solve the simplified version, where each slot could contain **at most one** number.\\n\\t- Try to generalize it to the original problem.\\n- How to solve the simplied version?\\n\\t- It is intuitive to use **Dynamic Programming** (or DFS + memoization) and maintain a **bit mask**, where bit `i` is set if and only if the `i`-th slot is occupied by some number.\\n\\t- the definition of DP table should be like:\\n\\t\\t- `dp[start][mask] :=` the maximum AND sum of `nums[start, ..., n-1]`, where `mask` indicates the availabilities of the slots.\\n\\t- the base case is:\\n\\t\\t- `dp[n][mask] = 0`, since `nums[n, ..., n-1]` represents an empty array (which means we\\'ve put every number into some slot.)\\n\\t- and the transition would be:\\n\\t\\t- `dp[start][mask] = max((nums[start] & i) + dp[start+1][mask|(1<<i)])` for all `i \\\\in [1, k]` s.t. the `i`-th bit is off in `mask` (i.e. `(mask & (1<<i)) == 0`, which means the `i`-th slot is avaliable).\\n\\t- there are `O(n * 2^k)` states, the transition for each state is `O(k)`, so the total complexity would be `O(nk 2^k)` (actually `O(k 2^k)`, but we just ignore this at this moment).\\n- Come back to the original problem\\n\\t- the idea is the same, but now at each slot there can be **at most two** numbers, which means one bit is not enough to encode the state for one slot.\\n\\t- but similarly, we can encode the availabilities of the slots using a **base-3 system**, in which the numbers would be like:\\n\\t\\t- `0120112...`\\n\\t- so each digit would represent the **current # of numbers** in that slot.\\n\\t- but now we can\\'t use the bit operations to check a slot\\'s availability! how can we do this now?\\n\\t\\t- note that each `d`-digit number in base-3 can be represented as `a_{d-1} * 3^(d-1) + a_{d-2} * 3^(d-2) + ... + a_1 * 3^1 + a_0 * 3^0`\\n\\t\\t- for example, `121001` in base-3 is `1 * 3^5 + 2 * 3^4 + 1 * 3^3 + 0 * 3^2 + 0 * 3^1 + 1 * 3^0`\\n\\t\\t- to check a slot `i`, we have to know what `a_i` is in this number, which can be obtained by\\n\\t\\t\\t- `a_i = floor( (mask % 3^(i+1)) / 3^i )`\\n\\t- so that conclues the method, the definition and base case of `dp` is the same as before, and the transition becomes:\\n\\t\\t- `dp[start][mask] = max((nums[start] & i) + dp[start+1][mask + 3^i]` for all `i \\\\in [1, k]` s.t. `a_i <= 1` (which means the `i`-th slot is not full).\\n- Code (C++)\\n```\\nclass Solution {\\nprivate:\\n    int dp[20][60000];\\n    vector<int> a;\\n    int n;\\n    int k;\\n    // n numbers, k slots\\n    int ans;\\n    int h[12];  // h[i] == 3^i\\n    int search(int start, int mask) {\\n        if (start == n) return 0;\\n        if (dp[start][mask] != -1) return dp[start][mask];\\n        // try to push a[start] into slot 1 ~ k\\n        for (int i = 1; i <= k; i++) {\\n            int cnt = (mask % h[i+1]) / h[i];\\n            if (cnt <= 1) {\\n                dp[start][mask] = max(dp[start][mask], (a[start] & i) + search(start+1, mask + h[i]));\\n            }\\n        }\\n        return dp[start][mask];\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        // states: at most 3^k\\n        // search: k\\n        a.assign(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof(dp));\\n        // dp[i][mask]: the answer for nums[i:] with mask   (based-3)\\n        // a 3^1 + b 3^2 + c 3^3 + ...\\n        n = nums.size();\\n        k = numSlots;\\n        ans = 0;\\n        h[0] = 1;\\n        for (int i = 1; i < 12; i++)\\n\\t\\t\\th[i] = h[i-1] * 3;\\n        return search(0, 0);\\n    }\\n};\\n```\\n- Time Complexity: `O(k 3^k)` (try to figure out why it\\'s not `O(nk 3^k)`)\\n- Space Complexity: `O(n 3^k)`, can be improved to `O(3^k)` since the first dimension of `dp` is redundant.\\n- Code (space optimized)\\n```\\nclass Solution {\\nprivate:\\n\\tint dp[20000];   // we don\\'t need the first dimension!\\n    vector<int> a;\\n    int n;\\n    int k;\\n    // n numbers, k slots\\n    int ans;\\n    int h[10];  // h[i] == 3^i\\n    int search(int start, int mask) {\\n        if (start == n) return 0;\\n        if (dp[mask] != -1) return dp[mask];\\n        // try to push a[start] into slot 1 ~ k\\n        for (int i = 1; i <= k; i++) {\\n            int cnt = (mask % h[i]) / h[i-1];\\n            if (cnt <= 1) {\\n                dp[mask] = max(dp[mask], (a[start] & i) + search(start+1, mask + h[i-1]));\\n            }\\n        }\\n        return dp[mask];\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        // states: at most 3^k\\n        // search: k\\n        a.assign(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof(dp));\\n        // dp[i][mask]: the answer for nums[i:] with mask   (based-3)\\n        // a 3^0 + b 3^1 + c 3^2 + ...\\n        n = nums.size();\\n        k = numSlots;\\n        ans = 0;\\n        h[0] = 1;\\n        for (int i = 1; i < 10; i++)\\n            h[i] = h[i-1] * 3;\\n        return search(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[20][60000];\\n    vector<int> a;\\n    int n;\\n    int k;\\n    // n numbers, k slots\\n    int ans;\\n    int h[12];  // h[i] == 3^i\\n    int search(int start, int mask) {\\n        if (start == n) return 0;\\n        if (dp[start][mask] != -1) return dp[start][mask];\\n        // try to push a[start] into slot 1 ~ k\\n        for (int i = 1; i <= k; i++) {\\n            int cnt = (mask % h[i+1]) / h[i];\\n            if (cnt <= 1) {\\n                dp[start][mask] = max(dp[start][mask], (a[start] & i) + search(start+1, mask + h[i]));\\n            }\\n        }\\n        return dp[start][mask];\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        // states: at most 3^k\\n        // search: k\\n        a.assign(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof(dp));\\n        // dp[i][mask]: the answer for nums[i:] with mask   (based-3)\\n        // a 3^1 + b 3^2 + c 3^3 + ...\\n        n = nums.size();\\n        k = numSlots;\\n        ans = 0;\\n        h[0] = 1;\\n        for (int i = 1; i < 12; i++)\\n\\t\\t\\th[i] = h[i-1] * 3;\\n        return search(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n\\tint dp[20000];   // we don\\'t need the first dimension!\\n    vector<int> a;\\n    int n;\\n    int k;\\n    // n numbers, k slots\\n    int ans;\\n    int h[10];  // h[i] == 3^i\\n    int search(int start, int mask) {\\n        if (start == n) return 0;\\n        if (dp[mask] != -1) return dp[mask];\\n        // try to push a[start] into slot 1 ~ k\\n        for (int i = 1; i <= k; i++) {\\n            int cnt = (mask % h[i]) / h[i-1];\\n            if (cnt <= 1) {\\n                dp[mask] = max(dp[mask], (a[start] & i) + search(start+1, mask + h[i-1]));\\n            }\\n        }\\n        return dp[mask];\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        // states: at most 3^k\\n        // search: k\\n        a.assign(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof(dp));\\n        // dp[i][mask]: the answer for nums[i:] with mask   (based-3)\\n        // a 3^0 + b 3^1 + c 3^2 + ...\\n        n = nums.size();\\n        k = numSlots;\\n        ans = 0;\\n        h[0] = 1;\\n        for (int i = 1; i < 10; i++)\\n            h[i] = h[i-1] * 3;\\n        return search(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767454,
                "title": "c-recursion-memo-clean-code-without-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int go(vector<int> &ar, int cur, int n, int k, vector<int> &vis, map<vector<int>, int> &occ){\\n        // Hit the last index - base case\\n        if(cur >= n)\\n            return 0;\\n        \\n        // Check if the current state is pre-computed\\n        if(occ.count(vis))\\n            return occ[vis];\\n        \\n        int mx = -1;\\n        \\n        // Try filling the slots recursively\\n        for(int i = 1; i <= k; i++){\\n            \\n            // An element can be filled in this \\'ith\\' slot, as each slot can\\n            // have atmost 2 elements\\n            if(vis[i] < 2){\\n                \\n                // Increment the filled spaces in \\'ith\\' slot\\n                vis[i]++;\\n                \\n                // Recur to find the best possible answer\\n                int res = (i & ar[cur]) + go(ar, cur+1, n, k, vis, occ);\\n                \\n                // Maximize mx\\n                mx = max(mx, res);\\n                \\n                // Backtrack, empty a space in \\'ith\\' slot\\n                vis[i]--;\\n            }\\n        }\\n        \\n        // return\\n        return occ[vis] = mx;\\n    }\\n    int maximumANDSum(vector<int>& ar, int k) {\\n        int n = ar.size();\\n        map<vector<int>, int> occ;\\n        \\n        // stores the configuration of slots (left or occupied) (1...k)\\n        vector<int> vis(k+1, 0);\\n        \\n        return go(ar, 0, n, k, vis, occ);\\n    }\\n};\\n```\\n\\nDo **upvote**, if the solution helped you!\\nThanks",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int go(vector<int> &ar, int cur, int n, int k, vector<int> &vis, map<vector<int>, int> &occ){\\n        // Hit the last index - base case\\n        if(cur >= n)\\n            return 0;\\n        \\n        // Check if the current state is pre-computed\\n        if(occ.count(vis))\\n            return occ[vis];\\n        \\n        int mx = -1;\\n        \\n        // Try filling the slots recursively\\n        for(int i = 1; i <= k; i++){\\n            \\n            // An element can be filled in this \\'ith\\' slot, as each slot can\\n            // have atmost 2 elements\\n            if(vis[i] < 2){\\n                \\n                // Increment the filled spaces in \\'ith\\' slot\\n                vis[i]++;\\n                \\n                // Recur to find the best possible answer\\n                int res = (i & ar[cur]) + go(ar, cur+1, n, k, vis, occ);\\n                \\n                // Maximize mx\\n                mx = max(mx, res);\\n                \\n                // Backtrack, empty a space in \\'ith\\' slot\\n                vis[i]--;\\n            }\\n        }\\n        \\n        // return\\n        return occ[vis] = mx;\\n    }\\n    int maximumANDSum(vector<int>& ar, int k) {\\n        int n = ar.size();\\n        map<vector<int>, int> occ;\\n        \\n        // stores the configuration of slots (left or occupied) (1...k)\\n        vector<int> vis(k+1, 0);\\n        \\n        return go(ar, 0, n, k, vis, occ);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774014,
                "title": "beats-100-hungarian-maximum-matching-algorithm-o-n-3",
                "content": "A few days have passed, and I just found that my solution beats 100% of the cpp solutions. So finally I decided to post it.\\n\\nBasically this problem can be transferred to finding the maximum weight matching in a bipartite graph, and get solved by using the Hungarian algorithm. This is **NOT** the solution that the problem setter expected you to give and you are also not expected to meet such kind of algorithm in an interview. So keep going on if you are still interested.\\n\\nInstead of showing every detail of the algorithm, I will explain how to construct the graph. The details can be found here:\\xA0https://brilliant.org/wiki/hungarian-matching/.\\n\\nIntuitively, all numbers in the array can be regarded as left nodes, and all numSlots can be regarded as right nodes. For example, if we have a num array [2, 4, 5, 3] and 3 numSlots, the graph will look like this. Here is a problem: we can put at most 2 numbers in a single slot, which means each right node can be matched twice. This does not sound good--we cannot simply apply the maximum matching algorithm to it.\\n<img src=\"https://assets.leetcode.com/users/images/d8fb810e-9343-4d99-89c5-48d19379257c_1644957954.5766587.png\" alt=\"1\" style=\"zoom:45%;\" />\\nSo, we split each right node into 2 nodes. This guarantees that each node can be matched only once. The next step is obvious: the weight of each edge is the bitwise AND of the numbers.\\n<img src=\"https://assets.leetcode.com/users/images/1d754c31-1896-4f42-b8ed-44d8161112f4_1644959106.5652359.png\" alt=\"1\" style=\"zoom:45%;\" />\\nNow the graph is constructed. After obtaining this graph, we simply apply the Hungarian algorithm and find the maximum matching of this bipartite graph. If you have a template, just copy & paste it, and write 8 lines of graph-constructing codes, then the problem is solved!\\n``` c++\\nclass Solution {\\n   public:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        hungarian<int> km(nums.size(), 2 * numSlots);\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 0; j < numSlots; j++) {\\n                km.addEdge(i, j, nums[i] & (j + 1));\\n                km.addEdge(i, j + numSlots, nums[i] & (j + 1));\\n            }\\n        }\\n        return km.solve();\\n    }\\n};\\n```\\nThe time complexity of this algorithm is `O(n^3)`. The complete version is shown below, feel free to use the algorithm template if you want.\\n\\n**C++**\\n``` c++\\ntemplate <typename T>\\nstruct hungarian {  // km\\n    int n;\\n    vector<int> matchx;\\n    vector<int> matchy;\\n    vector<int> pre;\\n    vector<bool> visx;\\n    vector<bool> visy;\\n    vector<T> lx;\\n    vector<T> ly;\\n    vector<vector<T> > g;\\n    vector<T> slack;\\n    T inf;\\n    T res;\\n    queue<int> q;\\n    int org_n;\\n    int org_m;\\n\\n    hungarian(int _n, int _m) {\\n        org_n = _n;\\n        org_m = _m;\\n        n = max(_n, _m);\\n        inf = numeric_limits<T>::max();\\n        res = 0;\\n        g = vector<vector<T> >(n, vector<T>(n));\\n        matchx = vector<int>(n, -1);\\n        matchy = vector<int>(n, -1);\\n        pre = vector<int>(n);\\n        visx = vector<bool>(n);\\n        visy = vector<bool>(n);\\n        lx = vector<T>(n, -inf);\\n        ly = vector<T>(n);\\n        slack = vector<T>(n);\\n    }\\n\\n    void addEdge(int u, int v, int w) {\\n        g[u][v] = max(w, 0);\\n    }\\n\\n    bool check(int v) {\\n        visy[v] = true;\\n        if (matchy[v] != -1) {\\n            q.push(matchy[v]);\\n            visx[matchy[v]] = true;  // in S\\n            return false;\\n        }\\n        \\n        while (v != -1) {\\n            matchy[v] = pre[v];\\n            swap(v, matchx[pre[v]]);\\n        }\\n        return true;\\n    }\\n\\n    void bfs(int i) {\\n        while (!q.empty()) {\\n            q.pop();\\n        }\\n        q.push(i);\\n        visx[i] = true;\\n        while (true) {\\n            while (!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for (int v = 0; v < n; v++) {\\n                    if (!visy[v]) {\\n                        T delta = lx[u] + ly[v] - g[u][v];\\n                        if (slack[v] >= delta) {\\n                            pre[v] = u;\\n                            if (delta) {\\n                                slack[v] = delta;\\n                            } else if (check(v)) {\\n                                return;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            T a = inf;\\n            for (int j = 0; j < n; j++) {\\n                if (!visy[j]) {\\n                    a = min(a, slack[j]);\\n                }\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (visx[j]) {  // S\\n                    lx[j] -= a;\\n                }\\n                if (visy[j]) {  // T\\n                    ly[j] += a;\\n                } else {  // T\\'\\n                    slack[j] -= a;\\n                }\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (!visy[j] && slack[j] == 0 && check(j)) {\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n\\n    int solve() {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                lx[i] = max(lx[i], g[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            fill(slack.begin(), slack.end(), inf);\\n            fill(visx.begin(), visx.end(), false);\\n            fill(visy.begin(), visy.end(), false);\\n            bfs(i);\\n        }\\n\\n        // custom\\n        for (int i = 0; i < n; i++) {\\n            if (g[i][matchx[i]] > 0) {\\n                res += g[i][matchx[i]];\\n            } else {\\n                matchx[i] = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\n   public:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        hungarian<int> km(nums.size(), 2 * numSlots);\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 0; j < numSlots; j++) {\\n                km.addEdge(i, j, nums[i] & (j + 1));\\n                km.addEdge(i, j + numSlots, nums[i] & (j + 1));\\n            }\\n        }\\n        return km.solve();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "``` c++\\nclass Solution {\\n   public:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        hungarian<int> km(nums.size(), 2 * numSlots);\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 0; j < numSlots; j++) {\\n                km.addEdge(i, j, nums[i] & (j + 1));\\n                km.addEdge(i, j + numSlots, nums[i] & (j + 1));\\n            }\\n        }\\n        return km.solve();\\n    }\\n};\\n```\n``` c++\\ntemplate <typename T>\\nstruct hungarian {  // km\\n    int n;\\n    vector<int> matchx;\\n    vector<int> matchy;\\n    vector<int> pre;\\n    vector<bool> visx;\\n    vector<bool> visy;\\n    vector<T> lx;\\n    vector<T> ly;\\n    vector<vector<T> > g;\\n    vector<T> slack;\\n    T inf;\\n    T res;\\n    queue<int> q;\\n    int org_n;\\n    int org_m;\\n\\n    hungarian(int _n, int _m) {\\n        org_n = _n;\\n        org_m = _m;\\n        n = max(_n, _m);\\n        inf = numeric_limits<T>::max();\\n        res = 0;\\n        g = vector<vector<T> >(n, vector<T>(n));\\n        matchx = vector<int>(n, -1);\\n        matchy = vector<int>(n, -1);\\n        pre = vector<int>(n);\\n        visx = vector<bool>(n);\\n        visy = vector<bool>(n);\\n        lx = vector<T>(n, -inf);\\n        ly = vector<T>(n);\\n        slack = vector<T>(n);\\n    }\\n\\n    void addEdge(int u, int v, int w) {\\n        g[u][v] = max(w, 0);\\n    }\\n\\n    bool check(int v) {\\n        visy[v] = true;\\n        if (matchy[v] != -1) {\\n            q.push(matchy[v]);\\n            visx[matchy[v]] = true;  // in S\\n            return false;\\n        }\\n        \\n        while (v != -1) {\\n            matchy[v] = pre[v];\\n            swap(v, matchx[pre[v]]);\\n        }\\n        return true;\\n    }\\n\\n    void bfs(int i) {\\n        while (!q.empty()) {\\n            q.pop();\\n        }\\n        q.push(i);\\n        visx[i] = true;\\n        while (true) {\\n            while (!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for (int v = 0; v < n; v++) {\\n                    if (!visy[v]) {\\n                        T delta = lx[u] + ly[v] - g[u][v];\\n                        if (slack[v] >= delta) {\\n                            pre[v] = u;\\n                            if (delta) {\\n                                slack[v] = delta;\\n                            } else if (check(v)) {\\n                                return;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            T a = inf;\\n            for (int j = 0; j < n; j++) {\\n                if (!visy[j]) {\\n                    a = min(a, slack[j]);\\n                }\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (visx[j]) {  // S\\n                    lx[j] -= a;\\n                }\\n                if (visy[j]) {  // T\\n                    ly[j] += a;\\n                } else {  // T\\'\\n                    slack[j] -= a;\\n                }\\n            }\\n            for (int j = 0; j < n; j++) {\\n                if (!visy[j] && slack[j] == 0 && check(j)) {\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n\\n    int solve() {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                lx[i] = max(lx[i], g[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            fill(slack.begin(), slack.end(), inf);\\n            fill(visx.begin(), visx.end(), false);\\n            fill(visy.begin(), visy.end(), false);\\n            bfs(i);\\n        }\\n\\n        // custom\\n        for (int i = 0; i < n; i++) {\\n            if (g[i][matchx[i]] > 0) {\\n                res += g[i][matchx[i]];\\n            } else {\\n                matchx[i] = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\n   public:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        hungarian<int> km(nums.size(), 2 * numSlots);\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 0; j < numSlots; j++) {\\n                km.addEdge(i, j, nums[i] & (j + 1));\\n                km.addEdge(i, j + numSlots, nums[i] & (j + 1));\\n            }\\n        }\\n        return km.solve();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769539,
                "title": "iterate-through-slots-vs-numbers",
                "content": "I was inclined to iterate through slots, and that approach is a bit more complicated, and needs some optimization to make it fast.\\n\\nThe runtime for both approaches is comparable, though the first approach should be faster when there are many duplicate numbers.\\n\\n#### Approach 1: Iterate Through Slots\\n We iterate through slots, and for each slot we try available numbers. This approach allows us to skip duplicate numbers; we sort `nums` in the beginning to allow that.\\n \\n Our variable `i` iterates through `2 * numSlots` slots, and the slot number (for the AND operation) can be determined as `((i + 1) / 2)`.\\n \\n One caveat here is that the length of `nums` should be  `2 * numSlots`, so we pad `nums` with zeros as needed.\\n \\n**C++**\\n```cpp\\nint dp[262144] = {};\\nint dfs(vector<int>& nums, int i, int mask) {\\n    if (i > nums.size()) \\n        return 0;\\n    if (dp[mask] == 0) {\\n        int last = -1;\\n        for (int j = 0; j < nums.size(); ++j)\\n            if ((1 << j) & mask && nums[j] != last) {\\n                dp[mask] = max(dp[mask], 1 + (nums[j] & ((i + 1) / 2)) + dfs(nums, i + 1, mask - (1 << j)));\\n                last = nums[j];\\n            }\\n    }\\n    return dp[mask] - 1;\\n}\\nint maximumANDSum(vector<int>& nums, int numSlots) {\\n    nums.resize(numSlots * 2);\\n    sort(begin(nums), end(nums));\\n    return dfs(nums, 1, (1 << nums.size()) - 1);\\n}\\n```\\n#### Approach 2: Iterate Through Numbers\\nHere, we iterate through numbers, and for each number we try available slots.\\n\\nWe track the slot availability using mask `m`. The lower `numSlots` bits and higher `numSlots` bits tell us if the slot is occupied by one or two numbers. \\n\\n**C++**\\n```cpp\\nint dp[262144] = {};\\nint dfs(vector<int>& nums, int i, int numSlots, int m) {\\n    if (i >= nums.size()) \\n        return 0;\\n    if (dp[m] == 0)\\n        for (int s = 0; s < numSlots; ++s)\\n            if (m & (1 << s) || m & (1 << (s + numSlots)))\\n                dp[m] = max(dp[m], ((s + 1) & nums[i]) + \\n                    dfs(nums, i + 1, numSlots, m - (m & (1 << s) ? 1 << s : 1 << (s + numSlots))));\\n    return dp[m];\\n}\\nint maximumANDSum(vector<int>& nums, int numSlots) {\\n    return dfs(nums, 0, numSlots, (1 << (2 * numSlots)) - 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[262144] = {};\\nint dfs(vector<int>& nums, int i, int mask) {\\n    if (i > nums.size()) \\n        return 0;\\n    if (dp[mask] == 0) {\\n        int last = -1;\\n        for (int j = 0; j < nums.size(); ++j)\\n            if ((1 << j) & mask && nums[j] != last) {\\n                dp[mask] = max(dp[mask], 1 + (nums[j] & ((i + 1) / 2)) + dfs(nums, i + 1, mask - (1 << j)));\\n                last = nums[j];\\n            }\\n    }\\n    return dp[mask] - 1;\\n}\\nint maximumANDSum(vector<int>& nums, int numSlots) {\\n    nums.resize(numSlots * 2);\\n    sort(begin(nums), end(nums));\\n    return dfs(nums, 1, (1 << nums.size()) - 1);\\n}\\n```\n```cpp\\nint dp[262144] = {};\\nint dfs(vector<int>& nums, int i, int numSlots, int m) {\\n    if (i >= nums.size()) \\n        return 0;\\n    if (dp[m] == 0)\\n        for (int s = 0; s < numSlots; ++s)\\n            if (m & (1 << s) || m & (1 << (s + numSlots)))\\n                dp[m] = max(dp[m], ((s + 1) & nums[i]) + \\n                    dfs(nums, i + 1, numSlots, m - (m & (1 << s) ? 1 << s : 1 << (s + numSlots))));\\n    return dp[m];\\n}\\nint maximumANDSum(vector<int>& nums, int numSlots) {\\n    return dfs(nums, 0, numSlots, (1 << (2 * numSlots)) - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766984,
                "title": "python3-dp-top-down",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/2506277d2af78559a0e58d2130fdbe87beab42b5) for solutions of weekly 280. \\n\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        @cache\\n        def fn(k, m): \\n            \"\"\"Return max AND sum.\"\"\"\\n            if k == len(nums): return 0 \\n            ans = 0 \\n            for i in range(numSlots): \\n                if m & 1<<2*i == 0 or m & 1<<2*i+1 == 0: \\n                    if m & 1<<2*i == 0: mm = m ^ 1<<2*i\\n                    else: mm = m ^ 1<<2*i+1\\n                    ans = max(ans, (nums[k] & i+1) + fn(k+1, mm))\\n            return ans \\n        \\n        return fn(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        @cache\\n        def fn(k, m): \\n            \"\"\"Return max AND sum.\"\"\"\\n            if k == len(nums): return 0 \\n            ans = 0 \\n            for i in range(numSlots): \\n                if m & 1<<2*i == 0 or m & 1<<2*i+1 == 0: \\n                    if m & 1<<2*i == 0: mm = m ^ 1<<2*i\\n                    else: mm = m ^ 1<<2*i+1\\n                    ans = max(ans, (nums[k] & i+1) + fn(k+1, mm))\\n            return ans \\n        \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767113,
                "title": "java-dfs-with-memo-easy-uderstand",
                "content": "```\\nclass Solution {\\n  private Map<String, Integer> memo = new HashMap<>();\\n  \\n  public int maximumANDSum(int[] nums, int numSlots) {\\n    int[] slots = new int[numSlots + 1];\\n    for (int i = 1; i <= numSlots; i++) {\\n      slots[i] = 2;\\n    }\\n    return dfs(nums, slots, 0);\\n  }\\n\\n  private int dfs(int[] nums, int[] slots, int i) {\\n    if (i == nums.length) return 0;\\n    String key = Arrays.toString(slots) + \",\" + i;\\n    if (memo.containsKey(key)) return memo.get(key);\\n    \\n    int ans = Integer.MIN_VALUE >> 1;\\n    for (int j = 1; j < slots.length; j++) {\\n      if (slots[j] == 0) continue;\\n\\n      slots[j]--;\\n      ans = Math.max(ans, dfs(nums, slots, i + 1) + (nums[i] & j));\\n      slots[j]++;\\n    }\\n    \\n    memo.put(key, ans);\\n    return ans;\\n  }\\n}\\n```\\n\\n\\n\\n**Same idea but with bitmask**\\n<details>\\n<summary>Click to expand</summary>\\n\\n```\\nclass Solution {\\n  private int numSlots;\\n  private int[] nums;\\n  private int[][] memo;\\n\\n  public int maximumANDSum(int[] nums, int numSlots) {\\n    int state = (1 << (numSlots * 2)) - 1;\\n    this.numSlots = numSlots;\\n    this.nums = nums;\\n    this.memo = new int[nums.length][state + 1];\\n\\n    return dp(0, state);\\n  }\\n\\n  private int dp(int i, int state) {\\n    if (i == nums.length) return 0;\\n    if (memo[i][state] != 0) return memo[i][state];\\n\\n    int res = Integer.MIN_VALUE >> 1;\\n    for (int j = 0; j < numSlots; j++) {\\n      // use 2 bits to represent the state of each slot\\n      int slot = state >> (j * 2) & 3;\\n      if (slot == 0) continue;\\n     \\n      // 3 -> 1 -> 0\\n      // \\n      // 11 (3 - 2) => 1\\n      // 01 (1 - 1) => 0\\n      // 00\\n      res = Math.max(res, dp(i + 1, state - ((slot + 1) / 2 << (j * 2))) + (nums[i] & (j + 1)));\\n    }\\n\\n    return memo[i][state] = res;\\n  }\\n}\\n```\\n\\n</details>\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  private Map<String, Integer> memo = new HashMap<>();\\n  \\n  public int maximumANDSum(int[] nums, int numSlots) {\\n    int[] slots = new int[numSlots + 1];\\n    for (int i = 1; i <= numSlots; i++) {\\n      slots[i] = 2;\\n    }\\n    return dfs(nums, slots, 0);\\n  }\\n\\n  private int dfs(int[] nums, int[] slots, int i) {\\n    if (i == nums.length) return 0;\\n    String key = Arrays.toString(slots) + \",\" + i;\\n    if (memo.containsKey(key)) return memo.get(key);\\n    \\n    int ans = Integer.MIN_VALUE >> 1;\\n    for (int j = 1; j < slots.length; j++) {\\n      if (slots[j] == 0) continue;\\n\\n      slots[j]--;\\n      ans = Math.max(ans, dfs(nums, slots, i + 1) + (nums[i] & j));\\n      slots[j]++;\\n    }\\n    \\n    memo.put(key, ans);\\n    return ans;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  private int numSlots;\\n  private int[] nums;\\n  private int[][] memo;\\n\\n  public int maximumANDSum(int[] nums, int numSlots) {\\n    int state = (1 << (numSlots * 2)) - 1;\\n    this.numSlots = numSlots;\\n    this.nums = nums;\\n    this.memo = new int[nums.length][state + 1];\\n\\n    return dp(0, state);\\n  }\\n\\n  private int dp(int i, int state) {\\n    if (i == nums.length) return 0;\\n    if (memo[i][state] != 0) return memo[i][state];\\n\\n    int res = Integer.MIN_VALUE >> 1;\\n    for (int j = 0; j < numSlots; j++) {\\n      // use 2 bits to represent the state of each slot\\n      int slot = state >> (j * 2) & 3;\\n      if (slot == 0) continue;\\n     \\n      // 3 -> 1 -> 0\\n      // \\n      // 11 (3 - 2) => 1\\n      // 01 (1 - 1) => 0\\n      // 00\\n      res = Math.max(res, dp(i + 1, state - ((slot + 1) / 2 << (j * 2))) + (nums[i] & (j + 1)));\\n    }\\n\\n    return memo[i][state] = res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766866,
                "title": "c-bitmask-dp-recursive",
                "content": "* We are given some slots in which we can place the given numbers. And each slot can contain atmost 2 numbers.\\n* Let us consider some point in time when some slots are filled and some slots are empty. How can we represent this? One way is to have two integer masks for each slot so that we can accomodate two numbers in each slot.\\n* Let mask1 and mask2 be the two masks and initially all the slots are empty thus the masks are 0.\\n* Now we need to place the elements one by one. \\n* Whenever we place an element in one of the slots, the bit for that corresponding mask is set. That is, it is switched from 0 to 1. And if the bit is already set in any of the slot positions for one of the masks, we can\\'t place an element in that particular position as it has been already occupied by some number from the given array ```nums```.\\n* And we finally return the maximum result we got by performing the previous operations.\\n```\\nint maximumANDSum(vector<int> &v, int slots)\\n{\\n    int n = v.size();\\n    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>((1LL << (slots + 1)) - 1, vector<int>((1LL << (slots + 1)) - 1, -1)));\\n    auto solve = [&](int i, int mask1, int mask2, auto &&self) -> int\\n    {\\n        if (i == n)\\n            return 0;\\n        if (dp[i][mask1][mask2] != -1)\\n            return dp[i][mask1][mask2];\\n        int res = 0;\\n        for (int j = 0; j < slots; ++j)\\n        {\\n            if ((mask1 >> j) & 1)\\n                continue;\\n            res = max(res, (v[i] & (j + 1)) + self(i + 1, mask1 | (1LL << j), mask2, self));\\n        }\\n        for (int j = 0; j < slots; ++j)\\n        {\\n            if ((mask2 >> j) & 1)\\n                continue;\\n            res = max(res, (v[i] & (j + 1)) + self(i + 1, mask1, mask2 | (1LL << j), self));\\n        }\\n        return dp[i][mask1][mask2] = res;\\n    };\\n    return solve(0, 0, 0, solve);\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```nums```\n```\\nint maximumANDSum(vector<int> &v, int slots)\\n{\\n    int n = v.size();\\n    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>((1LL << (slots + 1)) - 1, vector<int>((1LL << (slots + 1)) - 1, -1)));\\n    auto solve = [&](int i, int mask1, int mask2, auto &&self) -> int\\n    {\\n        if (i == n)\\n            return 0;\\n        if (dp[i][mask1][mask2] != -1)\\n            return dp[i][mask1][mask2];\\n        int res = 0;\\n        for (int j = 0; j < slots; ++j)\\n        {\\n            if ((mask1 >> j) & 1)\\n                continue;\\n            res = max(res, (v[i] & (j + 1)) + self(i + 1, mask1 | (1LL << j), mask2, self));\\n        }\\n        for (int j = 0; j < slots; ++j)\\n        {\\n            if ((mask2 >> j) & 1)\\n                continue;\\n            res = max(res, (v[i] & (j + 1)) + self(i + 1, mask1, mask2 | (1LL << j), self));\\n        }\\n        return dp[i][mask1][mask2] = res;\\n    };\\n    return solve(0, 0, 0, solve);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766754,
                "title": "python-clean-dp-with-bitmask-o-n-3-m-m",
                "content": "\\nI start with thinking over some greedy algorithm since brute-force seems infeasible here (`< O(perm(15, 15))` ~= 2^40). Later I realize the brute-force can be memorized via bitmask.\\n\\n---\\n\\nFor every slot, it can holds either `0`, `1` or `2` numbers, totaling three states. We need `ceil(log2(3)) = 2` bitmasks to represent the three states of all slots.\\n\\n`dp(i, mask1, mask2)` indictes the maximum possible AND sum when placing numbers starting from `i` till the end with some slots already filled as represented by `mask1` and `mask2`.\\n\\nWe use simple bit operations to mimic the procedure of a [half adder](https://en.wikipedia.org/wiki/Adder_(electronics)#Half_adder).\\n\\n**Code:**\\n\\n```python\\nfrom functools import lru_cache, cache\\n\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(i=0, m1=0, m2=0): # mask1, mask2\\n            if i == len(nums):\\n                return 0\\n            ans = 0\\n            for s in range(numSlots):\\n                if m2 & (1 << s) == 0: # i.e. 0b0?, implying the slot is not full \\n                    if m1 & (1 << s) == 0: # 0b00 + 1 => 0b01\\n                        nm1 = m1 | (1 << s);  nm2 = m2\\n                    else: # 0b01 + 1 => 0b10\\n                        nm1 = m1 & ~(1 << s); nm2 = m2 | (1 << s)\\n                    ans = max(ans, dp(i + 1, nm1, nm2) + ((s + 1) & nums[i])) # s + 1 is the actual slot no.\\n            return ans\\n        return dp()\\n```\\n\\n**Time complexity**:\\n\\n`\\u0398(n*3^m*m)`\\n\\nwhere `n = len(nums)` and `m=len(numSlots)`.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```python\\nfrom functools import lru_cache, cache\\n\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(i=0, m1=0, m2=0): # mask1, mask2\\n            if i == len(nums):\\n                return 0\\n            ans = 0\\n            for s in range(numSlots):\\n                if m2 & (1 << s) == 0: # i.e. 0b0?, implying the slot is not full \\n                    if m1 & (1 << s) == 0: # 0b00 + 1 => 0b01\\n                        nm1 = m1 | (1 << s);  nm2 = m2\\n                    else: # 0b01 + 1 => 0b10\\n                        nm1 = m1 & ~(1 << s); nm2 = m2 | (1 << s)\\n                    ans = max(ans, dp(i + 1, nm1, nm2) + ((s + 1) & nums[i])) # s + 1 is the actual slot no.\\n            return ans\\n        return dp()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801423,
                "title": "leetcode-the-hard-way-mcmf-explained",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\nPrerequisite: MCMF\\n\\nMCMF tutorial will not be included here. Please check out https://cp-algorithms.com/graph/min_cost_flow.html for more.\\n\\nWe can think of `nums` as the source of a bipartite graph and  `slots` as the destination. If we add two more vertices `source` before `nums` and `sink` after `slots` , then we can easily solve it using standard MCMF template.\\n\\nThis [template](https://github.com/ShahjalalShohag/code-library/blob/master/Graph%20Theory/Min%20Cost%20Max%20Flow.cpp) is created by Shahjalal Shohag.\\n\\n```\\nusing T = long long;\\nconst T inf = 1LL << 61;\\nstruct MCMF {\\n  struct edge {\\n    int u, v;\\n    T cap, cost;\\n    int id;\\n    edge(int _u, int _v, T _cap, T _cost, int _id) {\\n      u = _u;\\n      v = _v;\\n      cap = _cap;\\n      cost = _cost;\\n      id = _id;\\n    }\\n  };\\n  int n, s, t, mxid;\\n  T flow, cost;\\n  vector<vector<int>> g;\\n  vector<edge> e;\\n  vector<T> d, potential, flow_through;\\n  vector<int> par;\\n  bool neg;\\n  MCMF() {}\\n  MCMF(int _n) { // 0-based indexing\\n    n = _n + 10;\\n    g.assign(n, vector<int> ());\\n    neg = false;\\n    mxid = 0;\\n  }\\n  void add_edge(int u, int v, T cap, T cost, int id = -1, bool directed = true) {\\n    if(cost < 0) neg = true;\\n    g[u].push_back(e.size());\\n    e.push_back(edge(u, v, cap, cost, id));\\n    g[v].push_back(e.size());\\n    e.push_back(edge(v, u, 0, -cost, -1));\\n    mxid = max(mxid, id);\\n    if(!directed) add_edge(v, u, cap, cost, -1, true);\\n  }\\n  bool dijkstra() {\\n    par.assign(n, -1);\\n    d.assign(n, inf);\\n    priority_queue<pair<T, T>, vector<pair<T, T>>, greater<pair<T, T>> > q;\\n    d[s] = 0;\\n    q.push(pair<T, T>(0, s));\\n    while (!q.empty()) {\\n      int u = q.top().second;\\n      T nw = q.top().first;\\n      q.pop();\\n      if(nw != d[u]) continue;\\n      for (int i = 0; i < (int)g[u].size(); i++) {\\n        int id = g[u][i];\\n        int v = e[id].v;\\n        T cap = e[id].cap;\\n        T w = e[id].cost + potential[u] - potential[v];\\n        if (d[u] + w < d[v] && cap > 0) {\\n          d[v] = d[u] + w;\\n          par[v] = id;\\n          q.push(pair<T, T>(d[v], v));\\n        }\\n      }\\n    }\\n    for (int i = 0; i < n; i++) { // update potential\\n      if(d[i] < inf) potential[i] += d[i];\\n    }\\n    return d[t] != inf;\\n  }\\n  T send_flow(int v, T cur) {\\n    if(par[v] == -1) return cur;\\n    int id = par[v];\\n    int u = e[id].u;\\n    T w = e[id].cost;\\n    T f = send_flow(u, min(cur, e[id].cap));\\n    cost += f * w;\\n    e[id].cap -= f;\\n    e[id ^ 1].cap += f;\\n    return f;\\n  }\\n  //returns {maxflow, mincost}\\n  pair<T, T> solve(int _s, int _t, T goal = inf) {\\n    s = _s;\\n    t = _t;\\n    flow = 0, cost = 0;\\n    potential.assign(n, 0);\\n    if (neg) {\\n      // run Bellman-Ford to find starting potential\\n      d.assign(n, inf);\\n      for (int i = 0, relax = true; i < n && relax; i++) {\\n        for (int u = 0; u < n; u++) {\\n          for (int k = 0; k < (int)g[u].size(); k++) {\\n            int id = g[u][k];\\n            int v = e[id].v;\\n            T cap = e[id].cap, w = e[id].cost;\\n            if (d[v] > d[u] + w && cap > 0) {\\n              d[v] = d[u] + w;\\n              relax = true;\\n            }\\n          }\\n        }\\n      }\\n      for(int i = 0; i < n; i++) if(d[i] < inf) potential[i] = d[i];\\n    }\\n    while (flow < goal && dijkstra()) flow += send_flow(t, goal - flow);\\n    flow_through.assign(mxid + 10, 0);\\n    for (int u = 0; u < n; u++) {\\n      for (auto v : g[u]) {\\n        if (e[v].id >= 0) flow_through[e[v].id] = e[v ^ 1].cap;\\n      }\\n    }\\n    return make_pair(flow, cost);\\n  }\\n}\\n```\\n\\nLet\\'s build the graph. We have `len(nums) + len(slots) + 2` vertices in total (including `source` and `sink`). You may treat all vertices in a 1D array in the following order with 0-base indexing.\\n\\n```\\nsource, nums[0], nums[1], ... ,nums[n - 1], slot_1, slot_2, .., slot_k, sink\\n```\\n\\nNow we need to create the edges from `source` to each element in `nums` with `1` capacity and `0` cost. Then we create the edges from each element in `nums` to each slot with `1` capacity and `-(nums[i - 1]& slot)` . The minus sign is here because this MCMF template is to calculate the minimum cost and this problem is asking for the maximum one. Similarly, we create edges from each slot to `sink` with `2` capacities (because each slot at most contains 2 elements) and `0` cost.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        int n = (int) nums.size();\\n        // n + slots + 1 (source) + 1 (sink)\\n        int vertices = n + slots + 2; \\n        // [source, ...nums..., ...slots..., sink]\\n        int source = 0, sink = vertices - 1; // 0-based indexing\\n        MCMF F(vertices);\\n        for (int i = 1; i <= n; i++) {\\n            // from source (0) to each element in nums (i)\\n            // with 1 capacity and 0 cost\\n            F.add_edge(0, i, 1, 0);\\n            for (int slot = 1; slot <= slots; slot++) {\\n                // from each element in nums (i) to each slot (slot)\\n                // with 1 capacity and -(nums[i - 1] & slot) cost\\n                // negative sign for getting the max cost\\n                F.add_edge(i, slot + n, 1, -(nums[i - 1] & slot));\\n            }\\n        }\\n        for (int slot = 1; slot <= slots; slot++) {\\n            // from each slot to sink\\n            // with 2 capacities and 0 cost\\n            F.add_edge(slot + n, sink, 2, 0);\\n        }\\n        // get the cost from source to sink\\n        // solve() return {max_flow, min_cost} \\n        // we just need the latter one\\n        return -F.solve(source, sink, n).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nusing T = long long;\\nconst T inf = 1LL << 61;\\nstruct MCMF {\\n  struct edge {\\n    int u, v;\\n    T cap, cost;\\n    int id;\\n    edge(int _u, int _v, T _cap, T _cost, int _id) {\\n      u = _u;\\n      v = _v;\\n      cap = _cap;\\n      cost = _cost;\\n      id = _id;\\n    }\\n  };\\n  int n, s, t, mxid;\\n  T flow, cost;\\n  vector<vector<int>> g;\\n  vector<edge> e;\\n  vector<T> d, potential, flow_through;\\n  vector<int> par;\\n  bool neg;\\n  MCMF() {}\\n  MCMF(int _n) { // 0-based indexing\\n    n = _n + 10;\\n    g.assign(n, vector<int> ());\\n    neg = false;\\n    mxid = 0;\\n  }\\n  void add_edge(int u, int v, T cap, T cost, int id = -1, bool directed = true) {\\n    if(cost < 0) neg = true;\\n    g[u].push_back(e.size());\\n    e.push_back(edge(u, v, cap, cost, id));\\n    g[v].push_back(e.size());\\n    e.push_back(edge(v, u, 0, -cost, -1));\\n    mxid = max(mxid, id);\\n    if(!directed) add_edge(v, u, cap, cost, -1, true);\\n  }\\n  bool dijkstra() {\\n    par.assign(n, -1);\\n    d.assign(n, inf);\\n    priority_queue<pair<T, T>, vector<pair<T, T>>, greater<pair<T, T>> > q;\\n    d[s] = 0;\\n    q.push(pair<T, T>(0, s));\\n    while (!q.empty()) {\\n      int u = q.top().second;\\n      T nw = q.top().first;\\n      q.pop();\\n      if(nw != d[u]) continue;\\n      for (int i = 0; i < (int)g[u].size(); i++) {\\n        int id = g[u][i];\\n        int v = e[id].v;\\n        T cap = e[id].cap;\\n        T w = e[id].cost + potential[u] - potential[v];\\n        if (d[u] + w < d[v] && cap > 0) {\\n          d[v] = d[u] + w;\\n          par[v] = id;\\n          q.push(pair<T, T>(d[v], v));\\n        }\\n      }\\n    }\\n    for (int i = 0; i < n; i++) { // update potential\\n      if(d[i] < inf) potential[i] += d[i];\\n    }\\n    return d[t] != inf;\\n  }\\n  T send_flow(int v, T cur) {\\n    if(par[v] == -1) return cur;\\n    int id = par[v];\\n    int u = e[id].u;\\n    T w = e[id].cost;\\n    T f = send_flow(u, min(cur, e[id].cap));\\n    cost += f * w;\\n    e[id].cap -= f;\\n    e[id ^ 1].cap += f;\\n    return f;\\n  }\\n  //returns {maxflow, mincost}\\n  pair<T, T> solve(int _s, int _t, T goal = inf) {\\n    s = _s;\\n    t = _t;\\n    flow = 0, cost = 0;\\n    potential.assign(n, 0);\\n    if (neg) {\\n      // run Bellman-Ford to find starting potential\\n      d.assign(n, inf);\\n      for (int i = 0, relax = true; i < n && relax; i++) {\\n        for (int u = 0; u < n; u++) {\\n          for (int k = 0; k < (int)g[u].size(); k++) {\\n            int id = g[u][k];\\n            int v = e[id].v;\\n            T cap = e[id].cap, w = e[id].cost;\\n            if (d[v] > d[u] + w && cap > 0) {\\n              d[v] = d[u] + w;\\n              relax = true;\\n            }\\n          }\\n        }\\n      }\\n      for(int i = 0; i < n; i++) if(d[i] < inf) potential[i] = d[i];\\n    }\\n    while (flow < goal && dijkstra()) flow += send_flow(t, goal - flow);\\n    flow_through.assign(mxid + 10, 0);\\n    for (int u = 0; u < n; u++) {\\n      for (auto v : g[u]) {\\n        if (e[v].id >= 0) flow_through[e[v].id] = e[v ^ 1].cap;\\n      }\\n    }\\n    return make_pair(flow, cost);\\n  }\\n}\\n```\n```\\nsource, nums[0], nums[1], ... ,nums[n - 1], slot_1, slot_2, .., slot_k, sink\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        int n = (int) nums.size();\\n        // n + slots + 1 (source) + 1 (sink)\\n        int vertices = n + slots + 2; \\n        // [source, ...nums..., ...slots..., sink]\\n        int source = 0, sink = vertices - 1; // 0-based indexing\\n        MCMF F(vertices);\\n        for (int i = 1; i <= n; i++) {\\n            // from source (0) to each element in nums (i)\\n            // with 1 capacity and 0 cost\\n            F.add_edge(0, i, 1, 0);\\n            for (int slot = 1; slot <= slots; slot++) {\\n                // from each element in nums (i) to each slot (slot)\\n                // with 1 capacity and -(nums[i - 1] & slot) cost\\n                // negative sign for getting the max cost\\n                F.add_edge(i, slot + n, 1, -(nums[i - 1] & slot));\\n            }\\n        }\\n        for (int slot = 1; slot <= slots; slot++) {\\n            // from each slot to sink\\n            // with 2 capacities and 0 cost\\n            F.add_edge(slot + n, sink, 2, 0);\\n        }\\n        // get the cost from source to sink\\n        // solve() return {max_flow, min_cost} \\n        // we just need the latter one\\n        return -F.solve(source, sink, n).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775311,
                "title": "dp-with-bitmasking-faster-than-93-52-of-submissions",
                "content": "DP solution : \\n\\n**What does a mask here represents ?**\\n\\nWe need to figure out how to define a bit mask in this question.\\nI used a mask on base-2, where each slot takes two bits. Basically for each slot from i=1 to i=numSlots a slot is represented by two consecutive bits.\\nBitmask holds the information about which slots are filled and which are not. \\nFor eg : Consider the i-th slot , we represent the slot by two consecutive bits _ _ .\\n01 -> means one slot is occupied.\\n11 -> means both slots are occupied.\\n\\n**Explanation** :\\n\\nFor each index, **id** , in nums and a given  **mask** , we try to assign the id to i-th slot if it is empty ,set the corresponding bit in the mask and add (nums[id]&(i+1)), and recursively find the answer for next index with this new mask and maximize our answer.\\n\\n**Optimization** : \\nWe only need to memoize the mask as it holds all the information about the slots.\\n\\n**Complexity** : \\n\\nTime : O(m * 2^n)   ,  m = numSlots, n = 2*m  \\nSpace :  O(2^n)\\n\\n**Code** : \\n```\\nclass Solution {\\npublic:\\n    int dp[(1<<18) + 1];\\n    \\n    int func(int id,int mask,vector<int> &nums,int m){\\n        int n = nums.size();\\n        if(id == n) return 0;\\n        \\n        if(dp[mask] != -1){\\n            return dp[mask];\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int k = 0;k < m;k++){\\n            int z = 2*k;\\n            if( (mask & (1<<z) ) == 0){\\n                ans = max(ans,(nums[id] & (k+1)) + func(id+1, (mask | (1<<z)), nums,m));\\n            }\\n            else{\\n                z++;\\n                if( (mask & (1<<z)) == 0){\\n                    ans = max(ans,(nums[id] & (k+1)) + func(id+1, (mask | (1<<z)) ,nums,m));\\n                }   \\n            }\\n        }\\n        return dp[mask] = ans;\\n    } \\n    \\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memset(dp,-1,sizeof(dp));\\n        return func(0,0,nums,numSlots);\\n    }\\n};\\n```\\nPlease do upvote.",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[(1<<18) + 1];\\n    \\n    int func(int id,int mask,vector<int> &nums,int m){\\n        int n = nums.size();\\n        if(id == n) return 0;\\n        \\n        if(dp[mask] != -1){\\n            return dp[mask];\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int k = 0;k < m;k++){\\n            int z = 2*k;\\n            if( (mask & (1<<z) ) == 0){\\n                ans = max(ans,(nums[id] & (k+1)) + func(id+1, (mask | (1<<z)), nums,m));\\n            }\\n            else{\\n                z++;\\n                if( (mask & (1<<z)) == 0){\\n                    ans = max(ans,(nums[id] & (k+1)) + func(id+1, (mask | (1<<z)) ,nums,m));\\n                }   \\n            }\\n        }\\n        return dp[mask] = ans;\\n    } \\n    \\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memset(dp,-1,sizeof(dp));\\n        return func(0,0,nums,numSlots);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768099,
                "title": "solved-using-max-flow-min-cost",
                "content": "Used MAX_FLOW-MIN_Cost to solve this problem.\\n```\\nclass Solution {\\npublic:\\n    struct Edge\\n{\\n    int from, to, capacity, cost;\\n};\\n\\nvector<vector<int>> adj, cost, capacity;\\n\\nconst int INF = 1e9;\\n\\nvoid shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\\n    d.assign(n, INF);\\n    d[v0] = 0;\\n    vector<bool> inq(n, false);\\n    queue<int> q;\\n    q.push(v0);\\n    p.assign(n, -1);\\n\\n    while (!q.empty()) {\\n        int u = q.front();\\n        q.pop();\\n        inq[u] = false;\\n        for (int v : adj[u]) {\\n            if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\\n                d[v] = d[u] + cost[u][v];\\n                p[v] = u;\\n                if (!inq[v]) {\\n                    inq[v] = true;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nint min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\\n    adj.assign(N, vector<int>());\\n    cost.assign(N, vector<int>(N, 0));\\n    capacity.assign(N, vector<int>(N, 0));\\n    for (Edge e : edges) {\\n        adj[e.from].push_back(e.to);\\n        adj[e.to].push_back(e.from);\\n        cost[e.from][e.to] = e.cost;\\n        cost[e.to][e.from] = -e.cost;\\n        capacity[e.from][e.to] = e.capacity;\\n    }\\n\\n    int flow = 0;\\n    int cost = 0;\\n    vector<int> d, p;\\n    while (flow < K) {\\n        shortest_paths(N, s, d, p);\\n        if (d[t] == INF)\\n            break;\\n\\n        // find max flow on that path\\n        int f = K - flow;\\n        int cur = t;\\n        while (cur != s) {\\n            f = min(f, capacity[p[cur]][cur]);\\n            cur = p[cur];\\n        }\\n\\n        // apply flow\\n        cout<<f<<endl;\\n        flow += f;\\n        cost += f * d[t];\\n        cur = t;\\n        while (cur != s) {\\n            capacity[p[cur]][cur] -= f;\\n            capacity[cur][p[cur]] += f;\\n            cur = p[cur];\\n        }\\n        //cout<<cost<<endl;\\n    }\\n\\n    return cost;\\n}\\n\\n    int maximumANDSum(vector<int>& a, int num) {\\n        int n=a.size();\\n       \\n       \\n        int s=0;\\n        int c=1;\\n        vector<Edge> v;\\n        for(int i=0;i<n;i++){\\n            Edge e;\\n            e.from=0;\\n            e.to=c;\\n            c++;\\n            e.capacity=1;\\n            e.cost=0;\\n            v.push_back(e);\\n        }\\n        //cout<<c<<endl;\\n        for(int j=1;j<=num;j++){\\n            for(int i=0;i<n;i++){\\n            Edge e;\\n            e.from=i+1;\\n            e.to=c;\\n            e.capacity=1;\\n            e.cost=15-(a[i]&j);\\n                //cout<<e.cost<<endl;\\n            v.push_back(e);\\n                \\n            }\\n            c++;\\n        }\\n        //cout<<c<<endl;\\n        for(int i=1;i<=num;i++){\\n            int k1=i+n;\\n            Edge e;\\n            e.from=k1;\\n            e.to=c;\\n            //c++;\\n            e.capacity=2;\\n            e.cost=0;\\n            v.push_back(e);\\n            \\n        }\\n        c++;\\n        return 15*n -((min_cost_flow(c,v,n,0,c-1)));\\n        \\n      \\n        \\n      \\n        \\n    }\\n};\\n```\\n\\nFor learning max-flow refer to :[this](https://cp-algorithms.web.app/graph/min_cost_flow.html)",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Edge\\n{\\n    int from, to, capacity, cost;\\n};\\n\\nvector<vector<int>> adj, cost, capacity;\\n\\nconst int INF = 1e9;\\n\\nvoid shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\\n    d.assign(n, INF);\\n    d[v0] = 0;\\n    vector<bool> inq(n, false);\\n    queue<int> q;\\n    q.push(v0);\\n    p.assign(n, -1);\\n\\n    while (!q.empty()) {\\n        int u = q.front();\\n        q.pop();\\n        inq[u] = false;\\n        for (int v : adj[u]) {\\n            if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\\n                d[v] = d[u] + cost[u][v];\\n                p[v] = u;\\n                if (!inq[v]) {\\n                    inq[v] = true;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nint min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\\n    adj.assign(N, vector<int>());\\n    cost.assign(N, vector<int>(N, 0));\\n    capacity.assign(N, vector<int>(N, 0));\\n    for (Edge e : edges) {\\n        adj[e.from].push_back(e.to);\\n        adj[e.to].push_back(e.from);\\n        cost[e.from][e.to] = e.cost;\\n        cost[e.to][e.from] = -e.cost;\\n        capacity[e.from][e.to] = e.capacity;\\n    }\\n\\n    int flow = 0;\\n    int cost = 0;\\n    vector<int> d, p;\\n    while (flow < K) {\\n        shortest_paths(N, s, d, p);\\n        if (d[t] == INF)\\n            break;\\n\\n        // find max flow on that path\\n        int f = K - flow;\\n        int cur = t;\\n        while (cur != s) {\\n            f = min(f, capacity[p[cur]][cur]);\\n            cur = p[cur];\\n        }\\n\\n        // apply flow\\n        cout<<f<<endl;\\n        flow += f;\\n        cost += f * d[t];\\n        cur = t;\\n        while (cur != s) {\\n            capacity[p[cur]][cur] -= f;\\n            capacity[cur][p[cur]] += f;\\n            cur = p[cur];\\n        }\\n        //cout<<cost<<endl;\\n    }\\n\\n    return cost;\\n}\\n\\n    int maximumANDSum(vector<int>& a, int num) {\\n        int n=a.size();\\n       \\n       \\n        int s=0;\\n        int c=1;\\n        vector<Edge> v;\\n        for(int i=0;i<n;i++){\\n            Edge e;\\n            e.from=0;\\n            e.to=c;\\n            c++;\\n            e.capacity=1;\\n            e.cost=0;\\n            v.push_back(e);\\n        }\\n        //cout<<c<<endl;\\n        for(int j=1;j<=num;j++){\\n            for(int i=0;i<n;i++){\\n            Edge e;\\n            e.from=i+1;\\n            e.to=c;\\n            e.capacity=1;\\n            e.cost=15-(a[i]&j);\\n                //cout<<e.cost<<endl;\\n            v.push_back(e);\\n                \\n            }\\n            c++;\\n        }\\n        //cout<<c<<endl;\\n        for(int i=1;i<=num;i++){\\n            int k1=i+n;\\n            Edge e;\\n            e.from=k1;\\n            e.to=c;\\n            //c++;\\n            e.capacity=2;\\n            e.cost=0;\\n            v.push_back(e);\\n            \\n        }\\n        c++;\\n        return 15*n -((min_cost_flow(c,v,n,0,c-1)));\\n        \\n      \\n        \\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1767758,
                "title": "python-7-lines-hungarian-algorithm-linear-sum-assignment-using-scipy-library",
                "content": "This problem can be converted into a linear sum assignment problem. We can describe the problem using a bipartie graph with len(nums) left nodes and 2*numSlots right nodes (each slot can be split into 2 nodes). An edges between two nodes is the cost to place the number into the slot. We want to find a perfect matching between left nodes and right nodes with maximum cost. Scipy linear_sum_assignment library is a perfect solution to these problems.\\n\\nFor example, nums = [1,2,3,4,5,6], numSlots = 3 can be modeled as the following graph. The best match is to place [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3\\n\\n![image](https://assets.leetcode.com/users/images/0fda3fe0-1519-41f1-91bb-b9fe7f133f0c_1644743063.5311604.jpeg)\\n\\n\\n```\\nfrom scipy.optimize import linear_sum_assignment\\nimport numpy as np\\n\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        mat = np.array([[0] * m * 2 for i in range(n)])\\n        for i in range(n):\\n            for j in range(2*m):\\n                mat[i][j] = nums[i] & (j // 2 + 1)\\n        row, col = linear_sum_assignment(mat, True)\\n        return mat[row, col].sum()\\n```\\n\\nReferences:\\n\\nHungarian algorithm:\\nhttps://en.wikipedia.org/wiki/Hungarian_algorithm\\nScipy Linear Sum Assignment\\nhttps://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linear_sum_assignment.html",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nfrom scipy.optimize import linear_sum_assignment\\nimport numpy as np\\n\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        mat = np.array([[0] * m * 2 for i in range(n)])\\n        for i in range(n):\\n            for j in range(2*m):\\n                mat[i][j] = nums[i] & (j // 2 + 1)\\n        row, col = linear_sum_assignment(mat, True)\\n        return mat[row, col].sum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770118,
                "title": "java-recursion-memoization",
                "content": "1. Explore all possible combinations and choose the max answer\\n2. Memoization with map using combination of index and state of the slotwt array as key.\\n\\n\\n```\\nclass Solution {\\n\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        int[] slotWt = new int[numSlots+1];\\n        Map<Pair<Integer, String>, Integer> dp = new HashMap<>();\\n        return helper(0, nums, slotWt, numSlots, dp);\\n    }\\n    \\n    public int helper(int idx, int[] nums, int[] slotWt, int numSlots, Map<Pair<Integer, String>, Integer> dp){\\n        \\n        if(idx==nums.length) return 0;\\n        \\n        Pair<Integer, String> key = new Pair<>(idx, Arrays.toString(slotWt));\\n        if(dp.containsKey(key)) return dp.get(key);\\n        \\n        int maxi = Integer.MIN_VALUE;\\n        for(int k=1; k<=numSlots; k++){\\n            if(slotWt[k] < 2){\\n                slotWt[k]++;\\n                int ans = (nums[idx] & k) + helper(idx+1, nums, slotWt, numSlots, dp);\\n                slotWt[k]--;\\n                maxi = Math.max(maxi, ans);\\n            }\\n        }\\n        \\n        dp.put(key, maxi);\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        int[] slotWt = new int[numSlots+1];\\n        Map<Pair<Integer, String>, Integer> dp = new HashMap<>();\\n        return helper(0, nums, slotWt, numSlots, dp);\\n    }\\n    \\n    public int helper(int idx, int[] nums, int[] slotWt, int numSlots, Map<Pair<Integer, String>, Integer> dp){\\n        \\n        if(idx==nums.length) return 0;\\n        \\n        Pair<Integer, String> key = new Pair<>(idx, Arrays.toString(slotWt));\\n        if(dp.containsKey(key)) return dp.get(key);\\n        \\n        int maxi = Integer.MIN_VALUE;\\n        for(int k=1; k<=numSlots; k++){\\n            if(slotWt[k] < 2){\\n                slotWt[k]++;\\n                int ans = (nums[idx] & k) + helper(idx+1, nums, slotWt, numSlots, dp);\\n                slotWt[k]--;\\n                maxi = Math.max(maxi, ans);\\n            }\\n        }\\n        \\n        dp.put(key, maxi);\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767250,
                "title": "python-easy-to-understand-top-down-dp-no-bitmask",
                "content": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        self.nums, self.n = nums, len(nums)\\n        \\n        counts = [0 for _ in range(numSlots)]\\n        \\n        return self.dfs(0, tuple(counts))\\n\\n    @cache\\n    def dfs(self, cur, counts):\\n        if cur == self.n:\\n            return 0\\n        \\n        res, counts = 0, list(counts)\\n        for i, count in enumerate(counts):\\n            if count == 2:\\n                continue\\n            else:\\n                counts[i] += 1\\n\\t\\t\\t\\tres = max(res, (self.nums[cur] & (i + 1)) + self.dfs(cur + 1, tuple(counts)))\\n                counts[i] -= 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        self.nums, self.n = nums, len(nums)\\n        \\n        counts = [0 for _ in range(numSlots)]\\n        \\n        return self.dfs(0, tuple(counts))\\n\\n    @cache\\n    def dfs(self, cur, counts):\\n        if cur == self.n:\\n            return 0\\n        \\n        res, counts = 0, list(counts)\\n        for i, count in enumerate(counts):\\n            if count == 2:\\n                continue\\n            else:\\n                counts[i] += 1\\n\\t\\t\\t\\tres = max(res, (self.nums[cur] & (i + 1)) + self.dfs(cur + 1, tuple(counts)))\\n                counts[i] -= 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768393,
                "title": "c-bitmask-dp-with-proper-motivation",
                "content": "This question description vaguely points towards a DP solution. We can place N elements in pairs in any of the K number of slots provided. Now N can at max take value of 18. If we have to try out all permutations, we have 18! which will definitely excede Time Limit. Now we have to attempt to solve it faster. Now it is better to store the slots in the DP state for 2 reasons. It needs only 9 bits as compared to 18 bits to store level. More concretely, we may store 2 masks in DP state, one for each position available in a slot.\\n\\nSo \\nDP(level, mask1, mask2) -> Maximum sum possible while the mask1 and mask2 suggests the occupied slots.\\n\\n[](http://)`class Solution {\\npublic:\\n    int n;\\n    int dp[20][1000][1000];\\n    int Slots;\\n    vector<int> v;\\n    int rec(int level, int mask1, int mask2){\\n        \\n        if(level == n){\\n            return 0;\\n        }\\n        \\n        if(dp[level][mask1][mask2] != -1) return dp[level][mask1][mask2];\\n        \\n        int ans = 0;\\n        for(int i = 0; i<Slots; i++){\\n            if((mask1 & (1<<i)) == 0){\\n                ans = max(ans, rec(level + 1, (mask1 | (1<<i)) , mask2) + ((i + 1 ) & (v[level]))   );\\n            } \\n            \\n            if((mask2 & (1<<i)) == 0){\\n                ans = max(ans, rec(level + 1, mask1 , (mask2 | (1<<i)) ) + ((i + 1 ) & (v[level]))   );\\n            }\\n        }\\n        \\n        \\n        \\n        return dp[level][mask1][mask2] = ans;\\n        \\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = nums.size();\\n        memset(dp, -1,sizeof(dp));\\n        Slots = numSlots;\\n        v = nums;\\n        return rec(0, 0, 0);\\n        \\n        \\n    }\\n};`",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int n;\\n    int dp[20][1000][1000];\\n    int Slots;\\n    vector<int> v;\\n    int rec(int level, int mask1, int mask2){\\n        \\n        if(level == n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3593558,
                "title": "python3-top-down-dp-without-bitmask",
                "content": "I think bitmask is unintuitive while the slots selection state can be stored as a string instead. Although the performance will be less than using bitmask but time complexity will be the same.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        memo = {}\\n        def dfs(i, slots):\\n            if i == len(nums):\\n                return 0\\n            key = (i, \\'\\'.join(map(str, slots)))\\n            if key in memo:\\n                return memo[key]\\n            ans = 0\\n            for j in range(len(slots)):\\n                if slots[j] > 0:\\n                    slots[j] -= 1\\n                    ans = max(ans, dfs(i+1, slots) + (nums[i] & (j+1)))\\n                    slots[j] += 1\\n            memo[key] = ans\\n            return ans\\n        slots = [2 for _ in range(numSlots)]\\n        return dfs(0, slots)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        memo = {}\\n        def dfs(i, slots):\\n            if i == len(nums):\\n                return 0\\n            key = (i, \\'\\'.join(map(str, slots)))\\n            if key in memo:\\n                return memo[key]\\n            ans = 0\\n            for j in range(len(slots)):\\n                if slots[j] > 0:\\n                    slots[j] -= 1\\n                    ans = max(ans, dfs(i+1, slots) + (nums[i] & (j+1)))\\n                    slots[j] += 1\\n            memo[key] = ans\\n            return ans\\n        slots = [2 for _ in range(numSlots)]\\n        return dfs(0, slots)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603746,
                "title": "cpp-solution-bitmasking-dp",
                "content": "From the constraints it is clear that we cannot use all permutation cases, since lenght of array <=2*9 and Slotsize<=9 we can try to give each element a possible slot. Which can be implemented using bitmask dp. \\nThe states of my recursive function:\\ni-->index of array,\\nmask1--> mask for 1 element\\nmask2--> mask for 1 element (total of 2 elements)\\nTime complexity= O(n * 2^(slot) * 2^(slot) )\\n\\n```\\nclass Solution {\\npublic:\\n    int mx;\\n    map<tuple<int,int,int> , int>dp;\\n    int fun(int i,int mask1,int mask2,vector<int>&nums)\\n    {\\n        if(i>=nums.size())return 0;\\n        int ans=0;\\n        tuple<int,int,int>temp{i,mask1,mask2};\\n        if(dp.find(temp)!=dp.end())return dp[temp];\\n        for(int k=1;(1<<k)<=mx;k++)\\n        {\\n            // cout<<k<<\" \";\\n              if((mask1&(1<<k))==0)\\n              {\\n                  int nw=(mask1|(1<<k));\\n                 ans=max(ans,(nums[i]&k)+fun(i+1, nw,mask2,nums) );\\n              }\\n            else\\n                if((mask2&(1<<k))==0)\\n                {\\n                     int nw=(mask2|(1<<k));\\n                    ans=max(ans,(nums[i]&k)+fun(i+1, mask1,nw,nums) );\\n                }\\n        }\\n        return dp[temp]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        mx=(1<<numSlots);\\n        // memset(dp,-1,sizeof(dp));\\n        int ans=fun(0,0,0,nums);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx;\\n    map<tuple<int,int,int> , int>dp;\\n    int fun(int i,int mask1,int mask2,vector<int>&nums)\\n    {\\n        if(i>=nums.size())return 0;\\n        int ans=0;\\n        tuple<int,int,int>temp{i,mask1,mask2};\\n        if(dp.find(temp)!=dp.end())return dp[temp];\\n        for(int k=1;(1<<k)<=mx;k++)\\n        {\\n            // cout<<k<<\" \";\\n              if((mask1&(1<<k))==0)\\n              {\\n                  int nw=(mask1|(1<<k));\\n                 ans=max(ans,(nums[i]&k)+fun(i+1, nw,mask2,nums) );\\n              }\\n            else\\n                if((mask2&(1<<k))==0)\\n                {\\n                     int nw=(mask2|(1<<k));\\n                    ans=max(ans,(nums[i]&k)+fun(i+1, mask1,nw,nums) );\\n                }\\n        }\\n        return dp[temp]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        mx=(1<<numSlots);\\n        // memset(dp,-1,sizeof(dp));\\n        int ans=fun(0,0,0,nums);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1767089,
                "title": "python-clean-top-down",
                "content": "The dp state here is (ind, slotString). The slotString[i] represents the number of slots to fill. \\n\\n```\\nclass Solution:\\n    \\n    \\n    def getMaxAndSum(self, ind, slots):\\n        if ind == self.n:\\n            return 0\\n        \\n        if (ind, slots) in self.dp:\\n            return self.dp[(ind, slots)]\\n        \\n        slotsList = list(slots)\\n        ans = 0\\n        for i, v in enumerate(slotsList):\\n            if v == \\'2\\':\\n                continue\\n            else:\\n                cnt = self.nums[ind] & (i+1)\\n                tmp = slotsList[i]\\n                slotsList[i] = str(int(tmp) + 1)\\n                s = \\'\\'.join(slotsList)\\n                cnt += self.getMaxAndSum(ind+1, s)\\n                slotsList[i] = tmp\\n                ans = max(ans, cnt)\\n        \\n        self.dp[(ind, slots)] = ans\\n        return ans\\n                \\n            \\n    \\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        self.dp = {}\\n        self.n = len(nums)\\n        self.nums = nums\\n        slots = \\'\\'.join([str(0) for _ in range(numSlots)])\\n        return self.getMaxAndSum(0, slots)\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    \\n    def getMaxAndSum(self, ind, slots):\\n        if ind == self.n:\\n            return 0\\n        \\n        if (ind, slots) in self.dp:\\n            return self.dp[(ind, slots)]\\n        \\n        slotsList = list(slots)\\n        ans = 0\\n        for i, v in enumerate(slotsList):\\n            if v == \\'2\\':\\n                continue\\n            else:\\n                cnt = self.nums[ind] & (i+1)\\n                tmp = slotsList[i]\\n                slotsList[i] = str(int(tmp) + 1)\\n                s = \\'\\'.join(slotsList)\\n                cnt += self.getMaxAndSum(ind+1, s)\\n                slotsList[i] = tmp\\n                ans = max(ans, cnt)\\n        \\n        self.dp[(ind, slots)] = ans\\n        return ans\\n                \\n            \\n    \\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        self.dp = {}\\n        self.n = len(nums)\\n        self.nums = nums\\n        slots = \\'\\'.join([str(0) for _ in range(numSlots)])\\n        return self.getMaxAndSum(0, slots)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767082,
                "title": "simple-recursion-memoization",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int rec(vector<int> &nums, int i, vector<int> &slot, int numSlots,\\n            map<vector<int>, int> &dp) {\\n        \\n        if(i == nums.size())\\n            return 0;\\n        \\n        if(dp.find(slot) != dp.end()) {\\n            return dp[slot];\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int j = 0; j < numSlots; j++) {\\n            if(slot[j] < 2) {\\n                slot[j]++;\\n                res = max(res, (nums[i] & (j+1)) + rec(nums, i+1, slot, numSlots, dp));\\n                slot[j]--;\\n            }\\n        }\\n        return dp[slot] = res;\\n        \\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n = nums.size();\\n        \\n        vector<int> slot(numSlots);\\n        \\n        map<vector<int>, int> dp;\\n        \\n        return rec(nums, 0, slot, numSlots, dp);\\n    }\\n};\\n```\\n\\nInterestingly, We don\\'t need to memoize index because for two-state (i, slots1) and (i+k, slots2), slots1 != slots2 because the sum of all the values of slots is always i for index i.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int rec(vector<int> &nums, int i, vector<int> &slot, int numSlots,\\n            map<vector<int>, int> &dp) {\\n        \\n        if(i == nums.size())\\n            return 0;\\n        \\n        if(dp.find(slot) != dp.end()) {\\n            return dp[slot];\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int j = 0; j < numSlots; j++) {\\n            if(slot[j] < 2) {\\n                slot[j]++;\\n                res = max(res, (nums[i] & (j+1)) + rec(nums, i+1, slot, numSlots, dp));\\n                slot[j]--;\\n            }\\n        }\\n        return dp[slot] = res;\\n        \\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n = nums.size();\\n        \\n        vector<int> slot(numSlots);\\n        \\n        map<vector<int>, int> dp;\\n        \\n        return rec(nums, 0, slot, numSlots, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766836,
                "title": "dp-with-bitmasking-memoization-c-clear-comments-ternary-digit-mask",
                "content": "Upvote if you got someting from this. Do ask(comments) if you need any clarification.\\nNote: **mask used here is in base 3 to represent 3 states**\\n\\n```\\nclass Solution {\\npublic:\\n    // function to get ith bit - 1 based indexing\\n    int getBit(int num,int k)\\n    {\\n        string s;\\n        while(num > 0)\\n        {\\n            int b = num % 3;\\n            s += to_string(b);\\n            num /= 3;\\n        }\\n        if(k > s.length())\\n            return 0;\\n        return s[k-1] - \\'0\\';\\n    }\\n    // Note: there are 3^10 - 1 possible comibinations = 59048 so taken 60000 for safety :)\\n    // generally in dp with bitmasks mask is binary so here its ternary to represent 3 states\\n    // state 0 - slot empty\\n    // state 1 - slot is half filled\\n    // state 2 - slot it full\\n\\n    // array to memorize\\n    int dp[20][60000];\\n\\n\\n\\n    // function to find best possible answer\\n    int solve(vector<int>&nums,int i,int mask,int N)\\n    {\\n        if(i >= nums.size())\\n        {\\n            return 0;\\n        }\\n        // if already there, just return it\\n        if(dp[i][mask]!=-1)\\n            return dp[i][mask];\\n\\n        // ans --> stores best answer\\n        int ans = 0;\\n        for(int j=0;j<N;j++)\\n        {\\n            // hey, please give he j+1 th bit please\\n            int b = getBit(mask,j+1);\\n\\n            // oh no, this slot is already full, so cannot try here\\n            if(b == 2)\\n                continue;\\n            \\n            // found this slot, lets check if this is the best slot or not\\n            ans = max(ans,(nums[i] & (j+1)) + solve(nums,i+1,mask + pow(3,j),N));\\n\\n        }\\n\\n        // memorizing(so called DP)\\n        return dp[i][mask] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n\\n        // reinitializing all values to -1\\n        memset(dp,-1,sizeof dp);\\n\\n\\n        // ans\\n        return solve(nums,0,0,numSlots);\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    // function to get ith bit - 1 based indexing\\n    int getBit(int num,int k)\\n    {\\n        string s;\\n        while(num > 0)\\n        {\\n            int b = num % 3;\\n            s += to_string(b);\\n            num /= 3;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1766820,
                "title": "c-dp-memoization",
                "content": "\\nIt can be solved by memoizing maximum value till index(ind) in nums and slots filled till now.\\nfor maximum 2 entries in slots consider a bit mask of (1<<(2*n)), where n is total number of slots.\\nSo DP coordinates will be DP[1<<(2*numSlots)][nums.length+1];\\n```\\nclass Solution {\\npublic:\\n    int dp[262145][20];  // dp[1<<(2*numSlots)][nums.length()+1]\\n    int f(int ind, vector<int> &nums, int vis[], int n, int dd){\\n        if(ind == nums.size()) {\\n            return 0;\\n        }\\n        if(dp[dd][ind]!=-1)return dp[dd][ind]; // memoization condition\\n        int ans = 0;\\n        for(int i=0;i<n;++i){\\n            if(vis[i]<2){\\n                vis[i]++;\\n                int ll = (vis[i]-1)*n+i; // find out bit to set in dd correspond to occupied slot..\\n                //[ i, n+i correspond to same slot.]\\n                int ff = (i+1)&(nums[ind]);  // calculate value for placing nums[ind] in ith slot\\n                ans = max(ans, ff+f(ind+1,nums,vis,n,dd^(1<<ll)));\\n                vis[i]--;\\n            }\\n        }\\n        return dp[dd][ind] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int n) {\\n        int ans = INT_MAX;\\n        int vis[20]={0};\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,nums,vis,n,0);\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[262145][20];  // dp[1<<(2*numSlots)][nums.length()+1]\\n    int f(int ind, vector<int> &nums, int vis[], int n, int dd){\\n        if(ind == nums.size()) {\\n            return 0;\\n        }\\n        if(dp[dd][ind]!=-1)return dp[dd][ind]; // memoization condition\\n        int ans = 0;\\n        for(int i=0;i<n;++i){\\n            if(vis[i]<2){\\n                vis[i]++;\\n                int ll = (vis[i]-1)*n+i; // find out bit to set in dd correspond to occupied slot..\\n                //[ i, n+i correspond to same slot.]\\n                int ff = (i+1)&(nums[ind]);  // calculate value for placing nums[ind] in ith slot\\n                ans = max(ans, ff+f(ind+1,nums,vis,n,dd^(1<<ll)));\\n                vis[i]--;\\n            }\\n        }\\n        return dp[dd][ind] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int n) {\\n        int ans = INT_MAX;\\n        int vis[20]={0};\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,nums,vis,n,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974484,
                "title": "java-concise-solution-using-bit-masking",
                "content": "# Intuition\\n##### The following are the points to be remembered:\\n- since every number shld be included so bit masking on slots \\n- a single mask can hold only bool val \\n- Since the slots are <=9 we can afford 18 total masks 2 for each\\n- Another thing is if 2 numbers are in same slot\\n    * say 3 , 2 in position 1 its not 3&2&1 instead 3&2 +2&1\\n    * you might scratch your head here cz the later is needed and solvable using bitmasking\\n\\n# Approach\\nSame as any std bit masking question and to handle overlapping subproblems we use DP\\n\\n#### Please upvote if useful\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int maximumANDSum(int[] nums, int ns) {\\n        dp = new int[nums.length][(int)Math.pow(2,ns*2)];\\n        for(int[] d:dp)Arrays.fill(d,-1);\\n        return solve(nums,0,0,ns);\\n    }\\n  \\n    int solve(int[] nums,int mask,int cur,int ns){\\n//  Base case hit tht is we have an answer ready\\n        if(cur==nums.length) \\n            return 0;\\n// use of memoized values\\n        if(dp[cur][mask]!=-1)return dp[n][mask];\\n// Calculation of current max possible\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i<2*ns;i++){\\n            if(((mask>>i)&1)==0){\\n// Setting ith bit provided it wasnt used before \\n                mask = mask | (1<<i);\\n                int val = i>=ns?i-ns+1:i+1;\\n                max = Math.max(max,(nums[cur]&(val))+solve(nums,mask,n+1,ns));\\n// Unset the ith bit to try out other combinations\\n                mask = mask ^ (1<<i);\\n            }\\n        }\\n// Memoization finally \\n        return dp[cur][mask] = max;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    public int maximumANDSum(int[] nums, int ns) {\\n        dp = new int[nums.length][(int)Math.pow(2,ns*2)];\\n        for(int[] d:dp)Arrays.fill(d,-1);\\n        return solve(nums,0,0,ns);\\n    }\\n  \\n    int solve(int[] nums,int mask,int cur,int ns){\\n//  Base case hit tht is we have an answer ready\\n        if(cur==nums.length) \\n            return 0;\\n// use of memoized values\\n        if(dp[cur][mask]!=-1)return dp[n][mask];\\n// Calculation of current max possible\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i<2*ns;i++){\\n            if(((mask>>i)&1)==0){\\n// Setting ith bit provided it wasnt used before \\n                mask = mask | (1<<i);\\n                int val = i>=ns?i-ns+1:i+1;\\n                max = Math.max(max,(nums[cur]&(val))+solve(nums,mask,n+1,ns));\\n// Unset the ith bit to try out other combinations\\n                mask = mask ^ (1<<i);\\n            }\\n        }\\n// Memoization finally \\n        return dp[cur][mask] = max;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694047,
                "title": "golang-simple-solution-with-two-bitmasks",
                "content": "```\\nfunc maximumANDSum(nums []int, numSlots int) int {\\n    mask1 := (1 << numSlots)-1\\n    mask2 := mask1\\n    res := 0\\n    \\n    // First try to store each number to its slot, which gives max result\\n    // Then try DP on remaining nums\\n    for id, num := range nums {\\n        if isSlotAvailable(num, &mask1, &mask2) {\\n            bookSlot(num, &mask1, &mask2)\\n            res += num\\n            nums[id] = 0     // Will not considered later in DP\\n        }\\n    }\\n    \\n    cache := make(map[string]int)\\n    return res + dp(0, nums, numSlots, &mask1, &mask2, cache)\\n}\\n\\n\\nfunc dp(id int, nums []int, numSlots int, mask1, mask2 *int, cache map[string]int) int {\\n    if id == len(nums) {\\n        return 0\\n    }\\n    \\n    key := strconv.Itoa(id) + \"-\" + strconv.Itoa(*mask1) + \"-\" + strconv.Itoa(*mask2)\\n    if value, ok := cache[key]; ok {\\n        return value\\n    }\\n    \\n    if nums[id] == 0 {\\n        return dp(id+1, nums, numSlots, mask1, mask2, cache)\\n    }\\n    \\n    res := 0\\n    // Check which slot suits better for the num\\n    for slot := 1; slot <= numSlots; slot++ {\\n        if isSlotAvailable(slot, mask1, mask2) {\\n            bookSlot(slot, mask1, mask2)\\n            currRes := nums[id] & slot\\n            res = max(res, currRes + dp(id+1, nums, numSlots, mask1, mask2, cache))\\n            unBookSlot(slot, mask1, mask2)\\n        }\\n    }\\n    cache[key] = res\\n    return res\\n}\\n\\nfunc isSlotAvailable(slot int, mask1, mask2 *int) bool {\\n    if (*mask1) & (1 << (slot-1)) != 0 {\\n        return true\\n    }\\n    if (*mask2) & (1 << (slot-1)) != 0 {\\n        return true\\n    }\\n    return false\\n}\\n\\nfunc bookSlot(slot int, mask1, mask2 *int) {\\n    if (*mask1) & (1 << (slot-1)) != 0 {\\n        (*mask1) = (*mask1) ^ (1 << (slot-1))\\n        return\\n    }\\n    (*mask2) = (*mask2) ^ (1 << (slot-1))\\n}\\n\\nfunc unBookSlot(slot int, mask1, mask2 *int) {\\n    if (*mask1) & (1 << (slot-1)) == 0 {\\n        (*mask1) = (*mask1) | (1 << (slot-1))\\n        return\\n    }\\n    (*mask2) = (*mask2) | (1 << (slot-1))\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bitmask"
                ],
                "code": "```\\nfunc maximumANDSum(nums []int, numSlots int) int {\\n    mask1 := (1 << numSlots)-1\\n    mask2 := mask1\\n    res := 0\\n    \\n    // First try to store each number to its slot, which gives max result\\n    // Then try DP on remaining nums\\n    for id, num := range nums {\\n        if isSlotAvailable(num, &mask1, &mask2) {\\n            bookSlot(num, &mask1, &mask2)\\n            res += num\\n            nums[id] = 0     // Will not considered later in DP\\n        }\\n    }\\n    \\n    cache := make(map[string]int)\\n    return res + dp(0, nums, numSlots, &mask1, &mask2, cache)\\n}\\n\\n\\nfunc dp(id int, nums []int, numSlots int, mask1, mask2 *int, cache map[string]int) int {\\n    if id == len(nums) {\\n        return 0\\n    }\\n    \\n    key := strconv.Itoa(id) + \"-\" + strconv.Itoa(*mask1) + \"-\" + strconv.Itoa(*mask2)\\n    if value, ok := cache[key]; ok {\\n        return value\\n    }\\n    \\n    if nums[id] == 0 {\\n        return dp(id+1, nums, numSlots, mask1, mask2, cache)\\n    }\\n    \\n    res := 0\\n    // Check which slot suits better for the num\\n    for slot := 1; slot <= numSlots; slot++ {\\n        if isSlotAvailable(slot, mask1, mask2) {\\n            bookSlot(slot, mask1, mask2)\\n            currRes := nums[id] & slot\\n            res = max(res, currRes + dp(id+1, nums, numSlots, mask1, mask2, cache))\\n            unBookSlot(slot, mask1, mask2)\\n        }\\n    }\\n    cache[key] = res\\n    return res\\n}\\n\\nfunc isSlotAvailable(slot int, mask1, mask2 *int) bool {\\n    if (*mask1) & (1 << (slot-1)) != 0 {\\n        return true\\n    }\\n    if (*mask2) & (1 << (slot-1)) != 0 {\\n        return true\\n    }\\n    return false\\n}\\n\\nfunc bookSlot(slot int, mask1, mask2 *int) {\\n    if (*mask1) & (1 << (slot-1)) != 0 {\\n        (*mask1) = (*mask1) ^ (1 << (slot-1))\\n        return\\n    }\\n    (*mask2) = (*mask2) ^ (1 << (slot-1))\\n}\\n\\nfunc unBookSlot(slot int, mask1, mask2 *int) {\\n    if (*mask1) & (1 << (slot-1)) == 0 {\\n        (*mask1) = (*mask1) | (1 << (slot-1))\\n        return\\n    }\\n    (*mask2) = (*mask2) | (1 << (slot-1))\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2274174,
                "title": "python-3-solution-o-3-numslots-numslots-n",
                "content": "To solve this problem we need to check all posible solutions, i.e. try to put each number to each slot. We can use recursive function with memoization for it. \\nOn each recursive call we need to track number idx in array and mask, which represents the state of each slot. \\nThe problem is that each slot has 3 states (empty, one number, two numbers), so to encode slot state we need to use ** 2 bits** in bit mask instead of 1 bit as usual.\\n\\n00 - slot empty\\n01 - only one number in a slot\\n11 - slot is full\\n\\n```\\nclass Solution(object):\\n    def maximumANDSum(self, nums, numSlots):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type numSlots: int\\n        :rtype: int\\n        \"\"\"\\n        @cache\\n        def traverse(mask, idx):\\n            if idx >= len(nums):\\n                return 0\\n            \\n            ans = 0\\n            for i in range(numSlots):\\n                if not 1 << (i*2) & mask:\\n                    ans = max(ans, ((i + 1) & nums[idx]) + traverse(1 << (i*2) ^ mask , idx + 1))\\n                elif not 1 << (i*2 + 1) & mask:\\n                    ans = max(ans, ((i + 1) & nums[idx]) + traverse((1 << ((i*2) + 1)) ^ mask, idx + 1))\\n            \\n            return ans\\n                              \\n        return traverse(0, 0)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumANDSum(self, nums, numSlots):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type numSlots: int\\n        :rtype: int\\n        \"\"\"\\n        @cache\\n        def traverse(mask, idx):\\n            if idx >= len(nums):\\n                return 0\\n            \\n            ans = 0\\n            for i in range(numSlots):\\n                if not 1 << (i*2) & mask:\\n                    ans = max(ans, ((i + 1) & nums[idx]) + traverse(1 << (i*2) ^ mask , idx + 1))\\n                elif not 1 << (i*2 + 1) & mask:\\n                    ans = max(ans, ((i + 1) & nums[idx]) + traverse((1 << ((i*2) + 1)) ^ mask, idx + 1))\\n            \\n            return ans\\n                              \\n        return traverse(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235706,
                "title": "c-recursion-memoization-dp-with-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    \\n    int getMax(vector<int>& nums,long first ,long second,int &numSlots,int idx){\\n        if(idx == nums.size())return 0;\\n        if(dp[first][second] != -1)return dp[first][second];\\n        \\n        int ans = 0;\\n        int temp = 0;\\n        for(int i = 0; i < numSlots; i++){\\n            int curSlot = 1<<i;\\n            if(second & curSlot){\\n                temp = (i + 1) & nums[idx];\\n                if(first & curSlot) temp += getMax(nums, first ^ curSlot, second, numSlots, idx + 1);\\n                else temp += getMax(nums, first, second ^ curSlot, numSlots, idx + 1);\\n            }\\n            ans = max(ans,temp);\\n        }\\n        return dp[first][second] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        int first = pow(2,numSlots)-1;\\n        int second = first;\\n        dp.resize(first+1,vector<int>(first+1,-1));\\n\\n        return getMax(nums,first,second,numSlots,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    \\n    int getMax(vector<int>& nums,long first ,long second,int &numSlots,int idx){\\n        if(idx == nums.size())return 0;\\n        if(dp[first][second] != -1)return dp[first][second];\\n        \\n        int ans = 0;\\n        int temp = 0;\\n        for(int i = 0; i < numSlots; i++){\\n            int curSlot = 1<<i;\\n            if(second & curSlot){\\n                temp = (i + 1) & nums[idx];\\n                if(first & curSlot) temp += getMax(nums, first ^ curSlot, second, numSlots, idx + 1);\\n                else temp += getMax(nums, first, second ^ curSlot, numSlots, idx + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2095505,
                "title": "dp-bitmask-explained",
                "content": "```\\n/*\\n\\nfor each  nums[i] we have choices among n slots\\n\\nto store the condition of slots, we use bit mask\\n\\ntwo adjacent bits represent the situation of any slot\\n\\n00 00 00 11 01 => it means 1st slot have 1 integer , 2nd slot have 2 integers \\n                  and other slots are empty\\n\\nas max no of slots =9\\nso size of bitmask=18\\n\\ndp[i][mask] = max And sum using [i...n-1] array, if condition of slots till now is stored in mask\\n\\n*/\\n\\n\\nint dp[18][1<<18];\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        \\n        int n=nums.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return find(0,0,nums,slots);\\n    \\n    }\\n    \\n    int find(int i,int mask,vector<int>&nums,int slots){\\n        \\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[i][mask]!=-1)\\n            return dp[i][mask];\\n        \\n        int mx=INT_MIN;\\n        \\n        for(int j=0;j<2*slots;j++){\\n            if((mask & (1<<j))!=0)\\n                continue;\\n            int temp=(nums[i]&((j/2)+1));\\n     mx=max(mx,(temp+find(i+1,mask | (1<<j),nums,slots)));\\n        }\\n            \\n           return dp[i][mask]=mx;\\n    }\\n    \\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        \\n        int n=nums.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return find(0,0,nums,slots);\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1886234,
                "title": "python-top-down-tuple-no-bitmask",
                "content": "I thought this was slightly easier to code just using a tuple rather than a bitmask.\\n\\nThe one non-obvious thing for me about this problem at first was that we actually ant to use all nums. I guess that somewhat makes sense since every num will add and never subtract.\\n\\n```python\\nfrom functools import cache\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dfs(i, slots):\\n            if i == len(nums):\\n                return 0\\n            max_used = 0\\n            for j in range(len(slots)):\\n                if slots[j] > 0:\\n                    max_used = max(max_used, ((j+1) & nums[i]) + dfs(i+1, slots[:j] + (slots[j]-1,) + slots[j+1:]))\\n            return max_used\\n        return dfs(0, tuple([2]*numSlots))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom functools import cache\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dfs(i, slots):\\n            if i == len(nums):\\n                return 0\\n            max_used = 0\\n            for j in range(len(slots)):\\n                if slots[j] > 0:\\n                    max_used = max(max_used, ((j+1) & nums[i]) + dfs(i+1, slots[:j] + (slots[j]-1,) + slots[j+1:]))\\n            return max_used\\n        return dfs(0, tuple([2]*numSlots))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769748,
                "title": "c-recursion-memoization-clean-code",
                "content": "**Approach 1 : ( TLE )** \\nRecusion Approach will give us TLE.\\n```\\nclass Solution {\\npublic:\\n    int recur(int idx,vector<int>&nums,vector<int>&wt,int numSlots)\\n    {\\n        if(idx>=nums.size()) return 0;\\n        \\n        int res=INT_MIN;\\n        for(int k=1;k<=numSlots;k++)\\n        {\\n            if(wt[k]<2)\\n            {\\n                wt[k]++;\\n                int ans=(nums[idx] & k) + recur(idx+1,nums,wt,numSlots);\\n                wt[k]--;\\n                \\n                res=max(res,ans);\\n            }\\n        }\\n        return res;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        \\n        vector<int>wt(numSlots+1,0);\\n        \\n        return recur(0,nums,wt,numSlots);\\n    }\\n};\\n```\\n\\n**Approach 2 : ( AC )**\\n\\n**We will memoize the \"wt\" vector along with index and if \\nthat entry is already found in map we will directly return the ans**\\n\\n```\\nclass Solution {\\npublic:\\n    int recur(int idx,vector<int>&nums,vector<int>&wt,int numSlots, map<pair<int,vector<int>>,int>&dp)\\n    {\\n        if(idx>=nums.size()) return 0;\\n        \\n        if(dp.find({idx,wt})!=dp.end())\\n            return dp[{idx,wt}];\\n        int res=INT_MIN;\\n        for(int k=1;k<=numSlots;k++)\\n        {\\n            if(wt[k]<2)\\n            {\\n                wt[k]++;\\n                int ans=(nums[idx] & k) + recur(idx+1,nums,wt,numSlots,dp);\\n                wt[k]--;\\n                \\n                res=max(res,ans);\\n            }\\n        }\\n        return dp[{idx,wt}]=res;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        \\n        vector<int>wt(numSlots+1,0);\\n        map<pair<int,vector<int>>,int>dp;\\n        return recur(0,nums,wt,numSlots,dp);\\n    }\\n};\\n```\\n\\n**Pls upvote if you found helpful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int idx,vector<int>&nums,vector<int>&wt,int numSlots)\\n    {\\n        if(idx>=nums.size()) return 0;\\n        \\n        int res=INT_MIN;\\n        for(int k=1;k<=numSlots;k++)\\n        {\\n            if(wt[k]<2)\\n            {\\n                wt[k]++;\\n                int ans=(nums[idx] & k) + recur(idx+1,nums,wt,numSlots);\\n                wt[k]--;\\n                \\n                res=max(res,ans);\\n            }\\n        }\\n        return res;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        \\n        vector<int>wt(numSlots+1,0);\\n        \\n        return recur(0,nums,wt,numSlots);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int recur(int idx,vector<int>&nums,vector<int>&wt,int numSlots, map<pair<int,vector<int>>,int>&dp)\\n    {\\n        if(idx>=nums.size()) return 0;\\n        \\n        if(dp.find({idx,wt})!=dp.end())\\n            return dp[{idx,wt}];\\n        int res=INT_MIN;\\n        for(int k=1;k<=numSlots;k++)\\n        {\\n            if(wt[k]<2)\\n            {\\n                wt[k]++;\\n                int ans=(nums[idx] & k) + recur(idx+1,nums,wt,numSlots,dp);\\n                wt[k]--;\\n                \\n                res=max(res,ans);\\n            }\\n        }\\n        return dp[{idx,wt}]=res;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        \\n        vector<int>wt(numSlots+1,0);\\n        map<pair<int,vector<int>>,int>dp;\\n        return recur(0,nums,wt,numSlots,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768324,
                "title": "python-3-two-masks",
                "content": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i, m1, m2):\\n            if i == len(nums):\\n                return 0\\n\\n            ans = float(\\'-inf\\')\\n            for j in range(numSlots):\\n                if m1 & (1 << j):\\n                    ans = max(ans, (nums[i] & (j + 1)) + dp(i + 1, m1 ^ (1 << j), m2))\\n                elif m2 & (1 << j):\\n                    ans = max(ans, (nums[i] & (j + 1)) + dp(i + 1, m1, m2 ^ (1 << j)))\\n            return ans\\n\\n        return dp(0, (1<<numSlots)-1, (1<<numSlots)-1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i, m1, m2):\\n            if i == len(nums):\\n                return 0\\n\\n            ans = float(\\'-inf\\')\\n            for j in range(numSlots):\\n                if m1 & (1 << j):\\n                    ans = max(ans, (nums[i] & (j + 1)) + dp(i + 1, m1 ^ (1 << j), m2))\\n                elif m2 & (1 << j):\\n                    ans = max(ans, (nums[i] & (j + 1)) + dp(i + 1, m1, m2 ^ (1 << j)))\\n            return ans\\n\\n        return dp(0, (1<<numSlots)-1, (1<<numSlots)-1)",
                "codeTag": "Java"
            },
            {
                "id": 1767726,
                "title": "brute-force-and-intitutive",
                "content": "class Solution {\\npublic:\\n    \\n    map<pair<int,vector<int>>,int> mp1;\\n    \\n    // map is for memoization of index and buf array\\n    // vector buf is to check the maximum number in each slot\\n    // index at which are computing\\n    \\n    \\n    int dfs(int i,vector<int> &nums,vector<int>&buf,int& n,int& numSlots)\\n    {\\n        if(i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        pair<int,vector<int>> a = make_pair(i,buf);\\n        \\n        if(mp1[a] != 0)\\n            return mp1[a];\\n        \\n        int ans1 = INT_MIN;\\n        for(int k = 0;k<numSlots;k++)\\n        {\\n            if(buf[k]<2)\\n            {\\n                buf[k]++;\\n                ans1 = max(ans1,(nums[i]&(k+1))+dfs(i+1,nums,buf,n,numSlots));\\n                buf[k]--;\\n            }\\n            \\n            \\n        }\\n        \\n        mp1[a] = ans1;\\n        return ans1;\\n        \\n        \\n        \\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        mp1.clear();\\n        int n = nums.size();\\n        vector<int> buf(numSlots,0);\\n        return dfs(0,nums,buf,n,numSlots);\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    map<pair<int,vector<int>>,int> mp1;\\n    \\n    // map is for memoization of index and buf array\\n    // vector buf is to check the maximum number in each slot\\n    // index at which are computing\\n    \\n    \\n    int dfs(int i,vector<int> &nums,vector<int>&buf,int& n,int& numSlots)\\n    {\\n        if(i == n)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1766853,
                "title": "java-dp-bitmask",
                "content": "```\\n\\nclass Solution {\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        int counter = 0;\\n        int[] slots = new int[2 * numSlots];\\n        for(int i = 1; i <= numSlots; i++) {\\n            slots[counter++] = i;\\n            slots[counter++] = i;\\n        }\\n        int M = nums.length, N = slots.length, max = 0;\\n        int[][] DP = new int[M + 1][1 << N];\\n        for(int i = 1; i <= M; i++) {\\n            for(int j = 0; j < (1 << N); j++) {\\n                if(Integer.bitCount(j) == (i - 1)) {\\n                    for(int k = 0; k < N; k++) {\\n                        if((j & (1 << k)) == 0) {\\n                            DP[i][j | (1 << k)] = Math.max(DP[i][j | (1 << k)], (DP[i - 1][j] + (slots[k] & nums[i - 1])));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int j = 0; j < (1 << N); j++) {\\n            max = Math.max(max, DP[M][j]);\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        int counter = 0;\\n        int[] slots = new int[2 * numSlots];\\n        for(int i = 1; i <= numSlots; i++) {\\n            slots[counter++] = i;\\n            slots[counter++] = i;\\n        }\\n        int M = nums.length, N = slots.length, max = 0;\\n        int[][] DP = new int[M + 1][1 << N];\\n        for(int i = 1; i <= M; i++) {\\n            for(int j = 0; j < (1 << N); j++) {\\n                if(Integer.bitCount(j) == (i - 1)) {\\n                    for(int k = 0; k < N; k++) {\\n                        if((j & (1 << k)) == 0) {\\n                            DP[i][j | (1 << k)] = Math.max(DP[i][j | (1 << k)], (DP[i - 1][j] + (slots[k] & nums[i - 1])));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int j = 0; j < (1 << N); j++) {\\n            max = Math.max(max, DP[M][j]);\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415488,
                "title": "bitmask-recursive-memoization-very-very-easy-soln",
                "content": "# Intuition &  Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **What are the choices , we can make?**\\nwe can try all numbers to put in any slots if there is place in slots.\\n- **How to store slots?**\\n   since maximumof number of slots can be 9 and every slots have two place to store the numbers, take 2 consecutive bit to represent 1 slot.\\n- Then for every index, try to put at any of vacant place in any of slots. \\n ```\\n   for(int i=0;i<numSlots;i++)\\n        {\\n            int firstSlotVacant=mask&(1<<(2*i));\\n            int secondSlotVacant=mask&(1<<(2*i+1));\\n            if(firstSlotVacant==0)ans=max(ans,(nums[ind]&(i+1))+ fun(ind+1, mask|(1<<(2*i)), numSlots, nums));\\n            else if(secondSlotVacant==0)ans=max(ans,(nums[ind]&(i+1))+ fun(ind+1, mask|(1<<(2*i+1)),numSlots, nums));\\n        }\\n```\\n\\n\\n# Complexity\\n- Time complexity:O(n* 2^n * numSlots) as O(n* 2^n) is number of unique states and o(numSlots) tranistion time for every slot.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(19*(1<<18-1)) as i have declared \\n\\n```\\nint dp[19][(1<<18)-1]\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[19][(1<<18)-1];\\n    int fun(int ind, int mask,int numSlots, vector<int>&nums)\\n    {\\n        if(ind==nums.size() )return 0;\\n        if(dp[ind][mask]!=-1) return dp[ind][mask];\\n        // mujhe nums[ind] ko kisi bhi availiable slots me rakhna hai\\n        int ans=0;\\n        for(int i=0;i<numSlots;i++)\\n        {\\n            int firstSlotVacant=mask&(1<<(2*i));\\n            int secondSlotVacant=mask&(1<<(2*i+1));\\n            if(firstSlotVacant==0)ans=max(ans,(nums[ind]&(i+1))+ fun(ind+1, mask|(1<<(2*i)), numSlots, nums));\\n            else if(secondSlotVacant==0)ans=max(ans,(nums[ind]&(i+1))+ fun(ind+1, mask|(1<<(2*i+1)),numSlots, nums));\\n        }\\n       return dp[ind][mask]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n=nums.size()-1;\\n        int mx=(1<<(2*numSlots))-1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=fun(0,0,numSlots,nums);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n   for(int i=0;i<numSlots;i++)\\n        {\\n            int firstSlotVacant=mask&(1<<(2*i));\\n            int secondSlotVacant=mask&(1<<(2*i+1));\\n            if(firstSlotVacant==0)ans=max(ans,(nums[ind]&(i+1))+ fun(ind+1, mask|(1<<(2*i)), numSlots, nums));\\n            else if(secondSlotVacant==0)ans=max(ans,(nums[ind]&(i+1))+ fun(ind+1, mask|(1<<(2*i+1)),numSlots, nums));\\n        }\\n```\n```\\nint dp[19][(1<<18)-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[19][(1<<18)-1];\\n    int fun(int ind, int mask,int numSlots, vector<int>&nums)\\n    {\\n        if(ind==nums.size() )return 0;\\n        if(dp[ind][mask]!=-1) return dp[ind][mask];\\n        // mujhe nums[ind] ko kisi bhi availiable slots me rakhna hai\\n        int ans=0;\\n        for(int i=0;i<numSlots;i++)\\n        {\\n            int firstSlotVacant=mask&(1<<(2*i));\\n            int secondSlotVacant=mask&(1<<(2*i+1));\\n            if(firstSlotVacant==0)ans=max(ans,(nums[ind]&(i+1))+ fun(ind+1, mask|(1<<(2*i)), numSlots, nums));\\n            else if(secondSlotVacant==0)ans=max(ans,(nums[ind]&(i+1))+ fun(ind+1, mask|(1<<(2*i+1)),numSlots, nums));\\n        }\\n       return dp[ind][mask]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n=nums.size()-1;\\n        int mx=(1<<(2*numSlots))-1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=fun(0,0,numSlots,nums);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957815,
                "title": "dynamic-programming-with-memoization-trying-to-explain-why-the-memo-is-one-dimension",
                "content": "# Intuition\\n\\n**Diclaimer**: Please understand that this is a DP problem and not a backtrack because the set we are updating does not reflect the vertices we have transversed. I mention a lot backtrack here because the concepts fit perfectly with that set of problems.\\n\\nI usually refer to this problems as backtrack with memoization.\\nI mentioned my thought about this exception to the backtrack limitation in this text: https://leetcode.com/problems/campus-bikes-ii/solutions/2919762/backtrack-with-dp-memory-one-of-the-few-ways-it-is-possible/\\n\\nAlso, the exercise on that link may be a good warms up for this, I do recomend you do it before jumping into this one.\\n\\nThe idea is that you can use memoization if you use also inform the vertices you have used (a generalization to graphs), and this is only feasible with small numbers (we use bitwise for this trick, so 31).\\n\\nWhat this exercise brings to the table is the realization that for some exercises the set itself may contain extra information, like the number of ones (vertices used) could also inform how deep/distant you are from the root (again abstracting to graphs).\\n\\nFor this problem, if we use the index (zero based) of nums in the recursion and the set being the slots used you may initially think of the memoization having `memo[index][set]`, but if you spend a little more time you will realize that the combination is `index` and `set` are unique, e.g.:\\n- on index 1 you will have sets `..001`, `..010`, `..100`, etc\\n- you will never have sets `..001`, `..010`, `..100` on any other index other than 1.\\n\\n**Note**: index 1 is the second iteration, as it is zero based! that is why one position was used.\\n\\nThen you realize that the index information on the memoization becames unnecessary.\\n\\nAbstracting this idea to graphs, if one of the information on the recursion can be induced from the set variable, then you dont need it on the memoization (such as the distance from the root). The fact that you can deduce it means that no information would have that set, and therefore are independent groups.\\n\\n**Similar Problems**: The idea presented in this problems has the same bases as the one applied at https://leetcode.com/problems/cherry-pickup/?envType=study-plan&id=dynamic-programming-iii\\n\\n# Approach\\n- Backtrack\\n- DP with memoization.\\n\\n# Complexity\\n## Time complexity:\\n$$O( pow(3,numSlots)*numSlots )$$\\n\\nOriginally it was `pow(2,2*numSlots)` -> `pow(4,numSlots)`, representing:\\n- `firstHalfSlot` empty `secondHalfSlot` empty.\\n- `firstHalfSlot` used `secondHalfSlot` empty.\\n- `firstHalfSlot` used `secondHalfSlot` used.\\n- `firstHalfSlot` empty `secondHalfSlot` used.\\n\\nbut then I realized that the combination:\\n- `firstHalfSlot` empty `secondHalfSlot` used \\n\\nwas impossible, that is why `pow(4,numSlots)` became `pow(3,numSlots)`\\n\\n## Space complexity:\\n$$O( pow(2,2*numSlots) )$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/48645f47-6f0c-4686-999e-8802b88f0758_1672137775.076674.png)\\n\\n```java\\nclass Solution {\\n    int[] memo;\\n    int[] nums;\\n    int numSlots;\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        this.memo=new int[1<<(2*numSlots)];\\n        this.nums=nums;\\n        this.numSlots=numSlots;\\n        return helper(0,0);\\n    }\\n    int helper(int numIndex, int set) {\\n        // Base case when we used all the numbers \\n        if(numIndex==nums.length) return 0;\\n        // Set informs BOTH the slots used and the numIndex. If the later\\n        // statement surprises you, think it like this: We must place all\\n        // the numbers in a slot, so how many slots are used in numIndex=10?\\n        // yes! 9 slots (because we will use the 10th now!), so the set will\\n        // have 10 ones. No other numIndex will have 9 ones. So having memo\\n        // with 2 dimentions would be redundant, as you would naver have a\\n        // combination of numIndex 3 with sets 1, 2, 4, 6.. etc, only\\n        // numIndex 2 will have those sets.\\n        if(memo[set]>0) return memo[set]-1; // I use memo-1 so I dont have to fill it with -1\\n        int max=0;\\n        for(int i=0;i<numSlots;i++) {\\n            int firstHalfSlot = (set&(1<<i))==0?i:-1; // -1 if it is used\\n            int secondHalfSlot = (set&(1<<(i+numSlots)))==0?i+numSlots:-1; // -1 if it is used\\n            int slotChosen = firstHalfSlot>-1?firstHalfSlot:secondHalfSlot;\\n            if(slotChosen<0) continue; // both slots are used\\n            int andSum=0;\\n            if(slotChosen>=numSlots) andSum=((slotChosen-numSlots)+1)&nums[numIndex];\\n            else andSum=(slotChosen+1)&nums[numIndex];\\n            // By adjusting the set in the recursion signature\\n            // I am backtracking in an elegant way.\\n            max=Math.max(max, andSum+ helper(numIndex+1,set|1<<slotChosen));\\n        }\\n        memo[set]=max+1; // I use memo+1 so I dont have to fill it with -1\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    int[] memo;\\n    int[] nums;\\n    int numSlots;\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        this.memo=new int[1<<(2*numSlots)];\\n        this.nums=nums;\\n        this.numSlots=numSlots;\\n        return helper(0,0);\\n    }\\n    int helper(int numIndex, int set) {\\n        // Base case when we used all the numbers \\n        if(numIndex==nums.length) return 0;\\n        // Set informs BOTH the slots used and the numIndex. If the later\\n        // statement surprises you, think it like this: We must place all\\n        // the numbers in a slot, so how many slots are used in numIndex=10?\\n        // yes! 9 slots (because we will use the 10th now!), so the set will\\n        // have 10 ones. No other numIndex will have 9 ones. So having memo\\n        // with 2 dimentions would be redundant, as you would naver have a\\n        // combination of numIndex 3 with sets 1, 2, 4, 6.. etc, only\\n        // numIndex 2 will have those sets.\\n        if(memo[set]>0) return memo[set]-1; // I use memo-1 so I dont have to fill it with -1\\n        int max=0;\\n        for(int i=0;i<numSlots;i++) {\\n            int firstHalfSlot = (set&(1<<i))==0?i:-1; // -1 if it is used\\n            int secondHalfSlot = (set&(1<<(i+numSlots)))==0?i+numSlots:-1; // -1 if it is used\\n            int slotChosen = firstHalfSlot>-1?firstHalfSlot:secondHalfSlot;\\n            if(slotChosen<0) continue; // both slots are used\\n            int andSum=0;\\n            if(slotChosen>=numSlots) andSum=((slotChosen-numSlots)+1)&nums[numIndex];\\n            else andSum=(slotChosen+1)&nums[numIndex];\\n            // By adjusting the set in the recursion signature\\n            // I am backtracking in an elegant way.\\n            max=Math.max(max, andSum+ helper(numIndex+1,set|1<<slotChosen));\\n        }\\n        memo[set]=max+1; // I use memo+1 so I dont have to fill it with -1\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397610,
                "title": "50ms-c-dp-bitmask",
                "content": "```\\nint N,n;\\nint dp[1<<10][1<<10];\\nint ff(int j,int k,vector<int> &a)\\n{\\n    int i = __builtin_popcount(j)+__builtin_popcount(k);\\n    if(i>=n)return 0;\\n    if(dp[j][k]!=-1)return dp[j][k];\\n    int res = 0;\\n    for(int b=0;b<N;b++)\\n    {\\n        if((j&(1<<b))==0)\\n        {\\n            j+=(1<<b);\\n            res = max(ff(j,k,a)+(a[i]&(b+1)),res);\\n            j-=(1<<b);\\n            continue;\\n        }\\n        if((k&(1<<b))==0)\\n        {\\n            k+=(1<<b);\\n            res = max(ff(j,k,a)+(a[i]&(b+1)),res);\\n            k-=(1<<b);\\n            continue;\\n        }\\n    }\\n    return dp[j][k]=res;\\n}\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& a, int Nn) {\\n        n = a.size();\\n        N = Nn;\\n        memset(dp,-1,sizeof(dp));\\n        return ff(0,0,a);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint N,n;\\nint dp[1<<10][1<<10];\\nint ff(int j,int k,vector<int> &a)\\n{\\n    int i = __builtin_popcount(j)+__builtin_popcount(k);\\n    if(i>=n)return 0;\\n    if(dp[j][k]!=-1)return dp[j][k];\\n    int res = 0;\\n    for(int b=0;b<N;b++)\\n    {\\n        if((j&(1<<b))==0)\\n        {\\n            j+=(1<<b);\\n            res = max(ff(j,k,a)+(a[i]&(b+1)),res);\\n            j-=(1<<b);\\n            continue;\\n        }\\n        if((k&(1<<b))==0)\\n        {\\n            k+=(1<<b);\\n            res = max(ff(j,k,a)+(a[i]&(b+1)),res);\\n            k-=(1<<b);\\n            continue;\\n        }\\n    }\\n    return dp[j][k]=res;\\n}\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& a, int Nn) {\\n        n = a.size();\\n        N = Nn;\\n        memset(dp,-1,sizeof(dp));\\n        return ff(0,0,a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879190,
                "title": "c-solution-memoization-using-map",
                "content": "```\\nclass Solution {\\nprivate:\\n    int solve(int index, vector<int> &slots, map<pair<int, vector<int>>, int> &dp, vector<int>& nums, int numSlots) {\\n        if(index == nums.size())\\n            return 0;\\n        \\n        // Using the stored result\\n        if(dp.find({index, slots}) != dp.end())\\n            return dp[{index, slots}];\\n        \\n        int maxRes = INT_MIN;\\n        \\n        for(int i=1; i<=numSlots; i++) {\\n            if(slots[i] < 2) {\\n                slots[i]++;\\n                //selecting an element and assign to a slot \\'i\\'\\n                int res = (nums[index] & i) + solve(index+1, slots, dp, nums, numSlots);\\n                slots[i]--;\\n                // select maximum result in maxRes\\n                maxRes = max(maxRes, res);\\n            }\\n        }\\n        //Memoization : Storing the result\\n        return dp[{index, slots}] = maxRes;\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        vector<int> slots(numSlots + 1, 0);\\n        map<pair<int, vector<int>>, int> dp;\\n        return solve(0, slots, dp, nums, numSlots);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int index, vector<int> &slots, map<pair<int, vector<int>>, int> &dp, vector<int>& nums, int numSlots) {\\n        if(index == nums.size())\\n            return 0;\\n        \\n        // Using the stored result\\n        if(dp.find({index, slots}) != dp.end())\\n            return dp[{index, slots}];\\n        \\n        int maxRes = INT_MIN;\\n        \\n        for(int i=1; i<=numSlots; i++) {\\n            if(slots[i] < 2) {\\n                slots[i]++;\\n                //selecting an element and assign to a slot \\'i\\'\\n                int res = (nums[index] & i) + solve(index+1, slots, dp, nums, numSlots);\\n                slots[i]--;\\n                // select maximum result in maxRes\\n                maxRes = max(maxRes, res);\\n            }\\n        }\\n        //Memoization : Storing the result\\n        return dp[{index, slots}] = maxRes;\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        vector<int> slots(numSlots + 1, 0);\\n        map<pair<int, vector<int>>, int> dp;\\n        return solve(0, slots, dp, nums, numSlots);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814975,
                "title": "c-memoization",
                "content": "For every ```ar[pos]``` decide which slot from 1 to k it occupies.\\nEvery state of the slot is stored in variable used. For example:\\nif k=3, then :\\n`used=201` means \\n\\tslot 1 is occupied by 1 number\\n\\tslot 2 is occupied by 0 number\\n\\tslot 3 is occupied by 2 numbers\\n`used=011` means \\n\\tslot 1 is occupied by 1 number\\n\\tslot 2 is occupied by 1 number\\n\\tslot 3 is occupied by 0 number\\nand so on...\\nNow, its quite intuitive that we have to use base 3 number for the variable ```used```. \\nNote that used=210 doesn\\'t occupy the 210th bit of dp, instead, it occupies (2*(3^2)+1*(3^1)+(0*(3^0)))=22th bit.\\nThis observation helps in reducing the space (and thus time complexity) to a great extent. Now, to store the digit 222 we don\\'t need to use 1000 units of space but only 26 units.\\n**Time complexity: O(n\\\\*(3^k))**\\n**Space complexity: O(n\\\\*(3^k))**\\n```\\n\\nclass Solution {\\npublic:\\nint dp[18][19683];\\n\\nbool check(int used,int i){\\n    if(i==0) return (used%10)!=2;\\n    return check(used/10,i-1);\\n}\\n\\nint bitPos(int used,int pos){\\n    if(!used) return 0;\\n    return (pow(3,pos)*(used%10)+bitPos(used/10,pos+1));\\n}\\n\\nint help(vector<int> &ar,int k,int pos,int used){\\n    int n=ar.size(),ans=0;\\n    if(pos>=n) return 0;\\n    if(dp[pos][bitPos(used,0)]!=-1) return dp[pos][bitPos(used,0)];\\n    for(int i=0;i<k;i++){\\n        // if ith bit of \\'used\\' is 2 then ignore\\n        // if ith bit of \\'used\\' is 1 or 0 then try using this slot\\n        if(check(used,i)){\\n            int newUsed=used+pow(10,i);\\n            ans=max(ans,(ar[pos]&(i+1))+help(ar,k,pos+1,newUsed));\\n        }\\n    }\\n    return dp[pos][bitPos(used,0)]=ans;\\n}\\n\\nint maximumANDSum(vector<int>& ar, int k){\\n    memset(dp,-1,sizeof(dp));\\n    return help(ar,k,0,0);\\n}\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```ar[pos]```\n```used```\n```\\n\\nclass Solution {\\npublic:\\nint dp[18][19683];\\n\\nbool check(int used,int i){\\n    if(i==0) return (used%10)!=2;\\n    return check(used/10,i-1);\\n}\\n\\nint bitPos(int used,int pos){\\n    if(!used) return 0;\\n    return (pow(3,pos)*(used%10)+bitPos(used/10,pos+1));\\n}\\n\\nint help(vector<int> &ar,int k,int pos,int used){\\n    int n=ar.size(),ans=0;\\n    if(pos>=n) return 0;\\n    if(dp[pos][bitPos(used,0)]!=-1) return dp[pos][bitPos(used,0)];\\n    for(int i=0;i<k;i++){\\n        // if ith bit of \\'used\\' is 2 then ignore\\n        // if ith bit of \\'used\\' is 1 or 0 then try using this slot\\n        if(check(used,i)){\\n            int newUsed=used+pow(10,i);\\n            ans=max(ans,(ar[pos]&(i+1))+help(ar,k,pos+1,newUsed));\\n        }\\n    }\\n    return dp[pos][bitPos(used,0)]=ans;\\n}\\n\\nint maximumANDSum(vector<int>& ar, int k){\\n    memset(dp,-1,sizeof(dp));\\n    return help(ar,k,0,0);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772022,
                "title": "java-dp-without-mitmasking",
                "content": "\\n\\n   try all possible combination \\n   wt is slots array value at wt[i] indicates how much nums filled till  now \\n   calling function\\n   base case i>=nums.length end of array return 0;\\n   for each number at i index try to fill it in the slots available that is if wt[i]< 2 so we can \\n   now fill it and num[i]&k (k is slot number )  wt[k]++ as we have used this slot now call for next num that is on i+1 \\n   take maximum of all possible \\n   now as we have taken that slot  we can remove that num from that slot that is wt[k]--;\\n   and check with other combination\\n   // backtracking \\n   now the problem with memorization \\n   i tried lots of things we cant directely store map<int[],Integer> as in java things works in references (address) now \\n   each time slots array will be unique like\\n    k=1 to k=numslots\\n\\t 0 0 0 1 2 0 1 2 0 like this at each index there will be 0 or 1 0r 2 so \\n\\t create key by appending all the values as string store it map\\n\\t Map<String, Integer> map;\\n\\t ``\\n\\t keep learning``\\n\\n\\n\\n```\\nstatic Map<String ,Integer> map;\\n\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n            \\n            int[] wt= new int[numSlots+1];\\n               map= new HashMap<>();\\n            \\n            return solve(0,nums,wt,numSlots);\\n            \\n             \\n            \\n            \\n    }\\n        public static int solve(int i,int[] nums,int[] wt,int numSlots){\\n                if(i>=nums.length){\\n                        return 0;\\n                }\\n                int ans=Integer.MIN_VALUE;\\n                String key=getKey(nums,wt);\\n                if(map.containsKey(key)){\\n                        return map.get(key);\\n                }\\n              \\n                for(int k=1;k<=numSlots;k++){\\n                        if(wt[k]<2){\\n                                wt[k]++;\\n                                int ans1=nums[i]&k;\\n                                ans1=ans1+ (solve(i+1,nums,wt,numSlots));\\n                                wt[k]--;\\n                                ans=Math.max(ans1,ans);\\n                                \\n                                \\n                        }\\n                }\\n                String key1=getKey(nums,wt);\\n               map.put(key1,ans);\\n                \\n                return ans;\\n        }\\n        public static String getKey(int[] nums,int[] wt){\\n                StringBuilder ans= new StringBuilder();\\n                for(int i=0;i<wt.length-1;i++){\\n                        ans.append(wt[i+1]);\\n                }\\n                return ans.toString();\\n                \\n        }\\n      \\n        \\n        \\n       \\n}\\n```",
                "solutionTags": [
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nstatic Map<String ,Integer> map;\\n\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n            \\n            int[] wt= new int[numSlots+1];\\n               map= new HashMap<>();\\n            \\n            return solve(0,nums,wt,numSlots);\\n            \\n             \\n            \\n            \\n    }\\n        public static int solve(int i,int[] nums,int[] wt,int numSlots){\\n                if(i>=nums.length){\\n                        return 0;\\n                }\\n                int ans=Integer.MIN_VALUE;\\n                String key=getKey(nums,wt);\\n                if(map.containsKey(key)){\\n                        return map.get(key);\\n                }\\n              \\n                for(int k=1;k<=numSlots;k++){\\n                        if(wt[k]<2){\\n                                wt[k]++;\\n                                int ans1=nums[i]&k;\\n                                ans1=ans1+ (solve(i+1,nums,wt,numSlots));\\n                                wt[k]--;\\n                                ans=Math.max(ans1,ans);\\n                                \\n                                \\n                        }\\n                }\\n                String key1=getKey(nums,wt);\\n               map.put(key1,ans);\\n                \\n                return ans;\\n        }\\n        public static String getKey(int[] nums,int[] wt){\\n                StringBuilder ans= new StringBuilder();\\n                for(int i=0;i<wt.length-1;i++){\\n                        ans.append(wt[i+1]);\\n                }\\n                return ans.toString();\\n                \\n        }\\n      \\n        \\n        \\n       \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1770646,
                "title": "java-bitmask-dp",
                "content": "It is a problem of maximum weighted bipartite graph matching: we are matching the list of numbers to the list of slots (both up to 2 * 9=18), where the weight is equal to slot id (1..9). For a larger \"graph\" this requires the Hungarian algorithm, but for the small sized graph in this problem, the bitmask DP is sufficient - it tries all the permutations of slots in a DP-optimized manner, achieving time complexity of 2^(2 * numSlots), which is up to 2^18 ~= 262k operations\\n```\\nclass Solution {\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        // try all combinations of slots using bitmask DP - bit==1 in mask means slot is available (unallocated)\\n        // dp[i]:= where dp[i] has k zeros, is the max AND sum when slots with bit==0 have been allocated to first k numbers of the nums array\\n        int n= 2*numSlots;\\n\\t\\tint[] dp= new int[1<<n];    // 0 ... (2**n)-1\\n        Arrays.fill(dp, -1);\\n        return bitmaskDP((1<<n)-1, numSlots, 0, nums, dp);\\n    }\\n    \\n    int bitmaskDP(int mask, int numSlots, int i, int[] nums, int[] dp){\\n        // we don\\'t allocate all slots if the list of numbers is short - just stop when i reaches nums.length\\n\\t\\tif(i==nums.length || mask==0) return 0;\\n        int ans= dp[mask];\\n        if(ans!=-1) return ans;\\n        \\n\\t\\t// iterate through all the remaining unallocated slots\\n        for(int iMask=mask, iSlot; iMask!=0; iMask^= 1<<iSlot){\\n            iSlot= Integer.numberOfTrailingZeros(iMask); // java API for the index of the lowest bit set\\n            int valSlot= (iSlot%numSlots)+1;\\n            int candAns= (nums[i] & valSlot) + bitmaskDP(mask^(1<<iSlot), numSlots, i+1, nums, dp);\\n            if(candAns>ans) ans= candAns;\\n        }\\n        return dp[mask]= ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        // try all combinations of slots using bitmask DP - bit==1 in mask means slot is available (unallocated)\\n        // dp[i]:= where dp[i] has k zeros, is the max AND sum when slots with bit==0 have been allocated to first k numbers of the nums array\\n        int n= 2*numSlots;\\n\\t\\tint[] dp= new int[1<<n];    // 0 ... (2**n)-1\\n        Arrays.fill(dp, -1);\\n        return bitmaskDP((1<<n)-1, numSlots, 0, nums, dp);\\n    }\\n    \\n    int bitmaskDP(int mask, int numSlots, int i, int[] nums, int[] dp){\\n        // we don\\'t allocate all slots if the list of numbers is short - just stop when i reaches nums.length\\n\\t\\tif(i==nums.length || mask==0) return 0;\\n        int ans= dp[mask];\\n        if(ans!=-1) return ans;\\n        \\n\\t\\t// iterate through all the remaining unallocated slots\\n        for(int iMask=mask, iSlot; iMask!=0; iMask^= 1<<iSlot){\\n            iSlot= Integer.numberOfTrailingZeros(iMask); // java API for the index of the lowest bit set\\n            int valSlot= (iSlot%numSlots)+1;\\n            int candAns= (nums[i] & valSlot) + bitmaskDP(mask^(1<<iSlot), numSlots, i+1, nums, dp);\\n            if(candAns>ans) ans= candAns;\\n        }\\n        return dp[mask]= ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770219,
                "title": "python-use-dp-with-str-if-you-re-not-familar-with-bitmask",
                "content": "The brute-force solution as below would get TLE:\\n```python\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \"\"\"\\n        CREATED AT: 2022/2/13\\n        n == nums.length\\n        1 <= numSlots <= 9\\n        1 <= n <= 2 * numSlots\\n        1 <= nums[i] <= 15\\n        \"\"\"\\n\\n        def dfs(nums, slots) -> int:\\n            if not nums:\\n                return 0\\n            max_ret = 0\\n            for i in range(1, len(slots)):\\n                if slots[i] > 0:\\n                    slots[i] -= 1\\n                    ret = (nums[0] & i) + dfs(nums[1:], slots)\\n                    if ret > max_ret:\\n                        max_ret = ret\\n                    slots[i] += 1\\n            return max_ret\\n\\n        slots = [2] * (numSlots + 1)\\n\\n        return dfs(nums, slots)\\n```\\n\\nAnd I want to add lru_cache, but lru doesn\\'t support `List` type. So what we need to do is use base type to replace List type.\\n\\nSo the modified code as below, the [bit mask solution](https://leetcode.com/problems/maximum-and-sum-of-array/discuss/1766824/JavaC%2B%2BPython-DP-Solution) would be great as @lee215 posted, but if you are not familar with bit, you can try str.\\n\\n```python\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \"\"\"\\n        CREATED AT: 2022/2/14\\n        Runtime: 903 ms, faster than 50.00%\\n        Memory Usage: 26.3 MB, less than 50.00%\\n\\n        n == nums.length\\n        1 <= numSlots <= 9\\n        1 <= n <= 2 * numSlots\\n        1 <= nums[i] <= 15\\n        \"\"\"\\n\\n        @lru_cache(None)\\n        def dfs(pos, slots) -> int:\\n            if pos == len(nums):\\n                return 0\\n            max_ret = 0\\n            for i in range(1, len(slots)):\\n                if int(slots[i]) > 0:\\n                    new_slots = f\\'{slots[:i]}{int(slots[i]) - 1}{slots[i + 1:]}\\'\\n                    ret = (nums[pos] & i) + dfs(pos + 1, new_slots)\\n                    if ret > max_ret:\\n                        max_ret = ret\\n            return max_ret\\n\\n        slots = \\'2\\' * (numSlots + 1)\\n\\n        return dfs(0, slots)\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \"\"\"\\n        CREATED AT: 2022/2/13\\n        n == nums.length\\n        1 <= numSlots <= 9\\n        1 <= n <= 2 * numSlots\\n        1 <= nums[i] <= 15\\n        \"\"\"\\n\\n        def dfs(nums, slots) -> int:\\n            if not nums:\\n                return 0\\n            max_ret = 0\\n            for i in range(1, len(slots)):\\n                if slots[i] > 0:\\n                    slots[i] -= 1\\n                    ret = (nums[0] & i) + dfs(nums[1:], slots)\\n                    if ret > max_ret:\\n                        max_ret = ret\\n                    slots[i] += 1\\n            return max_ret\\n\\n        slots = [2] * (numSlots + 1)\\n\\n        return dfs(nums, slots)\\n```\n```python\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \"\"\"\\n        CREATED AT: 2022/2/14\\n        Runtime: 903 ms, faster than 50.00%\\n        Memory Usage: 26.3 MB, less than 50.00%\\n\\n        n == nums.length\\n        1 <= numSlots <= 9\\n        1 <= n <= 2 * numSlots\\n        1 <= nums[i] <= 15\\n        \"\"\"\\n\\n        @lru_cache(None)\\n        def dfs(pos, slots) -> int:\\n            if pos == len(nums):\\n                return 0\\n            max_ret = 0\\n            for i in range(1, len(slots)):\\n                if int(slots[i]) > 0:\\n                    new_slots = f\\'{slots[:i]}{int(slots[i]) - 1}{slots[i + 1:]}\\'\\n                    ret = (nums[pos] & i) + dfs(pos + 1, new_slots)\\n                    if ret > max_ret:\\n                        max_ret = ret\\n            return max_ret\\n\\n        slots = \\'2\\' * (numSlots + 1)\\n\\n        return dfs(0, slots)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1770169,
                "title": "similar-to-bitmask-but-used-a-map-with-string-as-the-key",
                "content": "I know this isnt optimal. HashMap with string as key has a linear time complexity find operation. This will add an extra multiplication factor of n where n is the size of slots.\\nWith given constraints, however it doesnt give TLE\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int maxSum(vector<int> &nums, string &arrangement, int ind){\\n        if(ind == nums.size()){\\n            return 0;\\n        }\\n        \\n        if(mp.find(arrangement + \" \" + to_string(ind)) != mp.end()){\\n            return mp[arrangement + \" \" + to_string(ind)];\\n        }\\n        int sum = 0;\\n        for(int i=0; i < arrangement.length(); i++){\\n            if(arrangement[i] == \\'2\\'){\\n                continue;\\n            }\\n            char original = arrangement[i];\\n            arrangement[i] = ((arrangement[i] - \\'0\\') + 1) + \\'0\\';\\n            int add = ((i+1) & nums[ind]);\\n            int remSum = add + maxSum(nums,arrangement,ind+1);\\n            sum = max(sum, remSum);\\n            arrangement[i] = original;\\n        }\\n        mp[arrangement + \" \" + to_string(ind)] = sum;\\n        return sum;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int sz = nums.size();\\n        int num = pow(2, numSlots)+1;\\n        string arrangement = \"\";\\n        for(int i = 0; i < numSlots; i++){\\n            arrangement += \"0\";\\n        }\\n        return maxSum(nums,arrangement,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int maxSum(vector<int> &nums, string &arrangement, int ind){\\n        if(ind == nums.size()){\\n            return 0;\\n        }\\n        \\n        if(mp.find(arrangement + \" \" + to_string(ind)) != mp.end()){\\n            return mp[arrangement + \" \" + to_string(ind)];\\n        }\\n        int sum = 0;\\n        for(int i=0; i < arrangement.length(); i++){\\n            if(arrangement[i] == \\'2\\'){\\n                continue;\\n            }\\n            char original = arrangement[i];\\n            arrangement[i] = ((arrangement[i] - \\'0\\') + 1) + \\'0\\';\\n            int add = ((i+1) & nums[ind]);\\n            int remSum = add + maxSum(nums,arrangement,ind+1);\\n            sum = max(sum, remSum);\\n            arrangement[i] = original;\\n        }\\n        mp[arrangement + \" \" + to_string(ind)] = sum;\\n        return sum;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int sz = nums.size();\\n        int num = pow(2, numSlots)+1;\\n        string arrangement = \"\";\\n        for(int i = 0; i < numSlots; i++){\\n            arrangement += \"0\";\\n        }\\n        return maxSum(nums,arrangement,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769186,
                "title": "c-2172-maximum-and-sum-of-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        vector<vector<int>> memo(nums.size(), vector<int>(1<<2*numSlots, -1)); \\n        \\n        function<int(int, int)> fn = [&](int k, int m) {\\n            if (k == nums.size()) return 0; \\n            if (memo[k][m] == -1) \\n                for (int i = 0; i < numSlots; ++i) \\n                    if ((m & 1<<2*i) == 0 || (m & 1<<2*i+1) == 0) {\\n                        int mm = m; \\n                        if ((m & 1<<2*i) == 0) mm ^= 1<<2*i; \\n                        else mm ^= 1<<2*i+1; \\n                        memo[k][m] = max(memo[k][m], (nums[k] & i+1) + fn(k+1, mm)); \\n                    }\\n            return memo[k][m]; \\n        }; \\n        \\n        return fn(0, 0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        vector<vector<int>> memo(nums.size(), vector<int>(1<<2*numSlots, -1)); \\n        \\n        function<int(int, int)> fn = [&](int k, int m) {\\n            if (k == nums.size()) return 0; \\n            if (memo[k][m] == -1) \\n                for (int i = 0; i < numSlots; ++i) \\n                    if ((m & 1<<2*i) == 0 || (m & 1<<2*i+1) == 0) {\\n                        int mm = m; \\n                        if ((m & 1<<2*i) == 0) mm ^= 1<<2*i; \\n                        else mm ^= 1<<2*i+1; \\n                        memo[k][m] = max(memo[k][m], (nums[k] & i+1) + fn(k+1, mm)); \\n                    }\\n            return memo[k][m]; \\n        }; \\n        \\n        return fn(0, 0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769089,
                "title": "c-dp-no-bitmask",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findMaxAndSum(vector<int>& count, int idx,vector<int>& nums, int numSlots, map<vector<int>, int> &dp) {\\n        if(idx >= nums.size())\\n            return 0;\\n        if(dp.find(count) != dp.end())\\n            return dp[count];\\n        int maxSum = INT_MIN;\\n        for(int i = 1; i <= numSlots; i++) {\\n            if(count[i] < 2){\\n                count[i]++;\\n                int ans = findMaxAndSum(count, idx+1, nums, numSlots, dp) + (nums[idx] & i);\\n                count[i]--;\\n                maxSum = max(maxSum, ans);\\n            }\\n        }\\n        return dp[count] = maxSum;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        vector<int> count(numSlots+1, 0);\\n        map<vector<int>, int> dp;\\n        return findMaxAndSum(count, 0, nums, numSlots, dp);\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaxAndSum(vector<int>& count, int idx,vector<int>& nums, int numSlots, map<vector<int>, int> &dp) {\\n        if(idx >= nums.size())\\n            return 0;\\n        if(dp.find(count) != dp.end())\\n            return dp[count];\\n        int maxSum = INT_MIN;\\n        for(int i = 1; i <= numSlots; i++) {\\n            if(count[i] < 2){\\n                count[i]++;\\n                int ans = findMaxAndSum(count, idx+1, nums, numSlots, dp) + (nums[idx] & i);\\n                count[i]--;\\n                maxSum = max(maxSum, ans);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1768546,
                "title": "python-3-dp-solution-remove-bit-mask",
                "content": "Inspried by [lee215\\'s answer](https://leetcode.com/problems/maximum-and-sum-of-array/discuss/1766824/JavaC%2B%2BPython-DP-Solution).\\n\\n[Explaination]\\n`slm` is the map for each position\\'s status, either it is filled with 0, 1, 2 numbered.\\nBrute forcely for each number in `num`, check if it can fill in the corresponding slot. If can (`if slm[s_i] == \"1\" or slm[s_i] == \"2\"`), update `slm` and try the following position to see if you can get larger sum.\\n\\nWe will cache `slm` to not go into overlap status.\\n\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(i, slm):\\n            if i >= len(nums):\\n                return 0\\n            res = 0\\n            for s_i in range(numSlots):\\n                if slm[s_i] == \"1\" or slm[s_i] == \"2\":\\n                    old_slm = slm\\n                    slm = slm[:s_i] + str(int(slm[s_i]) - 1) + slm[s_i + 1:]\\n                    res = max(res, (nums[i] & (s_i + 1)) + dp(i + 1, slm))\\n                    slm = old_slm\\n            return res\\n        return dp(0, \"2\" * numSlots)\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(i, slm):\\n            if i >= len(nums):\\n                return 0\\n            res = 0\\n            for s_i in range(numSlots):\\n                if slm[s_i] == \"1\" or slm[s_i] == \"2\":\\n                    old_slm = slm\\n                    slm = slm[:s_i] + str(int(slm[s_i]) - 1) + slm[s_i + 1:]\\n                    res = max(res, (nums[i] & (s_i + 1)) + dp(i + 1, slm))\\n                    slm = old_slm\\n            return res\\n        return dp(0, \"2\" * numSlots)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767404,
                "title": "c-simple-memoization",
                "content": "(Just a simple not so efficient solution)\\nEach slot can 0-2 numbers in them  and there are n such numbers ,so recursively find all the possible states and memoize to avoid double counting.\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n     unordered_map<int,int> memo;\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        // T O(pow(3,m) * n * m) \\n        // Space : O(pow(3,m))\\n         n = nums.size();\\n         m= numSlots;\\n         vector<int> slots(m,0);\\n        return find(slots,nums,0);\\n    }\\nprivate:\\n    int find(vector<int>& slots,vector<int>& nums,int i){\\n        if(i==n)return 0;\\n        int cur_state=0;\\n        for(int i=0;i<m;i++)\\n            cur_state = cur_state*10 + slots[i];\\n        \\n        if(memo.find(cur_state) != memo.end())return memo[cur_state];\\n        int res=0;\\n        for(int j=1;j<=m;j++){\\n            if(slots[j-1]<2){\\n                slots[j-1]++;\\n                res= max(res,((j & nums[i]) + find(slots,nums,i+1)));\\n                slots[j-1]--;\\n            }\\n        }\\n        return memo[cur_state]=res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n     unordered_map<int,int> memo;\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        // T O(pow(3,m) * n * m) \\n        // Space : O(pow(3,m))\\n         n = nums.size();\\n         m= numSlots;\\n         vector<int> slots(m,0);\\n        return find(slots,nums,0);\\n    }\\nprivate:\\n    int find(vector<int>& slots,vector<int>& nums,int i){\\n        if(i==n)return 0;\\n        int cur_state=0;\\n        for(int i=0;i<m;i++)\\n            cur_state = cur_state*10 + slots[i];\\n        \\n        if(memo.find(cur_state) != memo.end())return memo[cur_state];\\n        int res=0;\\n        for(int j=1;j<=m;j++){\\n            if(slots[j-1]<2){\\n                slots[j-1]++;\\n                res= max(res,((j & nums[i]) + find(slots,nums,i+1)));\\n                slots[j-1]--;\\n            }\\n        }\\n        return memo[cur_state]=res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767223,
                "title": "dp-numslots-2-numslots-numslots",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[512][512];\\n    int maximumANDSum(vector<int>& nums, int numSlots) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,numSlots,0,0,0);\\n    }\\n    int solve(vector<int>& nums,int numSlots,int index,int val1,int val2)\\n    { \\n        if(index == nums.size())\\n        return 0;   \\n        int ans = INT_MIN;\\n        if(dp[val1][val2] != -1)\\n        return dp[val1][val2];\\n        for(int i = 1;i <= numSlots;i++)\\n        {\\n            int x = i-1;\\n            if((val1 & 1<<x) == 0)\\n            ans = max(ans,(nums[index] & i) + solve(nums,numSlots,index+1,val1|1<<x,val2) );\\n            else if((val2 & 1<<x) == 0)\\n            ans = max(ans,(nums[index] & i) + solve(nums,numSlots,index+1,val1,val2|1<<x) );\\n        }\\n        return dp[val1][val2] = ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[512][512];\\n    int maximumANDSum(vector<int>& nums, int numSlots) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,numSlots,0,0,0);\\n    }\\n    int solve(vector<int>& nums,int numSlots,int index,int val1,int val2)\\n    { \\n        if(index == nums.size())\\n        return 0;   \\n        int ans = INT_MIN;\\n        if(dp[val1][val2] != -1)\\n        return dp[val1][val2];\\n        for(int i = 1;i <= numSlots;i++)\\n        {\\n            int x = i-1;\\n            if((val1 & 1<<x) == 0)\\n            ans = max(ans,(nums[index] & i) + solve(nums,numSlots,index+1,val1|1<<x,val2) );\\n            else if((val2 & 1<<x) == 0)\\n            ans = max(ans,(nums[index] & i) + solve(nums,numSlots,index+1,val1,val2|1<<x) );\\n        }\\n        return dp[val1][val2] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767150,
                "title": "creative-thinking-to-use-base-3-bitmasks",
                "content": "Let us represet the state of the slots with a string. \\nThe value of S[i] represents the number of integers presently occupying the slot. \\nWe can think about it as a base 3 mask ! \\n\\nLet f(i, m) be the maximum sum we can get with the first i integers with mask m. \\nWe will iterate over all tribits in m, and see whether we can put the integer A[i] inside any of the slots and calculate the sum accordingly. \\n\\n[Here](https://github.com/MathProgrammer/LeetCode/tree/master/Contests/Weekly%20Contest%20280) is my solution on GitHub\\n\\n```\\nclass Solution \\n{\\n    public:\\n    \\n    int digits_set(int n)\\n    {\\n        int sum = 0;\\n        while(n > 0)\\n        {\\n            sum += (n%3);\\n            n /= 3;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int get_tribit(int n, int digit)\\n    {\\n        while(digit > 0)\\n        {\\n            n /= 3;\\n            digit--;\\n        }\\n        \\n        return (n%3);\\n    }\\n    \\n    int power(int x, int p)\\n    {\\n        int result = 1;\\n        for(int i = 1; i <= p; i++)\\n        {\\n            result *= x;\\n        }\\n        return result;\\n    }\\n    \\n    int maximumANDSum(vector<int> &A, int numSlots) \\n    {\\n        const int MAX_MASK = power(3, numSlots);\\n        vector <vector <int> > maximum_sum(A.size() + 1, vector <int> (MAX_MASK, 0));\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            for(int m = 0; m < MAX_MASK; m++)\\n            {\\n                for(int tribit = 0; tribit < numSlots; tribit++)\\n                {\\n                    int current_tribit = get_tribit(m, tribit);\\n                    \\n                    if(current_tribit == 0 || digits_set(m) != i + 1)\\n                    {\\n                        continue;\\n                    }\\n                    \\n                    int current_AND = (A[i]&(tribit + 1));\\n                    int old_m = m - power(3, tribit);\\n                    \\n                    if(i == 0)\\n                    {\\n                        maximum_sum[i][m] = current_AND;\\n                    }\\n                    else \\n                    {\\n                        maximum_sum[i][m] = max(maximum_sum[i][m], current_AND + maximum_sum[i - 1][old_m]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for(int m = 0; m < MAX_MASK; m++)\\n        {\\n            if(digits_set(m) == A.size())\\n            {\\n                answer = max(answer, maximum_sum[A.size() - 1][m]);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    \\n    int digits_set(int n)\\n    {\\n        int sum = 0;\\n        while(n > 0)\\n        {\\n            sum += (n%3);\\n            n /= 3;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int get_tribit(int n, int digit)\\n    {\\n        while(digit > 0)\\n        {\\n            n /= 3;\\n            digit--;\\n        }\\n        \\n        return (n%3);\\n    }\\n    \\n    int power(int x, int p)\\n    {\\n        int result = 1;\\n        for(int i = 1; i <= p; i++)\\n        {\\n            result *= x;\\n        }\\n        return result;\\n    }\\n    \\n    int maximumANDSum(vector<int> &A, int numSlots) \\n    {\\n        const int MAX_MASK = power(3, numSlots);\\n        vector <vector <int> > maximum_sum(A.size() + 1, vector <int> (MAX_MASK, 0));\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            for(int m = 0; m < MAX_MASK; m++)\\n            {\\n                for(int tribit = 0; tribit < numSlots; tribit++)\\n                {\\n                    int current_tribit = get_tribit(m, tribit);\\n                    \\n                    if(current_tribit == 0 || digits_set(m) != i + 1)\\n                    {\\n                        continue;\\n                    }\\n                    \\n                    int current_AND = (A[i]&(tribit + 1));\\n                    int old_m = m - power(3, tribit);\\n                    \\n                    if(i == 0)\\n                    {\\n                        maximum_sum[i][m] = current_AND;\\n                    }\\n                    else \\n                    {\\n                        maximum_sum[i][m] = max(maximum_sum[i][m], current_AND + maximum_sum[i - 1][old_m]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for(int m = 0; m < MAX_MASK; m++)\\n        {\\n            if(digits_set(m) == A.size())\\n            {\\n                answer = max(answer, maximum_sum[A.size() - 1][m]);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767140,
                "title": "why-tle",
                "content": "Why is this code giving TLE ?\\n```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& a, int l) {\\n        int n=a.size();\\n        vector<int>s;\\n        for (int i = 1; i <=l ; ++i)\\n        {\\n            s.push_back(i);\\n            s.push_back(i);\\n        }\\n        int d=s.size();\\n        int M=1LL<<(s.size());\\n        vector<vector<int>>dp(M,vector<int>(n+1,0));\\n        for (int S = 0; S <M; ++S)\\n        {\\n            int x=0;\\n            for (int j = 0; j <d ; ++j)\\n            {\\n                if((1LL<<j)&S)\\n                {\\n                    int p=a[0]&s[j];\\n                    x=max(x,p);\\n                }\\n            }\\n            dp[S][0]=max(dp[S][0],x);\\n        }\\n\\n        for (int S = 1; S <M; ++S)\\n        {\\n            for (int i = 1; i <n ; ++i)\\n            {\\n                for (int j = 0; j <d ; ++j)\\n                {\\n                    if((1LL<<j)&S)\\n                    {\\n                        int p=a[i]&s[j];\\n                        dp[S][i]=max(dp[S][i],p+dp[S^(1LL<<j)][i-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[M-1][n-1];\\n    }\\n};\\n\\n\\nstatic const auto speedup = []() {\\n\\tstd::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0;\\n}();\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& a, int l) {\\n        int n=a.size();\\n        vector<int>s;\\n        for (int i = 1; i <=l ; ++i)\\n        {\\n            s.push_back(i);\\n            s.push_back(i);\\n        }\\n        int d=s.size();\\n        int M=1LL<<(s.size());\\n        vector<vector<int>>dp(M,vector<int>(n+1,0));\\n        for (int S = 0; S <M; ++S)\\n        {\\n            int x=0;\\n            for (int j = 0; j <d ; ++j)\\n            {\\n                if((1LL<<j)&S)\\n                {\\n                    int p=a[0]&s[j];\\n                    x=max(x,p);\\n                }\\n            }\\n            dp[S][0]=max(dp[S][0],x);\\n        }\\n\\n        for (int S = 1; S <M; ++S)\\n        {\\n            for (int i = 1; i <n ; ++i)\\n            {\\n                for (int j = 0; j <d ; ++j)\\n                {\\n                    if((1LL<<j)&S)\\n                    {\\n                        int p=a[i]&s[j];\\n                        dp[S][i]=max(dp[S][i],p+dp[S^(1LL<<j)][i-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[M-1][n-1];\\n    }\\n};\\n\\n\\nstatic const auto speedup = []() {\\n\\tstd::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1766948,
                "title": "c-using-minimum-cost-network-flow-16ms",
                "content": "https://cp-algorithms.com/graph/min_cost_flow.html \\n\\n```\\nclass Solution {    \\n    struct Edge {\\n        int from, to, capacity;\\n        int cost;\\n    };\\n\\n    // https://cp-algorithms.com/graph/min_cost_flow.html\\n    class MinCostFlow {\\n        std::vector<std::vector<int>> adj, capacity;\\n        std::vector<std::vector<int>> cost;\\n\\n        static constexpr int INF = 1e9;    \\n\\n        void shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\\n            d.assign(n, INF);\\n            d[v0] = 0;\\n            vector<bool> inq(n, false);\\n            queue<int> q;\\n            q.push(v0);\\n            p.assign(n, -1);\\n\\n            while (!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                inq[u] = false;\\n                for (int v : adj[u]) {\\n                    if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\\n                        d[v] = d[u] + cost[u][v];\\n                        p[v] = u;\\n                        if (!inq[v]) {\\n                            inq[v] = true;\\n                            q.push(v);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n    public:\\n        int min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\\n            adj.assign(N, vector<int>());\\n            cost.assign(N, vector<int>(N, 0));\\n            capacity.assign(N, vector<int>(N, 0));\\n            for (Edge e : edges) {\\n                adj[e.from].push_back(e.to);\\n                adj[e.to].push_back(e.from);\\n                cost[e.from][e.to] = e.cost;\\n                cost[e.to][e.from] = -e.cost;\\n                capacity[e.from][e.to] = e.capacity;\\n            }\\n\\n            int flow = 0;\\n            int cost = 0;\\n            vector<int> d, p;\\n            while (flow < K) {\\n                shortest_paths(N, s, d, p);\\n                if (d[t] == INF)\\n                    break;\\n\\n                // find max flow on that path\\n                int f = K - flow;\\n                int cur = t;\\n                while (cur != s) {\\n                    f = min(f, capacity[p[cur]][cur]);\\n                    cur = p[cur];\\n                }\\n\\n                // apply flow\\n                flow += f;\\n                cost += f * d[t];\\n                cur = t;\\n                while (cur != s) {\\n                    capacity[p[cur]][cur] -= f;\\n                    capacity[cur][p[cur]] += f;\\n                    cur = p[cur];\\n                }\\n            }\\n\\n            if (flow < K)\\n                return -1;\\n            else\\n                return cost;\\n        }\\n\\n\\n    };\\n    \\n    \\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        const int num_slots = numSlots;\\n                \\n        std::vector<Edge> edges;\\n        const int len = nums.size();\\n        const int num_vertex = 1 + len + num_slots + 1;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            edges.push_back(Edge{\\n                .from = 0,\\n                .to = i + 1,\\n                .capacity = 1,\\n                .cost = 0\\n            });\\n            for (int slot = 1; slot <= num_slots; ++slot) {\\n                edges.push_back(Edge{\\n                    .from = i + 1,\\n                    .to = len + slot,\\n                    .capacity = 1,\\n                    .cost = -(nums[i] & slot),\\n                });\\n            }\\n        }\\n        const int sink = num_vertex - 1;\\n        for (int slot = 1; slot <= num_slots; ++slot) {\\n            edges.push_back(Edge{\\n                .from = len + slot,\\n                .to = sink,\\n                .capacity = 2,\\n                .cost = 0\\n            });\\n        }\\n        \\n        return -MinCostFlow().min_cost_flow(num_vertex, edges, len, 0, sink);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    struct Edge {\\n        int from, to, capacity;\\n        int cost;\\n    };\\n\\n    // https://cp-algorithms.com/graph/min_cost_flow.html\\n    class MinCostFlow {\\n        std::vector<std::vector<int>> adj, capacity;\\n        std::vector<std::vector<int>> cost;\\n\\n        static constexpr int INF = 1e9;    \\n\\n        void shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\\n            d.assign(n, INF);\\n            d[v0] = 0;\\n            vector<bool> inq(n, false);\\n            queue<int> q;\\n            q.push(v0);\\n            p.assign(n, -1);\\n\\n            while (!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                inq[u] = false;\\n                for (int v : adj[u]) {\\n                    if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\\n                        d[v] = d[u] + cost[u][v];\\n                        p[v] = u;\\n                        if (!inq[v]) {\\n                            inq[v] = true;\\n                            q.push(v);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n    public:\\n        int min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\\n            adj.assign(N, vector<int>());\\n            cost.assign(N, vector<int>(N, 0));\\n            capacity.assign(N, vector<int>(N, 0));\\n            for (Edge e : edges) {\\n                adj[e.from].push_back(e.to);\\n                adj[e.to].push_back(e.from);\\n                cost[e.from][e.to] = e.cost;\\n                cost[e.to][e.from] = -e.cost;\\n                capacity[e.from][e.to] = e.capacity;\\n            }\\n\\n            int flow = 0;\\n            int cost = 0;\\n            vector<int> d, p;\\n            while (flow < K) {\\n                shortest_paths(N, s, d, p);\\n                if (d[t] == INF)\\n                    break;\\n\\n                // find max flow on that path\\n                int f = K - flow;\\n                int cur = t;\\n                while (cur != s) {\\n                    f = min(f, capacity[p[cur]][cur]);\\n                    cur = p[cur];\\n                }\\n\\n                // apply flow\\n                flow += f;\\n                cost += f * d[t];\\n                cur = t;\\n                while (cur != s) {\\n                    capacity[p[cur]][cur] -= f;\\n                    capacity[cur][p[cur]] += f;\\n                    cur = p[cur];\\n                }\\n            }\\n\\n            if (flow < K)\\n                return -1;\\n            else\\n                return cost;\\n        }\\n\\n\\n    };\\n    \\n    \\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        const int num_slots = numSlots;\\n                \\n        std::vector<Edge> edges;\\n        const int len = nums.size();\\n        const int num_vertex = 1 + len + num_slots + 1;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            edges.push_back(Edge{\\n                .from = 0,\\n                .to = i + 1,\\n                .capacity = 1,\\n                .cost = 0\\n            });\\n            for (int slot = 1; slot <= num_slots; ++slot) {\\n                edges.push_back(Edge{\\n                    .from = i + 1,\\n                    .to = len + slot,\\n                    .capacity = 1,\\n                    .cost = -(nums[i] & slot),\\n                });\\n            }\\n        }\\n        const int sink = num_vertex - 1;\\n        for (int slot = 1; slot <= num_slots; ++slot) {\\n            edges.push_back(Edge{\\n                .from = len + slot,\\n                .to = sink,\\n                .capacity = 2,\\n                .cost = 0\\n            });\\n        }\\n        \\n        return -MinCostFlow().min_cost_flow(num_vertex, edges, len, 0, sink);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766939,
                "title": "c-bottom-up-dp-3-base-for-the-state",
                "content": "The number range is very small, so we can consider \"brute-force\" dp usually.\\n\\nHere \"brute-force\" means to scan all the possible states.\\n\\nIn this question, for each slot, we have three possible choices: place 0, 1, or 2 elements. So natually we can choose a 3-base number to represent the state. (if not familiar, think about 2-base numbers which for two states for each \"bit\", of course).\\n\\nMore for 3-based numbers, if interested in.\\nFor example,\\n00 -> 0\\n01 -> 1\\n02 -> 2\\n10 -> 3\\n11 -> 4\\n12 -> 5\\n20 -> 6\\n21 -> 7\\n22 -> 8\\n(for each \"bit\", the value could be 0, 1, or 2)\\n\\nso the general formula is:\\nvalue = coef * 3^0 + coef * 3^1 + coef * 3^2 + ..., where coef is in the range of [0, 2].\\n\\nSo we can define a function to record the max value for a specific state for the first i elements,\\ndp[i][state1] = max(dp[i-1][state2] + nums[i] & k), where state1 = state2 + 3^(k-1) && at most two elements && iterate all k\\'s\\n\\nSee the code below:\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        // dp[i][state1] = max(dp[i-1][state2] + nums[i] & k), where state1 = state2 + 3^(i-1) && at most two elements && iterate all k slots\\n        int m = nums.size(), n = numSlots, v = pow(3, n), res = 0;\\n        vector<vector<int>> dp(m, vector<int>(v, 0));\\n\\t\\t// initialization\\n        for(int i=0; i<m; ++i) {\\n            for(int j=1; j<=n; ++j) {\\n                int val = pow(3, j-1);\\n                dp[i][val] = nums[i] & j;\\n                res = max(res, dp[i][val]);\\n            }\\n        }\\n        for(int i=1; i<m; ++i) {\\n            for(int j=0; j<v; ++j) {\\n                for(int k=1; k<=n; ++k) {\\n                    int r = pow(3, k-1), coef = j/r%3;\\n\\t\\t\\t\\t\\t// we will place the ith element at the kth slot, so the coef need to be 1 at least\\n                    if(coef>0) {\\n                        dp[i][j] = max(dp[i][j], dp[i-1][j-r] + (nums[i] & k));\\n                    }\\n                }\\n                if(i==m-1) res = max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        // dp[i][state1] = max(dp[i-1][state2] + nums[i] & k), where state1 = state2 + 3^(i-1) && at most two elements && iterate all k slots\\n        int m = nums.size(), n = numSlots, v = pow(3, n), res = 0;\\n        vector<vector<int>> dp(m, vector<int>(v, 0));\\n\\t\\t// initialization\\n        for(int i=0; i<m; ++i) {\\n            for(int j=1; j<=n; ++j) {\\n                int val = pow(3, j-1);\\n                dp[i][val] = nums[i] & j;\\n                res = max(res, dp[i][val]);\\n            }\\n        }\\n        for(int i=1; i<m; ++i) {\\n            for(int j=0; j<v; ++j) {\\n                for(int k=1; k<=n; ++k) {\\n                    int r = pow(3, k-1), coef = j/r%3;\\n\\t\\t\\t\\t\\t// we will place the ith element at the kth slot, so the coef need to be 1 at least\\n                    if(coef>0) {\\n                        dp[i][j] = max(dp[i][j], dp[i-1][j-r] + (nums[i] & k));\\n                    }\\n                }\\n                if(i==m-1) res = max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766741,
                "title": "mask-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(const vector<int>& nums, int numSlots) {\\n        unordered_map<int, int> mc;\\n        int iShift = numSlots * 2, n = nums.size();\\n        function<int(int, int)> f = [&](int index, int bitmap) {\\n            if (index == n) return 0;\\n            int key = (index << iShift) | bitmap;\\n            if (mc.count(key)) return mc[key];\\n            int& v = mc[key];\\n            for (int s = 1; s <= numSlots; ++s) {\\n                int count = (bitmap >> ((s - 1) * 2)) & 3;\\n                if (count >= 2) continue;\\n                int mask = 3 << ((s - 1) * 2);\\n                int bit = (count + 1) << ((s - 1) * 2);\\n                int nBitmap = (bitmap & ~mask) | bit;\\n                v = max(v, (s & nums[index]) + f(index + 1, nBitmap));\\n            }\\n            return v;\\n        };\\n\\n        return f(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(const vector<int>& nums, int numSlots) {\\n        unordered_map<int, int> mc;\\n        int iShift = numSlots * 2, n = nums.size();\\n        function<int(int, int)> f = [&](int index, int bitmap) {\\n            if (index == n) return 0;\\n            int key = (index << iShift) | bitmap;\\n            if (mc.count(key)) return mc[key];\\n            int& v = mc[key];\\n            for (int s = 1; s <= numSlots; ++s) {\\n                int count = (bitmap >> ((s - 1) * 2)) & 3;\\n                if (count >= 2) continue;\\n                int mask = 3 << ((s - 1) * 2);\\n                int bit = (count + 1) << ((s - 1) * 2);\\n                int nBitmap = (bitmap & ~mask) | bit;\\n                v = max(v, (s & nums[index]) + f(index + 1, nBitmap));\\n            }\\n            return v;\\n        };\\n\\n        return f(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069473,
                "title": "c-dp-bit-manipulation-84-12-faster",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums,int i,int n,int x1,int x2,vector<vector<int>>&dp){\\n        if(i>=nums.size()){return 0;}\\n        if(dp[x1][x2]!=-1)return dp[x1][x2];\\n        int ans = 0;\\n        for(int j=0;j<n;++j){\\n            if(((x2>>j)&1)==0){\\n                int f=0;\\n                if(((x1>>j)&1)==0){x1 += (1<<j);f=1;}\\n                else x2 += (1<<j);\\n                ans = max(ans,((j+1)&(nums[i]))+solve(nums,i+1,n,x1,x2,dp));\\n                if(f)x1 -= (1<<j);\\n                else x2 -= (1<<j);\\n            }\\n        }\\n        return dp[x1][x2] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        vector<vector<int>> dp(513,vector<int>(513,-1));\\n        return solve(nums,0,numSlots,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums,int i,int n,int x1,int x2,vector<vector<int>>&dp){\\n        if(i>=nums.size()){return 0;}\\n        if(dp[x1][x2]!=-1)return dp[x1][x2];\\n        int ans = 0;\\n        for(int j=0;j<n;++j){\\n            if(((x2>>j)&1)==0){\\n                int f=0;\\n                if(((x1>>j)&1)==0){x1 += (1<<j);f=1;}\\n                else x2 += (1<<j);\\n                ans = max(ans,((j+1)&(nums[i]))+solve(nums,i+1,n,x1,x2,dp));\\n                if(f)x1 -= (1<<j);\\n                else x2 -= (1<<j);\\n            }\\n        }\\n        return dp[x1][x2] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        vector<vector<int>> dp(513,vector<int>(513,-1));\\n        return solve(nums,0,numSlots,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059321,
                "title": "python-maximal-matching-44ms-beats-100",
                "content": "# Intuition\\n\\nIt is maximal matching problem on a bipartite graph.\\n\\nOn one side are the given numbers on the other side are the slots from 1 to `numSlots`, twice each. It is a complete bipartite graph, where an edge `(a, b)` has weight `(a & b)` and we need to find a maximal matching. Or a minimal one if the edge weights are negated.\\n\\nSuch a problem can be solved using `scipy.optimize.linear_sum_assignment`. However it is suprisingly slow in this environment. I suspect that loading the library, might be slow.\\n\\n\\nThis implementation beats `scipy.optimize`. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$\\n\\n- Space complexity: $$O(n)$$, where $n=2*numSlots$.\\n\\n# Code\\n```\\n# from scipy.optimize import linear_sum_assignment\\n\\ndef min_matching(cost):\\n    m, n = len(cost), len(cost[0])\\n    assert m <= n\\n    worker2job = [-1]*(n+1)\\n    job_pot = [0]*m\\n    worker_pot = [0]*(n+1)\\n    answer = []\\n    inf = int(10**9)\\n    dummy_worker = n\\n\\n    for curr_job in range(m):\\n        curr_workers = [dummy_worker]\\n        worker2job[dummy_worker] = curr_job\\n\\n        prev = [-1]*(n+1)\\n        in_Z = [False]*(n+1)\\n\\n        while curr_workers and all(worker2job[worker] != -1 for worker in curr_workers):\\n            for worker in curr_workers:\\n                in_Z[worker] = True\\n\\n            delta = inf\\n            min_reduced_cost = [inf] * (n + 1)\\n            for curr_worker in range(n+1):\\n                if not in_Z[curr_worker]:\\n                    continue\\n                job = worker2job[curr_worker]\\n                for worker in range(n):\\n                    if not in_Z[worker]:\\n                        reduced_cost = cost[job][worker]-job_pot[job]-worker_pot[worker]\\n                        if reduced_cost < min_reduced_cost[worker]:\\n                            min_reduced_cost[worker] = reduced_cost\\n                            prev[worker] = curr_worker\\n                        if reduced_cost < delta:\\n                            delta = reduced_cost\\n\\n            curr_workers.clear()\\n            for worker in range(n+1):\\n                if in_Z[worker]:\\n                    job_pot[worker2job[worker]] += delta\\n                    worker_pot[worker] -= delta\\n                else:\\n                    min_reduced_cost[worker] -= delta\\n                    if min_reduced_cost[worker] == 0:\\n                        curr_workers.append(worker)\\n        # print(f\"{curr_workers=},\\\\n{worker2job=},\\\\n{prev=},\\\\n{in_Z=},\\\\n{min_reduced_cost=},\\\\n{delta=}\")\\n        curr_workers = [worker for worker in curr_workers if worker2job[worker] == -1]\\n        # print(f\"filtered {curr_workers=}\")\\n        curr_worker = curr_workers[0]\\n\\n        while curr_worker != -1:\\n            worker2job[curr_worker] = worker2job[prev[curr_worker]]\\n            curr_worker = prev[curr_worker]\\n    return [(worker2job[i], i) for i in range(n) if worker2job[i] != -1]\\n    \\n\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        cost = [[-((1+(i%numSlots)) & num) for i in range(2*numSlots)] for num in nums]\\n        matching = min_matching(cost)\\n        return sum(-cost[i][j] for i, j in matching)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# from scipy.optimize import linear_sum_assignment\\n\\ndef min_matching(cost):\\n    m, n = len(cost), len(cost[0])\\n    assert m <= n\\n    worker2job = [-1]*(n+1)\\n    job_pot = [0]*m\\n    worker_pot = [0]*(n+1)\\n    answer = []\\n    inf = int(10**9)\\n    dummy_worker = n\\n\\n    for curr_job in range(m):\\n        curr_workers = [dummy_worker]\\n        worker2job[dummy_worker] = curr_job\\n\\n        prev = [-1]*(n+1)\\n        in_Z = [False]*(n+1)\\n\\n        while curr_workers and all(worker2job[worker] != -1 for worker in curr_workers):\\n            for worker in curr_workers:\\n                in_Z[worker] = True\\n\\n            delta = inf\\n            min_reduced_cost = [inf] * (n + 1)\\n            for curr_worker in range(n+1):\\n                if not in_Z[curr_worker]:\\n                    continue\\n                job = worker2job[curr_worker]\\n                for worker in range(n):\\n                    if not in_Z[worker]:\\n                        reduced_cost = cost[job][worker]-job_pot[job]-worker_pot[worker]\\n                        if reduced_cost < min_reduced_cost[worker]:\\n                            min_reduced_cost[worker] = reduced_cost\\n                            prev[worker] = curr_worker\\n                        if reduced_cost < delta:\\n                            delta = reduced_cost\\n\\n            curr_workers.clear()\\n            for worker in range(n+1):\\n                if in_Z[worker]:\\n                    job_pot[worker2job[worker]] += delta\\n                    worker_pot[worker] -= delta\\n                else:\\n                    min_reduced_cost[worker] -= delta\\n                    if min_reduced_cost[worker] == 0:\\n                        curr_workers.append(worker)\\n        # print(f\"{curr_workers=},\\\\n{worker2job=},\\\\n{prev=},\\\\n{in_Z=},\\\\n{min_reduced_cost=},\\\\n{delta=}\")\\n        curr_workers = [worker for worker in curr_workers if worker2job[worker] == -1]\\n        # print(f\"filtered {curr_workers=}\")\\n        curr_worker = curr_workers[0]\\n\\n        while curr_worker != -1:\\n            worker2job[curr_worker] = worker2job[prev[curr_worker]]\\n            curr_worker = prev[curr_worker]\\n    return [(worker2job[i], i) for i in range(n) if worker2job[i] != -1]\\n    \\n\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        cost = [[-((1+(i%numSlots)) & num) for i in range(2*numSlots)] for num in nums]\\n        matching = min_matching(cost)\\n        return sum(-cost[i][j] for i, j in matching)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054977,
                "title": "time-efficient-runtime-11-ms-beats-98-68-base-2-dp-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(numSlots*2^(2*numSlots))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^(2*numSlots))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint dp[(1<<18)];\\n    int n;\\n    int numbers(vector<int>& nums, int numSlots, int index, int mask){\\n        if(index>=n) return 0;\\n        if(dp[mask]!=-1) return dp[mask];               \\n        int ans = INT_MIN;\\n        for(int i = 0; i<numSlots; i++) {\\n            int z = 2*i;\\n                if(!(mask&(1<<z))) ans = max(ans,((i+1)&nums[index])+numbers(nums,numSlots,index+1,(mask|(1<<z))));\\n                else {\\n                    z++;\\n                    if(!(mask&(1<<z))) ans = max(ans,((i+1)&nums[index])+numbers(nums,numSlots,index+1,(mask|(1<<z))));\\n                }\\n        }\\n        return dp[mask] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return numbers(nums,numSlots,0,0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint dp[(1<<18)];\\n    int n;\\n    int numbers(vector<int>& nums, int numSlots, int index, int mask){\\n        if(index>=n) return 0;\\n        if(dp[mask]!=-1) return dp[mask];               \\n        int ans = INT_MIN;\\n        for(int i = 0; i<numSlots; i++) {\\n            int z = 2*i;\\n                if(!(mask&(1<<z))) ans = max(ans,((i+1)&nums[index])+numbers(nums,numSlots,index+1,(mask|(1<<z))));\\n                else {\\n                    z++;\\n                    if(!(mask&(1<<z))) ans = max(ans,((i+1)&nums[index])+numbers(nums,numSlots,index+1,(mask|(1<<z))));\\n                }\\n        }\\n        return dp[mask] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return numbers(nums,numSlots,0,0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051806,
                "title": "recursion-memoized-ternary-digit-dp-efficient-time-and-space-optimized-c-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExplanation in Code Below \\n\\n# Complexity\\n- Time complexity: O(3^numSlots*numSlots)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(3^numSlots)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/* \\nTIME OPTIMIZED and SPACE OPTIMIZED --> This Time independent of index;\\n3-BASED NUMBER SYSTEM\\nCOMPLETE GREEDY + RECURSION + MEMOIZATION + BITMASKING(ternary digit) + BASE-3 NUMBER SYSTEM\\nTC: O(3^numSlots*numSlots)\\nSC: O(3^numSlots)\\n*/\\n    int dp[20000];\\n    int h[13];\\n    int n;\\n    int Maximum(vector<int>& nums, int index, int mask, int numSlots){\\n        if(index>=n) return 0;\\n        if(dp[mask]!=-1) return dp[mask];\\n\\n        int maxi = INT_MIN;\\n        for(int i = 0; i<numSlots; i++){  \\n        int a_i = floor((mask%h[i+1])/h[i]);   // give me the value present at the i\\'th bit position  or it is the status of (i+1)th slot \\n        /* \\n        i = 0th bit position i.e. 1st Slot\\n        i = 1st bit position i.e. 2nd Slot\\n        */\\n        /*\\n        for example: mask = (26)10 = (222)3 \\n        give me what is present at the 2nd bit position i.e. 3rd Slot ka kya status hain (0 or 1 or 2)\\n        So, 1) humlog ek bit aage se modulo nikalenge i.e. mask ko pow(3,i+1) se modula nikalenge\\n        2) ab hamare pas ith bit to 0th bit tak ka value present, so upar se obtained modulo ko pow(3,i) se divide karo that will give frontmost value of modulo which we want.\\n        \\n        = 2*3^2+2*3^1+2*3^0\\n        \\n        I want status at 1st bit position which is = 2\\n        How i will get ?\\n        = (2*3^2+2*3^1+2*3^0)%3^(1+1)\\n        = 2*3^1+2*3^0\\n\\n        Now Divide by 3^1.\\n        (2*3^1+2*3^0)/3^1 = 2 \\n        baki ka to remainder hain(2*3^0)\\n        */\\n\\n        /* \\n        AND How to Change Status \\n        jaise 0-->1-->2 kaise change kare \\n        So catch is jis bit position(i) pe change kar rahe ho usme utne power of 3 se addition kardo\\n        to uss bit position pe 1 increment ho jayega\\n\\n        For Example: (111)3 \\n        I Want ot change 1st bit position from 1 to 2\\n        (111)3 = (1*3^2+1*3^1+1*3^0)\\n\\n        (1*3^2+1*3^1+1*3^0)+3^1 = (1*3^2+2*3^1+1*3^0) = (121)3\\n        */\\n        if(a_i<=1) maxi = max(maxi,(nums[index]&(i+1))+Maximum(nums,index+1,mask+h[i],numSlots));  // changes done here\\n        }\\n        return dp[mask] = maxi;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        h[0]=1;\\n        for(int i = 1; i<=12; i++) h[i]=h[i-1]*3;   // changes done here\\n        return Maximum(nums,0,0,numSlots);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/* \\nTIME OPTIMIZED and SPACE OPTIMIZED --> This Time independent of index;\\n3-BASED NUMBER SYSTEM\\nCOMPLETE GREEDY + RECURSION + MEMOIZATION + BITMASKING(ternary digit) + BASE-3 NUMBER SYSTEM\\nTC: O(3^numSlots*numSlots)\\nSC: O(3^numSlots)\\n*/\\n    int dp[20000];\\n    int h[13];\\n    int n;\\n    int Maximum(vector<int>& nums, int index, int mask, int numSlots){\\n        if(index>=n) return 0;\\n        if(dp[mask]!=-1) return dp[mask];\\n\\n        int maxi = INT_MIN;\\n        for(int i = 0; i<numSlots; i++){  \\n        int a_i = floor((mask%h[i+1])/h[i]);   // give me the value present at the i\\'th bit position  or it is the status of (i+1)th slot \\n        /* \\n        i = 0th bit position i.e. 1st Slot\\n        i = 1st bit position i.e. 2nd Slot\\n        */\\n        /*\\n        for example: mask = (26)10 = (222)3 \\n        give me what is present at the 2nd bit position i.e. 3rd Slot ka kya status hain (0 or 1 or 2)\\n        So, 1) humlog ek bit aage se modulo nikalenge i.e. mask ko pow(3,i+1) se modula nikalenge\\n        2) ab hamare pas ith bit to 0th bit tak ka value present, so upar se obtained modulo ko pow(3,i) se divide karo that will give frontmost value of modulo which we want.\\n        \\n        = 2*3^2+2*3^1+2*3^0\\n        \\n        I want status at 1st bit position which is = 2\\n        How i will get ?\\n        = (2*3^2+2*3^1+2*3^0)%3^(1+1)\\n        = 2*3^1+2*3^0\\n\\n        Now Divide by 3^1.\\n        (2*3^1+2*3^0)/3^1 = 2 \\n        baki ka to remainder hain(2*3^0)\\n        */\\n\\n        /* \\n        AND How to Change Status \\n        jaise 0-->1-->2 kaise change kare \\n        So catch is jis bit position(i) pe change kar rahe ho usme utne power of 3 se addition kardo\\n        to uss bit position pe 1 increment ho jayega\\n\\n        For Example: (111)3 \\n        I Want ot change 1st bit position from 1 to 2\\n        (111)3 = (1*3^2+1*3^1+1*3^0)\\n\\n        (1*3^2+1*3^1+1*3^0)+3^1 = (1*3^2+2*3^1+1*3^0) = (121)3\\n        */\\n        if(a_i<=1) maxi = max(maxi,(nums[index]&(i+1))+Maximum(nums,index+1,mask+h[i],numSlots));  // changes done here\\n        }\\n        return dp[mask] = maxi;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        h[0]=1;\\n        for(int i = 1; i<=12; i++) h[i]=h[i-1]*3;   // changes done here\\n        return Maximum(nums,0,0,numSlots);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048295,
                "title": "simple-recursion-memoization-no-bitmasking-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimilar Problem: https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/description/\\n\\n# Complexity\\n- Time complexity: O(n*3^numSlots*numSlots)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(3^numSlots*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/* Same Starting Approach without Bitmask as done in Minimum XOR Sum of Two Arrays\\n--> use map<vector<int>,int>\\n--> use vis array\\nCOMPLETE GREEDY + RECURSION + MEMOIZATION + NO BITMASKING\\nTC: O(n*3^numSlots*numSlots)\\nSC: O(3^numSlots*n)\\n*/\\n    vector<int> vis;\\n    map<vector<int>,int> mp;\\n    int n;\\n    int Maximum(vector<int>& nums, int index, int numSlots){\\n        if(index>=n) return 0;\\n\\n        if(mp.find(vis)!=mp.end()) return mp[vis];\\n\\n\\n        int maxi = INT_MIN;\\n        for(int i = 1; i<= numSlots; i++){\\n        if(vis[i]<2){\\n                vis[i]++;\\n                maxi = max(maxi,(nums[index]&i)+Maximum(nums,index+1,numSlots));\\n                vis[i]--;\\n        }\\n        }\\n\\n        return mp[vis] = maxi;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = nums.size();\\n        vis.resize(numSlots+1,0);\\n        mp.clear();\\n        return Maximum(nums,0,numSlots);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/* Same Starting Approach without Bitmask as done in Minimum XOR Sum of Two Arrays\\n--> use map<vector<int>,int>\\n--> use vis array\\nCOMPLETE GREEDY + RECURSION + MEMOIZATION + NO BITMASKING\\nTC: O(n*3^numSlots*numSlots)\\nSC: O(3^numSlots*n)\\n*/\\n    vector<int> vis;\\n    map<vector<int>,int> mp;\\n    int n;\\n    int Maximum(vector<int>& nums, int index, int numSlots){\\n        if(index>=n) return 0;\\n\\n        if(mp.find(vis)!=mp.end()) return mp[vis];\\n\\n\\n        int maxi = INT_MIN;\\n        for(int i = 1; i<= numSlots; i++){\\n        if(vis[i]<2){\\n                vis[i]++;\\n                maxi = max(maxi,(nums[index]&i)+Maximum(nums,index+1,numSlots));\\n                vis[i]--;\\n        }\\n        }\\n\\n        return mp[vis] = maxi;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = nums.size();\\n        vis.resize(numSlots+1,0);\\n        mp.clear();\\n        return Maximum(nums,0,numSlots);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034959,
                "title": "c-python-bitmask-dp-solution-with-explanation",
                "content": "### bitmask dp\\n\\nbeacuse each slot contains at most two numbers, so we can assign two buckets to each slot,\\nand each bucket contains at most one number.\\nAnd we can use a bitmask to indicate which bucket has a number or not, a bit of 1 means bucket has a number.\\n\\nAnd for each 1 bit in mask, and cnt is number of 1 bits in mask,\\nif cnt > size of nums, the mask is invalid, total numbers are not enough.\\nwe try to match cnt-th number in nums with each 1 bit. the slot id is j/2+1 where j is indexof bit (0-based).\\n\\ndp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + ((j / 2 + 1) & nums[cnt-1]) ).\\n![image](https://assets.leetcode.com/users/images/294b77dd-14d5-443d-b350-9c291fb49ce3_1694512193.0261786.png)\\n\\ntc is ((2 * numSlots) * 2^(2 * numSlots)), sc is O(2^(2 * numSlots)).\\n### python\\n```python\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        dp = [0] * (1 << (2 * numSlots))\\n        for mask in range(1, 1 << (2 * numSlots)):\\n            cnt = mask.bit_count()\\n            if cnt > len(nums): continue\\n            for j in range(2 * numSlots):\\n                if mask >> j & 1:\\n                    dp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + ((j // 2 + 1) & nums[cnt - 1]))\\n        return max(dp)\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        vector<int> dp (1 << (2 * numSlots));\\n        for (int mask = 1, cnt; mask < 1 << (2 * numSlots); mask += 1) {\\n            cnt = __builtin_popcount(mask);\\n            if (cnt > nums.size()) continue;\\n            for (int j = 0; j < 2 * numSlots; j+=1) {\\n                if (mask >> j & 1)\\n                    dp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + ((j / 2 + 1) & nums[cnt-1]));\\n            }\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        dp = [0] * (1 << (2 * numSlots))\\n        for mask in range(1, 1 << (2 * numSlots)):\\n            cnt = mask.bit_count()\\n            if cnt > len(nums): continue\\n            for j in range(2 * numSlots):\\n                if mask >> j & 1:\\n                    dp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + ((j // 2 + 1) & nums[cnt - 1]))\\n        return max(dp)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        vector<int> dp (1 << (2 * numSlots));\\n        for (int mask = 1, cnt; mask < 1 << (2 * numSlots); mask += 1) {\\n            cnt = __builtin_popcount(mask);\\n            if (cnt > nums.size()) continue;\\n            for (int j = 0; j < 2 * numSlots; j+=1) {\\n                if (mask >> j & 1)\\n                    dp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + ((j / 2 + 1) & nums[cnt-1]));\\n            }\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010798,
                "title": "c-easy-with-two-bitmask-solution",
                "content": "# Intuition\\nAccording to given problem we have to allot slot for elements of array such that sum of all Bitwise AND between value of slot no. that is alloted to elemnent of array and value of that element is maxiumum.\\n\\none slot can be alloted to atmost two elements.\\n\\nNumslot : given no. of slots.\\n\\nSo, here basically for given element at index i have choices of get any slot between (1 to numSlot).but if any slot between (1 to numslot ) is already occupied by two previous elements then we can\\'t allot that slot to index i element.so for this we have to take care of which slot is occupied by two elements and we considered all possible ways and will find out the max ans possible out of those.\\n\\nWe will memoize this by dynamic programming.\\n\\n# Approach\\nTo store which slots is alloted to elments we can use mask.Maximum value of the mask will be pow(2,numslots-1)\\n\\nAssume number of slots is 5 and slot 1 is occupied by elements 2 of the array.\\n\\nthen our mask1  = 00001\\ni is 0 indexed\\nith bit from the last represents the (i+1) slot no.\\nso 1 slot is occupied because bit is on.\\n\\nBut in this we have to check one slots can be alloted for atmost two elments that\\'s why we are taking the second bitmask.\\n\\nif our mask2 = 00001\\nIts indicate that 1 slot is alloted to two elements\\n\\nif both bit are set of mask for particular slot then we can\\'t allot that slot to given ind and we will check for next slot in this way we can check which slot can\\'t be choice for the given elmennt\\n\\nNow , the state of dp \\ndp[i][mask1][mask2] = It give store ans till index i to \\nn-1 having these slots allotment.\\n\\nNow, base case will be if our index is equal to size of string then our answer will be 0.\\n\\ninitially maxx = 0\\n\\nfor an indices i we have choice from slot (1 to numslots) , but some restrictions we will check for restrictions i slots is fully occupied or not\\n\\nfor the ith slot we will extract the (i-1)th bit trom last in mask1 and same for mask2\\n\\nif bit in mask1 is off then we can choose that slot \\nwe will take max of all possible combinations\\nif we allot i slots to current index that ans will be \\nnums[ind]*i+check for (ind+1,n-1) with thesse slots allotments what wil be the max ans.\\n\\nif its already solved then ans will be stored in our dp.\\n\\notherwise checki for mask2 bit if this is off then we can allot that slot, otherwise we can\\'t allot that slots to elements.\\n\\nafter checking all possible ways ans for (ind to n-1) we have our max ans \\n\\nwe will store in our dp with the slots alotments in mask1 and mask2\\n\\n# Complexity\\n- Time complexity:\\nO(nums.size)*O((1<<numslots))*O((1<<numslots))\\n15x512x512  = 3*10^6\\n\\n- Space complexity:3D dp: O(nums.size)*O((1<<numslots))*O((1<<numslots))\\n15x512x512  = 3*10^6\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,int>mp;\\n    int ans = INT_MAX;\\n    int solve(vector<int>&nums, int n , vector<vector<vector<int>>>&dp,int mask1 , int mask2,int ind)\\n    {\\n        if(ind==nums.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[ind][mask1][mask2]!=-1)\\n        {\\n            return dp[ind][mask1][mask2];\\n        }\\n        int maxx = 0;\\n        for(int i = 1 ; i<=n ; i++)\\n        {\\n            int v1 = mask1&(1<<(i-1));\\n            int v2 = mask2&(1<<(i-1));\\n            \\n            if(v1==0)\\n            {\\n                maxx = max(maxx,(nums[ind] & (i))+\\n                solve (nums,n,dp,mask1|(1<<(i-1)),\\n                mask2,ind+1));\\n            }\\n            else if(v2==0)\\n            {\\n                maxx = max(maxx,(nums[ind] & (i))+\\n                solve(nums,n,dp,mask1,\\n                mask2|(1<<(i-1)),ind+1));\\n            }\\n        }\\n        \\n        return dp[ind][mask1][mask2]=maxx;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n = nums.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(1<<numSlots,vector<int>(1<<numSlots,-1)));\\n        return solve(nums,numSlots,dp,0,0,0);\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int>mp;\\n    int ans = INT_MAX;\\n    int solve(vector<int>&nums, int n , vector<vector<vector<int>>>&dp,int mask1 , int mask2,int ind)\\n    {\\n        if(ind==nums.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[ind][mask1][mask2]!=-1)\\n        {\\n            return dp[ind][mask1][mask2];\\n        }\\n        int maxx = 0;\\n        for(int i = 1 ; i<=n ; i++)\\n        {\\n            int v1 = mask1&(1<<(i-1));\\n            int v2 = mask2&(1<<(i-1));\\n            \\n            if(v1==0)\\n            {\\n                maxx = max(maxx,(nums[ind] & (i))+\\n                solve (nums,n,dp,mask1|(1<<(i-1)),\\n                mask2,ind+1));\\n            }\\n            else if(v2==0)\\n            {\\n                maxx = max(maxx,(nums[ind] & (i))+\\n                solve(nums,n,dp,mask1,\\n                mask2|(1<<(i-1)),ind+1));\\n            }\\n        }\\n        \\n        return dp[ind][mask1][mask2]=maxx;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n = nums.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(1<<numSlots,vector<int>(1<<numSlots,-1)));\\n        return solve(nums,numSlots,dp,0,0,0);\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009431,
                "title": "bitmask-but-with-ternary-number-system-easy-peasy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n;\\n\\n    map<pair<vector<int>, int>,int> umap;\\n    \\n    int help(int i, vector<int> mask, vector<int> &nums){\\n        if(i==nums.size()){\\n            return 0;\\n        }\\n\\n        if(umap.find({mask,i})!=umap.end()){\\n            return umap[{mask,i}];\\n        }\\n\\n        int ans = 0;\\n\\n        for(int j=0;j<n;j++){\\n            if(mask[j]==2){\\n                continue;\\n            }\\n            vector<int> new_mask = mask;\\n            mask[j]++;\\n            ans = max(ans,((j+1) & nums[i]) + help(i+1,mask, nums));\\n            mask[j]--;\\n        }\\n\\n        return umap[{mask,i}] = ans;\\n    }\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = numSlots;\\n\\n        vector<int> mask(n,0);\\n\\n        return help(0, mask, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n;\\n\\n    map<pair<vector<int>, int>,int> umap;\\n    \\n    int help(int i, vector<int> mask, vector<int> &nums){\\n        if(i==nums.size()){\\n            return 0;\\n        }\\n\\n        if(umap.find({mask,i})!=umap.end()){\\n            return umap[{mask,i}];\\n        }\\n\\n        int ans = 0;\\n\\n        for(int j=0;j<n;j++){\\n            if(mask[j]==2){\\n                continue;\\n            }\\n            vector<int> new_mask = mask;\\n            mask[j]++;\\n            ans = max(ans,((j+1) & nums[i]) + help(i+1,mask, nums));\\n            mask[j]--;\\n        }\\n\\n        return umap[{mask,i}] = ans;\\n    }\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = numSlots;\\n\\n        vector<int> mask(n,0);\\n\\n        return help(0, mask, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986885,
                "title": "rust-top-down-dp",
                "content": "# Code\\n```rust\\n// A non-binary bitmask serde.\\nstruct EnbyState {\\n    n: usize,\\n    threshold: usize,\\n\\n    op_vec: Vec<usize>,\\n}\\n\\nimpl EnbyState {\\n    // Construct a `threshold`-layer bitmask serde with `n` bits.\\n    pub fn new(n: usize, threshold: usize) -> Self {\\n        let mut op_vec = Vec::with_capacity(n + 1);\\n        let mut op = 1usize;\\n        for _ in 0..=n {\\n            op_vec.push(op);\\n            op *= threshold;\\n        }\\n\\n        Self {\\n            n,\\n            threshold,\\n            op_vec,\\n        }\\n    }\\n\\n    // Get the `ptr`-th bit of the bitmask `token`.\\n    pub fn get(&self, mut token: usize, ptr: usize) -> usize {\\n        assert!(ptr < self.n, \"OOB\");\\n\\n        token /= self.op_vec[ptr];\\n        token %= self.threshold;\\n\\n        token\\n    }\\n\\n    // Set the `ptr`-th bit of the bitmask `token` to `state`.\\n    pub fn set(&self, mut token: usize, ptr: usize, state: usize) -> usize {\\n        assert!(ptr < self.n, \"OOB\");\\n        assert!(state < self.threshold, \"OOT\");\\n\\n        let t0 = token % self.op_vec[ptr];\\n\\n        token /= self.op_vec[ptr + 1];\\n        token *= self.threshold;\\n\\n        token += state;\\n\\n        token *= self.op_vec[ptr];\\n        token += t0;\\n\\n        token\\n    }\\n\\n    // Returns the upper bound for this bitmask configuration.\\n    pub fn upper(&self) -> usize {\\n        self.op_vec[self.n]\\n    }\\n}\\n\\npub struct DP {\\n    vec: Vec<u32>,\\n    n: usize, k_max: usize,\\n\\n    memo: Vec<Vec<Option<u32>>>,\\n    enby: EnbyState,\\n}\\n\\nimpl DP {\\n    pub fn new(vec: Vec<u32>, k_max: usize) -> Self {\\n        let n = vec.len();\\n\\n        let enby = EnbyState::new(k_max, 3);\\n        let memo = vec![vec![None; enby.upper()]; n + 1];\\n\\n        Self {\\n            vec,\\n            n, k_max,\\n            memo, enby,\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, token: usize) -> u32 {\\n        if i > self.n { return u32::MIN; }\\n        if token >= self.enby.upper() { return u32::MIN; }\\n\\n        if let Some(ret) = self.memo[i][token] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(i, token);\\n        // println!(\"k: {}, flag: {:#018b}, ret={:?}\", k, flag, ret);\\n        self.memo[i][token] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, token: usize) -> u32 {\\n        if i >= self.n { return u32::MIN; }\\n\\n        let e = self.vec[i];\\n        let i_next = i + 1;\\n\\n        let mut ret = u32::MIN;\\n        for k in 0..self.k_max {\\n            let state = self.enby.get(token, k);\\n            if state >= 2 {\\n                continue; // box is full\\n            }\\n\\n            let token_next = self.enby.set(token, k, state + 1);\\n            let mut _ret = self.solve(i_next, token_next);\\n            _ret += (e & (k as u32 + 1));\\n\\n            ret = ret.max(_ret);\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn maximum_and_sum(vec: Vec<i32>, k_max: i32) -> i32 {\\n        let k_max = k_max as usize;\\n        let mut vec = vec.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n        \\n        let mut dp = DP::new(vec, k_max);\\n        dp.solve(usize::MIN, usize::MIN) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```rust\\n// A non-binary bitmask serde.\\nstruct EnbyState {\\n    n: usize,\\n    threshold: usize,\\n\\n    op_vec: Vec<usize>,\\n}\\n\\nimpl EnbyState {\\n    // Construct a `threshold`-layer bitmask serde with `n` bits.\\n    pub fn new(n: usize, threshold: usize) -> Self {\\n        let mut op_vec = Vec::with_capacity(n + 1);\\n        let mut op = 1usize;\\n        for _ in 0..=n {\\n            op_vec.push(op);\\n            op *= threshold;\\n        }\\n\\n        Self {\\n            n,\\n            threshold,\\n            op_vec,\\n        }\\n    }\\n\\n    // Get the `ptr`-th bit of the bitmask `token`.\\n    pub fn get(&self, mut token: usize, ptr: usize) -> usize {\\n        assert!(ptr < self.n, \"OOB\");\\n\\n        token /= self.op_vec[ptr];\\n        token %= self.threshold;\\n\\n        token\\n    }\\n\\n    // Set the `ptr`-th bit of the bitmask `token` to `state`.\\n    pub fn set(&self, mut token: usize, ptr: usize, state: usize) -> usize {\\n        assert!(ptr < self.n, \"OOB\");\\n        assert!(state < self.threshold, \"OOT\");\\n\\n        let t0 = token % self.op_vec[ptr];\\n\\n        token /= self.op_vec[ptr + 1];\\n        token *= self.threshold;\\n\\n        token += state;\\n\\n        token *= self.op_vec[ptr];\\n        token += t0;\\n\\n        token\\n    }\\n\\n    // Returns the upper bound for this bitmask configuration.\\n    pub fn upper(&self) -> usize {\\n        self.op_vec[self.n]\\n    }\\n}\\n\\npub struct DP {\\n    vec: Vec<u32>,\\n    n: usize, k_max: usize,\\n\\n    memo: Vec<Vec<Option<u32>>>,\\n    enby: EnbyState,\\n}\\n\\nimpl DP {\\n    pub fn new(vec: Vec<u32>, k_max: usize) -> Self {\\n        let n = vec.len();\\n\\n        let enby = EnbyState::new(k_max, 3);\\n        let memo = vec![vec![None; enby.upper()]; n + 1];\\n\\n        Self {\\n            vec,\\n            n, k_max,\\n            memo, enby,\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, token: usize) -> u32 {\\n        if i > self.n { return u32::MIN; }\\n        if token >= self.enby.upper() { return u32::MIN; }\\n\\n        if let Some(ret) = self.memo[i][token] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(i, token);\\n        // println!(\"k: {}, flag: {:#018b}, ret={:?}\", k, flag, ret);\\n        self.memo[i][token] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, token: usize) -> u32 {\\n        if i >= self.n { return u32::MIN; }\\n\\n        let e = self.vec[i];\\n        let i_next = i + 1;\\n\\n        let mut ret = u32::MIN;\\n        for k in 0..self.k_max {\\n            let state = self.enby.get(token, k);\\n            if state >= 2 {\\n                continue; // box is full\\n            }\\n\\n            let token_next = self.enby.set(token, k, state + 1);\\n            let mut _ret = self.solve(i_next, token_next);\\n            _ret += (e & (k as u32 + 1));\\n\\n            ret = ret.max(_ret);\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn maximum_and_sum(vec: Vec<i32>, k_max: i32) -> i32 {\\n        let k_max = k_max as usize;\\n        let mut vec = vec.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n        \\n        let mut dp = DP::new(vec, k_max);\\n        dp.solve(usize::MIN, usize::MIN) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944484,
                "title": "python-base-2-bitmask-bottom-up-dp",
                "content": "# Explanation\\n00 means there is no integer in this slot;\\n01 means there is 1 integer in this slot;\\n10 means there is 2 integers in this slot.\\n\\nFor example:\\nnumSlots = 3\\nbitmask = 100100\\n  10      01      00\\nslot3   slot2   slot1\\n\\nIt means:\\nslot1 has no integer\\nslot2 has 1 integer\\nslot3 has 2 integers\\n\\nIf we want to check whether a slot is already full, \\nwe can simply check: if (mask >> 1) & 1\\ni.e. if this bit (**1**0) is 1 or not.\\n\\n# Time complexity\\nAlthough we used base-2 bitmask, \\nit is still O(len(nums) * 3 ^ (numSlots))\\nnot O(len(nums) * 4 ^ (numSlots))\\nbecause we will never see \"11\" during this process.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        dp = defaultdict(int)\\n        dp[0] = 0\\n        for num in nums:\\n            temp = defaultdict(int)\\n            for mask in dp.keys():\\n                for i in range(numSlots):\\n                    p1, p2 = 2 * i, 2 * i + 1\\n                    if (mask >> p2) & 1:\\n                        continue\\n                    next_mask = mask + (1 << p1)\\n                    temp[next_mask] = max(temp[next_mask], dp[mask] + (num & (i + 1)))\\n            dp = temp\\n        return max(dp.values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        dp = defaultdict(int)\\n        dp[0] = 0\\n        for num in nums:\\n            temp = defaultdict(int)\\n            for mask in dp.keys():\\n                for i in range(numSlots):\\n                    p1, p2 = 2 * i, 2 * i + 1\\n                    if (mask >> p2) & 1:\\n                        continue\\n                    next_mask = mask + (1 << p1)\\n                    temp[next_mask] = max(temp[next_mask], dp[mask] + (num & (i + 1)))\\n            dp = temp\\n        return max(dp.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927458,
                "title": "ternary-masking-dp-new-version-of-bit-masking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int k, n;\\n    int pow3[12];\\n    int dp[20][60000];\\n    int solve(int i, int mask, vector<int>& v){\\n        if(i == n){\\n            return 0;\\n        }\\n        if(dp[i][mask] != -1) return dp[i][mask];\\n        int ans = 0;\\n        for(int j=1;j<=k;j++){\\n            int cnt = (mask % pow3[j+1]) / pow3[j];\\n            if(cnt <= 1){\\n                ans = max(ans, (v[i]&j) + solve(i+1, (mask + pow3[j]), v));\\n            }\\n        }\\n        return dp[i][mask] = ans;\\n    }\\n    int maximumANDSum(vector<int>& v, int slot) {\\n        n = v.size(), k = slot;\\n        pow3[0] = 1;\\n        for(int i=1;i<12;i++){\\n            pow3[i] = (pow3[i-1] * 3);\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k, n;\\n    int pow3[12];\\n    int dp[20][60000];\\n    int solve(int i, int mask, vector<int>& v){\\n        if(i == n){\\n            return 0;\\n        }\\n        if(dp[i][mask] != -1) return dp[i][mask];\\n        int ans = 0;\\n        for(int j=1;j<=k;j++){\\n            int cnt = (mask % pow3[j+1]) / pow3[j];\\n            if(cnt <= 1){\\n                ans = max(ans, (v[i]&j) + solve(i+1, (mask + pow3[j]), v));\\n            }\\n        }\\n        return dp[i][mask] = ans;\\n    }\\n    int maximumANDSum(vector<int>& v, int slot) {\\n        n = v.size(), k = slot;\\n        pow3[0] = 1;\\n        for(int i=1;i<12;i++){\\n            pow3[i] = (pow3[i-1] * 3);\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752080,
                "title": "don-t-complicate-it-simple-bitmask-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[18][1024][1024];\\n    int f(int i,vector<int> &coins,int s,int mask1,int mask2){\\n        if(i < 0) return 0;\\n        int maxSum = 0;\\n        if(dp[i][mask1][mask2] != -1) return dp[i][mask1][mask2];\\n        for(int slot=1;slot<=s;slot++){\\n            if((mask1&(1<<slot)) == 0){\\n                mask1 = mask1 ^ (1 << slot);\\n                int currSum = (slot & coins[i]) + f(i-1,coins,s,mask1,mask2);\\n                maxSum = max(maxSum,currSum);\\n                mask1 = mask1 ^ (1 << slot);\\n            }\\n            else if((mask2&(1<<slot)) == 0){\\n                mask2 = mask2 ^ (1 << slot);\\n                int currSum = (slot & coins[i]) + f(i-1,coins,s,mask1,mask2);\\n                maxSum = max(maxSum,currSum);\\n                mask2 = mask2 ^ (1 << slot);\\n            }\\n        }\\n        return dp[i][mask1][mask2] = maxSum;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memset(dp,-1,sizeof dp);\\n        int n = nums.size();\\n        int mask1 = 0 , mask2 = 0;\\n        return f(n-1,nums,numSlots,mask1,mask2);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[18][1024][1024];\\n    int f(int i,vector<int> &coins,int s,int mask1,int mask2){\\n        if(i < 0) return 0;\\n        int maxSum = 0;\\n        if(dp[i][mask1][mask2] != -1) return dp[i][mask1][mask2];\\n        for(int slot=1;slot<=s;slot++){\\n            if((mask1&(1<<slot)) == 0){\\n                mask1 = mask1 ^ (1 << slot);\\n                int currSum = (slot & coins[i]) + f(i-1,coins,s,mask1,mask2);\\n                maxSum = max(maxSum,currSum);\\n                mask1 = mask1 ^ (1 << slot);\\n            }\\n            else if((mask2&(1<<slot)) == 0){\\n                mask2 = mask2 ^ (1 << slot);\\n                int currSum = (slot & coins[i]) + f(i-1,coins,s,mask1,mask2);\\n                maxSum = max(maxSum,currSum);\\n                mask2 = mask2 ^ (1 << slot);\\n            }\\n        }\\n        return dp[i][mask1][mask2] = maxSum;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memset(dp,-1,sizeof dp);\\n        int n = nums.size();\\n        int mask1 = 0 , mask2 = 0;\\n        return f(n-1,nums,numSlots,mask1,mask2);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735684,
                "title": "backtracking-simple-easy-solution",
                "content": "# CODE\\n```\\nclass Solution {\\npublic:\\n    \\n    map<pair<int,vector<int>>, int >m;\\n     \\n    int f(vector<int>& nums, int idx, vector<int>& slot) {\\n\\n        if(idx >= nums.size()) return 0;\\n\\n        int ans = 0;\\n\\n        if(m.find({idx, slot}) != m.end()) return m[{idx, slot}];\\n\\n        for(int i = 0; i < slot.size(); i++) {\\n            if(slot[i] < 2) {\\n                slot[i]++;\\n                ans = max(ans, (nums[idx]&(i + 1)) + f(nums, idx + 1, slot));\\n                slot[i]--;\\n            }\\n        }\\n\\n\\n        return m[{idx, slot}] = ans;\\n\\n    }\\n\\n \\n\\n\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        vector<int>slot;\\n        \\n        for(int i = 0; i < numSlots; i++) slot.push_back(0);\\n\\n        return f(nums, 0, slot);\\n\\n    }\\n};\\n\\nT.C - > O(n*numSlots*(numSlots)!) \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    map<pair<int,vector<int>>, int >m;\\n     \\n    int f(vector<int>& nums, int idx, vector<int>& slot) {\\n\\n        if(idx >= nums.size()) return 0;\\n\\n        int ans = 0;\\n\\n        if(m.find({idx, slot}) != m.end()) return m[{idx, slot}];\\n\\n        for(int i = 0; i < slot.size(); i++) {\\n            if(slot[i] < 2) {\\n                slot[i]++;\\n                ans = max(ans, (nums[idx]&(i + 1)) + f(nums, idx + 1, slot));\\n                slot[i]--;\\n            }\\n        }\\n\\n\\n        return m[{idx, slot}] = ans;\\n\\n    }\\n\\n \\n\\n\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        vector<int>slot;\\n        \\n        for(int i = 0; i < numSlots; i++) slot.push_back(0);\\n\\n        return f(nums, 0, slot);\\n\\n    }\\n};\\n\\nT.C - > O(n*numSlots*(numSlots)!) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735006,
                "title": "string-masking",
                "content": "\\n# Approach\\nUsed Srings as mask instead of using a integers as a mask\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp(vector<int>& arr, int n, int i, string mask, int k, unordered_map<string, unordered_map<int,int>>& mp) {\\n        if(i == n) return 0;\\n\\n        if(mp.find(mask)!=mp.end() && mp[mask].find(i) != mp[mask].end()) return mp[mask][i];\\n\\n        int ans = 0;\\n        for(int j = 1 ; j<=k ; j++) {\\n            if(mask[j] == \\'2\\') continue;\\n\\n            if(mask[j] == \\'0\\') {\\n                mask[j] = \\'1\\';\\n                int val = (arr[i]&j) + dp(arr, n, i+1, mask, k, mp);\\n                ans = max(ans, val);\\n                mask[j] = \\'0\\';\\n            } else if(mask[j] == \\'1\\'){\\n                mask[j] = \\'2\\';\\n                int val = (arr[i]&j) + dp(arr, n, i+1, mask, k, mp);\\n                ans = max(ans, val);\\n                mask[j] = \\'1\\';\\n            }\\n        }\\n\\n        return mp[mask][i] = ans;\\n    }\\n\\n    int maximumANDSum(vector<int>& arr, int k) {\\n        string mask = \"\";\\n        for(int i = 0 ; i<=k ; i++) {\\n            mask = mask + \"0\";\\n        }\\n\\n        unordered_map<string, unordered_map<int,int>> mp;\\n        return dp(arr, arr.size(), 0, mask, k, mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(vector<int>& arr, int n, int i, string mask, int k, unordered_map<string, unordered_map<int,int>>& mp) {\\n        if(i == n) return 0;\\n\\n        if(mp.find(mask)!=mp.end() && mp[mask].find(i) != mp[mask].end()) return mp[mask][i];\\n\\n        int ans = 0;\\n        for(int j = 1 ; j<=k ; j++) {\\n            if(mask[j] == \\'2\\') continue;\\n\\n            if(mask[j] == \\'0\\') {\\n                mask[j] = \\'1\\';\\n                int val = (arr[i]&j) + dp(arr, n, i+1, mask, k, mp);\\n                ans = max(ans, val);\\n                mask[j] = \\'0\\';\\n            } else if(mask[j] == \\'1\\'){\\n                mask[j] = \\'2\\';\\n                int val = (arr[i]&j) + dp(arr, n, i+1, mask, k, mp);\\n                ans = max(ans, val);\\n                mask[j] = \\'1\\';\\n            }\\n        }\\n\\n        return mp[mask][i] = ans;\\n    }\\n\\n    int maximumANDSum(vector<int>& arr, int k) {\\n        string mask = \"\";\\n        for(int i = 0 ; i<=k ; i++) {\\n            mask = mask + \"0\";\\n        }\\n\\n        unordered_map<string, unordered_map<int,int>> mp;\\n        return dp(arr, arr.size(), 0, mask, k, mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695833,
                "title": "java-bitmask-base-3",
                "content": "# Code\\n```\\nclass Solution {\\n    int m;\\n\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        // states: i-th bit represents the status of i-th slots, 0 means no number, 1 means 1 number, 2 means 2 numbers\\n        // dp[i][s]: the maximum possible AND sum for the first i numbers, and the states of slots is s\\n        // The number is the items, we can take them one by one.\\n        int n = nums.length;\\n        this.m = numSlots;\\n        int nState = (int) Math.pow(3, numSlots);\\n        int[][] dp = new int[n + 1][nState];\\n        Arrays.fill(dp[0], -1);\\n        dp[0][0] = 0;\\n        for (int state = 0; state < nState; state++) {\\n            // we can get the current number according to state\\n            int i = 0;\\n            int temp = state;\\n            while (temp > 0) {\\n                i += temp % 3;\\n                temp /= 3;\\n            }\\n            // it is possible that numSlots * 2 > nums.length\\n            if (i > n) continue;\\n            for (int slot_index = 0; slot_index < numSlots; slot_index++) {\\n                if (!isValidSubset(state, slot_index)) continue;\\n                int subset = (int) Math.pow(3, slot_index);\\n                if (dp[i - 1][state - subset] == -1) continue;\\n                dp[i][state] = Math.max(dp[i][state], dp[i - 1][state - subset] + (nums[i - 1] & (slot_index + 1)));\\n            }\\n        }\\n        int res = -1;\\n        for (int i = 0; i < nState; i++) {\\n            res = Math.max(res, dp[n][i]);\\n        }\\n        return res;\\n    }\\n\\n    private boolean isValidSubset(int state, int index) {\\n        for (int i = 0; i < m; i++) {\\n            if (i == index) {\\n                if (state % 3 != 0) return true;\\n                break;\\n            }\\n            state /= 3;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        // states: i-th bit represents the status of i-th slots, 0 means no number, 1 means 1 number, 2 means 2 numbers\\n        // dp[i][s]: the maximum possible AND sum for the first i numbers, and the states of slots is s\\n        // The number is the items, we can take them one by one.\\n        int n = nums.length;\\n        this.m = numSlots;\\n        int nState = (int) Math.pow(3, numSlots);\\n        int[][] dp = new int[n + 1][nState];\\n        Arrays.fill(dp[0], -1);\\n        dp[0][0] = 0;\\n        for (int state = 0; state < nState; state++) {\\n            // we can get the current number according to state\\n            int i = 0;\\n            int temp = state;\\n            while (temp > 0) {\\n                i += temp % 3;\\n                temp /= 3;\\n            }\\n            // it is possible that numSlots * 2 > nums.length\\n            if (i > n) continue;\\n            for (int slot_index = 0; slot_index < numSlots; slot_index++) {\\n                if (!isValidSubset(state, slot_index)) continue;\\n                int subset = (int) Math.pow(3, slot_index);\\n                if (dp[i - 1][state - subset] == -1) continue;\\n                dp[i][state] = Math.max(dp[i][state], dp[i - 1][state - subset] + (nums[i - 1] & (slot_index + 1)));\\n            }\\n        }\\n        int res = -1;\\n        for (int i = 0; i < nState; i++) {\\n            res = Math.max(res, dp[n][i]);\\n        }\\n        return res;\\n    }\\n\\n    private boolean isValidSubset(int state, int index) {\\n        for (int i = 0; i < m; i++) {\\n            if (i == index) {\\n                if (state % 3 != 0) return true;\\n                break;\\n            }\\n            state /= 3;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668814,
                "title": "keep-2-bitmasks-to-keep-track-of-used-positions",
                "content": "```\\nclass Solution:\\n    def maxsum(self, nums, i, n, fmask, smask, numSlots):\\n        if i >= n:\\n            return 0\\n        key = (i, fmask, smask)\\n        if key in self.cache:\\n            return self.cache[key]\\n        res = 0\\n        for j in range(numSlots):\\n            if not fmask & (1 << j) or not smask & (1 << j):\\n                currfmask = fmask\\n                currsmask = smask\\n                if not currfmask & (1 << j):\\n                    currfmask |= 1 << j\\n                elif not currsmask & (1 << j):\\n                    currsmask |= 1 << j\\n                res = max(res, ((j + 1) & nums[i]) + self.maxsum(nums, i + 1, n, currfmask, currsmask, numSlots))\\n        self.cache[key] = res\\n        return res\\n    \\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        self.cache = {}\\n        return self.maxsum(nums, 0, len(nums), 0, 0, numSlots)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxsum(self, nums, i, n, fmask, smask, numSlots):\\n        if i >= n:\\n            return 0\\n        key = (i, fmask, smask)\\n        if key in self.cache:\\n            return self.cache[key]\\n        res = 0\\n        for j in range(numSlots):\\n            if not fmask & (1 << j) or not smask & (1 << j):\\n                currfmask = fmask\\n                currsmask = smask\\n                if not currfmask & (1 << j):\\n                    currfmask |= 1 << j\\n                elif not currsmask & (1 << j):\\n                    currsmask |= 1 << j\\n                res = max(res, ((j + 1) & nums[i]) + self.maxsum(nums, i + 1, n, currfmask, currsmask, numSlots))\\n        self.cache[key] = res\\n        return res\\n    \\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        self.cache = {}\\n        return self.maxsum(nums, 0, len(nums), 0, 0, numSlots)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477602,
                "title": "python-topdown-o-4-n-n-s-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nCan reduce to n * 3**n\\nby using base3 number but I\\'m lazy to implement\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(index, visited1, visited2):\\n            if index == len(nums):\\n                return 0\\n\\n            ans = 0\\n            for i in range(numSlots):\\n                # select first one\\n                if (visited1 >> i) & 1 != 1:\\n                    new_visited1 = visited1 | (1 << i)\\n                    offset = nums[index] & (i + 1)\\n                    ans = max(ans, offset + dp(index + 1, new_visited1, visited2))\\n\\n                # select second one\\n                if (visited2 >> i) & 1 != 1:\\n                    new_visited2 = visited2 | (1 << i)\\n                    offset = nums[index] & (i + 1)\\n                    ans = max(ans, offset + dp(index + 1, visited1, new_visited2))\\n\\n            return ans\\n\\n        return dp(0, 0, 0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(index, visited1, visited2):\\n            if index == len(nums):\\n                return 0\\n\\n            ans = 0\\n            for i in range(numSlots):\\n                # select first one\\n                if (visited1 >> i) & 1 != 1:\\n                    new_visited1 = visited1 | (1 << i)\\n                    offset = nums[index] & (i + 1)\\n                    ans = max(ans, offset + dp(index + 1, new_visited1, visited2))\\n\\n                # select second one\\n                if (visited2 >> i) & 1 != 1:\\n                    new_visited2 = visited2 | (1 << i)\\n                    offset = nums[index] & (i + 1)\\n                    ans = max(ans, offset + dp(index + 1, visited1, new_visited2))\\n\\n            return ans\\n\\n        return dp(0, 0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443430,
                "title": "use-2-mask",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], slt: int) -> int:\\n        n=len(nums)\\n        dp=defaultdict(lambda :-1)\\n        def rec(id,m1,m2):\\n            if id==n:\\n                return 0\\n            if dp[(id,m1,m2)]!=-1:\\n                return dp[(id,m1,m2)]\\n            ans=-1\\n            for i in range(slt):\\n                \\n                if (m1>>i)&1:\\n                    if (m2>>i)&1==0:\\n                        ans=max(((i+1)&nums[id])+rec(id+1,m1,m2|(1<<i)),ans)\\n                else:\\n                    ans=max(ans,((i+1)&nums[id])+rec(id+1,m1|(1<<i),m2))\\n            dp[(id,m1,m2)]=ans\\n            return ans\\n        return rec(0,0,0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], slt: int) -> int:\\n        n=len(nums)\\n        dp=defaultdict(lambda :-1)\\n        def rec(id,m1,m2):\\n            if id==n:\\n                return 0\\n            if dp[(id,m1,m2)]!=-1:\\n                return dp[(id,m1,m2)]\\n            ans=-1\\n            for i in range(slt):\\n                \\n                if (m1>>i)&1:\\n                    if (m2>>i)&1==0:\\n                        ans=max(((i+1)&nums[id])+rec(id+1,m1,m2|(1<<i)),ans)\\n                else:\\n                    ans=max(ans,((i+1)&nums[id])+rec(id+1,m1|(1<<i),m2))\\n            dp[(id,m1,m2)]=ans\\n            return ans\\n        return rec(0,0,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440446,
                "title": "memoization-in-python-with-simple-cutting-beating-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy implementation of the ``straightforward\\'\\' DP with bitmask cannot pass all testcases. Some cuttings are required to pass the strict testcases. \\n\\nOne key point should be considered is the repeated numbers. That is, it is a waste of time to permutate all the same numbers. Thus, the first cutting is to exclude the duplicate permutations during the DP process. I sort the numbers and skip exploring the duplicate numbers in the same DP state. In this way, the program can barely pass all the testcase in a couple of seconds. \\n\\nThe second and very intuitive cutting is the perfect matching. If a number equals to a slot, and it is always the best to put the number into the slot. No other choice will be better. \\n\\nThe third cutting is to skip the match whose score is zero. If ``nums[i] & slot == 0`` then it is sensesless to put the number into the slot. \\n\\nWith all the three simple cuttings, the implementation in memoization runs effiicently and outperforms 100% of Python submissions. \\n\\n# Complexity\\n- Time complexity: $$O(2^nnm)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^nm)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(slot, quota, used):\\n            if quota == 0:\\n                return dp(slot+1, 2, used)\\n            if used == goal:\\n                return 0\\n            if slot > numSlots:\\n                return 0\\n            for i in range(n):\\n                if ((1 << i) & used) == 0:\\n                    if nums[i] == slot:\\n                        return dp(slot, quota - 1, used | (1<<i)) + (nums[i] & slot)\\n            s = dp(slot+1, 2, used)\\n            for i in range(n):\\n               if (i == 0 or nums[i] != nums[i-1] \\\\\\n                   or (nums[i] == nums[i-1] and ((1 << (i-1)) & used))) \\\\\\n                   and ((1 << i) & used) == 0 \\\\\\n                   and (nums[i] & slot) > 0:\\n                    s = max(s, dp(slot, quota - 1, used | (1<<i)) + (nums[i] & slot))\\n            return s\\n            \\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        goal = reduce(operator.or_, [(1 << i) for i in range(n)])\\n        return dp(1, 2, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(slot, quota, used):\\n            if quota == 0:\\n                return dp(slot+1, 2, used)\\n            if used == goal:\\n                return 0\\n            if slot > numSlots:\\n                return 0\\n            for i in range(n):\\n                if ((1 << i) & used) == 0:\\n                    if nums[i] == slot:\\n                        return dp(slot, quota - 1, used | (1<<i)) + (nums[i] & slot)\\n            s = dp(slot+1, 2, used)\\n            for i in range(n):\\n               if (i == 0 or nums[i] != nums[i-1] \\\\\\n                   or (nums[i] == nums[i-1] and ((1 << (i-1)) & used))) \\\\\\n                   and ((1 << i) & used) == 0 \\\\\\n                   and (nums[i] & slot) > 0:\\n                    s = max(s, dp(slot, quota - 1, used | (1<<i)) + (nums[i] & slot))\\n            return s\\n            \\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        goal = reduce(operator.or_, [(1 << i) for i in range(n)])\\n        return dp(1, 2, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440419,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(2 ^ n_baskets)\\n * Space Complexity: O(2 ^ n_baskets)\\n * where `n_baskets` is `2 * numSlots`\\n */\\nclass Solution {\\n public:\\n  int maximumANDSum(const vector<int> &nums, const int numSlots) {\\n    constexpr int invalid_sum = -1;\\n    const int n = static_cast<int>(nums.size());\\n    const int n_baskets = 2 * numSlots;\\n    const int n_layouts = (1 << n_baskets);\\n    int dp[n_layouts];\\n    memset(dp, invalid_sum, sizeof(dp));\\n    dp[0] = 0;\\n    int ret = 0;\\n    for (int layout = 0; layout < n_layouts; ++layout) {\\n      if (dp[layout] == invalid_sum) {\\n        continue;\\n      }\\n\\n      const int numbers_in_baskets = one_bits(layout);\\n      if (numbers_in_baskets == n) {\\n        ret = max(ret, dp[layout]);\\n        continue;\\n      }\\n\\n      for (int basket = 0; basket < n_baskets; ++basket) {\\n        if ((layout & (1 << basket)) == 0) {\\n          dp[layout | (1 << basket)] = max(dp[layout | (1 << basket)],\\n                                           dp[layout] + ((basket / 2 + 1) & nums[numbers_in_baskets]));\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int one_bits(const int layout) {\\n    int ret = 0;\\n    for (int l = layout; l > 0; l &= (l - 1)) {\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(2 ^ n_baskets)\\n * Space Complexity: O(2 ^ n_baskets)\\n * where `n_baskets` is `2 * numSlots`\\n */\\nclass Solution {\\n public:\\n  int maximumANDSum(const vector<int> &nums, const int numSlots) {\\n    constexpr int invalid_sum = -1;\\n    const int n = static_cast<int>(nums.size());\\n    const int n_baskets = 2 * numSlots;\\n    const int n_layouts = (1 << n_baskets);\\n    int dp[n_layouts];\\n    memset(dp, invalid_sum, sizeof(dp));\\n    dp[0] = 0;\\n    int ret = 0;\\n    for (int layout = 0; layout < n_layouts; ++layout) {\\n      if (dp[layout] == invalid_sum) {\\n        continue;\\n      }\\n\\n      const int numbers_in_baskets = one_bits(layout);\\n      if (numbers_in_baskets == n) {\\n        ret = max(ret, dp[layout]);\\n        continue;\\n      }\\n\\n      for (int basket = 0; basket < n_baskets; ++basket) {\\n        if ((layout & (1 << basket)) == 0) {\\n          dp[layout | (1 << basket)] = max(dp[layout | (1 << basket)],\\n                                           dp[layout] + ((basket / 2 + 1) & nums[numbers_in_baskets]));\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int one_bits(const int layout) {\\n    int ret = 0;\\n    for (int l = layout; l > 0; l &= (l - 1)) {\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430443,
                "title": "c-hashmap-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ndp solution\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nint f(int ind,int numslots,vector<int>&nums,vector<int>&v,map<vector<int>,int>&dp){\\n\\n       if(ind==nums.size())return 0;//base case \\n\\n       if(dp.find(v)!=dp.end())return dp[v];\\n\\n        int ans = -1e9;\\n        //cheek all possibilities\\n        for(int i=1;i<=numslots;i++){\\n            if(v[i]<2){\\n            // if ith solt contains less than 2 element\\n            // then we can take the current element = nums[ind]\\n            v[i]++;\\n            ans = max(ans,(i&nums[ind]) + f(ind+1,numslots,nums,v,dp));//i is the numslot number and current index is taken in the ith slot so go to the next index and cheek further \\n            v[i]--;\\n            // backtrack\\n            }\\n            // one\\n        }\\n        return dp[v] = ans;\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        map<vector<int>,int>dp;\\n        vector<int> v(numSlots+1,0);\\n        return f(0,numSlots,nums,v,dp);\\n       // return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint f(int ind,int numslots,vector<int>&nums,vector<int>&v,map<vector<int>,int>&dp){\\n\\n       if(ind==nums.size())return 0;//base case \\n\\n       if(dp.find(v)!=dp.end())return dp[v];\\n\\n        int ans = -1e9;\\n        //cheek all possibilities\\n        for(int i=1;i<=numslots;i++){\\n            if(v[i]<2){\\n            // if ith solt contains less than 2 element\\n            // then we can take the current element = nums[ind]\\n            v[i]++;\\n            ans = max(ans,(i&nums[ind]) + f(ind+1,numslots,nums,v,dp));//i is the numslot number and current index is taken in the ith slot so go to the next index and cheek further \\n            v[i]--;\\n            // backtrack\\n            }\\n            // one\\n        }\\n        return dp[v] = ans;\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        map<vector<int>,int>dp;\\n        vector<int> v(numSlots+1,0);\\n        return f(0,numSlots,nums,v,dp);\\n       // return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374891,
                "title": "why-my-code-is-not-working-for-all-the-test-case-can-anyone-identify-what-s-going-wrong",
                "content": "```\\nclass Solution{\\npublic:\\n    int dp[50][50][3]; \\n    vector<int> vis;\\n    \\n    int solve(int n, vector<int>& nums, int slots, vector<int>& adj, int ind, int x, int y) {\\n        if (ind == n) {\\n            return 0;\\n        }\\n        if (dp[ind][x][y] != -1) {\\n            return dp[ind][x][y];\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= slots; i++) {\\n            if (vis[ind] == 0 && adj[i] < 2) {\\n                adj[i]++;\\n                vis[ind] = 1;\\n        ans = max(ans, (i & nums[ind]) + solve(n, nums, slots, adj, ind + 1, i,adj[i] )); \\n                vis[ind] = 0;\\n                adj[i]--;\\n            }\\n        }\\n        return dp[ind][x][y] = ans;\\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        vector<int> adj(slots + 1, 0);\\n        int n = nums.size();\\n        vis.resize(n + 1, 0);\\n        memset(dp, -1, sizeof(dp));\\n        return solve(n, nums, slots, adj, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\npublic:\\n    int dp[50][50][3]; \\n    vector<int> vis;\\n    \\n    int solve(int n, vector<int>& nums, int slots, vector<int>& adj, int ind, int x, int y) {\\n        if (ind == n) {\\n            return 0;\\n        }\\n        if (dp[ind][x][y] != -1) {\\n            return dp[ind][x][y];\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= slots; i++) {\\n            if (vis[ind] == 0 && adj[i] < 2) {\\n                adj[i]++;\\n                vis[ind] = 1;\\n        ans = max(ans, (i & nums[ind]) + solve(n, nums, slots, adj, ind + 1, i,adj[i] )); \\n                vis[ind] = 0;\\n                adj[i]--;\\n            }\\n        }\\n        return dp[ind][x][y] = ans;\\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        vector<int> adj(slots + 1, 0);\\n        int n = nums.size();\\n        vis.resize(n + 1, 0);\\n        memset(dp, -1, sizeof(dp));\\n        return solve(n, nums, slots, adj, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351502,
                "title": "backtracking-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    map<vector<int>,int> dp;\\n    int f(int i, vector<int>& nums, vector<int>& slots, vector<int> &vis)\\n    {\\n        if(i==nums.size()) return 0;\\n        int ans=0;\\n        if(dp.find(vis)!=dp.end()) return dp[vis];\\n        for(auto it: slots)\\n        {\\n            if(vis[it]<2) \\n            {\\n                vis[it]++;\\n                ans=max(ans,(it&nums[i])+f(i+1,nums,slots,vis));\\n                vis[it]--;\\n            }\\n        }\\n        return dp[vis]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) \\n    {\\n        vector<int> slots;\\n        for(int x=1; x<=numSlots; x++) slots.push_back(x);\\n        vector<int> vis(numSlots+1,0);\\n        return f(0,nums,slots,vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    map<vector<int>,int> dp;\\n    int f(int i, vector<int>& nums, vector<int>& slots, vector<int> &vis)\\n    {\\n        if(i==nums.size()) return 0;\\n        int ans=0;\\n        if(dp.find(vis)!=dp.end()) return dp[vis];\\n        for(auto it: slots)\\n        {\\n            if(vis[it]<2) \\n            {\\n                vis[it]++;\\n                ans=max(ans,(it&nums[i])+f(i+1,nums,slots,vis));\\n                vis[it]--;\\n            }\\n        }\\n        return dp[vis]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) \\n    {\\n        vector<int> slots;\\n        for(int x=1; x<=numSlots; x++) slots.push_back(x);\\n        vector<int> vis(numSlots+1,0);\\n        return f(0,nums,slots,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259976,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximum_and_sum(nums: Vec<i32>, num_slots: i32) -> i32 {\\n        fn dp(i: i32, mask: i32, ns: i32, memo: &mut Vec<i32>, nums: &Vec<i32>) -> i32 {\\n            if memo[mask as usize] > 0 {\\n                return memo[mask as usize];\\n            }\\n            if i < 0 {\\n                return 0;\\n            }\\n            let mut bit = 1;\\n            for slot in 1..=ns {\\n                if mask / bit % 3 > 0 {\\n                    let v1 = dp(i - 1, mask - bit, ns, memo, nums);\\n                    memo[mask as usize] = memo[mask as usize].max((nums[i as usize] & slot) + v1);\\n                }\\n                bit *= 3;\\n            }\\n            memo[mask as usize]\\n        }\\n\\n        let mask = 3_i32.pow(num_slots as u32) - 1;\\n        let mut memo = vec![0; (mask + 1) as usize];\\n        dp(nums.len() as i32 - 1, mask, num_slots, &mut memo, &nums)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_and_sum(nums: Vec<i32>, num_slots: i32) -> i32 {\\n        fn dp(i: i32, mask: i32, ns: i32, memo: &mut Vec<i32>, nums: &Vec<i32>) -> i32 {\\n            if memo[mask as usize] > 0 {\\n                return memo[mask as usize];\\n            }\\n            if i < 0 {\\n                return 0;\\n            }\\n            let mut bit = 1;\\n            for slot in 1..=ns {\\n                if mask / bit % 3 > 0 {\\n                    let v1 = dp(i - 1, mask - bit, ns, memo, nums);\\n                    memo[mask as usize] = memo[mask as usize].max((nums[i as usize] & slot) + v1);\\n                }\\n                bit *= 3;\\n            }\\n            memo[mask as usize]\\n        }\\n\\n        let mask = 3_i32.pow(num_slots as u32) - 1;\\n        let mut memo = vec![0; (mask + 1) as usize];\\n        dp(nums.len() as i32 - 1, mask, num_slots, &mut memo, &nums)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238456,
                "title": "bitmaks-dp-recursive-only-2-states",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int i,long long mask,int numSlots,vector<int>& nums,vector<vector<int>>& dp){\\n\\n        if(i>nums.size()-1) return 0;\\n\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n\\n        int mx = INT_MIN ; \\n\\n        for(int j=0;j< numSlots*2;j++){\\n\\n            bool isSet = (mask&(1<<j));\\n\\n            if(!isSet){\\n\\n                int index = j/2 + 1 ;\\n\\n                long long newMask = (mask|(1<<j));\\n\\n                mx = max(mx , (nums[i]&index) + solve(i+1,newMask,numSlots,nums,dp) );\\n\\n            }\\n\\n        }\\n\\n        return dp[i][mask] = mx ; \\n\\n    }\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        // 00 00 00 00 \\n\\n        vector<vector<int>> dp(nums.size(),vector<int>((1<<(numSlots*2)),-1));\\n\\n        return solve(0,0,numSlots, nums,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(int i,long long mask,int numSlots,vector<int>& nums,vector<vector<int>>& dp){\\n\\n        if(i>nums.size()-1) return 0;\\n\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n\\n        int mx = INT_MIN ; \\n\\n        for(int j=0;j< numSlots*2;j++){\\n\\n            bool isSet = (mask&(1<<j));\\n\\n            if(!isSet){\\n\\n                int index = j/2 + 1 ;\\n\\n                long long newMask = (mask|(1<<j));\\n\\n                mx = max(mx , (nums[i]&index) + solve(i+1,newMask,numSlots,nums,dp) );\\n\\n            }\\n\\n        }\\n\\n        return dp[i][mask] = mx ; \\n\\n    }\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        // 00 00 00 00 \\n\\n        vector<vector<int>> dp(nums.size(),vector<int>((1<<(numSlots*2)),-1));\\n\\n        return solve(0,0,numSlots, nums,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232790,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums, numSlots):\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dfs(i,mask1,mask2):\\n            if i == n:\\n                return 0\\n\\n            max_val = float(\"-inf\")\\n\\n            for j in range(numSlots):\\n                if mask1 & (1<<j):\\n                    max_val = max(max_val, (nums[i] & (j+1)) + dfs(i+1,mask1^(1<<j),mask2))\\n                elif mask2 & (1<<j):\\n                    max_val = max(max_val, (nums[i] & (j+1)) + dfs(i+1,mask1,mask2^(1<<j)))\\n\\n            return max_val \\n\\n        return dfs(0,(1<<numSlots)-1,(1<<numSlots)-1)\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums, numSlots):\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dfs(i,mask1,mask2):\\n            if i == n:\\n                return 0\\n\\n            max_val = float(\"-inf\")\\n\\n            for j in range(numSlots):\\n                if mask1 & (1<<j):\\n                    max_val = max(max_val, (nums[i] & (j+1)) + dfs(i+1,mask1^(1<<j),mask2))\\n                elif mask2 & (1<<j):\\n                    max_val = max(max_val, (nums[i] & (j+1)) + dfs(i+1,mask1,mask2^(1<<j)))\\n\\n            return max_val \\n\\n        return dfs(0,(1<<numSlots)-1,(1<<numSlots)-1)\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156321,
                "title": "explained-solution-using-dp-and-bitsmask-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe try to put every number with every numberslot according to availability of slots as preivious numbers used slots cannot be used .\\nSo i have created a DP with state as index and slots used ( mask ).\\nMask contain slots used as i have thought of using bits to see if we have used this slot or not .\\nmask : 000001111010 // we have to start from 1st bit as we have slots starting from 1 .\\nFor slot of same number i thought of getting bit of i + numSlots + 1. \\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> dp; // index , nubers used till now\\n    int sol(int ind, int mask, vector<int>&n , int& mxs){\\n        if(ind == n.size()) return 0;\\n        if(dp.find({ind,mask}) != dp.end()) return dp[{ind,mask}];\\n        int ans = -1;\\n        for(int i=1;i<=mxs;i++){\\n            bool s1 = ((mask>>i)&1);\\n            bool s2 = ((mask>>(i+mxs+1))&1);\\n            if(s1 && s2) continue;\\n            if(!s1){\\n                ans = max(sol(ind+1,mask|(1<<i),n,mxs) + (n[ind]&i) , ans);\\n            }else{\\n                ans = max(sol(ind+1,mask|(1<<(i+mxs+1)),n,mxs) + (n[ind]&i) , ans);\\n            }\\n        }\\n        return dp[{ind,mask}] = ans;\\n    }\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        return sol(0,0,nums,numSlots);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> dp; // index , nubers used till now\\n    int sol(int ind, int mask, vector<int>&n , int& mxs){\\n        if(ind == n.size()) return 0;\\n        if(dp.find({ind,mask}) != dp.end()) return dp[{ind,mask}];\\n        int ans = -1;\\n        for(int i=1;i<=mxs;i++){\\n            bool s1 = ((mask>>i)&1);\\n            bool s2 = ((mask>>(i+mxs+1))&1);\\n            if(s1 && s2) continue;\\n            if(!s1){\\n                ans = max(sol(ind+1,mask|(1<<i),n,mxs) + (n[ind]&i) , ans);\\n            }else{\\n                ans = max(sol(ind+1,mask|(1<<(i+mxs+1)),n,mxs) + (n[ind]&i) , ans);\\n            }\\n        }\\n        return dp[{ind,mask}] = ans;\\n    }\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        return sol(0,0,nums,numSlots);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138124,
                "title": "best-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& A, int ns) {\\n        int mask = pow(3, ns) - 1;\\n        vector<int> memo(mask + 1, 0);\\n        return dp(A.size() - 1, mask, ns, memo, A);\\n    }\\n    \\n    int dp(int i, int mask, int ns, vector<int>& memo, vector<int>& A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i < 0) return 0;\\n        for (int slot = 1, bit = 1; slot <= ns; ++slot, bit*= 3)\\n            if (mask / bit % 3 > 0)\\n                memo[mask] = max(memo[mask], (A[i] & slot) + dp(i - 1, mask - bit, ns, memo, A));\\n        return memo[mask];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ruby",
                    "Bash",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& A, int ns) {\\n        int mask = pow(3, ns) - 1;\\n        vector<int> memo(mask + 1, 0);\\n        return dp(A.size() - 1, mask, ns, memo, A);\\n    }\\n    \\n    int dp(int i, int mask, int ns, vector<int>& memo, vector<int>& A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i < 0) return 0;\\n        for (int slot = 1, bit = 1; slot <= ns; ++slot, bit*= 3)\\n            if (mask / bit % 3 > 0)\\n                memo[mask] = max(memo[mask], (A[i] & slot) + dp(i - 1, mask - bit, ns, memo, A));\\n        return memo[mask];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120344,
                "title": "50ms-top-down-dp",
                "content": "- Try to place numbers from the array in all possible slots if the slot is not already filled by two numbers\\n- Slots are represented by an integer mask, in which bits 0 to numSlots-1 represent if 1st number is already placed or not, and bits numSlots to 2*numSlots-1 represent if 2nd number is already placed or not\\n- Remember the results previously computed for a given index of the array and a given state of the slots mask\\n\\n# Code\\n```\\nclass Solution {\\n    int f(int idx, vector<int>& nums, int slots, int mask, vector<vector<int>>& dp) {\\n        if (idx == nums.size())\\n            return 0;\\n        \\n        if (dp[idx][mask] != -1) return dp[idx][mask];\\n\\n        int maxi = INT_MIN;\\n        for(int slot = 0; slot < slots; slot++) {\\n            if (((mask >> slot) & 1) == 0) {\\n                mask |= (1 << slot);\\n                int placed = ((slot+1) & nums[idx]) + f(idx+1, nums, slots, mask, dp);\\n                maxi = max(maxi, placed);\\n                mask &= ~(1 << slot);\\n            } \\n            else {\\n                int secondSlot = slot + slots;\\n                if (((mask >> secondSlot) & 1) == 0) {\\n                    mask |= (1 << secondSlot);\\n                    int placed = ((slot+1) & nums[idx]) + f(idx+1, nums, slots, mask, dp);\\n                    maxi = max(maxi, placed);\\n                    mask &= ~(1 << secondSlot);\\n                }\\n            }\\n        }\\n\\n        return dp[idx][mask] = maxi;\\n    }\\n\\n    public:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int size = 0;\\n        for(int bit = 0; bit < 2*numSlots; bit++) size += 1<<bit;\\n        vector<vector<int>> dp(nums.size(), vector<int>(size, -1));\\n        \\n        int mask = 0;\\n        return f(0, nums, numSlots, mask, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int f(int idx, vector<int>& nums, int slots, int mask, vector<vector<int>>& dp) {\\n        if (idx == nums.size())\\n            return 0;\\n        \\n        if (dp[idx][mask] != -1) return dp[idx][mask];\\n\\n        int maxi = INT_MIN;\\n        for(int slot = 0; slot < slots; slot++) {\\n            if (((mask >> slot) & 1) == 0) {\\n                mask |= (1 << slot);\\n                int placed = ((slot+1) & nums[idx]) + f(idx+1, nums, slots, mask, dp);\\n                maxi = max(maxi, placed);\\n                mask &= ~(1 << slot);\\n            } \\n            else {\\n                int secondSlot = slot + slots;\\n                if (((mask >> secondSlot) & 1) == 0) {\\n                    mask |= (1 << secondSlot);\\n                    int placed = ((slot+1) & nums[idx]) + f(idx+1, nums, slots, mask, dp);\\n                    maxi = max(maxi, placed);\\n                    mask &= ~(1 << secondSlot);\\n                }\\n            }\\n        }\\n\\n        return dp[idx][mask] = maxi;\\n    }\\n\\n    public:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int size = 0;\\n        for(int bit = 0; bit < 2*numSlots; bit++) size += 1<<bit;\\n        vector<vector<int>> dp(nums.size(), vector<int>(size, -1));\\n        \\n        int mask = 0;\\n        return f(0, nums, numSlots, mask, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970094,
                "title": "c-great-question-using-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nAt each bit position, for base 3 there could be 0,1,2\\n0 means both spots in the slot have been exhausted, \\n2 means no spot in the slot has been used yet and that there is still scope to assign number to this slot.\\nWe start from mask = 3 ^n  - 1 --> 22222... in base 3\\nEach time we use a slot (x) for a number at index i (A[i]) \\nwe reduce the mask by 3^(x - 1) to update the remaining slots\\nand recurse to get max value for i - 1....0 in remaining slots\\n\\nThe same thing can be done with base > 3 eg 4. like done below.\\nOnly change would be at each position possible values could 0,1,2,3\\nSince at each position only 2 spots can be used\\nmask/bit % 3 > 0 --> condition changes to --> mask/bit % 4 > 1\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& A, int ns) {\\n        int mask = pow(4, ns) - 1;\\n        vector<int> memo(mask + 1, 0);\\n        return dp(A.size() - 1, mask, ns, memo, A);\\n    }\\n    \\n    int dp(int i, int mask, int ns, vector<int>& memo, vector<int>& A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i < 0) return 0;\\n        for (int slot = 1, bit = 1; slot <= ns; ++slot, bit*= 4)\\n            if (mask / bit % 4 > 1)\\n                memo[mask] = max(memo[mask], (A[i] & slot) + dp(i - 1, mask - bit, ns, memo, A));\\n        return memo[mask];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nAt each bit position, for base 3 there could be 0,1,2\\n0 means both spots in the slot have been exhausted, \\n2 means no spot in the slot has been used yet and that there is still scope to assign number to this slot.\\nWe start from mask = 3 ^n  - 1 --> 22222... in base 3\\nEach time we use a slot (x) for a number at index i (A[i]) \\nwe reduce the mask by 3^(x - 1) to update the remaining slots\\nand recurse to get max value for i - 1....0 in remaining slots\\n\\nThe same thing can be done with base > 3 eg 4. like done below.\\nOnly change would be at each position possible values could 0,1,2,3\\nSince at each position only 2 spots can be used\\nmask/bit % 3 > 0 --> condition changes to --> mask/bit % 4 > 1\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& A, int ns) {\\n        int mask = pow(4, ns) - 1;\\n        vector<int> memo(mask + 1, 0);\\n        return dp(A.size() - 1, mask, ns, memo, A);\\n    }\\n    \\n    int dp(int i, int mask, int ns, vector<int>& memo, vector<int>& A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i < 0) return 0;\\n        for (int slot = 1, bit = 1; slot <= ns; ++slot, bit*= 4)\\n            if (mask / bit % 4 > 1)\\n                memo[mask] = max(memo[mask], (A[i] & slot) + dp(i - 1, mask - bit, ns, memo, A));\\n        return memo[mask];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967680,
                "title": "no-bitmask-map-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& nums,int idx,vector<int> &slots,map<pair<vector<int>,int>,int> &mp){\\n        if(idx>=nums.size()) return 0;\\n        if(mp.find({slots,idx})!=mp.end()) return mp[{slots,idx}];\\n        int ans=INT_MIN;\\n        for(int i=0;i<slots.size();i++) {\\n            if(slots[i]<2){\\n                slots[i]++;\\n                ans=max(ans,(nums[idx] & (i+1))+fun(nums,idx+1,slots,mp));\\n                slots[i]--;\\n            }\\n        }\\n\\n        return mp[{slots,idx}]=ans;\\n\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        map<pair<vector<int>,int>,int> mp;\\n        vector<int> arr(numSlots,0);\\n        return fun(nums,0,arr,mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& nums,int idx,vector<int> &slots,map<pair<vector<int>,int>,int> &mp){\\n        if(idx>=nums.size()) return 0;\\n        if(mp.find({slots,idx})!=mp.end()) return mp[{slots,idx}];\\n        int ans=INT_MIN;\\n        for(int i=0;i<slots.size();i++) {\\n            if(slots[i]<2){\\n                slots[i]++;\\n                ans=max(ans,(nums[idx] & (i+1))+fun(nums,idx+1,slots,mp));\\n                slots[i]--;\\n            }\\n        }\\n\\n        return mp[{slots,idx}]=ans;\\n\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        map<pair<vector<int>,int>,int> mp;\\n        vector<int> arr(numSlots,0);\\n        return fun(nums,0,arr,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952709,
                "title": "recursion-tenary-base-number-bitmasking",
                "content": "\\n# Approach\\n*Prerequisites:-*\\n- Recursion\\n- Bitmasking\\n\\nTo solve this problem, I will use the tenary base number method. It is also possible to solve this problem by using two binary bitmasks, however, the first method is faster. Let slots = 9 then my initial mask = **000000000**, and the ith index should go into the 2nd slot, so we should remake our mask = **000000010** here, my 2nd slot is 1, meaning one element can take place here and one place more can be taken by anyone.\\n\\n# Complexity\\n- Time complexity:\\nO(18 * (3 ^ 9) * 9)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ternary(int n, int& slots) {\\n        vector<int> digits;\\n        digits.resize(slots);\\n        int index = 0;\\n        while(n > 0) {\\n            digits[index++] = n % 3;\\n            n /= 3;\\n        }\\n        return digits;\\n    }\\n\\n    int cache[20][19700];\\n\\n    int dp(int i, int mask, vector<int>& A, int& slots) {\\n        if(i == (int) A.size()) {\\n            return 0;\\n        }\\n        int& ans = cache[i][mask];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        auto digits = ternary(mask, slots);\\n        for(int j = 0; j < slots; j++) {\\n            if(digits[j] != 2) {\\n                ans = max(ans, (A[i] & (1 + j)) + dp(i + 1, mask + (int) pow(3, j), A, slots));\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        memset(cache, -1, sizeof(cache));\\n        int ans = dp(0, 0, nums, slots);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ternary(int n, int& slots) {\\n        vector<int> digits;\\n        digits.resize(slots);\\n        int index = 0;\\n        while(n > 0) {\\n            digits[index++] = n % 3;\\n            n /= 3;\\n        }\\n        return digits;\\n    }\\n\\n    int cache[20][19700];\\n\\n    int dp(int i, int mask, vector<int>& A, int& slots) {\\n        if(i == (int) A.size()) {\\n            return 0;\\n        }\\n        int& ans = cache[i][mask];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        auto digits = ternary(mask, slots);\\n        for(int j = 0; j < slots; j++) {\\n            if(digits[j] != 2) {\\n                ans = max(ans, (A[i] & (1 + j)) + dp(i + 1, mask + (int) pow(3, j), A, slots));\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        memset(cache, -1, sizeof(cache));\\n        int ans = dp(0, 0, nums, slots);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919718,
                "title": "dart-simple-implementation-with-a-brief-explanation",
                "content": "# Intuition\\nWe put numbers into slots. Slots are a limited resource.\\nThe problem we face is that by the task definition it does matter what number we put into what slot. This is the case where bitmask DP can help us.\\n\\nIn case of brute force approach we would need to permutate numbers, plus distribute them in a number of slots that can exceed out needs.\\nThe result complexity would exceed N!.\\nThere might be some ideas connected to greedy algorithms but the prove that the result solution is optimal might not exist or become too difficult.\\n\\n\\n# Approach\\n\\nSimple approach - use brute force and bitmask DP to optimise complexity.\\nI implemented IMHO the simpliest (but non optimal) solution.\\n\\n**First - Lets double the number of Slots**\\nInstead of dealing with N slots where we can store up to two numbers - we can think of N*2 slots where we can store 0 or 1 item.\\nWe should realise that this brings additional computational complexity; instead of processing 3 states per slot (0, 1, 2 numbers in one slot) we will have four states in our two \"virtual slots\" (00, 01, 10, 11) where 01 and 10 have same effect on the end result, so we add 25% more complexity. There is a simple workarround but lets skip it for the sake of simplicity.\\nFrom now we can deal with a simple bitmask - where we can allocate numbers from our array on different bits in the mask.\\n\\n**Second - allocate numbers on \"0\" bits in the mask and get the maximum**\\nIts very simple - take any one number (we can start from the beggining or end of the array, does not matter), and get the maximum by allocating it on all free virtual slots (one \"0\" bit in our bitmask), calculate $$realSlotIndex & ourNumber$$  and add it to the result of recursive call - where we pass remaining numbers and the bitMask with the selected bit occupied (i.e. set from \"0\" to 1).\\nThats it. And use DP array to reduce time complexity to the size of our state array.\\n\\n**Further optimisation**\\nTwo things can be done to optimise our DP solution:\\nWe can use additional array and backtracking to reduce out time complexity on the \"25%\" mentioned above.\\nAnd we can use bottom-up DP to reduce amount of memory required for our calculations - from 2D to 1D array.\\nBoth a rather trivial.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n * 2^(slots * 2)  )\\n\\n- Space complexity:\\nO(n * 2^(slots * 2)  )\\n\\n# Code\\n```\\n\\nclass Solution {\\n  int topDown(List<int> nums, int idx, int slotsBitMask, int slotBitCount,\\n      List<List<int>> dp) {\\n    if (idx < 0) return 0; // no items to put in slots\\n    if (dp[idx][slotsBitMask] != -1) return dp[idx][slotsBitMask];\\n    int maxRes = 0;\\n    for (int i = 0; i < slotBitCount; i++) {\\n      if (((~slotsBitMask) & (1 << i)) != 0) // slot bit is empty ? put item there\\n        maxRes = max(\\n            maxRes,\\n            topDown(nums, \\n                      idx - 1, // put remaining N-1 items into remaining slots \\n                     (slotsBitMask | (1 << i)), // item is in the free slot - bit is set to 1\\n                    slotBitCount,\\n                    dp) +\\n                (((i >> 1) + 1) & nums[idx]));\\n    }\\n    return dp[idx][slotsBitMask] = maxRes;\\n  }\\n\\n  int maximumANDSum(List<int> nums, int numSlots) {\\n    int slotBitCount = numSlots * 2;\\n    final dp = List<List<int>>.generate(\\n        nums.length, (index) => List<int>.filled(1 << (slotBitCount + 1), -1));\\n    return topDown(nums, nums.length - 1, 0, slotBitCount, dp);\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nclass Solution {\\n  int topDown(List<int> nums, int idx, int slotsBitMask, int slotBitCount,\\n      List<List<int>> dp) {\\n    if (idx < 0) return 0; // no items to put in slots\\n    if (dp[idx][slotsBitMask] != -1) return dp[idx][slotsBitMask];\\n    int maxRes = 0;\\n    for (int i = 0; i < slotBitCount; i++) {\\n      if (((~slotsBitMask) & (1 << i)) != 0) // slot bit is empty ? put item there\\n        maxRes = max(\\n            maxRes,\\n            topDown(nums, \\n                      idx - 1, // put remaining N-1 items into remaining slots \\n                     (slotsBitMask | (1 << i)), // item is in the free slot - bit is set to 1\\n                    slotBitCount,\\n                    dp) +\\n                (((i >> 1) + 1) & nums[idx]));\\n    }\\n    return dp[idx][slotsBitMask] = maxRes;\\n  }\\n\\n  int maximumANDSum(List<int> nums, int numSlots) {\\n    int slotBitCount = numSlots * 2;\\n    final dp = List<List<int>>.generate(\\n        nums.length, (index) => List<int>.filled(1 << (slotBitCount + 1), -1));\\n    return topDown(nums, nums.length - 1, 0, slotBitCount, dp);\\n\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908766,
                "title": "c-simple-and-easy-approach-memoization-dp",
                "content": "SC: O(nums.size()) + Auxiliary stack space\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    int solve(int i,string &slots, vector<int>&nums){\\n        //base case\\n        if(i<0)return 0;\\n        \\n        //check the cache\\n        string hash = to_string(i) + \"#\" + slots;  //create custom key\\n        if(mp[hash])return mp[hash];\\n        \\n        int maxi=0;\\n        for(int j=1;j<slots.size();j++){\\n            if(slots[j]<\\'2\\'){\\n                slots[j] = slots[j]+1;\\n                int curr= (j&nums[i]) + solve(i-1,slots,nums);\\n                slots[j] = slots[j]-1;\\n                maxi=max(maxi,curr);\\n            }\\n        }\\n        return mp[hash] = maxi;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n=nums.size();\\n        string slots(numSlots+1,\\'0\\');\\n        return solve(n-1,slots,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    int solve(int i,string &slots, vector<int>&nums){\\n        //base case\\n        if(i<0)return 0;\\n        \\n        //check the cache\\n        string hash = to_string(i) + \"#\" + slots;  //create custom key\\n        if(mp[hash])return mp[hash];\\n        \\n        int maxi=0;\\n        for(int j=1;j<slots.size();j++){\\n            if(slots[j]<\\'2\\'){\\n                slots[j] = slots[j]+1;\\n                int curr= (j&nums[i]) + solve(i-1,slots,nums);\\n                slots[j] = slots[j]-1;\\n                maxi=max(maxi,curr);\\n            }\\n        }\\n        return mp[hash] = maxi;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n=nums.size();\\n        string slots(numSlots+1,\\'0\\');\\n        return solve(n-1,slots,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773756,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        int[] slots = new int[numSlots];\\n        for(int i=0;i<slots.length;i++){\\n            slots[i] = 2;\\n        }\\n        HashMap<String, Integer> map = new HashMap();\\n        return max(nums, slots, 0, map);\\n    }\\n    \\n    public int max(int[] nums,int[] slots, int index, HashMap<String, Integer> map) {\\n        if(index == nums.length) return 0;\\n        String key = getString(slots);\\n        if(map.get(key) != null){\\n            return map.get(key);\\n        }\\n        int ans = Integer.MIN_VALUE >> 1;\\n        for(int i=0;i<slots.length;i++){\\n           if(slots[i] == 0) continue;\\n           slots[i]--;\\n           ans = Math.max(ans, max(nums, slots, index+1, map)+(nums[index]&(i+1))); \\n           slots[i]++; \\n        }\\n        map.put(key, ans);\\n        return ans;\\n    }\\n    \\n    public String getString(int[] slots) {\\n        StringBuffer bf = new StringBuffer();\\n        for(int x: slots) {\\n            bf.append(x+\"-\");\\n        }\\n        return bf.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        int[] slots = new int[numSlots];\\n        for(int i=0;i<slots.length;i++){\\n            slots[i] = 2;\\n        }\\n        HashMap<String, Integer> map = new HashMap();\\n        return max(nums, slots, 0, map);\\n    }\\n    \\n    public int max(int[] nums,int[] slots, int index, HashMap<String, Integer> map) {\\n        if(index == nums.length) return 0;\\n        String key = getString(slots);\\n        if(map.get(key) != null){\\n            return map.get(key);\\n        }\\n        int ans = Integer.MIN_VALUE >> 1;\\n        for(int i=0;i<slots.length;i++){\\n           if(slots[i] == 0) continue;\\n           slots[i]--;\\n           ans = Math.max(ans, max(nums, slots, index+1, map)+(nums[index]&(i+1))); \\n           slots[i]++; \\n        }\\n        map.put(key, ans);\\n        return ans;\\n    }\\n    \\n    public String getString(int[] slots) {\\n        StringBuffer bf = new StringBuffer();\\n        for(int x: slots) {\\n            bf.append(x+\"-\");\\n        }\\n        return bf.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772529,
                "title": "900-ms-c",
                "content": "#define ll long long \\n\\nclass Solution \\n{ \\npublic: \\n    int maximumANDSum(vector<int>& nums, int ns) \\n    { \\n        int n=nums.size();\\n        ns*=2; \\n        vector<int> slot(ns); \\n        for(int i=0;i<ns;i+=2) \\n        { \\n            slot[i]=i/2+1; \\n            slot[i+1]=i/2+1; \\n        } \\n        \\n        vector<vector<int>> dp( ns+2, vector<int> ( (1<<n) , -1 ) ); \\n        int ans=0; \\n        \\n        auto dfs=[&] ( auto self, int pos, int mask ) -> int \\n        { \\n            if( pos>=ns ) return 0; \\n            if( dp[pos][mask]!=-1 ) return dp[pos][mask];\\n            dp[pos][mask]=0;\\n            int baki=n-__builtin_popcount(mask); \\n            if(baki<ns-pos) dp[pos][mask]=self( self, pos+1, mask ) ; \\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                if( (1<<i)&( mask ) ) continue;\\n                int newm= mask|( 1<<i ) ;\\n                int aha=self(self, pos+1, newm);\\n                dp[pos][mask]=max( dp[pos][mask],  aha+(nums[i]&slot[pos]) );\\n            }\\n            \\n            ans=max(ans, dp[pos][mask]);\\n            return dp[pos][mask];\\n            \\n        };\\n        \\n        return dfs(dfs, 0, 0);\\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution \\n{ \\npublic: \\n    int maximumANDSum(vector<int>& nums, int ns) \\n    { \\n        int n=nums.size();\\n        ns*=2; \\n        vector<int> slot(ns); \\n        for(int i=0;i<ns;i+=2) \\n        { \\n            slot[i]=i/2+1; \\n            slot[i+1]=i/2+1; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2729532,
                "title": "straight-forward-stringmask-instead-of-bitmask",
                "content": "# Intuition\\nWe need to permute all combinations of slots X numbers but there are many subproblems that repeat\\n\\n# Approach\\nGo through every number and try putting it into each slot. Use a string to record which slot is filled (0, 1 or 2). Use the string to detect already seen subproblems (dp)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun maximumANDSum(nums: IntArray, numSlots: Int): Int {\\n        val mem = HashMap<String, Int>()\\n        var buckets = StringBuilder()\\n        for (i in 1..numSlots) buckets.append(\"0\")\\n        return dfs(mem, nums, numSlots, buckets, 0)\\n    }\\n\\n    private fun dfs(mem: HashMap<String, Int>, nums: IntArray, numSlots: Int, buckets: StringBuilder, cur: Int): Int {\\n        if (mem[buckets.toString()] != null) return mem[buckets.toString()]!!\\n        if (cur >= nums.size) return 0\\n        var max = 0\\n        for (i in 1..numSlots) {\\n            if (addToBucket(buckets, i)) {\\n                val score = i and nums[cur]\\n                max = Math.max(max, dfs(mem, nums, numSlots, buckets, cur+1) + score)\\n                removeFromBucket(buckets, i)\\n            }\\n        }\\n        mem[buckets.toString()] = max\\n        return max\\n    }\\n\\n    private fun addToBucket(buckets: StringBuilder, ind: Int): Boolean {\\n        val curNum = (buckets[ind - 1] - \\'0\\').toInt()\\n        val newNum = Math.min(2, curNum + 1)\\n        buckets[ind - 1] = (\\'0\\' + newNum).toChar()\\n        return curNum < 2\\n    }\\n\\n    private fun removeFromBucket(buckets: StringBuilder, ind: Int): Boolean {\\n        val curNum = (buckets[ind - 1] - \\'0\\').toInt()\\n        val newNum = Math.max(0, curNum - 1)\\n        buckets[ind - 1] = (\\'0\\' + newNum).toChar()\\n        return curNum > 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumANDSum(nums: IntArray, numSlots: Int): Int {\\n        val mem = HashMap<String, Int>()\\n        var buckets = StringBuilder()\\n        for (i in 1..numSlots) buckets.append(\"0\")\\n        return dfs(mem, nums, numSlots, buckets, 0)\\n    }\\n\\n    private fun dfs(mem: HashMap<String, Int>, nums: IntArray, numSlots: Int, buckets: StringBuilder, cur: Int): Int {\\n        if (mem[buckets.toString()] != null) return mem[buckets.toString()]!!\\n        if (cur >= nums.size) return 0\\n        var max = 0\\n        for (i in 1..numSlots) {\\n            if (addToBucket(buckets, i)) {\\n                val score = i and nums[cur]\\n                max = Math.max(max, dfs(mem, nums, numSlots, buckets, cur+1) + score)\\n                removeFromBucket(buckets, i)\\n            }\\n        }\\n        mem[buckets.toString()] = max\\n        return max\\n    }\\n\\n    private fun addToBucket(buckets: StringBuilder, ind: Int): Boolean {\\n        val curNum = (buckets[ind - 1] - \\'0\\').toInt()\\n        val newNum = Math.min(2, curNum + 1)\\n        buckets[ind - 1] = (\\'0\\' + newNum).toChar()\\n        return curNum < 2\\n    }\\n\\n    private fun removeFromBucket(buckets: StringBuilder, ind: Int): Boolean {\\n        val curNum = (buckets[ind - 1] - \\'0\\').toInt()\\n        val newNum = Math.max(0, curNum - 1)\\n        buckets[ind - 1] = (\\'0\\' + newNum).toChar()\\n        return curNum > 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719771,
                "title": "no-bitmask-dp-solution-python",
                "content": "Each slot can hold two numbers so why dont we just double the number of slots and then each slot can only hold 1? this way we can apply bitmasking.\\nBut 2^(2n) >> 3^n. 2^20 = 10^6 and 3^10 = 60k \\nSo you can work with base 3 but math is a bit annoying specially if you are used to working with binary operators (& ~)\\n\\nSo I decided to just use strings instead of actual numbers. And it worked pretty well. \\nTC: 80% ~920ms\\n```\\ndef maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n\\n    #TLE -> double the slots\\n    # slots = 2*numSlots\\n    # @lru_cache(None)\\n    # def dp(i, available):\\n    #     if i == len(nums):\\n    #         return 0\\n    #     ans = -math.inf\\n    #     for k in range(slots-1, -1, -1):\\n    #         if available & (1<<k):\\n    #             AND = nums[i]&(k//2 + 1)\\n    #             ans = max(ans, AND + dp(i+1, available & ~(1 << k)))\\n    #     return ans\\n    # return dp(0, (1<<slots) - 1)\\n\\n    @lru_cache(None)\\n    def dp(i, available):\\n        if i == len(nums):\\n            return 0\\n        \\n        ans = -math.inf\\n        for k in range(numSlots):\\n            if available[k] != \"0\":\\n                AND = nums[i]&(k+1)\\n                nex = available[:k] + str(int(available[k]) - 1) + available[k+1:]\\n                ans = max(ans, AND + dp(i+1, nex))\\n        return ans \\n    \\n    return dp(0, \"2\"*numSlots)\\n```\\n\\nHungarian Match making algorithm for those brave enough\\nTC:100%\\n```\\nclass Hungarian:\\n    def __init__(self, n):\\n        self.n = n\\n        self.pa, self.pb = [-1] * n, [-1] * n\\n        self.g = defaultdict(lambda: defaultdict(int))\\n    \\n    def add_edge(self, u, v, w):\\n        self.g[u][v] = w\\n    \\n    def solve(self):\\n        n, g, pa, pb = self.n, self.g, self.pa, self.pb\\n        la, lb = [max(g[i].values()) for i in range(n)], [0] * n\\n        def bfs(p):\\n            def augment(v):\\n                while v != -1:\\n                    u = pre[v]\\n                    tmp = pa[u]\\n                    pa[u] = v\\n                    pb[v] = u\\n                    v = tmp\\n            visa, visb, pre = [False] * n, [False] * n, [-1] * n\\n            dq = deque([p])\\n            visa[p] = True\\n            while True:\\n                while dq:\\n                    u = dq.popleft()\\n                    for v in range(n):\\n                        if not visb[v] and la[u] + lb[v] == g[u][v]:\\n                            visb[v] = True\\n                            pre[v] = u\\n                            if pb[v] == -1:\\n                                augment(v)\\n                                return\\n                            else:\\n                                dq.append(pb[v])\\n                                visa[pb[v]] = True\\n                d = min(la[u] + lb[v] - g[u][v] for v in range(n) if not visb[v]\\n                                          for u in range(n) if visa[u])\\n                for i in range(n):\\n                    if visa[i]: la[i] -= d\\n                    if visb[i]: lb[i] += d\\n                dq.extend(u for u in range(n) if visa[u])\\n            \\n        for i in range(n):\\n            if pa[i] == -1: bfs(i)\\n        return sum(g[i][pa[i]] for i in range(n))\\n\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        solver = Hungarian(numSlots * 2)\\n        for i in range(numSlots):\\n            for j, x in enumerate(nums):\\n                solver.add_edge(i*2, j, (i+1) & x)\\n                solver.add_edge(i*2+1, j, (i+1) & x)\\n        return solver.solve()\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\ndef maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n\\n    #TLE -> double the slots\\n    # slots = 2*numSlots\\n    # @lru_cache(None)\\n    # def dp(i, available):\\n    #     if i == len(nums):\\n    #         return 0\\n    #     ans = -math.inf\\n    #     for k in range(slots-1, -1, -1):\\n    #         if available & (1<<k):\\n    #             AND = nums[i]&(k//2 + 1)\\n    #             ans = max(ans, AND + dp(i+1, available & ~(1 << k)))\\n    #     return ans\\n    # return dp(0, (1<<slots) - 1)\\n\\n    @lru_cache(None)\\n    def dp(i, available):\\n        if i == len(nums):\\n            return 0\\n        \\n        ans = -math.inf\\n        for k in range(numSlots):\\n            if available[k] != \"0\":\\n                AND = nums[i]&(k+1)\\n                nex = available[:k] + str(int(available[k]) - 1) + available[k+1:]\\n                ans = max(ans, AND + dp(i+1, nex))\\n        return ans \\n    \\n    return dp(0, \"2\"*numSlots)\\n```\n```\\nclass Hungarian:\\n    def __init__(self, n):\\n        self.n = n\\n        self.pa, self.pb = [-1] * n, [-1] * n\\n        self.g = defaultdict(lambda: defaultdict(int))\\n    \\n    def add_edge(self, u, v, w):\\n        self.g[u][v] = w\\n    \\n    def solve(self):\\n        n, g, pa, pb = self.n, self.g, self.pa, self.pb\\n        la, lb = [max(g[i].values()) for i in range(n)], [0] * n\\n        def bfs(p):\\n            def augment(v):\\n                while v != -1:\\n                    u = pre[v]\\n                    tmp = pa[u]\\n                    pa[u] = v\\n                    pb[v] = u\\n                    v = tmp\\n            visa, visb, pre = [False] * n, [False] * n, [-1] * n\\n            dq = deque([p])\\n            visa[p] = True\\n            while True:\\n                while dq:\\n                    u = dq.popleft()\\n                    for v in range(n):\\n                        if not visb[v] and la[u] + lb[v] == g[u][v]:\\n                            visb[v] = True\\n                            pre[v] = u\\n                            if pb[v] == -1:\\n                                augment(v)\\n                                return\\n                            else:\\n                                dq.append(pb[v])\\n                                visa[pb[v]] = True\\n                d = min(la[u] + lb[v] - g[u][v] for v in range(n) if not visb[v]\\n                                          for u in range(n) if visa[u])\\n                for i in range(n):\\n                    if visa[i]: la[i] -= d\\n                    if visb[i]: lb[i] += d\\n                dq.extend(u for u in range(n) if visa[u])\\n            \\n        for i in range(n):\\n            if pa[i] == -1: bfs(i)\\n        return sum(g[i][pa[i]] for i in range(n))\\n\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        solver = Hungarian(numSlots * 2)\\n        for i in range(numSlots):\\n            for j, x in enumerate(nums):\\n                solver.add_edge(i*2, j, (i+1) & x)\\n                solver.add_edge(i*2+1, j, (i+1) & x)\\n        return solver.solve()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718525,
                "title": "c-dp-bitmask-easy-to-understand",
                "content": "* ***Using DP + BITMASK***\\n\\n* ***Time Complexity :- O(N * 2 ^ N * 2 ^ N)***\\n\\n* ***Space Complexity :- O(N * 2 ^ N * 2 ^ N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& nums, int i, int n, int mask1, int mask2, int k, vector<vector<vector<int>>>& dp)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[i][mask1][mask2] != -1)\\n            return dp[i][mask1][mask2];\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int j = 1; j <= k; j++)\\n        {\\n            // if curr slot is booked\\n            \\n            if((mask1 & (1 << j)) && (mask2 & (1 << j)))\\n            {\\n                continue;\\n            }\\n            else if((mask1 & (1 << j)) == false)\\n            {\\n                int val = nums[i] & j;\\n                \\n                int new_mask1 = (mask1 | (1 << j));\\n                \\n                int ans = val + helper(nums, i + 1, n, new_mask1, mask2, k, dp);\\n                \\n                maxi = max(maxi, ans);\\n            }\\n            else if((mask2 & (1 << j)) == false)\\n            {\\n                int val = nums[i] & j;\\n                \\n                int new_mask2 = (mask2 | (1 << j));\\n                \\n                int ans = val + helper(nums, i + 1, n, mask1, new_mask2, k, dp);\\n                \\n                maxi = max(maxi, ans);\\n            }\\n        }\\n        \\n        // store the res and return it\\n        \\n        return dp[i][mask1][mask2] = maxi;\\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a 3D dp and initialize with -1\\n        \\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (1 << (k + 1), vector<int> (1 << (k + 1), -1)));\\n        \\n        return helper(nums, 0, n, 0, 0, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& nums, int i, int n, int mask1, int mask2, int k, vector<vector<vector<int>>>& dp)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[i][mask1][mask2] != -1)\\n            return dp[i][mask1][mask2];\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int j = 1; j <= k; j++)\\n        {\\n            // if curr slot is booked\\n            \\n            if((mask1 & (1 << j)) && (mask2 & (1 << j)))\\n            {\\n                continue;\\n            }\\n            else if((mask1 & (1 << j)) == false)\\n            {\\n                int val = nums[i] & j;\\n                \\n                int new_mask1 = (mask1 | (1 << j));\\n                \\n                int ans = val + helper(nums, i + 1, n, new_mask1, mask2, k, dp);\\n                \\n                maxi = max(maxi, ans);\\n            }\\n            else if((mask2 & (1 << j)) == false)\\n            {\\n                int val = nums[i] & j;\\n                \\n                int new_mask2 = (mask2 | (1 << j));\\n                \\n                int ans = val + helper(nums, i + 1, n, mask1, new_mask2, k, dp);\\n                \\n                maxi = max(maxi, ans);\\n            }\\n        }\\n        \\n        // store the res and return it\\n        \\n        return dp[i][mask1][mask2] = maxi;\\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a 3D dp and initialize with -1\\n        \\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (1 << (k + 1), vector<int> (1 << (k + 1), -1)));\\n        \\n        return helper(nums, 0, n, 0, 0, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691960,
                "title": "javascript-easy-efficient-explained-solution",
                "content": "**Approach**: \\n\\t\\n\\tTake mask of base 3.\\n    bit 0 means no nums[i] in the slot\\n    bit 1 means there is 1 nums[i] in the slot\\n    bit 2 means there are 2 nums[i] in the slot\\n\\tNow we can check for every nums[i] and try to put it in every possible slot and check the which is giving the maximum value.\\n    In memoization we need not to keep i as state variable as mask tells the possition of nums[i] and count also.\\n\\n\\t\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} numSlots\\n * @return {number}\\n */\\nvar maximumANDSum = function(nums, numSlots) {\\n    let memo=[],mask=0;\\n    let ans =  dp(0,0);\\n    return ans;\\n    \\n    function dp(i,mask){\\n        let max = 0,sum;\\n        if(memo[mask]!==undefined){\\n            return memo[mask];\\n        }\\n        if(i===nums.length){\\n            return 0;\\n        }\\n        for(let s=1,maskBit=1;s<=numSlots;s++,maskBit*=3){\\n            if(Math.floor(mask/maskBit)%3<2){\\n                sum = (nums[i]&s)+dp(i+1,mask+maskBit);\\n                max = Math.max(sum,max);\\n            }\\n        }\\n        memo[mask]=max;\\n        return memo[mask];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} numSlots\\n * @return {number}\\n */\\nvar maximumANDSum = function(nums, numSlots) {\\n    let memo=[],mask=0;\\n    let ans =  dp(0,0);\\n    return ans;\\n    \\n    function dp(i,mask){\\n        let max = 0,sum;\\n        if(memo[mask]!==undefined){\\n            return memo[mask];\\n        }\\n        if(i===nums.length){\\n            return 0;\\n        }\\n        for(let s=1,maskBit=1;s<=numSlots;s++,maskBit*=3){\\n            if(Math.floor(mask/maskBit)%3<2){\\n                sum = (nums[i]&s)+dp(i+1,mask+maskBit);\\n                max = Math.max(sum,max);\\n            }\\n        }\\n        memo[mask]=max;\\n        return memo[mask];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678372,
                "title": "why-is-this-greedy-solution-wrong",
                "content": "Calculate AND value of each number with all slots, and then keep selecting the max till either that number is already put in a slot or that slot already has two numbers. This does not work, why is this greedy solution wrong ?\\n\\nPassed 63/84 test cases\\n\\nExample failing test case \\n\\n[14,7,9,8,2,4,11,1,9]\\n8\\n\\n```\\nclass Solution {\\nprivate:\\n    struct Element{\\n        int numIdx = -1;\\n        int slotNum = -1;\\n        int andVal = -1;\\n    };\\n    \\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n    \\n        \\n        auto func = [](const Element& a, const Element& b){\\n            return a.andVal < b.andVal;\\n        };\\n        \\n        priority_queue<Element, vector<Element>, decltype(func)> p(func);\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 1; j <= numSlots; j++){\\n                p.push(Element{i, j, nums[i] & j});\\n            }\\n        }\\n        \\n        int sol = 0;\\n        \\n        vector<int> countTaken(numSlots+1, 0);\\n        vector<bool> elementTaken(nums.size(), false);\\n        \\n        while(!p.empty()){\\n            auto x = p.top();\\n            p.pop();\\n            \\n            \\n            if(countTaken[x.slotNum] == 2 || elementTaken[x.numIdx]){\\n                continue;\\n            }\\n            else{\\n                sol += x.andVal;\\n                countTaken[x.slotNum]++;\\n                elementTaken[x.numIdx] = true;\\n            }\\n        }\\n        \\n        return sol;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Element{\\n        int numIdx = -1;\\n        int slotNum = -1;\\n        int andVal = -1;\\n    };\\n    \\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n    \\n        \\n        auto func = [](const Element& a, const Element& b){\\n            return a.andVal < b.andVal;\\n        };\\n        \\n        priority_queue<Element, vector<Element>, decltype(func)> p(func);\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 1; j <= numSlots; j++){\\n                p.push(Element{i, j, nums[i] & j});\\n            }\\n        }\\n        \\n        int sol = 0;\\n        \\n        vector<int> countTaken(numSlots+1, 0);\\n        vector<bool> elementTaken(nums.size(), false);\\n        \\n        while(!p.empty()){\\n            auto x = p.top();\\n            p.pop();\\n            \\n            \\n            if(countTaken[x.slotNum] == 2 || elementTaken[x.numIdx]){\\n                continue;\\n            }\\n            else{\\n                sol += x.andVal;\\n                countTaken[x.slotNum]++;\\n                elementTaken[x.numIdx] = true;\\n            }\\n        }\\n        \\n        return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610606,
                "title": "test-case-doubt",
                "content": "[1,4]\\n1\\nthis is giving output as 1 \\nwhile my output is 0\\nas 1&4 is 0 and they are placed in first slot.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2599739,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll sz;\\n    string bm;\\n    unordered_map<string, vi(ll)>dp;\\n    ll func(const vi(int)& v, ll in, const int& n) {\\n        if (in == sz) {\\n            return 0;\\n        }\\n        if (dp[bm].empty()) {\\n            dp[bm].assign(sz, -1);\\n        }\\n        ll& ans = dp[bm][in];\\n        if (ans == -1) {\\n            ans = 0;\\n            for (ll i = 0;i < n;++i) {\\n                if (bm[i] < \\'2\\') {\\n                    ++bm[i];\\n                    ans = max(ans, (v[in] & (i + 1)) + func(v, in + 1, n));\\n                    --bm[i];\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n    int maximumANDSum(vector<int>& v, int n) {\\n        sz = v.size();\\n        bm.assign(n, \\'0\\');\\n        return func(v, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll sz;\\n    string bm;\\n    unordered_map<string, vi(ll)>dp;\\n    ll func(const vi(int)& v, ll in, const int& n) {\\n        if (in == sz) {\\n            return 0;\\n        }\\n        if (dp[bm].empty()) {\\n            dp[bm].assign(sz, -1);\\n        }\\n        ll& ans = dp[bm][in];\\n        if (ans == -1) {\\n            ans = 0;\\n            for (ll i = 0;i < n;++i) {\\n                if (bm[i] < \\'2\\') {\\n                    ++bm[i];\\n                    ans = max(ans, (v[in] & (i + 1)) + func(v, in + 1, n));\\n                    --bm[i];\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n    int maximumANDSum(vector<int>& v, int n) {\\n        sz = v.size();\\n        bm.assign(n, \\'0\\');\\n        return func(v, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599161,
                "title": "c-dp-bit-mask-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> memo;\\n    int helper(vector<int>& nums, int idx, int slots, int numSlots) {\\n        if(idx == nums.size()) return 0;\\n        if(memo[idx][slots] != -1) return memo[idx][slots];\\n        int max_val = 0;\\n        for(int i = 0; i < numSlots; i++) {\\n            int curr_val = 0;\\n            if((slots & 1 << ( i *2)) == 0 || (slots & 1 << ( i *2 + 1)) == 0) {\\n                if((slots & 1 << ( i *2)) == 0) {\\n                    curr_val = (nums[idx] & (i+1)) + helper(nums, idx+1, slots | 1 << ( i *2), numSlots);\\n                } else {\\n                    curr_val = (nums[idx] & (i+1)) + helper(nums, idx+1, slots | 1 << ( i *2 +1), numSlots);\\n                }\\n                max_val = max(max_val, curr_val);\\n            }\\n        }\\n        return memo[idx][slots] = max_val;\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memo.resize(nums.size(), vector<int>(pow(2, 2*numSlots)-1, -1));\\n        return helper(nums, 0, 0, numSlots);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> memo;\\n    int helper(vector<int>& nums, int idx, int slots, int numSlots) {\\n        if(idx == nums.size()) return 0;\\n        if(memo[idx][slots] != -1) return memo[idx][slots];\\n        int max_val = 0;\\n        for(int i = 0; i < numSlots; i++) {\\n            int curr_val = 0;\\n            if((slots & 1 << ( i *2)) == 0 || (slots & 1 << ( i *2 + 1)) == 0) {\\n                if((slots & 1 << ( i *2)) == 0) {\\n                    curr_val = (nums[idx] & (i+1)) + helper(nums, idx+1, slots | 1 << ( i *2), numSlots);\\n                } else {\\n                    curr_val = (nums[idx] & (i+1)) + helper(nums, idx+1, slots | 1 << ( i *2 +1), numSlots);\\n                }\\n                max_val = max(max_val, curr_val);\\n            }\\n        }\\n        return memo[idx][slots] = max_val;\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memo.resize(nums.size(), vector<int>(pow(2, 2*numSlots)-1, -1));\\n        return helper(nums, 0, 0, numSlots);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527635,
                "title": "o-3-numslots-numslots-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n=nums.size();\\n        int ans=0;\\n        int maskCount=pow(3,numSlots);\\n        int dp[maskCount][n+1];\\n        for(int i=0;i<maskCount;i++){\\n            for(int j=0;j<=n;j++){\\n                dp[i][j]=0;\\n            }\\n        }\\n      \\n        \\n        for(int mask=1;mask<maskCount;mask++){\\n           vector<int>v;\\n           int x=mask;\\n            for(int i=0;i<numSlots;i++){\\n                v.push_back(x%3);\\n                x/=3;\\n            }\\n            \\n           for(int pos=1;pos<=n;pos++){\\n               for(int where=0;where<numSlots;where++){\\n                   if(v[where]==0)\\n                       continue;\\n                   dp[mask][pos]=max(dp[mask][pos],(nums[pos-1]&(where+1))+dp[mask-(int)pow(3,where)][pos-1]);\\n               }\\n           }\\n        }\\n        \\n        for(int mask=1;mask<maskCount;mask++)\\n            ans=max(ans,dp[mask][n]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n=nums.size();\\n        int ans=0;\\n        int maskCount=pow(3,numSlots);\\n        int dp[maskCount][n+1];\\n        for(int i=0;i<maskCount;i++){\\n            for(int j=0;j<=n;j++){\\n                dp[i][j]=0;\\n            }\\n        }\\n      \\n        \\n        for(int mask=1;mask<maskCount;mask++){\\n           vector<int>v;\\n           int x=mask;\\n            for(int i=0;i<numSlots;i++){\\n                v.push_back(x%3);\\n                x/=3;\\n            }\\n            \\n           for(int pos=1;pos<=n;pos++){\\n               for(int where=0;where<numSlots;where++){\\n                   if(v[where]==0)\\n                       continue;\\n                   dp[mask][pos]=max(dp[mask][pos],(nums[pos-1]&(where+1))+dp[mask-(int)pow(3,where)][pos-1]);\\n               }\\n           }\\n        }\\n        \\n        for(int mask=1;mask<maskCount;mask++)\\n            ans=max(ans,dp[mask][n]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500508,
                "title": "bitmask-of-ternarily-digits-hungarian",
                "content": "can be solved using bitmask dp as constraints are pretty low. maximal matching impiles to maxflow min cost and Hungarian. \\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2475232,
                "title": "top-down-approach-without-bitmask",
                "content": "```\\nclass Solution {\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        Map<String, Integer> memo = new HashMap<>();\\n        int[] slots = new int[numSlots + 1];\\n        return recur(nums, slots, numSlots, 0, memo);\\n    }\\n    \\n    private int recur(int[] nums, int[] slots, int numSlots, int index, Map<String, Integer> memo) {\\n        \\n        if (index == nums.length) {\\n            return 0;\\n        }\\n        String key = Arrays.toString(slots) + \"|\" + index;\\n        \\n        if (memo.get(key) != null) {\\n            return memo.get(key);\\n        }\\n        int ans = 0;\\n        \\n        for (int i = 1; i <= numSlots; i++) {\\n            \\n            if (slots[i - 1] < 2) {\\n                slots[i - 1]++;\\n                int temp = (nums[index] & i) + recur(nums, slots, numSlots, index + 1, memo);\\n                ans = Math.max(ans, temp);\\n                slots[i - 1]--;\\n            }\\n        }\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        Map<String, Integer> memo = new HashMap<>();\\n        int[] slots = new int[numSlots + 1];\\n        return recur(nums, slots, numSlots, 0, memo);\\n    }\\n    \\n    private int recur(int[] nums, int[] slots, int numSlots, int index, Map<String, Integer> memo) {\\n        \\n        if (index == nums.length) {\\n            return 0;\\n        }\\n        String key = Arrays.toString(slots) + \"|\" + index;\\n        \\n        if (memo.get(key) != null) {\\n            return memo.get(key);\\n        }\\n        int ans = 0;\\n        \\n        for (int i = 1; i <= numSlots; i++) {\\n            \\n            if (slots[i - 1] < 2) {\\n                slots[i - 1]++;\\n                int temp = (nums[index] & i) + recur(nums, slots, numSlots, index + 1, memo);\\n                ans = Math.max(ans, temp);\\n                slots[i - 1]--;\\n            }\\n        }\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456020,
                "title": "need-help-please-giving-wrong-answer-but-i-think-idea-is-correct",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_map<int,int>> dp;\\n    vector<int> a;\\n    int n;\\n    map<int,vector<int>> mp;\\n    int go(int mask, int numslot){\\n        if(mask==(1<<a.size())-1){\\n            return 0;\\n        }\\n        if(numslot>n|| (a.size()-__builtin_popcount(mask))>2*(n+1-numslot)) \\n            return -1e6;\\n        if(dp[mask].count(numslot)){\\n            return dp[mask][numslot];\\n        }\\n        int ans=go(mask,numslot+1);\\n        for(int j=0;j<a.size();j++){\\n            if((mask&(1<<j))==0){\\n                ans=max(ans,a[j]&numslot+go(mask|(1<<j), numslot+1));\\n                for(int k=0;k<a.size();k++){\\n                    if((mask&(1<<k))==0 and j!=k){\\n                        int p=a[j]&numslot+a[k]&numslot;\\n                        ans=max(ans,p+go(mask|(1<<j)|(1<<k),numslot+1));\\n                    }\\n                }\\n            }\\n        }\\n        return dp[mask][numslot]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        this->a=nums;\\n        this->n=numSlots;\\n        return go(0,1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_map<int,int>> dp;\\n    vector<int> a;\\n    int n;\\n    map<int,vector<int>> mp;\\n    int go(int mask, int numslot){\\n        if(mask==(1<<a.size())-1){\\n            return 0;\\n        }\\n        if(numslot>n|| (a.size()-__builtin_popcount(mask))>2*(n+1-numslot)) \\n            return -1e6;\\n        if(dp[mask].count(numslot)){\\n            return dp[mask][numslot];\\n        }\\n        int ans=go(mask,numslot+1);\\n        for(int j=0;j<a.size();j++){\\n            if((mask&(1<<j))==0){\\n                ans=max(ans,a[j]&numslot+go(mask|(1<<j), numslot+1));\\n                for(int k=0;k<a.size();k++){\\n                    if((mask&(1<<k))==0 and j!=k){\\n                        int p=a[j]&numslot+a[k]&numslot;\\n                        ans=max(ans,p+go(mask|(1<<j)|(1<<k),numslot+1));\\n                    }\\n                }\\n            }\\n        }\\n        return dp[mask][numslot]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        this->a=nums;\\n        this->n=numSlots;\\n        return go(0,1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440750,
                "title": "javascript-memoization-backtracking-dfs-code-comments-easy",
                "content": "This solution is less efficient but scalable:\\n```\\nvar maximumANDSum = function(nums, numSlots) { \\n  const memo = new Map();\\n  // Initialize slots with full quota, this can accommodate more than 9 slots and 2 capacity\\n  return backtrack(0, Array(numSlots + 1).fill(2));\\n  \\n  function backtrack(idx, slots) {\\n    if (idx === nums.length) return 0;   // We reached the end\\n    \\n    const code = `${idx}:${slots.join()}`; // Unique code for key of memo\\n    if (memo.has(code)) return memo.get(code);  // Short-circuit if memo[code] exists\\n    \\n    let res = 0;\\n    for (let i = 1; i <= numSlots; i++) {\\n      if (slots[i] === 0) continue;  // No capacity remaining\\n      \\n      // Decrement capacity of slots. Increment visited count in DFS\\n      slots[i]--;\\n      \\n      // Backtrack/DFS\\n      res = Math.max(res, (nums[idx] & i) + backtrack(idx + 1, slots));  \\n      \\n      // Reset slots capacity for next iteration of loop. Reset visited count in DFS\\n      slots[i]++;\\n    }\\n    \\n    memo.set(code, res);\\n    return res;\\n  }\\n};\\n```\\n\\nThe above is derived from a more efficient but less scalable solution below using a decimal mask:\\n```\\nvar maximumANDSum = function(nums, numSlots) {\\n  const initMask = parseInt(\\'2\\'.repeat(numSlots));  // This isn\\'t a bit mask\\n  const dp = new Map();\\n  return backtrack(0, initMask);\\n  \\n  function backtrack(idx, mask) {\\n    if (idx === nums.length) return 0;   // We reached the end\\n    \\n    const code = `${idx},${mask}`;\\n    if (dp.has(code)) return dp.get(code);  // Short-circuit\\n    \\n    let res = 0;\\n    for (let i = 1; i <= numSlots; i++) {\\n      // Get the quota at slot index\\n      const base = Math.pow(10, i - 1);\\n      const left = Math.floor(mask / base) % 10;\\n      \\n      // If no quota left at index\\n      if (left === 0) continue;\\n      \\n      // Recurse\\n      res = Math.max(res, (nums[idx] & i) + backtrack(idx + 1, mask - base));\\n    }\\n    \\n    dp.set(code, res);\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nvar maximumANDSum = function(nums, numSlots) { \\n  const memo = new Map();\\n  // Initialize slots with full quota, this can accommodate more than 9 slots and 2 capacity\\n  return backtrack(0, Array(numSlots + 1).fill(2));\\n  \\n  function backtrack(idx, slots) {\\n    if (idx === nums.length) return 0;   // We reached the end\\n    \\n    const code = `${idx}:${slots.join()}`; // Unique code for key of memo\\n    if (memo.has(code)) return memo.get(code);  // Short-circuit if memo[code] exists\\n    \\n    let res = 0;\\n    for (let i = 1; i <= numSlots; i++) {\\n      if (slots[i] === 0) continue;  // No capacity remaining\\n      \\n      // Decrement capacity of slots. Increment visited count in DFS\\n      slots[i]--;\\n      \\n      // Backtrack/DFS\\n      res = Math.max(res, (nums[idx] & i) + backtrack(idx + 1, slots));  \\n      \\n      // Reset slots capacity for next iteration of loop. Reset visited count in DFS\\n      slots[i]++;\\n    }\\n    \\n    memo.set(code, res);\\n    return res;\\n  }\\n};\\n```\n```\\nvar maximumANDSum = function(nums, numSlots) {\\n  const initMask = parseInt(\\'2\\'.repeat(numSlots));  // This isn\\'t a bit mask\\n  const dp = new Map();\\n  return backtrack(0, initMask);\\n  \\n  function backtrack(idx, mask) {\\n    if (idx === nums.length) return 0;   // We reached the end\\n    \\n    const code = `${idx},${mask}`;\\n    if (dp.has(code)) return dp.get(code);  // Short-circuit\\n    \\n    let res = 0;\\n    for (let i = 1; i <= numSlots; i++) {\\n      // Get the quota at slot index\\n      const base = Math.pow(10, i - 1);\\n      const left = Math.floor(mask / base) % 10;\\n      \\n      // If no quota left at index\\n      if (left === 0) continue;\\n      \\n      // Recurse\\n      res = Math.max(res, (nums[idx] & i) + backtrack(idx + 1, mask - base));\\n    }\\n    \\n    dp.set(code, res);\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2440660,
                "title": "simple-go-solution-using-bitmask",
                "content": "```\\npackage main\\n\\nimport \"math\"\\n\\nfunc maximumANDSum(nums []int, numSlots int) int {\\n\\tmask := int(math.Pow(3.0, float64(numSlots))) - 1\\n\\tmemo := make([]int, mask+1)\\n\\treturn dp(len(nums)-1, mask, numSlots, memo, nums)\\n}\\n\\nfunc dp(idx, mask, numSlots int, memo, nums []int) int {\\n\\tif memo[mask] > 0 {\\n\\t\\treturn memo[mask]\\n\\t}\\n\\tif idx < 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tfor slot, bit := 1, 1; slot <= numSlots; slot, bit = slot+1, bit*3 {\\n\\t\\tif mask/bit%3 > 0 {\\n\\t\\t\\tmemo[mask] = max(memo[mask], (nums[idx]&slot)+dp(idx-1, mask-bit, numSlots, memo, nums))\\n\\t\\t}\\n\\t}\\n\\treturn memo[mask]\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport \"math\"\\n\\nfunc maximumANDSum(nums []int, numSlots int) int {\\n\\tmask := int(math.Pow(3.0, float64(numSlots))) - 1\\n\\tmemo := make([]int, mask+1)\\n\\treturn dp(len(nums)-1, mask, numSlots, memo, nums)\\n}\\n\\nfunc dp(idx, mask, numSlots int, memo, nums []int) int {\\n\\tif memo[mask] > 0 {\\n\\t\\treturn memo[mask]\\n\\t}\\n\\tif idx < 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tfor slot, bit := 1, 1; slot <= numSlots; slot, bit = slot+1, bit*3 {\\n\\t\\tif mask/bit%3 > 0 {\\n\\t\\t\\tmemo[mask] = max(memo[mask], (nums[idx]&slot)+dp(idx-1, mask-bit, numSlots, memo, nums))\\n\\t\\t}\\n\\t}\\n\\treturn memo[mask]\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2387761,
                "title": "c-solution-dp-bitmaks",
                "content": "The brute force approach would involve arranging `2*numSlots` and aligning them with the `nums` and finding the maximum AND sum. The complexity of this approach is `O(n * (2*numSlots)! / (2^numSlots))`.\\n\\nThe naive approach is exponential so let\\'s think `dp`. Let\\'s assume we have the answer till `i-1`th index. For `i`th index, we will start with all the `2*numSlots`.  We will AND `nums[i]` with all the `numSlots` one by one and get the maximum value of the AND sum. If we take `j`th slot, then we need to decrement the count of `j`th slot and get the answer from `dp[i-1]`. The naive way to store the count of all slots is to store it in a vector. But we can optimize it by mapping the state of count vector to a single integer. Each slot has 3 states, `0, 1, 2` and there are `numSlots` slots. Thus each state of count array can be mapped to integers in the range `[0, 3^numSlots)`.\\n\\nFormally, `dp[i][j]` indicates the maximum AND sum after using `i+1` elements and the starting state of count vector mapped to integer `j`. To compute `dp[i][j]`, we iterate over all the `numSlots` and check it\\'s count in `j`. If the count is non-zero, then we will have the answer as sum of AND of current number with the current slot and the `dp[i-1][encoding after decreasing the current slot\\'s count from j]`. We take the max of all possible AND sum.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n = nums.size(), s = pow(3, numSlots);\\n        vector<vector<int>> dp(n+1, vector<int>(s, 0));\\n        for(int i = 1; i <= n; i++){\\n            for(int b = 1; b < s; b++){\\n                int m = 1;\\n                dp[i][b] = dp[i-1][b];\\n                for(int j = 0; j < numSlots; j++){\\n                    if((b/m)%3 > 0){\\n                        int bprime = ((b/m) - 1)*m + (b%m);\\n                        dp[i][b] = max(dp[i][b], (nums[i-1]&(j+1)) + dp[i-1][bprime]);\\n                    }\\n                    m *= 3;\\n                }\\n            }\\n        }\\n        return dp[n][s-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n = nums.size(), s = pow(3, numSlots);\\n        vector<vector<int>> dp(n+1, vector<int>(s, 0));\\n        for(int i = 1; i <= n; i++){\\n            for(int b = 1; b < s; b++){\\n                int m = 1;\\n                dp[i][b] = dp[i-1][b];\\n                for(int j = 0; j < numSlots; j++){\\n                    if((b/m)%3 > 0){\\n                        int bprime = ((b/m) - 1)*m + (b%m);\\n                        dp[i][b] = max(dp[i][b], (nums[i-1]&(j+1)) + dp[i-1][bprime]);\\n                    }\\n                    m *= 3;\\n                }\\n            }\\n        }\\n        return dp[n][s-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386311,
                "title": "c-dp-with-bitmasks",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int dp[19][1<<9][1<<9];\\n    int func(vector<int>&nums,int n,int idx,int mask1,int mask2,int slots){\\n        if(idx==n) return 0;\\n        if(dp[idx][mask1][mask2]!=-1) return dp[idx][mask1][mask2];\\n        int ans=0;\\n        for(int i=0;i<slots;i++){\\n            int b1=(mask1&(1<<i));\\n            int b2=(mask2&(1<<i));\\n            if(b1==0&&b2==0) ans=max(ans,((i+1)&nums[idx])+func(nums,n,idx+1,mask1|(1<<i),mask2,slots));\\n            else if(b2==0) ans=max(ans,((i+1)&nums[idx])+func(nums,n,idx+1,mask1,mask2|(1<<i),slots));\\n        }        \\n        return dp[idx][mask1][mask2]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        int n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return func(nums,n,0,0,0,slots);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[19][1<<9][1<<9];\\n    int func(vector<int>&nums,int n,int idx,int mask1,int mask2,int slots){\\n        if(idx==n) return 0;\\n        if(dp[idx][mask1][mask2]!=-1) return dp[idx][mask1][mask2];\\n        int ans=0;\\n        for(int i=0;i<slots;i++){\\n            int b1=(mask1&(1<<i));\\n            int b2=(mask2&(1<<i));\\n            if(b1==0&&b2==0) ans=max(ans,((i+1)&nums[idx])+func(nums,n,idx+1,mask1|(1<<i),mask2,slots));\\n            else if(b2==0) ans=max(ans,((i+1)&nums[idx])+func(nums,n,idx+1,mask1,mask2|(1<<i),slots));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2272925,
                "title": "easy-python-solution-with-60-tc-and-74-sc",
                "content": "```\\ndef maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n\\t@cache\\n\\tdef solve(i, l, n = len(nums)):\\n\\t\\tif(i == n):\\n\\t\\t\\treturn 0\\n\\t\\ttemp = 0\\n\\t\\tfor j in range(numSlots):\\n\\t\\t\\tif(l[j] < 2):\\n\\t\\t\\t\\ttemp = max(temp, ((j+1) & nums[i]) + solve(i+1, l[:j] + (l[j]+1,) + l[j+1:]))\\n\\t\\treturn temp\\n\\treturn solve(0, tuple([0]*numSlots))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ndef maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n\\t@cache\\n\\tdef solve(i, l, n = len(nums)):\\n\\t\\tif(i == n):\\n\\t\\t\\treturn 0\\n\\t\\ttemp = 0\\n\\t\\tfor j in range(numSlots):\\n\\t\\t\\tif(l[j] < 2):\\n\\t\\t\\t\\ttemp = max(temp, ((j+1) & nums[i]) + solve(i+1, l[:j] + (l[j]+1,) + l[j+1:]))\\n\\t\\treturn temp\\n\\treturn solve(0, tuple([0]*numSlots))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2213757,
                "title": "c-code-dp-memoization-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[20][300005];\\n    \\n    int func(vector<int> &v,vector<int> &nums,int idx,int key){\\n        if (idx>=nums.size()){\\n            return 0;\\n        }\\n        \\n        if (dp[idx][key]!=-1){\\n            return dp[idx][key];\\n        }\\n        \\n        int val=0;\\n        for (int j=0; j<v.size(); j++){\\n            if (key&(1<<j)){\\n                continue;\\n            }\\n            \\n            val=max(val,(v[j]&nums[idx])+func(v,nums,idx+1,(key|(1<<j))));\\n        }\\n        \\n      return dp[idx][key]=val;\\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int n) {\\n        int i;\\n        vector<int> v;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for (i=1; i<=n; i++){\\n            v.push_back(i);\\n            v.push_back(i);\\n        }\\n        \\n       return func(v,nums,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[20][300005];\\n    \\n    int func(vector<int> &v,vector<int> &nums,int idx,int key){\\n        if (idx>=nums.size()){\\n            return 0;\\n        }\\n        \\n        if (dp[idx][key]!=-1){\\n            return dp[idx][key];\\n        }\\n        \\n        int val=0;\\n        for (int j=0; j<v.size(); j++){\\n            if (key&(1<<j)){\\n                continue;\\n            }\\n            \\n            val=max(val,(v[j]&nums[idx])+func(v,nums,idx+1,(key|(1<<j))));\\n        }\\n        \\n      return dp[idx][key]=val;\\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int n) {\\n        int i;\\n        vector<int> v;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for (i=1; i<=n; i++){\\n            v.push_back(i);\\n            v.push_back(i);\\n        }\\n        \\n       return func(v,nums,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208708,
                "title": "c-solution-dp-with-bit-masking",
                "content": "![image](https://assets.leetcode.com/users/images/e0f61526-a3fb-4493-bc37-4bb27f5b6c55_1656404622.91452.jpeg)\\n![image](https://assets.leetcode.com/users/images/3a3061bd-a2cf-4378-9c85-f7a91f537c04_1656404632.3644915.jpeg)\\n![image](https://assets.leetcode.com/users/images/578e1b25-74c9-4dd2-97e9-1ec2a1698efa_1656404639.5726829.jpeg)\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int,pair<int,int>>pos;\\n    vector<vector<int>>mem;\\n    int solve(vector<int>&nums,int index,int numSlots,int config){\\n        if(index==nums.size()){\\n            return 0;\\n        } else if(mem[index][config]!=-1){\\n            return mem[index][config];\\n        } else {\\n            int ans=0;\\n            for(int i=1;i<=numSlots;i++){\\n                int first=pos[i].first,second=pos[i].second;\\n                if(((config>>first)&1)==0){\\n                    ans=max(ans,(nums[index]&i)+solve(nums,index+1,numSlots,config|(1<<first)));\\n                } else if(((config>>second)&1)==0){\\n                    ans=max(ans,(nums[index]&i)+solve(nums,index+1,numSlots,config|(1<<second)));\\n                }\\n            }\\n            return mem[index][config]=ans;\\n        }\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int diff=0;\\n        for(int i=1;i<=numSlots;i++){\\n            int first=i+diff;\\n            int second=i+diff+1;\\n            diff++;\\n            pos[i]=make_pair(first,second);\\n        }\\n        int n=nums.size();\\n        mem=vector<vector<int>>(n,vector<int>(1<<(2*numSlots)+1,-1));\\n        return solve(nums,0,numSlots,0);\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "class Solution {\\nprivate:\\n    unordered_map<int,pair<int,int>>pos;\\n    vector<vector<int>>mem;\\n    int solve(vector<int>&nums,int index,int numSlots,int config){\\n        if(index==nums.size()){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2150856,
                "title": "c-dp-two-masks",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint n;\\n\\tint dp[18][1 << 9][1 << 9];\\n    vector<int> a;\\n    int numSlots;\\n\\tint solve(int i, int mask1, int mask2) {\\n\\t\\tif (i >= n) return 0;\\n\\n\\t\\tif (dp[i][mask1][mask2] != -1) return dp[i][mask1][mask2];\\n\\n        int ans = INT_MIN;\\n\\t\\tfor (int j = 0; j < numSlots; j++) {\\n\\n\\t\\t\\tif ((mask1 & (1 << j))) {\\n\\t\\t\\t\\tans = max(ans, (a[i] & (j + 1)) + solve(i + 1, mask1 ^ (1 << j), mask2));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ((mask2 & (1 << j))) {\\n\\t\\t\\t\\tans = max(ans, ((a[i]) & (j + 1)) + solve(i + 1, mask1, mask2 ^ (1 << j)));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[i][mask1][mask2] = ans;\\n\\n\\t}\\n\\n\\n\\tint maximumANDSum(vector<int>& nums, int numSlots1) {\\n\\t\\tn = nums.size();\\n        a = nums;\\n        a = nums;\\n        numSlots = numSlots1;\\n\\t\\tint initialMask = ((1 << numSlots) - 1);\\n        \\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\t\\treturn solve(0, initialMask, initialMask);\\n\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint n;\\n\\tint dp[18][1 << 9][1 << 9];\\n    vector<int> a;\\n    int numSlots;\\n\\tint solve(int i, int mask1, int mask2) {\\n\\t\\tif (i >= n) return 0;\\n\\n\\t\\tif (dp[i][mask1][mask2] != -1) return dp[i][mask1][mask2];\\n\\n        int ans = INT_MIN;\\n\\t\\tfor (int j = 0; j < numSlots; j++) {\\n\\n\\t\\t\\tif ((mask1 & (1 << j))) {\\n\\t\\t\\t\\tans = max(ans, (a[i] & (j + 1)) + solve(i + 1, mask1 ^ (1 << j), mask2));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ((mask2 & (1 << j))) {\\n\\t\\t\\t\\tans = max(ans, ((a[i]) & (j + 1)) + solve(i + 1, mask1, mask2 ^ (1 << j)));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[i][mask1][mask2] = ans;\\n\\n\\t}\\n\\n\\n\\tint maximumANDSum(vector<int>& nums, int numSlots1) {\\n\\t\\tn = nums.size();\\n        a = nums;\\n        a = nums;\\n        numSlots = numSlots1;\\n\\t\\tint initialMask = ((1 << numSlots) - 1);\\n        \\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\t\\treturn solve(0, initialMask, initialMask);\\n\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148796,
                "title": "python-100-time-maximum-flow-with-maximum-cost-heuristic",
                "content": "(1) If number is equal to slot number than it should be assigned to that slot,\\n(2) Max flow with max cost is max flow with min cost after negating cost of traversing edges,\\n\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        result = 0\\n\\t\\t# heuristic to eliminate obvious matchings\\n        slots = []\\n        for i in range(numSlots+1):\\n            slots.append({\\n                \"free\": 2,\\n                \"inside\": [],\\n                \"no\": i\\n            })\\n        d = collections.defaultdict(int)\\n        for n in nums:\\n            if n < len(slots) and slots[n][\\'free\\']:\\n                slots[n][\\'free\\'] -= 1\\n                slots[n][\\'inside\\'].append(n)\\n                result += n\\n            else:\\n                d[n] += 1\\n        nums = []\\n        for k, v in zip(d.keys(), d.values()):\\n            for i in range(v):\\n                nums.append(k)\\n        \\n\\t\\t# graph construction\\n        INF = 100000000\\n        V = [{\\'visited\\': False} for _ in range(len(nums)+numSlots+2)]\\n        E = [[None for _ in range(len(V))] for __ in range(len(V))]\\n        BFE = []\\n        def addEdge(s, e, capacity, cost):\\n            E[s][e] = {\\n                \\'capacity\\': capacity,\\n                \\'cost\\': cost,\\n            }\\n            E[e][s] = {\\n                \\'capacity\\': 0,\\n                \\'cost\\': -cost,\\n            }\\n            BFE.append((s,e))\\n            BFE.append((e,s))\\n        numsRange = range(2, 2+len(nums))\\n        slotsRange = range(2+len(nums), 2+len(nums)+numSlots)\\n        for i in numsRange:\\n            addEdge(0, i, 1, 0)\\n        for i in slotsRange:\\n            addEdge(i, 1, slots[i - len(nums) - 1][\\'free\\'], 0)\\n        for i in numsRange:\\n            tmp = 0\\n            for j in slotsRange:\\n                addEdge(i,j,999, -(nums[i-2] & (tmp+1)))\\n                tmp += 1\\n                \\n        def reset():\\n            for v in V:\\n                v[\\'visited\\'] = False\\n                v[\\'prev\\'] = None\\n                v[\\'distance\\'] = INF\\n        \\n\\t\\t# Ford-Bellman\\n        def path2():\\n            reset()\\n            V[0][\\'distance\\'] = 0\\n            capacity = INF\\n            for _ in range(len(V)-1):\\n                for e in BFE:\\n                    i = e[0]\\n                    j = e[1]\\n                    if V[i][\\'distance\\'] < INF and E[i][j] and E[i][j][\\'capacity\\']:\\n                        tmp = V[i][\\'distance\\'] + E[i][j][\\'cost\\']\\n                        if V[j][\\'distance\\'] > tmp:\\n                            V[j][\\'distance\\'] = tmp\\n                            V[j][\\'prev\\'] = i\\n                            capacity = min(capacity, E[i][j][\\'capacity\\'])\\n            \\n            if V[1][\\'distance\\'] == INF:\\n                return None\\n            \\n            t = [1]\\n            while V[t[len(t)-1]][\\'prev\\'] != None:\\n                t.append(V[t[len(t)-1]][\\'prev\\'])\\n            t.reverse()\\n            return (t, capacity);\\n        \\n        def debug():\\n            for row in E:\\n                print(*map(lambda e: e and (e[\\'capacity\\'], e[\\'cost\\']), row))\\n            for i, v in enumerate(V):\\n                print(i, v)\\n        \\n\\t\\t# Ford-Fulkerson\\n        p = path2()\\n        while p:\\n            for i in range(len(p[0])-1):\\n                E[p[0][i]][p[0][i+1]][\\'capacity\\'] -= p[1]\\n                E[p[0][i+1]][p[0][i]][\\'capacity\\'] += p[1]\\n            result -= V[1][\\'distance\\'] * p[1]\\n            p = path2()\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        result = 0\\n\\t\\t# heuristic to eliminate obvious matchings\\n        slots = []\\n        for i in range(numSlots+1):\\n            slots.append({\\n                \"free\": 2,\\n                \"inside\": [],\\n                \"no\": i\\n            })\\n        d = collections.defaultdict(int)\\n        for n in nums:\\n            if n < len(slots) and slots[n][\\'free\\']:\\n                slots[n][\\'free\\'] -= 1\\n                slots[n][\\'inside\\'].append(n)\\n                result += n\\n            else:\\n                d[n] += 1\\n        nums = []\\n        for k, v in zip(d.keys(), d.values()):\\n            for i in range(v):\\n                nums.append(k)\\n        \\n\\t\\t# graph construction\\n        INF = 100000000\\n        V = [{\\'visited\\': False} for _ in range(len(nums)+numSlots+2)]\\n        E = [[None for _ in range(len(V))] for __ in range(len(V))]\\n        BFE = []\\n        def addEdge(s, e, capacity, cost):\\n            E[s][e] = {\\n                \\'capacity\\': capacity,\\n                \\'cost\\': cost,\\n            }\\n            E[e][s] = {\\n                \\'capacity\\': 0,\\n                \\'cost\\': -cost,\\n            }\\n            BFE.append((s,e))\\n            BFE.append((e,s))\\n        numsRange = range(2, 2+len(nums))\\n        slotsRange = range(2+len(nums), 2+len(nums)+numSlots)\\n        for i in numsRange:\\n            addEdge(0, i, 1, 0)\\n        for i in slotsRange:\\n            addEdge(i, 1, slots[i - len(nums) - 1][\\'free\\'], 0)\\n        for i in numsRange:\\n            tmp = 0\\n            for j in slotsRange:\\n                addEdge(i,j,999, -(nums[i-2] & (tmp+1)))\\n                tmp += 1\\n                \\n        def reset():\\n            for v in V:\\n                v[\\'visited\\'] = False\\n                v[\\'prev\\'] = None\\n                v[\\'distance\\'] = INF\\n        \\n\\t\\t# Ford-Bellman\\n        def path2():\\n            reset()\\n            V[0][\\'distance\\'] = 0\\n            capacity = INF\\n            for _ in range(len(V)-1):\\n                for e in BFE:\\n                    i = e[0]\\n                    j = e[1]\\n                    if V[i][\\'distance\\'] < INF and E[i][j] and E[i][j][\\'capacity\\']:\\n                        tmp = V[i][\\'distance\\'] + E[i][j][\\'cost\\']\\n                        if V[j][\\'distance\\'] > tmp:\\n                            V[j][\\'distance\\'] = tmp\\n                            V[j][\\'prev\\'] = i\\n                            capacity = min(capacity, E[i][j][\\'capacity\\'])\\n            \\n            if V[1][\\'distance\\'] == INF:\\n                return None\\n            \\n            t = [1]\\n            while V[t[len(t)-1]][\\'prev\\'] != None:\\n                t.append(V[t[len(t)-1]][\\'prev\\'])\\n            t.reverse()\\n            return (t, capacity);\\n        \\n        def debug():\\n            for row in E:\\n                print(*map(lambda e: e and (e[\\'capacity\\'], e[\\'cost\\']), row))\\n            for i, v in enumerate(V):\\n                print(i, v)\\n        \\n\\t\\t# Ford-Fulkerson\\n        p = path2()\\n        while p:\\n            for i in range(len(p[0])-1):\\n                E[p[0][i]][p[0][i+1]][\\'capacity\\'] -= p[1]\\n                E[p[0][i+1]][p[0][i]][\\'capacity\\'] += p[1]\\n            result -= V[1][\\'distance\\'] * p[1]\\n            p = path2()\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131243,
                "title": "dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[9][(1<<18)+50];\\n    \\n    int sol(int i,int mask,vector<int> &a,int &slots)\\n    {\\n        if(mask==((1<<a.size())-1)) return 0;\\n        if(i==slots || (a.size()-__builtin_popcount(mask))>2*(slots-i)) return -1e9;\\n        \\n        int ans=dp[i][mask];\\n        if(ans!=-1) return ans;\\n        ans=sol(i+1,mask,a,slots);\\n        \\n        for(int j=0;j<a.size();j++)\\n            for(int k=0;k<a.size();k++)\\n                if((mask & (1<<j))==0 && (mask & (1<<k))==0)\\n                    ans=max(ans,((i+1)&a[j]) + ((i+1)&a[k]) - ((i+1)&a[j])*(j==k) + sol(i+1,mask|(1<<j)|(1<<k),a,slots));\\n        \\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int maximumANDSum(vector<int>& a, int slots) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,a,slots);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[9][(1<<18)+50];\\n    \\n    int sol(int i,int mask,vector<int> &a,int &slots)\\n    {\\n        if(mask==((1<<a.size())-1)) return 0;\\n        if(i==slots || (a.size()-__builtin_popcount(mask))>2*(slots-i)) return -1e9;\\n        \\n        int ans=dp[i][mask];\\n        if(ans!=-1) return ans;\\n        ans=sol(i+1,mask,a,slots);\\n        \\n        for(int j=0;j<a.size();j++)\\n            for(int k=0;k<a.size();k++)\\n                if((mask & (1<<j))==0 && (mask & (1<<k))==0)\\n                    ans=max(ans,((i+1)&a[j]) + ((i+1)&a[k]) - ((i+1)&a[j])*(j==k) + sol(i+1,mask|(1<<j)|(1<<k),a,slots));\\n        \\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int maximumANDSum(vector<int>& a, int slots) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,a,slots);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116673,
                "title": "97-fast-dp-bitmasking-recursive-solution",
                "content": "class Solution {\\npublic:\\n    int dp[1<<18];\\n    int solve(int mask,int x,int n,int m,vector<int>&nums)\\n    {\\n        if (x==n) return 0;\\n        if(dp[mask]!=-1)return dp[mask];\\n        int ans=-1e9;\\n        for(int i=0;i<m;i++)\\n        {\\n           if((mask&(1<<(2*i)))==0)\\n           {\\n               ans=max(ans,(nums[x]&(i+1))+solve((mask|(1<<(2*i))),x+1,n,m,nums));\\n           }\\n           else if((mask&(1<<(2*i+1)))==0)\\n           {\\n               ans=max(ans,(nums[x]&(i+1))+solve((mask|(1<<(2*i+1))),x+1,n,m,nums));\\n           }\\n           \\n        }\\n           return dp[mask]=ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n=nums.size();\\n        int m=numSlots;\\n        for(int i=0;i<(1<<(2*m));i++)\\n        {\\n            dp[i]=-1;\\n        }\\n        return solve(0,0,n,m,nums);\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[1<<18];\\n    int solve(int mask,int x,int n,int m,vector<int>&nums)\\n    {\\n        if (x==n) return 0;\\n        if(dp[mask]!=-1)return dp[mask];\\n        int ans=-1e9;\\n        for(int i=0;i<m;i++)\\n        {\\n           if((mask&(1<<(2*i)))==0)\\n           {\\n               ans=max(ans,(nums[x]&(i+1))+solve((mask|(1<<(2*i))),x+1,n,m,nums));\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2058166,
                "title": "c-hungarian-algorithm-beats-100-time-and-98-space",
                "content": "```\\n\\n//credit to Andrej Lopatin for which this implementation is based on\\n\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n = nums.size();\\n        int m = 2 * numSlots;\\n        vector<vector<int>> A(n + 1,vector<int>(m + 1,0));\\n        for (int i = 1; i <= n; ++i){\\n            for (int j = 1; j <= numSlots; ++j){\\n                A[i][j] = -1 * (nums[i - 1] & j);\\n                A[i][j + numSlots] = (-1) * (nums[i - 1] & j);\\n            }  \\n        }\\n        vector<int> u(n + 1), v(m + 1), p(m + 1), way(m + 1);\\n        for (int i = 1; i <= n; ++i) {\\n            p[0] = i;\\n            int j0 = 0;\\n            vector<int> minv(m + 1, INT_MAX);\\n            vector<char> used(m + 1, false);\\n            do {\\n                used[j0] = true;\\n                int i0 = p[j0], delta = INT_MAX, j1;\\n                for (int j = 1; j <= m; ++j)\\n                    if (!used[j]) {\\n                        int cur = A[i0][j] - u[i0] - v[j];\\n                        if (cur < minv[j])\\n                            minv[j] = cur, way[j] = j0;\\n                        if (minv[j] < delta)\\n                            delta = minv[j], j1 = j;\\n                    }\\n                for (int j = 0; j <= m; ++j)\\n                    if (used[j])\\n                        u[p[j]] += delta, v[j] -= delta;\\n                    else\\n                        minv[j] -= delta;\\n                j0 = j1;\\n            } while (p[j0] != 0);\\n            do {\\n                int j1 = way[j0];\\n                p[j0] = p[j1];\\n                j0 = j1;\\n            } while (j0);\\n        }\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n//credit to Andrej Lopatin for which this implementation is based on\\n\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int n = nums.size();\\n        int m = 2 * numSlots;\\n        vector<vector<int>> A(n + 1,vector<int>(m + 1,0));\\n        for (int i = 1; i <= n; ++i){\\n            for (int j = 1; j <= numSlots; ++j){\\n                A[i][j] = -1 * (nums[i - 1] & j);\\n                A[i][j + numSlots] = (-1) * (nums[i - 1] & j);\\n            }  \\n        }\\n        vector<int> u(n + 1), v(m + 1), p(m + 1), way(m + 1);\\n        for (int i = 1; i <= n; ++i) {\\n            p[0] = i;\\n            int j0 = 0;\\n            vector<int> minv(m + 1, INT_MAX);\\n            vector<char> used(m + 1, false);\\n            do {\\n                used[j0] = true;\\n                int i0 = p[j0], delta = INT_MAX, j1;\\n                for (int j = 1; j <= m; ++j)\\n                    if (!used[j]) {\\n                        int cur = A[i0][j] - u[i0] - v[j];\\n                        if (cur < minv[j])\\n                            minv[j] = cur, way[j] = j0;\\n                        if (minv[j] < delta)\\n                            delta = minv[j], j1 = j;\\n                    }\\n                for (int j = 0; j <= m; ++j)\\n                    if (used[j])\\n                        u[p[j]] += delta, v[j] -= delta;\\n                    else\\n                        minv[j] -= delta;\\n                j0 = j1;\\n            } while (p[j0] != 0);\\n            do {\\n                int j1 = way[j0];\\n                p[j0] = p[j1];\\n                j0 = j1;\\n            } while (j0);\\n        }\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043157,
                "title": "python-super-simple-top-down-dp-explained",
                "content": "This is a typical top down + bit mask question. \\nGiven its rather small number ranges, we are able to keep trying different combinations for each number. \\nWe use a bit mask to keep track of slots that are used. There are at most 9 slots, and each can store two. So our bit mask is at most 18 bits long. \\nWe make bits `[0, 1]` to record for the first slot, and `[2, 3]` for the second, and so on. In other words, the bits for slot `x` is `[2 * x - 1, 2 * x - 2]`.\\n\\nThere is really nothing trick about the recursion part, and I will skip it.\\n\\n```python\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        size = len(nums)\\n        @lru_cache(None)\\n        def assign(index, used):\\n            if index >= size: return 0\\n            max_sum = 0\\n            for slot in range(1, numSlots + 1):\\n                next_used = -1\\n                if used & (1 << (slot * 2 - 1)) == 0: # check the first bit of the slot\\n                    next_used = used | (1 << (slot * 2 - 1))\\n                elif used & (1 << (slot * 2 - 2)) == 0: # check the second bit of the slot\\n                    next_used = used | (1 << (slot * 2 - 2))\\n                if next_used < 0: continue # slot not available\\n                and_res = nums[index] & slot # and result\\n                max_sum = max(max_sum, and_res + assign(index + 1, next_used)) \\n            return max_sum\\n        return assign(0, 0)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        size = len(nums)\\n        @lru_cache(None)\\n        def assign(index, used):\\n            if index >= size: return 0\\n            max_sum = 0\\n            for slot in range(1, numSlots + 1):\\n                next_used = -1\\n                if used & (1 << (slot * 2 - 1)) == 0: # check the first bit of the slot\\n                    next_used = used | (1 << (slot * 2 - 1))\\n                elif used & (1 << (slot * 2 - 2)) == 0: # check the second bit of the slot\\n                    next_used = used | (1 << (slot * 2 - 2))\\n                if next_used < 0: continue # slot not available\\n                and_res = nums[index] & slot # and result\\n                max_sum = max(max_sum, and_res + assign(index + 1, next_used)) \\n            return max_sum\\n        return assign(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016496,
                "title": "c-bitmask-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int getUnusedBits(int num){\\n        int ans = 0;\\n        while(num != 0){\\n            if(num % 2){\\n                ans++;\\n            }\\n            num /= 2;\\n        }\\n        return ans;\\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int len = 2 * numSlots;\\n        int mask = 1 << len;\\n        int i, j, k, l;\\n        \\n        vector<int> dp(mask);\\n        \\n        for(i = 1; i < mask; i++){\\n            l = len - getUnusedBits(i);\\n            \\n            for(j = 0; j < len; j++){\\n                k = 1 << j; \\n                if(k & i){\\n                    if(l >= nums.size()){\\n                        dp[i] = max(dp[i], dp[i - k]);\\n                    }\\n                    else{\\n                        dp[i] = max(dp[i], dp[i - k] + (nums[nums.size() - l - 1] & (j / 2 + 1)));   \\n                    }\\n                }\\n            }\\n        }\\n        return dp[mask - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getUnusedBits(int num){\\n        int ans = 0;\\n        while(num != 0){\\n            if(num % 2){\\n                ans++;\\n            }\\n            num /= 2;\\n        }\\n        return ans;\\n    }\\n    \\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        int len = 2 * numSlots;\\n        int mask = 1 << len;\\n        int i, j, k, l;\\n        \\n        vector<int> dp(mask);\\n        \\n        for(i = 1; i < mask; i++){\\n            l = len - getUnusedBits(i);\\n            \\n            for(j = 0; j < len; j++){\\n                k = 1 << j; \\n                if(k & i){\\n                    if(l >= nums.size()){\\n                        dp[i] = max(dp[i], dp[i - k]);\\n                    }\\n                    else{\\n                        dp[i] = max(dp[i], dp[i - k] + (nums[nums.size() - l - 1] & (j / 2 + 1)));   \\n                    }\\n                }\\n            }\\n        }\\n        return dp[mask - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840294,
                "title": "c-bfs-solution",
                "content": "state is the bitmask of number of cards in each slot, which can be represented as an integer with 2 * numslots bits. Each 2 bits are used to represent number of cards in each slot.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int ns) {\\n        queue<array<int, 2>> q;\\n        q.push({0, 0});\\n        unordered_map<int, int> m;\\n        for(int i : nums) {\\n            m.clear();\\n            while(!q.empty()) {\\n                auto h = q.front();\\n                q.pop();\\n                for(int j = 0; j < ns; j++) {\\n                    int t = (h[0] >> (2 * j)) & 3;\\n                    if(t < 2) {\\n                        int key = h[0] + (1 << (2 * j));\\n                        m[key] = max(m[key], h[1] + (i & (j + 1)));\\n                    }\\n                }\\n            }\\n            for(auto& t : m) q.push({t.first, t.second});\\n        }\\n        int res = 0;\\n        for(auto& t : m) res = max(res, t.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int ns) {\\n        queue<array<int, 2>> q;\\n        q.push({0, 0});\\n        unordered_map<int, int> m;\\n        for(int i : nums) {\\n            m.clear();\\n            while(!q.empty()) {\\n                auto h = q.front();\\n                q.pop();\\n                for(int j = 0; j < ns; j++) {\\n                    int t = (h[0] >> (2 * j)) & 3;\\n                    if(t < 2) {\\n                        int key = h[0] + (1 << (2 * j));\\n                        m[key] = max(m[key], h[1] + (i & (j + 1)));\\n                    }\\n                }\\n            }\\n            for(auto& t : m) q.push({t.first, t.second});\\n        }\\n        int res = 0;\\n        for(auto& t : m) res = max(res, t.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824599,
                "title": "golang-simple-dp-without-bitmasks-10-based",
                "content": "Based on this solution (good explanation and simple):\\nhttps://leetcode.com/problems/maximum-and-sum-of-array/discuss/1769139/Python.-Simple-dp-solution-without-bitmask-with-explanation\\n\\n```\\nfunc maximumANDSum(nums []int, numSlots int) int {\\n\\troom, _ := strconv.Atoi(\"222222222\"[:numSlots])\\n\\tmemo := make(map[int]int)\\n\\treturn dp(0, room, numSlots, nums, memo)\\n}\\n\\nfunc dp(pos, room, numSlots int, nums []int, memo map[int]int) int {\\n\\tif pos == len(nums) {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif memo[room] > 0 {\\n\\t\\treturn memo[room]\\n\\t}\\n\\n\\tfor slot := 1; slot <= numSlots; slot++ {\\n\\t\\tbase := int(math.Pow(10, float64(slot)-1))\\n\\n\\t\\tleft := (room / base) % 10\\n\\t\\tif left > 0 {\\n\\t\\t\\tmemo[room] = max(memo[room], (nums[pos]&slot)+dp(pos+1, room-base, numSlots, nums, memo))\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo[room]\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfunc maximumANDSum(nums []int, numSlots int) int {\\n\\troom, _ := strconv.Atoi(\"222222222\"[:numSlots])\\n\\tmemo := make(map[int]int)\\n\\treturn dp(0, room, numSlots, nums, memo)\\n}\\n\\nfunc dp(pos, room, numSlots int, nums []int, memo map[int]int) int {\\n\\tif pos == len(nums) {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif memo[room] > 0 {\\n\\t\\treturn memo[room]\\n\\t}\\n\\n\\tfor slot := 1; slot <= numSlots; slot++ {\\n\\t\\tbase := int(math.Pow(10, float64(slot)-1))\\n\\n\\t\\tleft := (room / base) % 10\\n\\t\\tif left > 0 {\\n\\t\\t\\tmemo[room] = max(memo[room], (nums[pos]&slot)+dp(pos+1, room-base, numSlots, nums, memo))\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo[room]\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802240,
                "title": "simple-recursive-dp-in-python-3",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @lru_cache(maxsize = None)\\n        def helper(usage_arr, remained_elements):\\n            if len(remained_elements) == 0:\\n                return 0\\n            max_val = 0\\n            for i in range(len(usage_arr)):\\n                if usage_arr[i] <=1:\\n                    val = helper(usage_arr[0:i]+(usage_arr[i]+1, )+ usage_arr[i+1:len(usage_arr)], remained_elements[1:len(remained_elements)])\\n                    val += remained_elements[0] & (i+1)\\n                    max_val = max(max_val, val)  \\n            return max_val\\n        \\n        res = helper((0,)*numSlots,tuple(nums) )\\n        return res\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @lru_cache(maxsize = None)\\n        def helper(usage_arr, remained_elements):\\n            if len(remained_elements) == 0:\\n                return 0\\n            max_val = 0\\n            for i in range(len(usage_arr)):\\n                if usage_arr[i] <=1:\\n                    val = helper(usage_arr[0:i]+(usage_arr[i]+1, )+ usage_arr[i+1:len(usage_arr)], remained_elements[1:len(remained_elements)])\\n                    val += remained_elements[0] & (i+1)\\n                    max_val = max(max_val, val)  \\n            return max_val\\n        \\n        res = helper((0,)*numSlots,tuple(nums) )\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790126,
                "title": "python-dp-with-tuple",
                "content": "```\\nimport json\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        filled = [0 for _ in range(numSlots)]\\n        n = len(nums)\\n        nums.sort()\\n        taken = [False for _ in range(n)]\\n        filled = [0 for _ in range(numSlots)]\\n        \\n        @cache\\n        def dp(i=0, filled=tuple(filled)):\\n            if i >= n:\\n                return 0\\n            res = 0\\n            filled = list(filled)\\n            \\n            for j in range(numSlots):\\n                if filled[j] < 2:\\n                    filled[j] += 1\\n                    res  = max(res,(nums[i]&(j+1))+ dp(i+1, tuple(filled)))\\n                    filled[j] -= 1\\n            return res\\n        \\n        return dp()\\n```",
                "solutionTags": [],
                "code": "```\\nimport json\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        filled = [0 for _ in range(numSlots)]\\n        n = len(nums)\\n        nums.sort()\\n        taken = [False for _ in range(n)]\\n        filled = [0 for _ in range(numSlots)]\\n        \\n        @cache\\n        def dp(i=0, filled=tuple(filled)):\\n            if i >= n:\\n                return 0\\n            res = 0\\n            filled = list(filled)\\n            \\n            for j in range(numSlots):\\n                if filled[j] < 2:\\n                    filled[j] += 1\\n                    res  = max(res,(nums[i]&(j+1))+ dp(i+1, tuple(filled)))\\n                    filled[j] -= 1\\n            return res\\n        \\n        return dp()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790071,
                "title": "bitmask-dp",
                "content": "```\\nfunc maximumANDSum(nums []int, numSlots int) int {\\n    for ; len(nums) < 2 * numSlots; {\\n        nums = append(nums, 0)\\n    }\\n    \\n    maxMask := (1 << len(nums)) - 1\\n    dp := make([]int, maxMask + 1, maxMask + 1)\\n    for mask, _ := range dp {   \\n        cnt := bits.OnesCount(uint(mask))\\n        for i, num := range nums  {\\n            if mask & (1 << i) == 0 {\\n                continue\\n            }\\n            prev := mask & ^ (1 << i)\\n            slot :=  (cnt + 1) / 2\\n            sum := dp[prev] + (slot & num)\\n            if sum > dp[mask] {\\n                dp[mask] = sum\\n            }\\n        }\\n    }\\n    return dp[len(dp) - 1]\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumANDSum(nums []int, numSlots int) int {\\n    for ; len(nums) < 2 * numSlots; {\\n        nums = append(nums, 0)\\n    }\\n    \\n    maxMask := (1 << len(nums)) - 1\\n    dp := make([]int, maxMask + 1, maxMask + 1)\\n    for mask, _ := range dp {   \\n        cnt := bits.OnesCount(uint(mask))\\n        for i, num := range nums  {\\n            if mask & (1 << i) == 0 {\\n                continue\\n            }\\n            prev := mask & ^ (1 << i)\\n            slot :=  (cnt + 1) / 2\\n            sum := dp[prev] + (slot & num)\\n            if sum > dp[mask] {\\n                dp[mask] = sum\\n            }\\n        }\\n    }\\n    return dp[len(dp) - 1]\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1782740,
                "title": "simple-c-bitmask-memo",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    \\n    int dp[19][1025][1025];\\n    \\n    int  recurs(vector<int>& nums,int i,int place1,int place2,int slots)\\n    {\\n        if(i>=nums.size())\\n            return 0;\\n        \\n        \\n        if(dp[i][place1][place2]!=-1)\\n            return dp[i][place1][place2];\\n        \\n        int a=0;\\n        \\n       for(int i1=1;i1<=slots;i1++)\\n       {\\n           if(((1<<i1)&place1)==0)\\n           {\\n               int temp=place1;\\n               temp|=(1<<i1);\\n               a=max(a,recurs(nums,i+1,temp,place2,slots)+(nums[i]&i1));\\n           }\\n           else if(((1<<i1)&place2)==0)\\n           {\\n               int temp=place2;\\n               temp|=(1<<i1);\\n               a=max(a,recurs(nums,i+1,place1,temp,slots)+(nums[i]&i1));\\n           }\\n       }\\n        \\n        return dp[i][place1][place2]=a;\\n    }\\n\\n    \\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(nums,0,0,0,slots);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n    int dp[19][1025][1025];\\n    \\n    int  recurs(vector<int>& nums,int i,int place1,int place2,int slots)\\n    {\\n        if(i>=nums.size())\\n            return 0;\\n        \\n        \\n        if(dp[i][place1][place2]!=-1)\\n            return dp[i][place1][place2];\\n        \\n        int a=0;\\n        \\n       for(int i1=1;i1<=slots;i1++)\\n       {\\n           if(((1<<i1)&place1)==0)\\n           {\\n               int temp=place1;\\n               temp|=(1<<i1);\\n               a=max(a,recurs(nums,i+1,temp,place2,slots)+(nums[i]&i1));\\n           }\\n           else if(((1<<i1)&place2)==0)\\n           {\\n               int temp=place2;\\n               temp|=(1<<i1);\\n               a=max(a,recurs(nums,i+1,place1,temp,slots)+(nums[i]&i1));\\n           }\\n       }\\n        \\n        return dp[i][place1][place2]=a;\\n    }\\n\\n    \\n    int maximumANDSum(vector<int>& nums, int slots) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(nums,0,0,0,slots);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779380,
                "title": "dfs-simple-trick",
                "content": "A liitle tricky: strech base 3 to base 2\\n\\n```\\nclass Solution {\\n    \\n    int n;\\n    int[] dp;\\n    \\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        \\n        n = numSlots * 2;\\n        dp = new int[1 << n + 1];\\n        Arrays.fill(dp, -1);\\n        \\n        return dfs(0, 0, nums, numSlots);\\n    }\\n    \\n    int dfs(int u, int state, int[] nums, int numSlots) { // iterator every number\\n        \\n        if(u == nums.length) return 0;\\n        \\n        if(dp[state] != -1) return dp[state];\\n        \\n        // state -> slot\\n        int res = 0;\\n        \\n        for(int i = 0; i < numSlots * 2; i++){ // iterator slot\\n            // get current slot size in state\\n            int d = state >> i & 1;\\n            if(d == 0){\\n                int nextState = state | (1 << i);\\n                int idx = getOriginalIdx(i + 1);\\n                res = Math.max(res, dfs(u + 1, nextState, nums, numSlots) + (nums[u] & idx));\\n            }\\n        }    \\n        \\n        dp[state] = res;\\n        \\n        return res;\\n        \\n    }\\n    \\n    int getOriginalIdx(int x){\\n        \\n        if(x % (n / 2) == 0 ) return n / 2;    \\n        else return x % (n / 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int n;\\n    int[] dp;\\n    \\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        \\n        n = numSlots * 2;\\n        dp = new int[1 << n + 1];\\n        Arrays.fill(dp, -1);\\n        \\n        return dfs(0, 0, nums, numSlots);\\n    }\\n    \\n    int dfs(int u, int state, int[] nums, int numSlots) { // iterator every number\\n        \\n        if(u == nums.length) return 0;\\n        \\n        if(dp[state] != -1) return dp[state];\\n        \\n        // state -> slot\\n        int res = 0;\\n        \\n        for(int i = 0; i < numSlots * 2; i++){ // iterator slot\\n            // get current slot size in state\\n            int d = state >> i & 1;\\n            if(d == 0){\\n                int nextState = state | (1 << i);\\n                int idx = getOriginalIdx(i + 1);\\n                res = Math.max(res, dfs(u + 1, nextState, nums, numSlots) + (nums[u] & idx));\\n            }\\n        }    \\n        \\n        dp[state] = res;\\n        \\n        return res;\\n        \\n    }\\n    \\n    int getOriginalIdx(int x){\\n        \\n        if(x % (n / 2) == 0 ) return n / 2;    \\n        else return x % (n / 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775422,
                "title": "sol-n-by-keeping-three-states-in-the-bitmask-and-2-as-base",
                "content": "Three states are 0, 1 and 2. The binary representations are 00, 01, 10. So we need two bits to represent these states. \\n```\\nclass Solution {\\n    public int maximumANDSum(int[] A, int ns) {\\n        int[] memo = new int[(1 << (2 * ns)) + 1];\\n        return dp(0, 0, ns, memo, A);\\n    }\\n    \\n    private int dp(int i, int mask, int ns, int[] memo, int[] A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i == A.length) return 0;\\n        \\n        for (int slot = 0; slot < ns; slot++) {\\n            int firstBit = ((mask >> (2 * slot)) & 1), secondBit = (mask >> (1 + (2 * slot)) & 1);\\n            if (firstBit == 0 || secondBit == 0) {\\n                int newMask = 0;\\n                if (firstBit == 0) newMask = mask | (1 << (2 * slot));\\n                else if (secondBit == 0) newMask = mask | (1 << (1 + (2 * slot)));\\n                memo[mask] = Math.max(memo[mask], (A[i] & (slot + 1)) + dp(i + 1, newMask, ns, memo, A));   \\n            }   \\n        }\\n        return memo[mask];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumANDSum(int[] A, int ns) {\\n        int[] memo = new int[(1 << (2 * ns)) + 1];\\n        return dp(0, 0, ns, memo, A);\\n    }\\n    \\n    private int dp(int i, int mask, int ns, int[] memo, int[] A) {\\n        if (memo[mask] > 0) return memo[mask];\\n        if (i == A.length) return 0;\\n        \\n        for (int slot = 0; slot < ns; slot++) {\\n            int firstBit = ((mask >> (2 * slot)) & 1), secondBit = (mask >> (1 + (2 * slot)) & 1);\\n            if (firstBit == 0 || secondBit == 0) {\\n                int newMask = 0;\\n                if (firstBit == 0) newMask = mask | (1 << (2 * slot));\\n                else if (secondBit == 0) newMask = mask | (1 << (1 + (2 * slot)));\\n                memo[mask] = Math.max(memo[mask], (A[i] & (slot + 1)) + dp(i + 1, newMask, ns, memo, A));   \\n            }   \\n        }\\n        return memo[mask];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774226,
                "title": "top-down-dp-solution-easy-understanding",
                "content": "Every slot has at most 2 chances to AND with 2 items from nums. Put mask into base-10 integer to represent slot in range of numSlots. Count from 0 if count to 2, switch the higher digit. If numSlots has 5, we will finally have mask like 22222. \\n```class Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @lru_cache(None)\\n        def dp(i, mask):\\n            if i == len(nums):\\n                return 0\\n            ans = 0\\n            for slot in range(numSlots):\\n                base = 10**slot\\n                if mask // base % 10 < 2:\\n                    ans = max(ans, (nums[i] & (slot + 1)) + dp(i + 1, mask + base))\\n                \\n            return ans\\n\\n        return dp(0, 0)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "Every slot has at most 2 chances to AND with 2 items from nums. Put mask into base-10 integer to represent slot in range of numSlots. Count from 0 if count to 2, switch the higher digit. If numSlots has 5, we will finally have mask like 22222. \\n```class Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @lru_cache(None)\\n        def dp(i, mask):\\n            if i == len(nums):\\n                return 0\\n            ans = 0\\n            for slot in range(numSlots):\\n                base = 10**slot\\n                if mask // base % 10 < 2:\\n                    ans = max(ans, (nums[i] & (slot + 1)) + dp(i + 1, mask + base))\\n                \\n            return ans\\n\\n        return dp(0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 1772914,
                "title": "recursive-with-memoization-python-o-n-3-numslots",
                "content": "Represent available `numSlots` using bits. `11` if still can place 2 numbers in the slot, `01` if can place 1 number, `00` otherwise. Given this representation iterate numbers left to right. So the state space is `index of a number, available slots saved in bitmask`. \\n\\nStandard and easy recursion using this state space.\\n\\n\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums, numSlots):\\n        pw = 1 << (2 * numSlots)\\n        memo = {}\\n\\n        def rec(i = 0, bits = pw - 1):\\n            if i == len(nums): return 0\\n            if (i, bits) not in memo:\\n                mx = 0\\n                for w in range(1, 2 * numSlots, 2):\\n                    if bits & (1 << w):\\n                        mx = max(mx, (nums[i] & w // 2 + 1) + rec(i + 1, bits ^ (1 << w)))\\n                    elif bits & (1 << w - 1):\\n                        mx = max(mx, (nums[i] & w // 2 + 1) + rec(i + 1, bits ^ (1 << w - 1)))\\n\\n                memo[(i, bits)] = mx\\n            return memo[(i, bits)]\\n\\n        return rec()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums, numSlots):\\n        pw = 1 << (2 * numSlots)\\n        memo = {}\\n\\n        def rec(i = 0, bits = pw - 1):\\n            if i == len(nums): return 0\\n            if (i, bits) not in memo:\\n                mx = 0\\n                for w in range(1, 2 * numSlots, 2):\\n                    if bits & (1 << w):\\n                        mx = max(mx, (nums[i] & w // 2 + 1) + rec(i + 1, bits ^ (1 << w)))\\n                    elif bits & (1 << w - 1):\\n                        mx = max(mx, (nums[i] & w // 2 + 1) + rec(i + 1, bits ^ (1 << w - 1)))\\n\\n                memo[(i, bits)] = mx\\n            return memo[(i, bits)]\\n\\n        return rec()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771707,
                "title": "java-bottom-up-dp-bit-mask",
                "content": "```\\nclass Solution {\\n    //bottom-up DP\\n    int[] power = new int[]{1,3,9,27,81,243,729,2187,6561,19683};\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        \\n        int[] dp = new int[power[numSlots]];\\n        Set<Integer> masks = new HashSet<>();\\n        masks.add(0);\\n        for(int n:nums){\\n            Set<Integer> newMasks = new HashSet<>();\\n            for(int mask:masks){\\n                int sum = dp[mask];\\n                for(int i=1;i<=numSlots;i++){\\n                    if(mask/power[i-1]%3<2){\\n                        int newMask = mask + power[i-1];\\n                        int newSum = sum + (n&i);\\n                        newMasks.add(newMask);\\n                        dp[newMask] = Math.max(dp[newMask],newSum);\\n                    }\\n                }\\n            }\\n            masks = newMasks;\\n//            System.out.println(masks);\\n        }\\n        int maxSum = 0;\\n        for(int mask:masks){\\n            maxSum = Math.max(maxSum,dp[mask]);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //bottom-up DP\\n    int[] power = new int[]{1,3,9,27,81,243,729,2187,6561,19683};\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        \\n        int[] dp = new int[power[numSlots]];\\n        Set<Integer> masks = new HashSet<>();\\n        masks.add(0);\\n        for(int n:nums){\\n            Set<Integer> newMasks = new HashSet<>();\\n            for(int mask:masks){\\n                int sum = dp[mask];\\n                for(int i=1;i<=numSlots;i++){\\n                    if(mask/power[i-1]%3<2){\\n                        int newMask = mask + power[i-1];\\n                        int newSum = sum + (n&i);\\n                        newMasks.add(newMask);\\n                        dp[newMask] = Math.max(dp[newMask],newSum);\\n                    }\\n                }\\n            }\\n            masks = newMasks;\\n//            System.out.println(masks);\\n        }\\n        int maxSum = 0;\\n        for(int mask:masks){\\n            maxSum = Math.max(maxSum,dp[mask]);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771084,
                "title": "c-bitmask",
                "content": "I have represented each slot using two bits, so if there are three slots, our mask will look like 111111.\\nWe can now determine if the slot is occupied or not by considering a 0 based index.\\nChecking the mask at position 3<<(2j) will show us whether a particular slot j is empty or not. In order to test whether one place is left or two places are left we can use 1<<(2j) for checking the first place and 2<<(2j) for checking the second place.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=0;\\n    int dp[300000][20];\\n    int solve(int slot,int mask,vector<int>&nums,int k){\\n        \\n        if(k==nums.size()){\\n            return 0;\\n        }\\n        if(dp[mask][k]!=-1)return dp[mask][k];\\n        \\n        int o1=INT_MIN;\\n        int o2=INT_MIN;\\n        \\n        for(int j=0;j<slot;j++){\\n            \\n            if(mask&(3<<(2*j))){\\n                if(mask&(1<<(2*j))){                                \\n                o1= max(o1,(nums[k]&(j+1))+solve(slot,mask^(1<<(2*j)),nums,k+1));\\n                }\\n                else if(mask&(2<<(2*j))){\\n                 o2=max(o2,(nums[k]&(j+1))+solve(slot,mask^(2<<(2*j)),nums,k+1));\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[mask][k]= max(o1,o2);\\n        \\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        int n=nums.size();\\n        int m=numSlots;\\n        m=m*2;\\n        int mask = (1<<m) -1;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(numSlots,mask,nums,0);\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ans=0;\\n    int dp[300000][20];\\n    int solve(int slot,int mask,vector<int>&nums,int k){\\n        \\n        if(k==nums.size()){\\n            return 0;\\n        }\\n        if(dp[mask][k]!=-1)return dp[mask][k];\\n        \\n        int o1=INT_MIN;\\n        int o2=INT_MIN;\\n        \\n        for(int j=0;j<slot;j++){\\n            \\n            if(mask&(3<<(2*j))){\\n                if(mask&(1<<(2*j))){                                \\n                o1= max(o1,(nums[k]&(j+1))+solve(slot,mask^(1<<(2*j)),nums,k+1));\\n                }\\n                else if(mask&(2<<(2*j))){\\n                 o2=max(o2,(nums[k]&(j+1))+solve(slot,mask^(2<<(2*j)),nums,k+1));\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[mask][k]= max(o1,o2);\\n        \\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        \\n        int n=nums.size();\\n        int m=numSlots;\\n        m=m*2;\\n        int mask = (1<<m) -1;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(numSlots,mask,nums,0);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770295,
                "title": "java-solution-recursion-and-memorization",
                "content": "```\\n    class Solution {\\n\\n        Integer[][] memo; \\n\\t\\t\\n        int f(int[] nums, int mask, int x, int numSlots) {\\n            if (mask == 0 \\n\\t\\t\\t || x > numSlots\\n\\t\\t\\t || Integer.bitCount(mask) > (numSlots - x + 1) * 2) return 0; // the left nums larger than 2*slots\\n      \\n            if (memo[mask][x] != null) return memo[mask][x];\\n\\n            int rst = f(nums, mask, x + 1, numSlots); // case 1: slot not used\\n            for (int i = 0; i < nums.length; i++) { \\n                if ((mask & (1 << i)) == 0) continue;\\n                rst = Math.max(rst, (nums[i] & x) + f(nums, mask & ~(1 << i), x + 1, numSlots)); // case 2: slot used for 1 num\\n            }\\n            for (int i = 0; i < nums.length; i++) {\\n                if ((mask & (1 << i)) == 0) continue;\\n                int and = (nums[i] & x);\\n                for (int j = i + 1; j < nums.length; j++) {\\n                    if ((mask & (1 << j)) == 0) continue;\\n                    rst = Math.max(rst, and + (nums[j] & x) + f(nums, mask & ~(1 << i) & ~(1 << j), x + 1, numSlots)); // case 3:  slot used for 2 nums\\n                }\\n            }\\n            return memo[mask][x] = rst;\\n        }\\n\\n        public int maximumANDSum(int[] nums, int numSlots) {\\n            memo = new Integer[(1 << nums.length)][numSlots + 1];\\n            return f(nums, (1 << nums.length) - 1, 1, numSlots);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\n    class Solution {\\n\\n        Integer[][] memo; \\n\\t\\t\\n        int f(int[] nums, int mask, int x, int numSlots) {\\n            if (mask == 0 \\n\\t\\t\\t || x > numSlots\\n\\t\\t\\t || Integer.bitCount(mask) > (numSlots - x + 1) * 2) return 0; // the left nums larger than 2*slots\\n      \\n            if (memo[mask][x] != null) return memo[mask][x];\\n\\n            int rst = f(nums, mask, x + 1, numSlots); // case 1: slot not used\\n            for (int i = 0; i < nums.length; i++) { \\n                if ((mask & (1 << i)) == 0) continue;\\n                rst = Math.max(rst, (nums[i] & x) + f(nums, mask & ~(1 << i), x + 1, numSlots)); // case 2: slot used for 1 num\\n            }\\n            for (int i = 0; i < nums.length; i++) {\\n                if ((mask & (1 << i)) == 0) continue;\\n                int and = (nums[i] & x);\\n                for (int j = i + 1; j < nums.length; j++) {\\n                    if ((mask & (1 << j)) == 0) continue;\\n                    rst = Math.max(rst, and + (nums[j] & x) + f(nums, mask & ~(1 << i) & ~(1 << j), x + 1, numSlots)); // case 3:  slot used for 2 nums\\n                }\\n            }\\n            return memo[mask][x] = rst;\\n        }\\n\\n        public int maximumANDSum(int[] nums, int numSlots) {\\n            memo = new Integer[(1 << nums.length)][numSlots + 1];\\n            return f(nums, (1 << nums.length) - 1, 1, numSlots);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770259,
                "title": "c-bottom-up-dp-solution",
                "content": "A bottom-up implementation of https://leetcode.com/problems/maximum-and-sum-of-array/discuss/1766824/JavaC%2B%2BPython-DP-Solution\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        const int maskSize = pow(3, numSlots);\\n        const int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(maskSize, 0));\\n        int max_sum = 0;\\n        //recurrence\\n        for(int i=0;i<n;++i){\\n            for(int mask=0;mask<maskSize;++mask){\\n                for(int bit = 1, slot = 1;slot <= numSlots;++slot, bit *= 3){\\n                    if(mask / bit % 3 > 0){\\n                        if(i-1 >= 0){\\n                            dp[i][mask] = max(dp[i][mask], (nums[i] & slot) + dp[i-1][mask - bit]);   \\n                        } else {\\n                            dp[i][mask] = max(dp[i][mask], nums[i] & slot);   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //retrieve\\n        for(int mask=0;mask<maskSize;++mask){\\n            max_sum = max(max_sum, dp[n-1][mask]);\\n        }\\n        return max_sum;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        const int maskSize = pow(3, numSlots);\\n        const int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(maskSize, 0));\\n        int max_sum = 0;\\n        //recurrence\\n        for(int i=0;i<n;++i){\\n            for(int mask=0;mask<maskSize;++mask){\\n                for(int bit = 1, slot = 1;slot <= numSlots;++slot, bit *= 3){\\n                    if(mask / bit % 3 > 0){\\n                        if(i-1 >= 0){\\n                            dp[i][mask] = max(dp[i][mask], (nums[i] & slot) + dp[i-1][mask - bit]);   \\n                        } else {\\n                            dp[i][mask] = max(dp[i][mask], nums[i] & slot);   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //retrieve\\n        for(int mask=0;mask<maskSize;++mask){\\n            max_sum = max(max_sum, dp[n-1][mask]);\\n        }\\n        return max_sum;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770221,
                "title": "c-bitmask-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  long getMax(vector<int>& nums, int numIdx, int numSlots, long mask,\\n            unordered_map<long, long>& cache) {\\n    if (numIdx == nums.size()) {\\n      return 0;\\n    }\\n    if (cache.find(mask) != cache.end()) {\\n      return cache[mask];\\n    }\\n    long soFar = 0;\\n    long num = nums[numIdx];\\n    for (long slot = 1; slot <= 2 * numSlots; ++slot) {\\n      if ((mask & (1 << (slot - 1))) != 0) continue;\\n      long actualSlot = slot > numSlots ? slot - numSlots : slot;\\n      long b = num & actualSlot;\\n      long tot = b + getMax(nums, numIdx + 1, numSlots, mask | (1 << (slot - 1)), cache);\\n      soFar = max(soFar, tot);\\n    }\\n    cache[mask] = soFar;\\n    return soFar;\\n  }\\n  \\n  int maximumANDSum(vector<int>& nums, int numSlots) {\\n    unordered_map<long, long> cache;\\n    return getMax(nums, 0, numSlots, 0, cache);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  long getMax(vector<int>& nums, int numIdx, int numSlots, long mask,\\n            unordered_map<long, long>& cache) {\\n    if (numIdx == nums.size()) {\\n      return 0;\\n    }\\n    if (cache.find(mask) != cache.end()) {\\n      return cache[mask];\\n    }\\n    long soFar = 0;\\n    long num = nums[numIdx];\\n    for (long slot = 1; slot <= 2 * numSlots; ++slot) {\\n      if ((mask & (1 << (slot - 1))) != 0) continue;\\n      long actualSlot = slot > numSlots ? slot - numSlots : slot;\\n      long b = num & actualSlot;\\n      long tot = b + getMax(nums, numIdx + 1, numSlots, mask | (1 << (slot - 1)), cache);\\n      soFar = max(soFar, tot);\\n    }\\n    cache[mask] = soFar;\\n    return soFar;\\n  }\\n  \\n  int maximumANDSum(vector<int>& nums, int numSlots) {\\n    unordered_map<long, long> cache;\\n    return getMax(nums, 0, numSlots, 0, cache);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769321,
                "title": "python-o-1-solution-w-keyblade",
                "content": "So, you have come this far and still you understand nothing. Every light must fade, every heart...\\n```python\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        return \"to darkness!\"\\n```\\nIt is I, ANDsum, the seeker of darkness.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        return \"to darkness!\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769282,
                "title": "java-dfs-mem",
                "content": "```\\nclass Solution {\\n    // for each num:\\n    //   for each bucket\\n    //      if (bucket-size < 2)\\n    //         update sum + update bucket size + dfs()..\\n    // compare final sum\\n    // dfs(currIdx, bucketSizes:int, currSum)\\n    // dp[i][bucketSizes], bucketSizes = 1 << numSlots\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        int bucketSizes = (1 << (2*numSlots) );\\n        int[] mem = new int[bucketSizes];\\n        Arrays.fill(mem, Integer.MIN_VALUE);\\n        return dfs(0, 0, mem, nums, numSlots);\\n    }\\n    \\n    private int dfs(int currIdx, int currBucketSizes, int[] mem, int[] nums, int numSlots) {\\n        if (currIdx == nums.length)\\n            return 0;\\n        if (mem[currBucketSizes] >= 0) {\\n            return mem[currBucketSizes];\\n        }\\n        \\n        int max = 0;\\n        for(int currSlot = 1 ; currSlot <= numSlots ; currSlot++) {\\n            int currBucketIdx = currSlot - 1;\\n            int currBucketSize = getBucketSize(currBucketSizes, currBucketIdx);\\n            \\n            if (currBucketSize < 2) {\\n                int andRes = (nums[currIdx] & currSlot);\\n                int nextBucketSizes = setBucketSizes(currBucketSizes, currBucketIdx, currBucketSize + 1);\\n                \\n                max = Math.max(max, andRes + dfs(currIdx+1, nextBucketSizes, mem, nums, numSlots));\\n            }\\n        }\\n        \\n        return mem[currBucketSizes] = max;\\n    }\\n    \\n    private int getBucketSize(int bucketSizes, int ithBucket) {\\n        return (bucketSizes >> (2 * ithBucket) ) & 3;\\n    }\\n    \\n    private int setBucketSizes(int bucketSizes, int ithBucket, int newVal) {\\n        return bucketSizes ^ (getBucketSize(bucketSizes, ithBucket) << (2 * ithBucket)) | (newVal << (2 * ithBucket) );\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // for each num:\\n    //   for each bucket\\n    //      if (bucket-size < 2)\\n    //         update sum + update bucket size + dfs()..\\n    // compare final sum\\n    // dfs(currIdx, bucketSizes:int, currSum)\\n    // dp[i][bucketSizes], bucketSizes = 1 << numSlots\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        int bucketSizes = (1 << (2*numSlots) );\\n        int[] mem = new int[bucketSizes];\\n        Arrays.fill(mem, Integer.MIN_VALUE);\\n        return dfs(0, 0, mem, nums, numSlots);\\n    }\\n    \\n    private int dfs(int currIdx, int currBucketSizes, int[] mem, int[] nums, int numSlots) {\\n        if (currIdx == nums.length)\\n            return 0;\\n        if (mem[currBucketSizes] >= 0) {\\n            return mem[currBucketSizes];\\n        }\\n        \\n        int max = 0;\\n        for(int currSlot = 1 ; currSlot <= numSlots ; currSlot++) {\\n            int currBucketIdx = currSlot - 1;\\n            int currBucketSize = getBucketSize(currBucketSizes, currBucketIdx);\\n            \\n            if (currBucketSize < 2) {\\n                int andRes = (nums[currIdx] & currSlot);\\n                int nextBucketSizes = setBucketSizes(currBucketSizes, currBucketIdx, currBucketSize + 1);\\n                \\n                max = Math.max(max, andRes + dfs(currIdx+1, nextBucketSizes, mem, nums, numSlots));\\n            }\\n        }\\n        \\n        return mem[currBucketSizes] = max;\\n    }\\n    \\n    private int getBucketSize(int bucketSizes, int ithBucket) {\\n        return (bucketSizes >> (2 * ithBucket) ) & 3;\\n    }\\n    \\n    private int setBucketSizes(int bucketSizes, int ithBucket, int newVal) {\\n        return bucketSizes ^ (getBucketSize(bucketSizes, ithBucket) << (2 * ithBucket)) | (newVal << (2 * ithBucket) );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768794,
                "title": "python-dp",
                "content": "````\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        slot_states = [0] * numSlots\\n        N = len(nums)\\n        cache = dict()\\n        \\n        def dp(index, state):\\n            if index == N: return 0\\n            state_tuple = tuple(state)\\n            key = (index, state_tuple)\\n            if key in cache: return cache[key]\\n            \\n            result = 0\\n            \\n            for slot_index in range(numSlots):\\n                if state[slot_index] < 2:\\n                    state[slot_index] += 1\\n                    candidate = (slot_index + 1) & nums[index]\\n                    candidate += dp(index + 1, state)\\n                    result = max(result, candidate)\\n                    state[slot_index] -= 1\\n            \\n            cache[key] = result\\n            \\n            return result\\n        \\n        return dp(0, slot_states)\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        slot_states = [0] * numSlots\\n        N = len(nums)\\n        cache = dict()\\n        \\n        def dp(index, state):\\n            if index == N: return 0\\n            state_tuple = tuple(state)\\n            key = (index, state_tuple)\\n            if key in cache: return cache[key]\\n            \\n            result = 0\\n            \\n            for slot_index in range(numSlots):\\n                if state[slot_index] < 2:\\n                    state[slot_index] += 1\\n                    candidate = (slot_index + 1) & nums[index]\\n                    candidate += dp(index + 1, state)\\n                    result = max(result, candidate)\\n                    state[slot_index] -= 1\\n            \\n            cache[key] = result\\n            \\n            return result\\n        \\n        return dp(0, slot_states)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768782,
                "title": "python-3-simulation-needs-proof",
                "content": "This is a lot longer than most of the solutions here but I figured I\\'d share and explain anyway.\\n\\nAlgorithm: \\n1. Start with all of the leftmost slots filled with all of the numbers.\\n2. Until no improvements have been made for two iterations, perform the following:\\n\\t3. Compare every pair of slots and consider all configurations of those two slots.\\n\\t\\t4. For each pair, switch to the first best configuration of the neighboring state\\n\\t\\t5. An improvement is made if the new state of those two slots is better than the old state\\n6. Calculate the score\\n\\nI originally wrote this to search for only one \"degree of completeness\" which reached a local maximum on the second test case. Surprisingly, performing this for two iterations was enough to pass all test cases. I\\'m curious if someone can find a counter example that causes this approach to fail, as I\\'m not aware of any reason there can\\'t be an input that causes this approach to get stuck on a wider local maximum.\\n\\n```python\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        # Initial setup\\n        slots = deque()\\n        for _ in range(numSlots):\\n            slot = []\\n            while nums and len(slot) < 2:\\n                slot.insert(0, nums.pop())\\n            while len(slot) < 2:\\n                slot.append(0)\\n            slots.insert(0, slot)\\n        \\n        # Optimize\\n        doi = 2  # \"Degrees of incompleteness\"\\n        while doi:\\n            incomplete = False\\n            slots = list(slots)\\n            for i, a in enumerate(slots, start=1):\\n                for j, b in enumerate(slots[i:], start=i+1):\\n                    scores = [\\n                        (a[0] & i) + (a[1] & i) + (b[0] & j) + (b[1] & j),\\n                        (a[0] & i) + (a[1] & j) + (b[0] & i) + (b[1] & j),  # Switch inner\\n                        (a[0] & j) + (a[1] & i) + (b[0] & j) + (b[1] & i),  # Switch outer\\n                        (a[0] & j) + (a[1] & i) + (b[0] & i) + (b[1] & j),  # Switch left\\n                        (a[0] & i) + (a[1] & j) + (b[0] & j) + (b[1] & i),  # Switch right\\n                        (a[0] & j) + (a[1] & j) + (b[0] & i) + (b[1] & i),  # Switch both\\n                    ]\\n                    k = max(scores)\\n                    \\n                    swapped = False\\n                    if k == scores[1]:\\n                        a[1], b[0] = b[0], a[1]  # Switch inner\\n                        swapped = True\\n                    elif k == scores[2]:\\n                        a[0], b[1] = b[1], a[0]  # Switch outer\\n                        swapped = True\\n                    elif k == scores[3]:\\n                        a[0], b[0] = b[0], a[0]  # Switch left\\n                        swapped = True\\n                    elif k == scores[4]:\\n                        a[1], b[1] = b[1], a[1]  # Switch right\\n                        swapped = True\\n                    elif k == scores[5]:\\n                        a[0], b[0] = b[0], a[0]  # Switch both\\n                        a[1], b[1] = b[1], a[1]\\n                        swapped = True\\n                    \\n                    if swapped and scores[0] != k:\\n                        incomplete = True\\n                        \\n            if incomplete:\\n                doi = 2\\n            else:\\n                doi -= 1\\n                    \\n        # Calculate current score\\n        score = 0\\n        for i, slot in enumerate(slots, start=1):\\n            for e in slot:\\n                score += i & e\\n                    \\n        return score\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        # Initial setup\\n        slots = deque()\\n        for _ in range(numSlots):\\n            slot = []\\n            while nums and len(slot) < 2:\\n                slot.insert(0, nums.pop())\\n            while len(slot) < 2:\\n                slot.append(0)\\n            slots.insert(0, slot)\\n        \\n        # Optimize\\n        doi = 2  # \"Degrees of incompleteness\"\\n        while doi:\\n            incomplete = False\\n            slots = list(slots)\\n            for i, a in enumerate(slots, start=1):\\n                for j, b in enumerate(slots[i:], start=i+1):\\n                    scores = [\\n                        (a[0] & i) + (a[1] & i) + (b[0] & j) + (b[1] & j),\\n                        (a[0] & i) + (a[1] & j) + (b[0] & i) + (b[1] & j),  # Switch inner\\n                        (a[0] & j) + (a[1] & i) + (b[0] & j) + (b[1] & i),  # Switch outer\\n                        (a[0] & j) + (a[1] & i) + (b[0] & i) + (b[1] & j),  # Switch left\\n                        (a[0] & i) + (a[1] & j) + (b[0] & j) + (b[1] & i),  # Switch right\\n                        (a[0] & j) + (a[1] & j) + (b[0] & i) + (b[1] & i),  # Switch both\\n                    ]\\n                    k = max(scores)\\n                    \\n                    swapped = False\\n                    if k == scores[1]:\\n                        a[1], b[0] = b[0], a[1]  # Switch inner\\n                        swapped = True\\n                    elif k == scores[2]:\\n                        a[0], b[1] = b[1], a[0]  # Switch outer\\n                        swapped = True\\n                    elif k == scores[3]:\\n                        a[0], b[0] = b[0], a[0]  # Switch left\\n                        swapped = True\\n                    elif k == scores[4]:\\n                        a[1], b[1] = b[1], a[1]  # Switch right\\n                        swapped = True\\n                    elif k == scores[5]:\\n                        a[0], b[0] = b[0], a[0]  # Switch both\\n                        a[1], b[1] = b[1], a[1]\\n                        swapped = True\\n                    \\n                    if swapped and scores[0] != k:\\n                        incomplete = True\\n                        \\n            if incomplete:\\n                doi = 2\\n            else:\\n                doi -= 1\\n                    \\n        # Calculate current score\\n        score = 0\\n        for i, slot in enumerate(slots, start=1):\\n            for e in slot:\\n                score += i & e\\n                    \\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768511,
                "title": "python-3-100-time-100-memory-greedy-top-down-dp",
                "content": "Following [lee215\\'s post ](https://leetcode.com/problems/maximum-and-sum-of-array/discuss/1766824/JavaC%2B%2BPython-DP-Solution) using 3-based mask to represent empty, 1 open, full. Plus greedy pre-placement, ends 100% time and memory.\\n\\n![image](https://assets.leetcode.com/users/images/7b25a788-2f15-43d9-b6fa-f9496e2efd78_1644787248.447312.png)\\n\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(idx, bm):\\n            if idx == n:\\n                return 0\\n            res = 0\\n            v = arr[idx]\\n            for i in range(numSlots):\\n                b = 3 ** i\\n                if (bm // b) % 3 > 0:\\n                    res = max(res, (v & (i + 1)) + dp(idx + 1, bm - b))\\n            return res\\n        \\n\\t\\t# greedily placing numbers to their matching slots\\n        bm = 3 ** numSlots - 1\\n        fixed = 0\\n        arr = []\\n        for v in nums:\\n            b = 3 ** (v - 1)\\n            if (bm // b) % 3 > 0:\\n                bm -= b\\n                fixed += v\\n            else:\\n                arr.append(v)\\n        \\n\\t\\t# unplaced numbers situated using dp\\n        n = len(arr)\\n        return fixed + dp(0, bm)\\n```\\n\\n\\n\\nMy original solution greedy + dp with 2 bits representing each slot. Quite some redundant calls: for a particular slot, [a, b] or [b, a] are the same but mine regard them as two different states. Sort a and b when placing the 2nd number can resolve it.\\n\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(idx, bm):\\n            if idx == n:\\n                return 0\\n            res = 0\\n            v = arr[idx]\\n            for i in range(2 * numSlots):\\n                if bm & (1 << i):\\n                    j = i // 2 + 1\\n                    res = max(res, (v & j) + dp(idx + 1, bm & ~(1 << i)))\\n            return res\\n        \\n\\t\\t# 2 * numSlots bits to represent the slots\\n        bm = 2 ** (2 * numSlots) - 1\\n        fixed = 0\\n        arr = []\\n        # greedily place numbers into slots with matching values, and collect the unplacable numbers\\n        for v in nums:\\n            if bm & 1 << ((v - 1) * 2):\\n                bm &= ~(1 << ((v - 1) * 2))\\n                fixed += v\\n            elif bm & 1 << ((v - 1) * 2 + 1):\\n                bm &= ~(1 << ((v - 1) * 2 + 1))\\n                fixed += v\\n            else:\\n                arr.append(v)\\n        \\n        n = len(arr)\\n        # dp to place the unplacables\\n        return fixed + dp(0, bm)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(idx, bm):\\n            if idx == n:\\n                return 0\\n            res = 0\\n            v = arr[idx]\\n            for i in range(numSlots):\\n                b = 3 ** i\\n                if (bm // b) % 3 > 0:\\n                    res = max(res, (v & (i + 1)) + dp(idx + 1, bm - b))\\n            return res\\n        \\n\\t\\t# greedily placing numbers to their matching slots\\n        bm = 3 ** numSlots - 1\\n        fixed = 0\\n        arr = []\\n        for v in nums:\\n            b = 3 ** (v - 1)\\n            if (bm // b) % 3 > 0:\\n                bm -= b\\n                fixed += v\\n            else:\\n                arr.append(v)\\n        \\n\\t\\t# unplaced numbers situated using dp\\n        n = len(arr)\\n        return fixed + dp(0, bm)\\n```\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(idx, bm):\\n            if idx == n:\\n                return 0\\n            res = 0\\n            v = arr[idx]\\n            for i in range(2 * numSlots):\\n                if bm & (1 << i):\\n                    j = i // 2 + 1\\n                    res = max(res, (v & j) + dp(idx + 1, bm & ~(1 << i)))\\n            return res\\n        \\n\\t\\t# 2 * numSlots bits to represent the slots\\n        bm = 2 ** (2 * numSlots) - 1\\n        fixed = 0\\n        arr = []\\n        # greedily place numbers into slots with matching values, and collect the unplacable numbers\\n        for v in nums:\\n            if bm & 1 << ((v - 1) * 2):\\n                bm &= ~(1 << ((v - 1) * 2))\\n                fixed += v\\n            elif bm & 1 << ((v - 1) * 2 + 1):\\n                bm &= ~(1 << ((v - 1) * 2 + 1))\\n                fixed += v\\n            else:\\n                arr.append(v)\\n        \\n        n = len(arr)\\n        # dp to place the unplacables\\n        return fixed + dp(0, bm)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767874,
                "title": "iterative-string-representing-state-simple",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {        \\n        int n=nums.size();\\n        vector<map<string,int>> dp(n+1);\\n        dp[0][string(numSlots,\\'2\\')]=0;    //initial each slot can accomodate 2 num, so state represented as \"22222\" for numSlots=5\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(auto &sp:dp[i]){\\n                const string &s=sp.first;\\n                int &val=sp.second;\\n                \\n                for(int j=0;j<numSlots;j++){\\n                    if(s[j]==\\'0\\')           // jth slot already having 2 num\\n                        continue;\\n                    \\n                    string p=s;\\n                    p[j]--;         //state s->p , jth slot can now occupy 1 less, e.g. \"22222\"->\"22122\" for j=2\\n                    \\n                    if(dp[i+1].find(p)==dp[i+1].end())\\n                        dp[i+1][p]=val+(nums[i+1-1]&(j+1));\\n                    else\\n                        dp[i+1][p]=max(dp[i+1][p],val+(nums[i+1-1]&(j+1)));\\n                    \\n                    ans=max(ans,dp[i+1][p]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maximumANDSum(vector<int>& nums, int numSlots) {        \\n        int n=nums.size();\\n        vector<map<string,int>> dp(n+1);\\n        dp[0][string(numSlots,\\'2\\')]=0;    //initial each slot can accomodate 2 num, so state represented as \"22222\" for numSlots=5\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(auto &sp:dp[i]){\\n                const string &s=sp.first;\\n                int &val=sp.second;\\n                \\n                for(int j=0;j<numSlots;j++){\\n                    if(s[j]==\\'0\\')           // jth slot already having 2 num\\n                        continue;\\n                    \\n                    string p=s;\\n                    p[j]--;         //state s->p , jth slot can now occupy 1 less, e.g. \"22222\"->\"22122\" for j=2\\n                    \\n                    if(dp[i+1].find(p)==dp[i+1].end())\\n                        dp[i+1][p]=val+(nums[i+1-1]&(j+1));\\n                    else\\n                        dp[i+1][p]=max(dp[i+1][p],val+(nums[i+1-1]&(j+1)));\\n                    \\n                    ans=max(ans,dp[i+1][p]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767743,
                "title": "bottom-up-dp-c",
                "content": "So bascially i allocate 2 bits for each location. \\n\\n```\\n00 - none filled\\n01/10 - 1 filled\\n11 - 2 filled\\n```\\n\\ndp[mask] - max AND sum given the mask of values for each slot.\\n\\n```\\n    int maximumANDSum(vector<int>& nums, int &numSlots) {\\n        const int n=1<<(numSlots*2);\\n        int dp[n];\\n        for(int i=0;i<n;i++) dp[i]=0;\\n        for(auto &x:nums){\\n            for(int i=n-1;i>=1;i--){\\n                for(int j=0;j<numSlots;j++){ \\n                    if(i&(1<<(2*j))){\\n                        dp[i]=max(dp[i],(x&(j+1))+dp[i^(1<<(2*j))]);\\n                    }\\n                    else if(i&(1<<(2*j+1))){\\n                        dp[i]=max(dp[i],(x&(j+1))+dp[i^(1<<((2*j)+1))]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n00 - none filled\\n01/10 - 1 filled\\n11 - 2 filled\\n```\n```\\n    int maximumANDSum(vector<int>& nums, int &numSlots) {\\n        const int n=1<<(numSlots*2);\\n        int dp[n];\\n        for(int i=0;i<n;i++) dp[i]=0;\\n        for(auto &x:nums){\\n            for(int i=n-1;i>=1;i--){\\n                for(int j=0;j<numSlots;j++){ \\n                    if(i&(1<<(2*j))){\\n                        dp[i]=max(dp[i],(x&(j+1))+dp[i^(1<<(2*j))]);\\n                    }\\n                    else if(i&(1<<(2*j+1))){\\n                        dp[i]=max(dp[i],(x&(j+1))+dp[i^(1<<((2*j)+1))]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1767628,
                "title": "java-dp",
                "content": "The idea is to track the slots using 2 states for slots.\\n\\n\\n\\n```\\npublic int maximumANDSum(int[] nums, int numSlots) {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int num : nums) {\\n      map.put(num, map.getOrDefault(num, 0) + 1);\\n    }\\n    int max = -1;\\n    List<int[]> list = new ArrayList<>();\\n    for (int key : map.keySet()) {\\n      max = Math.max(map.get(key), max);\\n      list.add(new int[] {key, map.get(key)});\\n    }\\n    int[][][][] dp = new int[list.size()][max + 1][(1 << 9)][(1 << 9)];\\n    for (int[][][] row : dp) {\\n      for (int[][] r : row) {\\n        for (int[] x : r) {\\n          Arrays.fill(x, -1);\\n        }\\n      }\\n    }\\n    return solve(list, 0, 0, 0, 0, numSlots, dp);\\n  }\\n\\n  private int solve(List<int[]> arr, int idx, int k, int state1, int state2, int numSlots, int[][][][] dp) {\\n    if (idx >= arr.size()) {\\n      return 0;\\n    }\\n    if (dp[idx][k][state1][state2] != -1) {\\n      return dp[idx][k][state1][state2];\\n    }\\n    if (k == arr.get(idx)[1]) {\\n      return solve(arr, idx + 1, 0, state1, state2, numSlots, dp);\\n    }\\n    int best = Integer.MIN_VALUE / 2;\\n    boolean placed = false;\\n    for (int i = 0; i < numSlots; i++) {\\n      if ((state1 & (1 << i)) == 0 && (state2 & (1 << i)) == 0) {\\n        best = Math.max(best,\\n            (arr.get(idx)[0] & (i + 1)) + solve(arr, idx, k + 1, state1 | (1 << i), state2, numSlots, dp));\\n        best = Math.max(best,\\n            (arr.get(idx)[0] & (i + 1)) + solve(arr, idx, k + 1, state1, state2 | (1 << i), numSlots, dp));\\n        placed = true;\\n      } else if ((state1 & (1 << i)) == 0) {\\n        best = Math.max(best,\\n            (arr.get(idx)[0] & (i + 1)) + solve(arr, idx, k + 1, state1 | (1 << i), state2, numSlots, dp));\\n        placed = true;\\n      } else if ((state2 & (1 << i)) == 0) {\\n        best = Math.max(best,\\n            (arr.get(idx)[0] & (i + 1)) + solve(arr, idx, k + 1, state1, state2 | (1 << i), numSlots, dp));\\n        placed = true;\\n      }\\n    }\\n    if (placed) {\\n      return dp[idx][k][state1][state2] = best;\\n    }\\n    return dp[idx][k][state1][state2] = Integer.MIN_VALUE / 2;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\npublic int maximumANDSum(int[] nums, int numSlots) {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int num : nums) {\\n      map.put(num, map.getOrDefault(num, 0) + 1);\\n    }\\n    int max = -1;\\n    List<int[]> list = new ArrayList<>();\\n    for (int key : map.keySet()) {\\n      max = Math.max(map.get(key), max);\\n      list.add(new int[] {key, map.get(key)});\\n    }\\n    int[][][][] dp = new int[list.size()][max + 1][(1 << 9)][(1 << 9)];\\n    for (int[][][] row : dp) {\\n      for (int[][] r : row) {\\n        for (int[] x : r) {\\n          Arrays.fill(x, -1);\\n        }\\n      }\\n    }\\n    return solve(list, 0, 0, 0, 0, numSlots, dp);\\n  }\\n\\n  private int solve(List<int[]> arr, int idx, int k, int state1, int state2, int numSlots, int[][][][] dp) {\\n    if (idx >= arr.size()) {\\n      return 0;\\n    }\\n    if (dp[idx][k][state1][state2] != -1) {\\n      return dp[idx][k][state1][state2];\\n    }\\n    if (k == arr.get(idx)[1]) {\\n      return solve(arr, idx + 1, 0, state1, state2, numSlots, dp);\\n    }\\n    int best = Integer.MIN_VALUE / 2;\\n    boolean placed = false;\\n    for (int i = 0; i < numSlots; i++) {\\n      if ((state1 & (1 << i)) == 0 && (state2 & (1 << i)) == 0) {\\n        best = Math.max(best,\\n            (arr.get(idx)[0] & (i + 1)) + solve(arr, idx, k + 1, state1 | (1 << i), state2, numSlots, dp));\\n        best = Math.max(best,\\n            (arr.get(idx)[0] & (i + 1)) + solve(arr, idx, k + 1, state1, state2 | (1 << i), numSlots, dp));\\n        placed = true;\\n      } else if ((state1 & (1 << i)) == 0) {\\n        best = Math.max(best,\\n            (arr.get(idx)[0] & (i + 1)) + solve(arr, idx, k + 1, state1 | (1 << i), state2, numSlots, dp));\\n        placed = true;\\n      } else if ((state2 & (1 << i)) == 0) {\\n        best = Math.max(best,\\n            (arr.get(idx)[0] & (i + 1)) + solve(arr, idx, k + 1, state1, state2 | (1 << i), numSlots, dp));\\n        placed = true;\\n      }\\n    }\\n    if (placed) {\\n      return dp[idx][k][state1][state2] = best;\\n    }\\n    return dp[idx][k][state1][state2] = Integer.MIN_VALUE / 2;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1767460,
                "title": "c-weird-runtime",
                "content": "I got two different verdicts upon submitting the same code.\\nOne time it got Accepted , and the second time it got TLE\\n\\nI used <B>Bitmasking</B>(Base 3) + <B>DP</B>\\n```c++\\nclass Solution {\\n    int n;\\n    int m;\\n    int dp[20][60000];\\npublic:\\n    int getBit(int mask,int k){\\n        string s;\\n        while(mask > 0){\\n            int b = mask % 3;\\n            s += to_string(b);\\n            mask /= 3;\\n        }\\n        if(k > s.length())\\n            return 0;\\n        return s[k-1] - \\'0\\';\\n    }\\n    int solve(int idx,int mask,vector<int>& nums){\\n        if(idx >= n)\\n            return 0;\\n        if(dp[idx][mask] != -1)\\n            return dp[idx][mask];\\n        int res = 0;\\n        for(int i=0;i<m;i++){\\n            int b = getBit(mask,i+1);\\n            if(b == 2)\\n                continue;\\n            res = max(res,(nums[idx]&(i+1)) + solve(idx+1,mask + pow(3,i),nums));\\n        }\\n        return dp[idx][mask] = res;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = nums.size();\\n        m = numSlots;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```c++\\nclass Solution {\\n    int n;\\n    int m;\\n    int dp[20][60000];\\npublic:\\n    int getBit(int mask,int k){\\n        string s;\\n        while(mask > 0){\\n            int b = mask % 3;\\n            s += to_string(b);\\n            mask /= 3;\\n        }\\n        if(k > s.length())\\n            return 0;\\n        return s[k-1] - \\'0\\';\\n    }\\n    int solve(int idx,int mask,vector<int>& nums){\\n        if(idx >= n)\\n            return 0;\\n        if(dp[idx][mask] != -1)\\n            return dp[idx][mask];\\n        int res = 0;\\n        for(int i=0;i<m;i++){\\n            int b = getBit(mask,i+1);\\n            if(b == 2)\\n                continue;\\n            res = max(res,(nums[idx]&(i+1)) + solve(idx+1,mask + pow(3,i),nums));\\n        }\\n        return dp[idx][mask] = res;\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        n = nums.size();\\n        m = numSlots;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767417,
                "title": "javascript-graph-mcmf-186ms-dfs-memo-1096ms",
                "content": "```\\n/////////////////////////////////////////////// Template //////////////////////////////////////////////////////////////\\nfunction edge(from, to, cost, cap) {\\n    this.from = from;\\n    this.to = to;\\n    this.cost = cost;\\n    this.cap = cap;\\n}\\n\\nfunction MCMF(n) {\\n    const initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\n    let g = initializeGraph(n), h = Array(n).fill(0), dis = Array(n).fill(0), prev_v = Array(n).fill(0), prev_e = Array(n).fill(0);\\n    return { addEdge, minCostFlow }\\n    function addEdge(from, to, cost, cap) {\\n        g[from].push(new edge(g[to].length, to, cost, cap));\\n        g[to].push(new edge(g[from].length - 1, from, -cost, 0));\\n    }\\n    function minCostFlow(from, to, flow) {\\n        let res = 0;\\n        while (flow > 0) {\\n            let pq = new MinPriorityQueue({\\n                compare: (x, y) => {\\n                    if (x[0] != y[0]) return x[0] - y[0];\\n                    return x[1] - y[1];\\n                }\\n            });\\n            dis.fill(Number.MAX_SAFE_INTEGER);\\n            dis[from] = 0;\\n            pq.enqueue([0, from]);\\n            while (pq.size()) {\\n                let [curDis, cur] = pq.dequeue();\\n                if (dis[cur] < curDis) continue;\\n                for (let i = 0; i < g[cur].length; i++) {\\n                    let child = g[cur][i];\\n                    if (child.cap > 0 && dis[child.to] > dis[cur] + child.cost + h[cur] - h[child.to]) {\\n                        dis[child.to] = dis[cur] + child.cost + h[cur] - h[child.to];\\n                        prev_v[child.to] = cur;\\n                        prev_e[child.to] = i;\\n                        pq.enqueue([dis[child.to], child.to]);\\n                    }\\n                }\\n            }\\n            if (dis[to] == Number.MAX_SAFE_INTEGER) return -1;\\n            for (let i = 0; i < n; i++) h[i] += dis[i];\\n            let d = flow;\\n            for (let i = to; i != from; i = prev_v[i]) {\\n                d = Math.min(d, g[prev_v[i]][prev_e[i]].cap);\\n            }\\n            flow -= d;\\n            res += d * h[to];\\n            for (let i = to; i != from; i = prev_v[i]) {\\n                let edge = g[prev_v[i]][prev_e[i]];\\n                edge.cap -= d;\\n                g[i][edge.from].cap += d;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst maximumANDSum = (a, m) => {\\n    let n = a.length, mcmf = new MCMF(n + m + 2), from = n + m, to = from + 1;\\n    for (let i = 0; i < n; i++) {\\n        mcmf.addEdge(from, i, 0, 1);\\n        for (let j = 0; j < m; j++) {\\n            mcmf.addEdge(i, j + n, -(a[i] & (j + 1)), 1);\\n        }\\n    }\\n    for (let i = 0; i < m; i++) mcmf.addEdge(i + n, to, 0, 2);\\n    return -mcmf.minCostFlow(from, to, n);\\n};\\n```\\nreference: \\nhttps://en.wikipedia.org/wiki/Minimum-cost_flow_problem\\nhttps://cp-algorithms.com/graph/min_cost_flow.html\\n\\n\\nSolution 2  dfs + memo\\n```\\nlet a, memo, n;\\nconst maximumANDSum = (nums, m) => {\\n    a = nums;\\n    memo = new Map();\\n    n = a.length;\\n    let cap = Array(m).fill(2);\\n    return dfs(0, cap);\\n};\\n\\nconst dfs = (pos, cap) => {\\n    if (pos == n) return 0;\\n    let ke = pos + \\' \\' + JSON.stringify(cap);\\n    if (memo.has(ke)) return memo.get(ke);\\n    let len = cap.length, res = 0;\\n    for (let i = 0; i < len; i++) {\\n        if (cap[i] > 0) {\\n            cap[i]--;\\n            res = Math.max(res, (a[pos] & (i + 1)) + dfs(pos + 1, cap));\\n            cap[i]++;\\n        }\\n    }\\n    memo.set(ke, res);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n/////////////////////////////////////////////// Template //////////////////////////////////////////////////////////////\\nfunction edge(from, to, cost, cap) {\\n    this.from = from;\\n    this.to = to;\\n    this.cost = cost;\\n    this.cap = cap;\\n}\\n\\nfunction MCMF(n) {\\n    const initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\n    let g = initializeGraph(n), h = Array(n).fill(0), dis = Array(n).fill(0), prev_v = Array(n).fill(0), prev_e = Array(n).fill(0);\\n    return { addEdge, minCostFlow }\\n    function addEdge(from, to, cost, cap) {\\n        g[from].push(new edge(g[to].length, to, cost, cap));\\n        g[to].push(new edge(g[from].length - 1, from, -cost, 0));\\n    }\\n    function minCostFlow(from, to, flow) {\\n        let res = 0;\\n        while (flow > 0) {\\n            let pq = new MinPriorityQueue({\\n                compare: (x, y) => {\\n                    if (x[0] != y[0]) return x[0] - y[0];\\n                    return x[1] - y[1];\\n                }\\n            });\\n            dis.fill(Number.MAX_SAFE_INTEGER);\\n            dis[from] = 0;\\n            pq.enqueue([0, from]);\\n            while (pq.size()) {\\n                let [curDis, cur] = pq.dequeue();\\n                if (dis[cur] < curDis) continue;\\n                for (let i = 0; i < g[cur].length; i++) {\\n                    let child = g[cur][i];\\n                    if (child.cap > 0 && dis[child.to] > dis[cur] + child.cost + h[cur] - h[child.to]) {\\n                        dis[child.to] = dis[cur] + child.cost + h[cur] - h[child.to];\\n                        prev_v[child.to] = cur;\\n                        prev_e[child.to] = i;\\n                        pq.enqueue([dis[child.to], child.to]);\\n                    }\\n                }\\n            }\\n            if (dis[to] == Number.MAX_SAFE_INTEGER) return -1;\\n            for (let i = 0; i < n; i++) h[i] += dis[i];\\n            let d = flow;\\n            for (let i = to; i != from; i = prev_v[i]) {\\n                d = Math.min(d, g[prev_v[i]][prev_e[i]].cap);\\n            }\\n            flow -= d;\\n            res += d * h[to];\\n            for (let i = to; i != from; i = prev_v[i]) {\\n                let edge = g[prev_v[i]][prev_e[i]];\\n                edge.cap -= d;\\n                g[i][edge.from].cap += d;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst maximumANDSum = (a, m) => {\\n    let n = a.length, mcmf = new MCMF(n + m + 2), from = n + m, to = from + 1;\\n    for (let i = 0; i < n; i++) {\\n        mcmf.addEdge(from, i, 0, 1);\\n        for (let j = 0; j < m; j++) {\\n            mcmf.addEdge(i, j + n, -(a[i] & (j + 1)), 1);\\n        }\\n    }\\n    for (let i = 0; i < m; i++) mcmf.addEdge(i + n, to, 0, 2);\\n    return -mcmf.minCostFlow(from, to, n);\\n};\\n```\n```\\nlet a, memo, n;\\nconst maximumANDSum = (nums, m) => {\\n    a = nums;\\n    memo = new Map();\\n    n = a.length;\\n    let cap = Array(m).fill(2);\\n    return dfs(0, cap);\\n};\\n\\nconst dfs = (pos, cap) => {\\n    if (pos == n) return 0;\\n    let ke = pos + \\' \\' + JSON.stringify(cap);\\n    if (memo.has(ke)) return memo.get(ke);\\n    let len = cap.length, res = 0;\\n    for (let i = 0; i < len; i++) {\\n        if (cap[i] > 0) {\\n            cap[i]--;\\n            res = Math.max(res, (a[pos] & (i + 1)) + dfs(pos + 1, cap));\\n            cap[i]++;\\n        }\\n    }\\n    memo.set(ke, res);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1767332,
                "title": "dp-with-base-3-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    int power[12];\\n    vector<int> a;\\n    int slots;\\n    int n;\\n    int dp[177150];\\n    int func(int i,int mask){\\n        if(i == n){\\n            return 0;\\n        }\\n        int &ans = dp[mask];\\n        if(ans != -1){\\n            return ans;\\n        }\\n        ans = 0;\\n        for(int j=0;j<slots;j++){\\n            int cnt = (mask % power[j+1])/power[j];\\n            if(cnt <= 1){\\n                ans = max(ans,(a[i] & (j+1))+func(i+1,mask + power[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumANDSum(vector<int>& t, int ns) {\\n        a = t;\\n        slots = ns;\\n        n = a.size();\\n        power[0] = 1;\\n        memset(dp,-1,sizeof dp);\\n        for(int i=1;i<12;i++){\\n            power[i] = power[i-1] * 3;\\n        }\\n        int ans = func(0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int power[12];\\n    vector<int> a;\\n    int slots;\\n    int n;\\n    int dp[177150];\\n    int func(int i,int mask){\\n        if(i == n){\\n            return 0;\\n        }\\n        int &ans = dp[mask];\\n        if(ans != -1){\\n            return ans;\\n        }\\n        ans = 0;\\n        for(int j=0;j<slots;j++){\\n            int cnt = (mask % power[j+1])/power[j];\\n            if(cnt <= 1){\\n                ans = max(ans,(a[i] & (j+1))+func(i+1,mask + power[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumANDSum(vector<int>& t, int ns) {\\n        a = t;\\n        slots = ns;\\n        n = a.size();\\n        power[0] = 1;\\n        memset(dp,-1,sizeof dp);\\n        for(int i=1;i<12;i++){\\n            power[i] = power[i-1] * 3;\\n        }\\n        int ans = func(0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767241,
                "title": "python-3-dp-100",
                "content": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        ans = 0\\n        X = tuple([2]*numSlots)\\n        # Allocate the best number to best slot\\n        for j in range(1,numSlots+1):\\n            if j in nums and X[j-1]>0:\\n                X = X[:j-1] + (X[j-1]-1,) + X[j:]\\n                nums.remove(j)\\n                ans += j \\n        n = len(nums)\\n        #standard dp with memonization (exponential complexity)\\n        @lru_cache(None)\\n        def dp(curr,i):\\n            if i==n: return 0\\n            return max((nums[i] & (j+1)) + dp(curr[:j]+(curr[j]-1,)+curr[j+1:],i+1) for j in range(numSlots) if curr[j]>0)\\n        return ans+dp(X,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        ans = 0\\n        X = tuple([2]*numSlots)\\n        # Allocate the best number to best slot\\n        for j in range(1,numSlots+1):\\n            if j in nums and X[j-1]>0:\\n                X = X[:j-1] + (X[j-1]-1,) + X[j:]\\n                nums.remove(j)\\n                ans += j \\n        n = len(nums)\\n        #standard dp with memonization (exponential complexity)\\n        @lru_cache(None)\\n        def dp(curr,i):\\n            if i==n: return 0\\n            return max((nums[i] & (j+1)) + dp(curr[:j]+(curr[j]-1,)+curr[j+1:],i+1) for j in range(numSlots) if curr[j]>0)\\n        return ans+dp(X,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767008,
                "title": "c-basic-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& a, int slots) {\\n        int   n = a.size();\\n        unordered_map<int,map<vector<int>,int>> mp;\\n        function<int(int,vector<int>)> cnt = [&](int i,vector<int> freq)\\n        {\\n            if(i==n)\\n            {return 0;}\\n            if(mp[i].count(freq))\\n            {return  mp[i][freq];}\\n            int ans  = 0;\\n            for(int  j = 0;j<slots;j++)\\n            {\\n                if(freq[j]+1<=2)\\n                {\\n                    freq[j]++;\\n                    ans = max(ans,((j+1) & a[i]) + cnt(i+1,freq));\\n                    freq[j]--;\\n                }\\n            }\\n            return mp[i][freq] =  ans;\\n        };\\n        vector<int> freq(slots,0);\\n        int ans = cnt(0,freq);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumANDSum(vector<int>& a, int slots) {\\n        int   n = a.size();\\n        unordered_map<int,map<vector<int>,int>> mp;\\n        function<int(int,vector<int>)> cnt = [&](int i,vector<int> freq)\\n        {\\n            if(i==n)\\n            {return 0;}\\n            if(mp[i].count(freq))\\n            {return  mp[i][freq];}\\n            int ans  = 0;\\n            for(int  j = 0;j<slots;j++)\\n            {\\n                if(freq[j]+1<=2)\\n                {\\n                    freq[j]++;\\n                    ans = max(ans,((j+1) & a[i]) + cnt(i+1,freq));\\n                    freq[j]--;\\n                }\\n            }\\n            return mp[i][freq] =  ans;\\n        };\\n        vector<int> freq(slots,0);\\n        int ans = cnt(0,freq);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766994,
                "title": "difference-between-and-in-pruning-means-accept-vs-tle",
                "content": "When pruning during DFS, we need to skip any subsequent paths that give less or EQUAL scores\\nIf we don\\'t skip branches w/ equal scores we TLE \\uD83D\\uDE2C\\uD83D\\uDE2C\\uD83D\\uDE2C\\n\\nHmm. I didn\\'t figure this out during the contest. Only some time later.\\n\\n```\\nclass Solution {\\npublic:\\n  int attempt;\\n  vector<int> dp;\\n  void DoSomething(vector<int>& nums, int idx, const int num_slots, bitset<32>& used_slots, int curr_sc, int* out) {\\n    unsigned long key = used_slots.to_ulong();\\n    if (dp[key] == -999) {\\n      {\\n        dp[key] = curr_sc;\\n      }\\n    }\\n    else {\\n\\t  //if (dp[key] > curr_sc) {  // Time limit exceeded (solves 51/81 inputs)\\n      if (dp[key] >= curr_sc) {  // Accept with a very low headroom (takes about ~1600ms)\\n        return;\\n      }\\n      else {\\n        dp[key] = curr_sc;\\n      }\\n    }\\n\\n    if (idx == int(nums.size())) {\\n      if (*out < curr_sc) {\\n        (*out) = max(*out, curr_sc);\\n        printf(\"%d, attempt=%d\\\\n\", curr_sc, attempt);\\n      }\\n      ++attempt;\\n      return;\\n    }\\n\\n    for (int i = num_slots - 1; i >= 0; i--) {\\n      int ii = i + num_slots;\\n      if (used_slots.test(ii) == false) {\\n\\n        used_slots.set(ii);\\n        int sc = curr_sc + ((ii % num_slots + 1) & nums[idx]);\\n        DoSomething(nums, idx + 1, num_slots, used_slots, sc, out);\\n        used_slots.reset(ii);\\n      }\\n      else if (used_slots.test(i) == false) {\\n        used_slots.set(i);\\n        int sc = curr_sc + ((i % num_slots + 1) & nums[idx]);\\n        DoSomething(nums, idx + 1, num_slots, used_slots, sc, out);\\n        used_slots.reset(i);\\n      }\\n    }\\n  }\\n\\n  int maximumANDSum(vector<int>& nums, int numSlots) {\\n    dp.resize(1000000);\\n    fill(dp.begin(), dp.end(), -999);\\n    attempt = 0;\\n    bitset<32> used_slots{};\\n    int out = 0;\\n    sort(nums.begin(), nums.end());\\n    reverse(nums.begin(), nums.end());\\n    DoSomething(nums, 0, numSlots, used_slots, 0, &out);\\n    return out;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int attempt;\\n  vector<int> dp;\\n  void DoSomething(vector<int>& nums, int idx, const int num_slots, bitset<32>& used_slots, int curr_sc, int* out) {\\n    unsigned long key = used_slots.to_ulong();\\n    if (dp[key] == -999) {\\n      {\\n        dp[key] = curr_sc;\\n      }\\n    }\\n    else {\\n\\t  //if (dp[key] > curr_sc) {  // Time limit exceeded (solves 51/81 inputs)\\n      if (dp[key] >= curr_sc) {  // Accept with a very low headroom (takes about ~1600ms)\\n        return;\\n      }\\n      else {\\n        dp[key] = curr_sc;\\n      }\\n    }\\n\\n    if (idx == int(nums.size())) {\\n      if (*out < curr_sc) {\\n        (*out) = max(*out, curr_sc);\\n        printf(\"%d, attempt=%d\\\\n\", curr_sc, attempt);\\n      }\\n      ++attempt;\\n      return;\\n    }\\n\\n    for (int i = num_slots - 1; i >= 0; i--) {\\n      int ii = i + num_slots;\\n      if (used_slots.test(ii) == false) {\\n\\n        used_slots.set(ii);\\n        int sc = curr_sc + ((ii % num_slots + 1) & nums[idx]);\\n        DoSomething(nums, idx + 1, num_slots, used_slots, sc, out);\\n        used_slots.reset(ii);\\n      }\\n      else if (used_slots.test(i) == false) {\\n        used_slots.set(i);\\n        int sc = curr_sc + ((i % num_slots + 1) & nums[idx]);\\n        DoSomething(nums, idx + 1, num_slots, used_slots, sc, out);\\n        used_slots.reset(i);\\n      }\\n    }\\n  }\\n\\n  int maximumANDSum(vector<int>& nums, int numSlots) {\\n    dp.resize(1000000);\\n    fill(dp.begin(), dp.end(), -999);\\n    attempt = 0;\\n    bitset<32> used_slots{};\\n    int out = 0;\\n    sort(nums.begin(), nums.end());\\n    reverse(nums.begin(), nums.end());\\n    DoSomething(nums, 0, numSlots, used_slots, 0, &out);\\n    return out;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766983,
                "title": "bug-in-java-checker",
                "content": "Hi @admins in todays Amazon Weekly Contest - 280 and for problem [Maximum AND Sum of Array](https://leetcode.com/problems/maximum-and-sum-of-array/) , I encountered something uneven with the Java checker.\\n\\n![image](https://assets.leetcode.com/users/images/1c706127-ba2a-4ba4-b97d-c89659a76152_1644725779.9802468.png)\\n\\nWhen I was submitting my code it is saying my output and expected output are not same as you can see, however, when I run it in my compiler, the same code runs exactly correctly giving the expected output.\\n\\nBelow is my code: \\n\\n```\\nclass Solution {\\n    \\n    static int max = 0;\\n    static Map<String, Integer> map;\\n\\n    static String getString(int[] arr){\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=1;i<arr.length;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    static int get(int[] nums, int[] hash, int sum, int index){\\n        if(index >= nums.length){\\n            max = Math.max(max, sum);\\n            return 0;\\n        }\\n\\n        if(map.containsKey(getString(hash))){\\n            max = Math.max(max, map.get(getString(hash)) + sum);\\n            return map.get(getString(hash));\\n        }\\n\\n        int cmax = 0;\\n        for(int i=1;i<hash.length;i++){\\n            if(hash[i] == 2){\\n                continue;\\n            }\\n\\n            hash[i]++;\\n            sum = sum + (i & nums[index]);\\n\\n            int val = get(nums, hash, sum, index+1);\\n            cmax = Math.max(cmax, val + (nums[index] & i));\\n\\n            sum = sum - (i & nums[index]);\\n            hash[i]--;\\n        }\\n\\n        map.put(getString(hash), cmax);\\n        return cmax;\\n    }\\n\\n    public static int maximumANDSum(int[] nums, int numSlots) {\\n        int[] hash = new int[numSlots+1];\\n        map = new HashMap<>();\\n        get(nums, hash, 0, 0);\\n\\n        return max;\\n    }\\n}\\n```\\n\\nCan anybody tell, how to report this problem to leetcode, else I might loose a lot of rating points and confidence most importantly. Please!!!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static int max = 0;\\n    static Map<String, Integer> map;\\n\\n    static String getString(int[] arr){\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=1;i<arr.length;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    static int get(int[] nums, int[] hash, int sum, int index){\\n        if(index >= nums.length){\\n            max = Math.max(max, sum);\\n            return 0;\\n        }\\n\\n        if(map.containsKey(getString(hash))){\\n            max = Math.max(max, map.get(getString(hash)) + sum);\\n            return map.get(getString(hash));\\n        }\\n\\n        int cmax = 0;\\n        for(int i=1;i<hash.length;i++){\\n            if(hash[i] == 2){\\n                continue;\\n            }\\n\\n            hash[i]++;\\n            sum = sum + (i & nums[index]);\\n\\n            int val = get(nums, hash, sum, index+1);\\n            cmax = Math.max(cmax, val + (nums[index] & i));\\n\\n            sum = sum - (i & nums[index]);\\n            hash[i]--;\\n        }\\n\\n        map.put(getString(hash), cmax);\\n        return cmax;\\n    }\\n\\n    public static int maximumANDSum(int[] nums, int numSlots) {\\n        int[] hash = new int[numSlots+1];\\n        map = new HashMap<>();\\n        get(nums, hash, 0, 0);\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766897,
                "title": "using-bit-mask-dp-to-optimize-factorial-solution-to-2-n-n-m",
                "content": "we are going to represent a dp state for a mask as pair. where first element of pair give the information that\\nhow are all the elements in mask occupy the given slots and second value of pair tells us the **Maximum  AND SUM**\\nwe can have for this mask elements.\\n\\nhow we can know about slots availability  by just an integer ?\\n-> an integer has 32 bits available , so what we can do is to use 2 bits each to represent each slots.\\n    for example for  jth slot , we can use the  (2*j)th & (2*j+1)th  bits  of integer to represent it .\\n    if jth slot is  filled once  than we can  set the (2* j)th and if jth slot is filled twice than we can set the (2* j +1)th \\n\\tbit . thus we can know which slots is filled how many times by just using one integer .\\n\\nRest is usual bitmask DP solution , we start traversing from  mask 1 to (1<<n) and for each mask all it\\'s submask \\nare already calculated and using that we can calculate each mask taking the best possible answer of each mask.\\n\\t\\n\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> dp[1LL<<18];\\n    int maximumANDSum(vector<int>& nums, int m) {\\n        int n=nums.size();\\n        int total_mask= (1LL<<n);\\n        int ans=0;\\n        for(int mask=0;mask<total_mask;mask++){\\n            for(int j=0;j<n;j++){\\n                if(mask&(1<<j)){\\n                    int sub_mask=(mask^(1<<j));\\n                    for(int o=1;o<=m;o++){\\n                        if(!(dp[sub_mask].first&(1LL<< (2*o+1))) && dp[mask].second< dp[sub_mask].second+ (o&nums[j])){\\n                            dp[mask].first=dp[sub_mask].first;\\n                            if(dp[mask].first&(1LL<<(2*o))){\\n                                dp[mask].first^=(1LL<<(2*o));\\n                                dp[mask].first^=(1LL<<(2*o+1));\\n                            }\\n                            else{\\n                                dp[mask].first^=(1LL<<(2*o));\\n                            }\\n                            dp[mask].second=dp[sub_mask].second+ (o&nums[j]);\\n                            ans=max(dp[mask].second,ans);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> dp[1LL<<18];\\n    int maximumANDSum(vector<int>& nums, int m) {\\n        int n=nums.size();\\n        int total_mask= (1LL<<n);\\n        int ans=0;\\n        for(int mask=0;mask<total_mask;mask++){\\n            for(int j=0;j<n;j++){\\n                if(mask&(1<<j)){\\n                    int sub_mask=(mask^(1<<j));\\n                    for(int o=1;o<=m;o++){\\n                        if(!(dp[sub_mask].first&(1LL<< (2*o+1))) && dp[mask].second< dp[sub_mask].second+ (o&nums[j])){\\n                            dp[mask].first=dp[sub_mask].first;\\n                            if(dp[mask].first&(1LL<<(2*o))){\\n                                dp[mask].first^=(1LL<<(2*o));\\n                                dp[mask].first^=(1LL<<(2*o+1));\\n                            }\\n                            else{\\n                                dp[mask].first^=(1LL<<(2*o));\\n                            }\\n                            dp[mask].second=dp[sub_mask].second+ (o&nums[j]);\\n                            ans=max(dp[mask].second,ans);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766877,
                "title": "can-anyone-tell-me-what-is-wrong-with-this-solution",
                "content": "```\\n// For this test case it is failing \\n//[1,3,10,4,7,1]  9\\n// answer should be 24 but it gives 24\\n//here ith bit of nmask represent if ith slot is taken or not\\n// ith bit of mask represent if ith number is taken or not\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int max_n;\\n    int solve(vector<int>&nums , int nmask , int mask){\\n        if(((1<<nums.size())-1) == mask) return 0;\\n        int ans = INT_MIN;\\n        if(memo[nmask][mask]!= -1) return memo[nmask][mask];\\n        for(int j = 0;j<nums.size();j++){\\n            if(!(mask &(1<<j))){\\n                for(int  i = 0;i<nums.size();i++){\\n                    if(!(mask &(1<<i))){\\n                        for(int n = 1;n<=max_n ;n++){\\n                            if(!(nmask&(1<<n))){\\n                                int temp1 = solve(nums , nmask|(1<<n) , mask|(1<<i)|(1<<j));\\n                                int temp2 = solve(nums , nmask|(1<<n) , mask|(1<<i));\\n\\n                                if(temp1 != INT_MIN) temp1+= (nums[i] & n) + (nums[j] & n);\\n                                if(temp2 != INT_MIN) temp2+= (nums[i] & n);\\n\\n                                ans = max({ans , temp1 , temp2});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return memo[nmask][mask] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int n) {\\n        max_n = n;\\n        memo.resize((1<<(n+1)) , vector<int>(1<<(nums.size()) , -1));\\n        return solve(nums , 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n// For this test case it is failing \\n//[1,3,10,4,7,1]  9\\n// answer should be 24 but it gives 24\\n//here ith bit of nmask represent if ith slot is taken or not\\n// ith bit of mask represent if ith number is taken or not\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int max_n;\\n    int solve(vector<int>&nums , int nmask , int mask){\\n        if(((1<<nums.size())-1) == mask) return 0;\\n        int ans = INT_MIN;\\n        if(memo[nmask][mask]!= -1) return memo[nmask][mask];\\n        for(int j = 0;j<nums.size();j++){\\n            if(!(mask &(1<<j))){\\n                for(int  i = 0;i<nums.size();i++){\\n                    if(!(mask &(1<<i))){\\n                        for(int n = 1;n<=max_n ;n++){\\n                            if(!(nmask&(1<<n))){\\n                                int temp1 = solve(nums , nmask|(1<<n) , mask|(1<<i)|(1<<j));\\n                                int temp2 = solve(nums , nmask|(1<<n) , mask|(1<<i));\\n\\n                                if(temp1 != INT_MIN) temp1+= (nums[i] & n) + (nums[j] & n);\\n                                if(temp2 != INT_MIN) temp2+= (nums[i] & n);\\n\\n                                ans = max({ans , temp1 , temp2});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return memo[nmask][mask] = ans;\\n    }\\n    int maximumANDSum(vector<int>& nums, int n) {\\n        max_n = n;\\n        memo.resize((1<<(n+1)) , vector<int>(1<<(nums.size()) , -1));\\n        return solve(nums , 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766798,
                "title": "c-greedy-dp",
                "content": "```C++\\nclass Solution {\\n    unordered_map<string, int> dp;\\n    string makeKey(vector<int>& slots, int p) {\\n        stringstream key;\\n\\n        key<<to_string(p);\\n\\n        for(auto n : slots) {\\n            key<<to_string(n);\\n        }\\n        return key.str();\\n    }\\n    int solution(vector<int>& slots, vector<int>& remain, int p) {\\n        if(p == remain.size()) return 0;\\n        string key = makeKey(slots, p); \\n        if(dp.count(key)) return dp[key];\\n        int res = 0;\\n        for(int i = 1; i < slots.size(); i++) {\\n            if(slots[i] == 2) continue;\\n            slots[i]++;\\n            res = max(res, solution(slots, remain, p + 1) + (i & remain[p]));\\n            slots[i]--;\\n        }\\n        return dp[key] = res;\\n    }\\npublic:\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        unordered_map<int, int> m;\\n        vector<int> slots(numSlots + 1), remain;\\n        int res = 0, mi = 0;\\n        for(auto n : nums) m[n]++;\\n        for(int i = 1; i <= numSlots; i++) {\\n            slots[i] = min(2, m[i]);\\n            m[i] -= slots[i];\\n            mi += slots[i] * i;\\n            if(!m[i]) m.erase(i);\\n        }\\n        for(auto [k, v]:m) {\\n            while(v--) {\\n                remain.push_back(k);\\n            }\\n        }\\n        return mi + solution(slots, remain, 0);\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    unordered_map<string, int> dp;\\n    string makeKey(vector<int>& slots, int p) {\\n        stringstream key;\\n\\n        key<<to_string(p);\\n\\n        for(auto n : slots) {\\n            key<<to_string(n);\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1887093,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "Since number of slots is not big,you can represent slot1 with first and second bits,slot2 with third and fourth bits"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Why Google??? \\nWhy???"
                    },
                    {
                        "username": "brinuke",
                        "content": "I think this problem was inspired by the Held\\u2013Karp algorithm."
                    },
                    {
                        "username": "Mranshmoon",
                        "content": " PROBLEM IN MY CODE??\\n\\n`class Solution {\\npublic:\\n    int dp[10][3][1<<19];\\n    int fun(vector<int>& nums,int slot,int eleCount,int mask){\\n        if(mask == ((1<<nums.size())-1)) {\\n           // cout<<\"             \"<<mask<<endl;\\n            return 0;\\n            }\\n        if(slot==0) return -1;\\n      // cout<<slot<<\"  \"<<eleCount<<\"  \"<<mask<<endl;\\n      if(dp[slot][eleCount][mask]!=-1) return dp[slot][eleCount][mask];\\n        int ans=-1;\\n        if(eleCount<2){\\n            \\n            for(int i=0;i<nums.size();i++){\\n                if(!(mask & (1<<i) )){\\n                    int tempmask= (mask | (1<<i));\\n                    int temp=fun(nums,slot,eleCount+1,tempmask);\\n                    if(temp!=-1) ans=max(ans,(nums[i] and slot)+temp);\\n                }\\n            }\\n\\n        }\\n        ans=max(ans,fun(nums,slot-1,0,mask));\\n        return dp[slot][eleCount][mask]=(ans==-1 ? -1:ans);\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=fun(nums,numSlots,0,0);\\n        return ans;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1929016,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "Since number of slots is not big,you can represent slot1 with first and second bits,slot2 with third and fourth bits"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Why Google??? \\nWhy???"
                    },
                    {
                        "username": "brinuke",
                        "content": "I think this problem was inspired by the Held\\u2013Karp algorithm."
                    },
                    {
                        "username": "Mranshmoon",
                        "content": " PROBLEM IN MY CODE??\\n\\n`class Solution {\\npublic:\\n    int dp[10][3][1<<19];\\n    int fun(vector<int>& nums,int slot,int eleCount,int mask){\\n        if(mask == ((1<<nums.size())-1)) {\\n           // cout<<\"             \"<<mask<<endl;\\n            return 0;\\n            }\\n        if(slot==0) return -1;\\n      // cout<<slot<<\"  \"<<eleCount<<\"  \"<<mask<<endl;\\n      if(dp[slot][eleCount][mask]!=-1) return dp[slot][eleCount][mask];\\n        int ans=-1;\\n        if(eleCount<2){\\n            \\n            for(int i=0;i<nums.size();i++){\\n                if(!(mask & (1<<i) )){\\n                    int tempmask= (mask | (1<<i));\\n                    int temp=fun(nums,slot,eleCount+1,tempmask);\\n                    if(temp!=-1) ans=max(ans,(nums[i] and slot)+temp);\\n                }\\n            }\\n\\n        }\\n        ans=max(ans,fun(nums,slot-1,0,mask));\\n        return dp[slot][eleCount][mask]=(ans==-1 ? -1:ans);\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=fun(nums,numSlots,0,0);\\n        return ans;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1867899,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "Since number of slots is not big,you can represent slot1 with first and second bits,slot2 with third and fourth bits"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Why Google??? \\nWhy???"
                    },
                    {
                        "username": "brinuke",
                        "content": "I think this problem was inspired by the Held\\u2013Karp algorithm."
                    },
                    {
                        "username": "Mranshmoon",
                        "content": " PROBLEM IN MY CODE??\\n\\n`class Solution {\\npublic:\\n    int dp[10][3][1<<19];\\n    int fun(vector<int>& nums,int slot,int eleCount,int mask){\\n        if(mask == ((1<<nums.size())-1)) {\\n           // cout<<\"             \"<<mask<<endl;\\n            return 0;\\n            }\\n        if(slot==0) return -1;\\n      // cout<<slot<<\"  \"<<eleCount<<\"  \"<<mask<<endl;\\n      if(dp[slot][eleCount][mask]!=-1) return dp[slot][eleCount][mask];\\n        int ans=-1;\\n        if(eleCount<2){\\n            \\n            for(int i=0;i<nums.size();i++){\\n                if(!(mask & (1<<i) )){\\n                    int tempmask= (mask | (1<<i));\\n                    int temp=fun(nums,slot,eleCount+1,tempmask);\\n                    if(temp!=-1) ans=max(ans,(nums[i] and slot)+temp);\\n                }\\n            }\\n\\n        }\\n        ans=max(ans,fun(nums,slot-1,0,mask));\\n        return dp[slot][eleCount][mask]=(ans==-1 ? -1:ans);\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=fun(nums,numSlots,0,0);\\n        return ans;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1732905,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "Since number of slots is not big,you can represent slot1 with first and second bits,slot2 with third and fourth bits"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Why Google??? \\nWhy???"
                    },
                    {
                        "username": "brinuke",
                        "content": "I think this problem was inspired by the Held\\u2013Karp algorithm."
                    },
                    {
                        "username": "Mranshmoon",
                        "content": " PROBLEM IN MY CODE??\\n\\n`class Solution {\\npublic:\\n    int dp[10][3][1<<19];\\n    int fun(vector<int>& nums,int slot,int eleCount,int mask){\\n        if(mask == ((1<<nums.size())-1)) {\\n           // cout<<\"             \"<<mask<<endl;\\n            return 0;\\n            }\\n        if(slot==0) return -1;\\n      // cout<<slot<<\"  \"<<eleCount<<\"  \"<<mask<<endl;\\n      if(dp[slot][eleCount][mask]!=-1) return dp[slot][eleCount][mask];\\n        int ans=-1;\\n        if(eleCount<2){\\n            \\n            for(int i=0;i<nums.size();i++){\\n                if(!(mask & (1<<i) )){\\n                    int tempmask= (mask | (1<<i));\\n                    int temp=fun(nums,slot,eleCount+1,tempmask);\\n                    if(temp!=-1) ans=max(ans,(nums[i] and slot)+temp);\\n                }\\n            }\\n\\n        }\\n        ans=max(ans,fun(nums,slot-1,0,mask));\\n        return dp[slot][eleCount][mask]=(ans==-1 ? -1:ans);\\n    }\\n    int maximumANDSum(vector<int>& nums, int numSlots) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=fun(nums,numSlots,0,0);\\n        return ans;\\n    }\\n};`"
                    }
                ]
            }
        ]
    }
]