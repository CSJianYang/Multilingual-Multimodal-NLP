[
    {
        "title": "Swap Nodes in Pairs",
        "question_content": "Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n\nExample 2:\n\nInput: head = []\nOutput: []\n\nExample 3:\n\nInput: head = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the&nbsp;list&nbsp;is in the range [0, 100].\n\t0 <= Node.val <= 100",
        "solutions": [
            {
                "id": 1775033,
                "title": "swapping-nodes-not-just-the-values-visual-explanation-well-explained-c",
                "content": "As mentioned in the question we have to **exchange the nodes itself (and not just their values)**, and this solution follows this constraint.\\n\\nI will be placing a `dummy node` before the head node so that the code we write can also be applicable to the head node also, and we don\\'t have to specifically write different conditions for the head node.\\n\\n#### Example:\\n***Given Linked List***\\n\\n![image](https://assets.leetcode.com/users/images/d4219c57-0fa8-4d02-8c75-e437d1613be0_1644993781.493073.jpeg)\\n\\n ***Final Linked List***\\n\\n![image](https://assets.leetcode.com/users/images/88cece9e-8fff-4f5f-807f-dcabecebe71e_1644993901.1494746.jpeg)\\n\\n\\nLet\\'s now understand the **approach**\\n\\n1. As mentioned earlier, we will place a `dummyNode` before the head node.\\n\\n![image](https://assets.leetcode.com/users/images/b06f77f0-507a-42ac-af35-04ebbd4a71b0_1644993113.5176115.jpeg)\\n\\n\\n2. Now, let the head be our `currNode`. That means the `node with value 1` is the currNode, and we have to swap it with the `node with value 2`. So for this, we will also have to keep track of the node previous to the currNode, let it be `prevNode`, as it\\'s next pointer value will have to change after we swap the currNode and the node next to currNode.\\n\\n![image](https://assets.leetcode.com/users/images/00a5d82c-ce1f-4d73-afb2-0ce20d23fb26_1644993239.638449.jpeg)\\n\\n3. Now the very first thing to do is change the `next pointer of prevNode to point to currNode->next`. Why?? Because in the answer we want the `node with value 2` after the dummyNode. Right? So we will have to connect `dummyNode` (prevNode) to the `node with value  2` (currNode->next). This means\\n```cpp\\nprevNode->next = currNode->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5a4ce313-4f60-48f4-857d-ca141e48c103_1644993309.3371558.jpeg)\\n\\n\\n4. Now, in our finl answer `node with value 1` should be at the place of `node with value 2`. So the next pointer of `node with value 1` should point to whatever the `node with value 2` is pointing to originally. That means we will have to change `currNode->next` to the `next of next of prevNode`, as currently prevNode is dummyNode, prevNode->next is node with value 2 and prevNode->next->next = next of node with value 2. This means\\n```cpp\\ncurrNode->next = prevNode->next->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e531a190-a0cd-4117-ab66-4c5ed08047d9_1644993389.8530746.jpeg)\\n\\n\\n5. Now, as in the answer the `node with value 2` should point to `node with value 1`. That means\\n```cpp\\nprevNode->next->next = currNode\\n```\\n\\n![image](https://assets.leetcode.com/users/images/11fda637-3c1c-4f41-82a5-598f41540429_1644993447.1567922.jpeg)\\n\\n\\n6. After this iteration, nodes 1 and 2 will get swapped and our linked list will look like this.\\n\\n![image](https://assets.leetcode.com/users/images/eba94308-ed4a-4542-aed6-ef8f4eb1f807_1644993522.337313.jpeg)\\n\\n\\n7. Now for the next iteration, we have to swap `nodes with values 3 and 4`. For that the `prevNode` should point to `node with value 1` and the `currNode` should point to `node with value 3`. This means\\n```cpp\\nprevNode = currNode\\ncurrNode = currNode->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e73873b6-a236-4171-ac89-52f0c5d63164_1645010559.588748.jpeg)\\n\\n\\n\\n\\n8. We should stop this procedure when either there is no nodes left to swap or there is only one node left which cannot be swapped with any node.\\n\\n9. At the end, as we can see that our head of the list has been misplaced in the procedure of swapping, so we can return `dummyNode->next` to return the swapped linked list.\\n\\n\\n#### Code\\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\\n\\t\\t\\n        ListNode* dummyNode = new ListNode();\\n        \\n        ListNode* prevNode=dummyNode;\\n        ListNode* currNode=head;\\n        \\n        while(currNode && currNode->next){\\n            prevNode->next = currNode->next;\\n            currNode->next = prevNode->next->next;\\n            prevNode->next->next = currNode;\\n            \\n            prevNode = currNode;\\n            currNode = currNode->next;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n\\n```\\n\\n#### Complexity:\\n***TC*** **= O(n)**\\n***SC*** **= O(1)**\\n\\n***Plz upvote if you liked the post***\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```cpp\\nprevNode->next = currNode->next\\n```\n```cpp\\ncurrNode->next = prevNode->next->next\\n```\n```cpp\\nprevNode->next->next = currNode\\n```\n```cpp\\nprevNode = currNode\\ncurrNode = currNode->next\\n```\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\\n\\t\\t\\n        ListNode* dummyNode = new ListNode();\\n        \\n        ListNode* prevNode=dummyNode;\\n        ListNode* currNode=head;\\n        \\n        while(currNode && currNode->next){\\n            prevNode->next = currNode->next;\\n            currNode->next = prevNode->next->next;\\n            prevNode->next->next = currNode;\\n            \\n            prevNode = currNode;\\n            currNode = currNode->next;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774708,
                "title": "c-visual-image-how-links-change-explained-every-step-commented-code",
                "content": "***Brief note about Question-***\\n* We have to *swap every two adjacent nodes and return its head*.\\n```\\nLet\\'s take an example not given in question -\\nSuppose our head pointer given to us as [1,9,2,8,3,7]\\n\\nSo, we have to swap every two adjcant nodes,\\nthe answer should be [9,1,8,2,7,3]\\n```\\n_______________\\n***Solution - I (using recursion, Accepted)-***\\n* The very basic thing that is given to us is, **it is given in form of linked list**.\\n* We have a advantage by having linked list, How?\\n* For swapping every two adjcant nodes, we will be able to just change the link of nodes.\\n* See how we change links on the first example.\\n![image](https://assets.leetcode.com/users/images/53a7a769-ce39-4d7d-9e37-cd0420f72bf0_1644988593.5987253.jpeg)\\n\\n\\n* I have mention everything in image itself, and also add comment in code also, but if u have still doubt or suggestion,please put that in comment part.\\n ____________\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if head is NULL OR just having a single node, then no need to change anything \\n        if(head == NULL || head -> next == NULL) \\n        {\\n            return head;\\n        }\\n            \\n        ListNode* temp; // temporary pointer to store head -> next\\n        temp = head->next; // give temp what he want\\n        \\n        head->next = swapPairs(head->next->next); // changing links\\n        temp->next = head; // put temp -> next to head\\n        \\n        return temp; // now after changing links, temp act as our head\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our head pointer given to us as [1,9,2,8,3,7]\\n\\nSo, we have to swap every two adjcant nodes,\\nthe answer should be [9,1,8,2,7,3]\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if head is NULL OR just having a single node, then no need to change anything \\n        if(head == NULL || head -> next == NULL) \\n        {\\n            return head;\\n        }\\n            \\n        ListNode* temp; // temporary pointer to store head -> next\\n        temp = head->next; // give temp what he want\\n        \\n        head->next = swapPairs(head->next->next); // changing links\\n        temp->next = head; // put temp -> next to head\\n        \\n        return temp; // now after changing links, temp act as our head\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774318,
                "title": "python3-i-hate-linked-lists-not-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38-_-\\'), If you have any question, feel free to ask.**\\n\\nJust a bunch of placeholders, edge cases, and strange errors about a cycle meanwhile :(\\n\\nprev cur cur porev next cur prev pasdfaslfjgnzdsf;ljgfsdaz;lkjkfgn\\n\\nTime: **O(n)** - iterate\\nSpace: **O(1)**\\n\\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38-_-\\'), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11030,
                "title": "my-accepted-java-code-used-recursion",
                "content": "    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if ((head == null)||(head.next == null))\\n                return head;\\n            ListNode n = head.next;\\n            head.next = swapPairs(head.next.next);\\n            n.next = head;\\n            return n;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if ((head == null)||(head.next == null))\\n                return head;\\n            ListNode n = head.next;\\n            head.next = swapPairs(head.next.next);\\n            n.next = head;\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11019,
                "title": "7-8-lines-c-python-ruby",
                "content": "Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don't know all three languages.\\n\\nAll three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list.\\n\\n---\\n\\n**C++**\\n\\nPointer-pointer `pp`  points to the pointer to the current node. So at first, `pp` points to `head`, and later it points to the `next` field of ListNodes. Additionally, for convenience and clarity, pointers `a` and `b` point to the current node and the next node.\\n\\nWe need to go from `*pp == a -> b -> (b->next)` to `*pp == b -> a -> (b->next)`. The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves `pp` to the next pair.\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode **pp = &head, *a, *b;\\n        while ((a = *pp) && (b = a->next)) {\\n            a->next = b->next;\\n            b->next = a;\\n            *pp = b;\\n            pp = &(a->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\n**Python**\\n\\nHere, `pre` is the previous node. Since the head doesn't have a previous node, I just use `self` instead. Again, `a` is the current node and `b` is the next node.\\n\\nTo go from `pre -> a -> b -> b.next` to `pre -> b -> a -> b.next`, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once.\\n\\n    def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next\\n\\n---\\n\\n**Ruby**\\n\\nAgain, `pre` is the previous node, but here I create a dummy as previous node of the head. And again, `a` is the current node and `b` is the next node. This time I go one node further and call it `c`.\\n\\nTo go from `pre -> a -> b -> c` to `pre -> b -> a -> c`, we need to change those three references. Here I chain the assignments, pretty much directly saying \"`pre` points to `b`, which points to `a`, which points to `c`\".\\n\\n    def swap_pairs(head)\\n        pre = dummy = ListNode.new 0\\n        pre.next = head\\n        while a = pre.next and b = a.next\\n            c = b.next\\n            ((pre.next = b).next = a).next = c\\n            pre = a\\n        end\\n        dummy.next\\n    end",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby"
                ],
                "code": "Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don't know all three languages.\\n\\nAll three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list.\\n\\n---\\n\\n**C++**\\n\\nPointer-pointer `pp`  points to the pointer to the current node. So at first, `pp` points to `head`, and later it points to the `next` field of ListNodes. Additionally, for convenience and clarity, pointers `a` and `b` point to the current node and the next node.\\n\\nWe need to go from `*pp == a -> b -> (b->next)` to `*pp == b -> a -> (b->next)`. The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves `pp` to the next pair.\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode **pp = &head, *a, *b;\\n        while ((a = *pp) && (b = a->next)) {\\n            a->next = b->next;\\n            b->next = a;\\n            *pp = b;\\n            pp = &(a->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\n**Python**\\n\\nHere, `pre` is the previous node. Since the head doesn't have a previous node, I just use `self` instead. Again, `a` is the current node and `b` is the next node.\\n\\nTo go from `pre -> a -> b -> b.next` to `pre -> b -> a -> b.next`, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once.\\n\\n    def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next\\n\\n---\\n\\n**Ruby**\\n\\nAgain, `pre` is the previous node, but here I create a dummy as previous node of the head. And again, `a` is the current node and `b` is the next node. This time I go one node further and call it `c`.\\n\\nTo go from `pre -> a -> b -> c` to `pre -> b -> a -> c`, we need to change those three references. Here I chain the assignments, pretty much directly saying \"`pre` points to `b`, which points to `a`, which points to `c`\".\\n\\n    def swap_pairs(head)\\n        pre = dummy = ListNode.new 0\\n        pre.next = head\\n        while a = pre.next and b = a.next\\n            c = b.next\\n            ((pre.next = b).next = a).next = c\\n            pre = a\\n        end\\n        dummy.next\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 11046,
                "title": "my-simple-java-solution-for-share",
                "content": "    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode current = dummy;\\n        while (current.next != null && current.next.next != null) {\\n            ListNode first = current.next;\\n            ListNode second = current.next.next;\\n            first.next = second.next;\\n            current.next = second;\\n            current.next.next = first;\\n            current = current.next.next;\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode current = dummy;\\n        while (current.next != null && current.next.next != null) {\\n            ListNode first = current.next;\\n            ListNode second = current.next.next;\\n            first.next = second.next;\\n            current.next = second;\\n            current.next.next = first;\\n            current = current.next.next;\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 171788,
                "title": "python-dummynode",
                "content": "### 24. Swap Nodes in Pairs\\n\\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur = dummy\\n        \\n        while cur.next and cur.next.next:\\n            first = cur.next\\n            sec = cur.next.next\\n            cur.next = sec\\n            first.next = sec.next\\n            sec.next = first\\n            cur = cur.next.next\\n        return dummy.next       \\n```\\n![](https://raw.githubusercontent.com/yuzhoujr/spazzatura/master/img_box/24.jpg)\\n\\n#### Recursive\\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        new_start = head.next.next\\n        head, head.next = head.next, head\\n        head.next.next = self.swapPairs(new_start)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur = dummy\\n        \\n        while cur.next and cur.next.next:\\n            first = cur.next\\n            sec = cur.next.next\\n            cur.next = sec\\n            first.next = sec.next\\n            sec.next = first\\n            cur = cur.next.next\\n        return dummy.next       \\n```\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        new_start = head.next.next\\n        head, head.next = head.next, head\\n        head.next.next = self.swapPairs(new_start)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11271,
                "title": "simple-implementation-with-c",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            if(head->next == NULL)\\n                return head;\\n            \\n            ListNode* next = head->next;\\n            head->next = swapPairs(next->next);\\n            next->next = head;\\n            \\n            return next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            if(head->next == NULL)\\n                return head;\\n            \\n            ListNode* next = head->next;\\n            head->next = swapPairs(next->next);\\n            next->next = head;\\n            \\n            return next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11183,
                "title": "c-solution-with-graph-explanation",
                "content": "    /*\\n           #---->@---->@---->@---->@---->@---->@\\n                       ^     ^\\n                       pre   cur\\n\\n          1. pre->next = cur->next\\n                        __________\\n                       /          \\\\\\n           #---->@---->@     @---->@---->@---->@\\n                       ^     ^\\n                       pre   cur\\n\\n          2. pre = pre->next\\n                        __________\\n                       /          \\\\\\n          #---->@---->@      @---->@---->@---->@\\n                             ^     ^\\n                             cur   pre\\n\\n          3. cur->next = pre->next\\n                        __________\\n                       /          \\\\\\n           #---->@---->@     @     @---->@---->@\\n                              \\\\_________/\\n                             ^     ^\\n                             cur   pre\\n\\n          4. pre->next = cur\\n                       __________\\n                      /          \\\\\\n          #---->@---->@     @<----@     @---->@\\n                             \\\\_________/\\n                            ^     ^\\n                            cur   pre\\n        \\n          5. pre = cur; cur = cur->next\\n                       __________\\n                      /          \\\\\\n          #---->@---->@     @<----@     @---->@\\n                             \\\\_________/\\n                            ^           ^\\n                            pre         cur\\n     */\\n    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode tmp(0);\\n            tmp.next = head;\\n            ListNode *pre = &tmp, *cur = head;\\n            while(cur && cur->next){\\n                pre->next = cur->next;\\n                pre = pre->next;\\n                cur->next = pre->next;\\n                pre->next = cur;\\n                pre = cur;\\n                cur = cur->next;\\n            }\\n            return tmp.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode tmp(0);\\n            tmp.next = head;\\n            ListNode *pre = &tmp, *cur = head;\\n            while(cur && cur->next){\\n                pre->next = cur->next;\\n                pre = pre->next;\\n                cur->next = pre->next;\\n                pre->next = cur;\\n                pre = cur;\\n                cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11312,
                "title": "python-concise-iterative-and-recursive-solutions",
                "content": "    # Iteratively\\n    def swapPairs1(self, head):\\n        dummy = p = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            tmp = head.next\\n            head.next = tmp.next\\n            tmp.next = head\\n            p.next = tmp\\n            head = head.next\\n            p = tmp.next\\n        return dummy.next\\n     \\n    # Recursively    \\n    def swapPairs(self, head):\\n        if head and head.next:\\n            tmp = head.next\\n            head.next = self.swapPairs(tmp.next)\\n            tmp.next = head\\n            return tmp\\n        return head",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "    # Iteratively\\n    def swapPairs1(self, head):\\n        dummy = p = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            tmp = head.next\\n            head.next = tmp.next\\n            tmp.next = head\\n            p.next = tmp\\n            head = head.next\\n            p = tmp.next\\n        return dummy.next\\n     \\n    # Recursively    \\n    def swapPairs(self, head):\\n        if head and head.next:\\n            tmp = head.next\\n            head.next = self.swapPairs(tmp.next)\\n            tmp.next = head\\n            return tmp\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 11111,
                "title": "java-simple-recursive-solution",
                "content": "Starting to see that recursion is the perfect tool for (many) linked list problems (this one + merging list problem).\\n\\n    /**\\n     * Definition for singly-linked list.\\n     * public class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode second = head.next;\\n            ListNode third = second.next;\\n            \\n            second.next = head;\\n            head.next = swapPairs(third);\\n            \\n            return second;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode second = head.next;\\n            ListNode third = second.next;\\n            \\n            second.next = head;\\n            head.next = swapPairs(third);\\n            \\n            return second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 344445,
                "title": "c-recursive-solution-faster-than-100-of-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp;\\n        temp = head->next;\\n        head->next = swapPairs(head->next->next);\\n        temp->next = head;\\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp;\\n        temp = head->next;\\n        head->next = swapPairs(head->next->next);\\n        temp->next = head;\\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11223,
                "title": "javascript-solution-beats-94-44-of-all-submissions",
                "content": "    var swapPairs = function(head) {\\n        if(!head || !head.next) return head;\\n        var v1 = head, v2 = head.next, v3 = v2.next;\\n        v2.next = v1;\\n        v1.next = swapPairs(v3);\\n        return v2;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var swapPairs = function(head) {\\n        if(!head || !head.next) return head;\\n        var v1 = head, v2 = head.next, v3 = v2.next;\\n        v2.next = v1;\\n        v1.next = swapPairs(v3);\\n        return v2;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3528791,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution\\n\\n# Search \\uD83D\\uDC49 `Swap Nodes in Pairs by Tech Wired`\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\nThe approach used in the code is to traverse the linked list and swap adjacent pairs of nodes. This is done iteratively by maintaining a current pointer that points to the previous node before the pair to be swapped. The swapping is done by modifying the next pointers of the nodes.\\n\\n# Intuition:\\nThe intuition behind the code is to break down the problem into smaller subproblems. By swapping two nodes at a time, we can gradually swap adjacent pairs throughout the linked list. This is achieved by manipulating the next pointers of the nodes.\\n\\nThe use of a dummy node helps in handling the edge case where the head of the list needs to be swapped. It serves as a placeholder for the new head of the modified list.\\n\\nThe while loop iterates as long as there are at least two nodes remaining in the list. In each iteration, the current pair of nodes is swapped by adjusting the next pointers accordingly.\\n\\n\\n\\n```Python []\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not head or not head.next: return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = dummy\\n\\n        while curr.next and curr.next.next:\\n            first = curr.next\\n            second = curr.next.next\\n            curr.next = second\\n            first.next = second.next\\n            second.next = first\\n            curr = curr.next.next\\n        \\n        return dummy.next\\n```\\n```Java []\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode first = curr.next;\\n            ListNode second = curr.next.next;\\n            curr.next = second;\\n            first.next = second.next;\\n            second.next = first;\\n            curr = curr.next.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = dummy;\\n        \\n        while (curr->next != nullptr && curr->next->next != nullptr) {\\n            ListNode* first = curr->next;\\n            ListNode* second = curr->next->next;\\n            curr->next = second;\\n            first->next = second->next;\\n            second->next = first;\\n            curr = curr->next->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List"
                ],
                "code": "```Python []\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not head or not head.next: return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = dummy\\n\\n        while curr.next and curr.next.next:\\n            first = curr.next\\n            second = curr.next.next\\n            curr.next = second\\n            first.next = second.next\\n            second.next = first\\n            curr = curr.next.next\\n        \\n        return dummy.next\\n```\n```Java []\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode first = curr.next;\\n            ListNode second = curr.next.next;\\n            curr.next = second;\\n            first.next = second.next;\\n            second.next = first;\\n            curr = curr.next.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = dummy;\\n        \\n        while (curr->next != nullptr && curr->next->next != nullptr) {\\n            ListNode* first = curr->next;\\n            ListNode* second = curr->next->next;\\n            curr->next = second;\\n            first->next = second->next;\\n            second->next = first;\\n            curr = curr->next->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11028,
                "title": "my-straight-forward-java-solution-without-recursion-or-dummy-nodes-0ms",
                "content": "- The idea is straightforward: use two pointers and swap\\n - `a.next = b.next`, `b.next = a`.\\n - Then continue the next pair, `b = a.next.next`, `a=a.next`\\n - Remember to check `null`\\n - Remember to track new `head`\\n - Remember to link the new pair after the prior nodes. \\n\\nAttached is the accepted code.\\n\\n\\n    public class Solution {\\n      public ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode newHead = head.next, a=head,b=a.next,pre = null;\\n        while(a!=null && b!=null){\\n          a.next = b.next;\\n          b.next = a;\\n          if(pre!=null) pre.next = b;\\n          if(a.next==null) break;\\n          b = a.next.next;\\n          pre = a;\\n          a = a.next;\\n        }\\n        return newHead;\\n      }\\n    }\\n\\n- AC, 0ms",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode newHead = head.next, a=head,b=a.next,pre = null;\\n        while(a!=null && b!=null){\\n          a.next = b.next;\\n          b.next = a;\\n          if(pre!=null) pre.next = b;\\n          if(a.next==null) break;\\n          b = a.next.next;\\n          pre = a;\\n          a = a.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 486804,
                "title": "python-simple-solution-memory-usage-less-than-100",
                "content": "Given:\\n**prev->a->b->c**\\n\\nChange it to:\\n**prev->b->a->c**\\n\\nSince the first node does not have any previous node, we create a dummy node at the beginning.\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n\\t\\t\\n        while prev.next and prev.next.next:\\n            a = prev.next\\n            b = prev.next.next\\n            c = prev.next.next.next\\n            prev.next = b\\n            prev.next.next = a\\n            prev.next.next.next = c\\n            prev = prev.next.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n\\t\\t\\n        while prev.next and prev.next.next:\\n            a = prev.next\\n            b = prev.next.next\\n            c = prev.next.next.next\\n            prev.next = b\\n            prev.next.next = a\\n            prev.next.next.next = c\\n            prev = prev.next.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11320,
                "title": "my-simple-recursive-solution",
                "content": "My solution is quite simple. Just find the reverse job is the same for every 2 nodes.\\n\\n    public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            \\n            ListNode newhd = head.next;\\n            head.next = swapPairs(newhd.next);\\n            newhd.next = head;\\n            return newhd;\\n    }",
                "solutionTags": [],
                "code": "My solution is quite simple. Just find the reverse job is the same for every 2 nodes.\\n\\n    public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            \\n            ListNode newhd = head.next;\\n            head.next = swapPairs(newhd.next);\\n            newhd.next = head;\\n            return newhd;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 265325,
                "title": "java-recursive-solution-beats-100-with-explanation",
                "content": "The idea is simple:\\neach we take two first elements of (sub)sequence, swap them using two additional variables, and call the function recursively from the tail. For example:\\n![image](https://assets.leetcode.com/users/olsh/image_1553979740.png)\\n\\nThe code of this solution:\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next==null)return head;\\n        ListNode tempNext = head.next.next;\\n        ListNode tempFirst = head.next;\\n        ListNode tempSecond = head;\\n        head = tempFirst;\\n        head.next = tempSecond;\\n        head.next.next = swapPairs(tempNext);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next==null)return head;\\n        ListNode tempNext = head.next.next;\\n        ListNode tempFirst = head.next;\\n        ListNode tempSecond = head;\\n        head = tempFirst;\\n        head.next = tempSecond;\\n        head.next.next = swapPairs(tempNext);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11331,
                "title": "4ms-easy-c-iterative-solution",
                "content": "Well, since the `head` pointer may also been modified, we create a `new_head` that points to it to facilitate the swapping process.\\n\\nFor the example list `1 -> 2 -> 3 -> 4` in the problem statement, it will become `0 -> 1 -> 2 -> 3 -> 4` (we init `new_head -> val` to be `0`). Then we set a pointer `pre` to `new_head` and another `cur` to `head`. Each time, we will swap `pre -> next` and `cur -> next` using the following piece of code.\\n\\n    pre -> next = cur -> next;\\n    cur -> next = cur -> next -> next;\\n    pre -> next -> next = cur;\\n\\nAfter swapping them, we update as follows:\\n\\n    pre = cur; \\n    cur = pre -> next; \\n\\nto swap the next two nodes.\\n\\nFinally, we return `new_head -> next`.\\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) { \\n            if (!head || !(head -> next)) return head;\\n            ListNode* new_head = new ListNode(0);\\n            new_head -> next = head;\\n            ListNode* pre = new_head; \\n            ListNode* cur = head;\\n            while (pre -> next && cur -> next) {\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = cur;\\n                pre = cur;\\n                cur = pre -> next;\\n            }\\n            return new_head -> next;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) { \\n            if (!head || !(head -> next)) return head;\\n            ListNode* new_head = new ListNode(0);\\n            new_head -> next = head;\\n            ListNode* pre = new_head; \\n            ListNode* cur = head;\\n            while (pre -> next && cur -> next) {\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = cur;\\n                pre = cur;\\n                cur = pre -> next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 486026,
                "title": "java-0-ms-beating-100-simple-iterative-solution-with-diagram-and-explanation",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        ListNode prevNode = new ListNode(0);    //Node situated before the two to-be-swapped nodes\\n        prevNode.next = head;                   //Starting before head\\n        ListNode newHead = prevNode;            //Storing a reference for returning\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null){\\n            \\n            //Declare                                           // ...[prev]-->[node1]-->[node2]-->[next]...\\n            ListNode node1 = prevNode.next;                     \\n            ListNode node2 = node1.next;\\n            ListNode nextNode = node2.next;\\n            \\n            //Swap\\n            prevNode.next = node2;                              // ...[prev]-->[node2]<--[node1]   [next]...\\n            node2.next = node1;                                 // ...[prev]-->[node2]<-->[node1]  [next]...\\n            node1.next = nextNode;                              // ...[prev]-->[node2]-->[node1]-->[next]...\\n            \\n            //Move \\n            prevNode = node1;                                   // ...[...]-->[node2]-->[node1/prev]-->[next]...\\n        }\\n        \\n        return newHead.next;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        ListNode prevNode = new ListNode(0);    //Node situated before the two to-be-swapped nodes\\n        prevNode.next = head;                   //Starting before head\\n        ListNode newHead = prevNode;            //Storing a reference for returning\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null){\\n            \\n            //Declare                                           // ...[prev]-->[node1]-->[node2]-->[next]...\\n            ListNode node1 = prevNode.next;                     \\n            ListNode node2 = node1.next;\\n            ListNode nextNode = node2.next;\\n            \\n            //Swap\\n            prevNode.next = node2;                              // ...[prev]-->[node2]<--[node1]   [next]...\\n            node2.next = node1;                                 // ...[prev]-->[node2]<-->[node1]  [next]...\\n            node1.next = nextNode;                              // ...[prev]-->[node2]-->[node1]-->[next]...\\n            \\n            //Move \\n            prevNode = node1;                                   // ...[...]-->[node2]-->[node1/prev]-->[next]...\\n        }\\n        \\n        return newHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11175,
                "title": "c-recursive-and-iterative-solutions",
                "content": "    \\n    // recursively\\n    ListNode* swapPairs1(ListNode* head) {\\n        if (!head || !(head->next))\\n            return head;\\n        ListNode *res = head->next;\\n        head->next = swapPairs(res->next);\\n        res->next = head;\\n        return res;\\n    }\\n    \\n    // iteratively\\n    ListNode *swapPairs(ListNode *head) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        dummy->next = head;\\n        while (head && head->next) {\\n            ListNode *nxt = head->next;\\n            head->next = nxt->next;\\n            nxt->next = head;\\n            node->next = nxt;\\n            node = head;\\n            head = node->next;\\n        }\\n        return dummy->next;\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Iterator"
                ],
                "code": "    \\n    // recursively\\n    ListNode* swapPairs1(ListNode* head) {\\n        if (!head || !(head->next))\\n            return head;\\n        ListNode *res = head->next;\\n        head->next = swapPairs(res->next);\\n        res->next = head;\\n        return res;\\n    }\\n    \\n    // iteratively\\n    ListNode *swapPairs(ListNode *head) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        dummy->next = head;\\n        while (head && head->next) {\\n            ListNode *nxt = head->next;\\n            head->next = nxt->next;\\n            nxt->next = head;\\n            node->next = nxt;\\n            node = head;\\n            head = node->next;\\n        }\\n        return dummy->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529293,
                "title": "c-easy-recursion",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp=swapPairs(head->next->next);\\n        ListNode* t=head;\\n        head=head->next;\\n        head->next=t;\\n        head->next->next=temp;\\n        return head;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/425d38ef-1ecd-4fe2-966c-1df715fb51d0_1684210746.862829.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp=swapPairs(head->next->next);\\n        ListNode* t=head;\\n        head=head->next;\\n        head->next=t;\\n        head->next->next=temp;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529474,
                "title": "easy-solution-beginner-friendly-easy-to-understand-beats-100-java-python-3-c-js-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the list and swap pairs of nodes one by one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The node \"ans\" is to point to the head of the original list. It then uses a \"curr\" node to traverse the list and swap pairs of nodes. The loop continues as long as there are at least two more nodes to swap.\\n\\n- Inside the loop, the solution uses two temporary nodes, \"t1\" and \"t2\", to hold the first and second nodes of the pair. Then, it updates the pointers to swap the nodes, and moves \"curr\" two nodes ahead. At the end, it returns the modified list starting from the next node of the  \"ans\" node.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n          if (head == null || head.next == null) {\\n            return head;\\n        }\\n    ListNode ans =new ListNode(0);\\n    ans.next=head;\\n    ListNode curr=ans;\\n   while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }  \\n      return ans.next;\\n    }\\n}\\n```\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        ans = ListNode(0)\\n        ans.next = head\\n        curr = ans\\n        \\n        while curr.next and curr.next.next:\\n            t1 = curr.next\\n            t2 = curr.next.next\\n            curr.next = t2\\n            t1.next = t2.next\\n            t2.next = t1\\n            curr = curr.next.next\\n        \\n        return ans.next\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n    }\\n};\\n```\\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};\\n```\\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode ans = new ListNode(0);\\n        ans.next = head;\\n        ListNode curr = ans;\\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }\\n        return ans.next;    \\n    }\\n}\\n```\\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n         if (head == null || head.next == null) {\\n            return head\\n        }\\n        val ans = ListNode(0)\\n        ans.next = head\\n        var curr: ListNode? = ans\\n        while (curr?.next != null && curr.next?.next != null) {\\n            val t1 = curr.next\\n            val t2 = curr.next?.next\\n            curr.next = t2\\n            t1.next = t2?.next\\n            t2?.next = t1\\n            curr = curr.next?.next\\n        }\\n        return ans.next\\n    }\\n}\\n```\\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n}\\n```\\n\\nUPVOTES ARE ENCOURAGING!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n          if (head == null || head.next == null) {\\n            return head;\\n        }\\n    ListNode ans =new ListNode(0);\\n    ans.next=head;\\n    ListNode curr=ans;\\n   while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }  \\n      return ans.next;\\n    }\\n}\\n```\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        ans = ListNode(0)\\n        ans.next = head\\n        curr = ans\\n        \\n        while curr.next and curr.next.next:\\n            t1 = curr.next\\n            t2 = curr.next.next\\n            curr.next = t2\\n            t1.next = t2.next\\n            t2.next = t1\\n            curr = curr.next.next\\n        \\n        return ans.next\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n    }\\n};\\n```\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};\\n```\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode ans = new ListNode(0);\\n        ans.next = head;\\n        ListNode curr = ans;\\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }\\n        return ans.next;    \\n    }\\n}\\n```\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n         if (head == null || head.next == null) {\\n            return head\\n        }\\n        val ans = ListNode(0)\\n        ans.next = head\\n        var curr: ListNode? = ans\\n        while (curr?.next != null && curr.next?.next != null) {\\n            val t1 = curr.next\\n            val t2 = curr.next?.next\\n            curr.next = t2\\n            t1.next = t2?.next\\n            t2?.next = t1\\n            curr = curr.next?.next\\n        }\\n        return ans.next\\n    }\\n}\\n```\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656816,
                "title": "solution-swift-swap-nodes-in-pairs-test-cases",
                "content": "```swift\\nclass Solution {\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        var head = head, node = head, pre: ListNode?\\n        \\n        while node != nil, let next = node!.next {\\n            let cur = next, tmp = cur.next\\n            pre == nil ? (head = cur) : (pre!.next = cur)\\n            cur.next = node\\n            node!.next = tmp\\n            pre = node\\n            node = tmp\\n        }\\n        return head\\n    }\\n}\\n```\\n\\n---\\n\\n<p><details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.swapPairs(ListNode([1,2,3,4]))\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.swapPairs(ListNode([]))\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n    \\n    func test2() {\\n        let value = solution.swapPairs(ListNode([1]))\\n        XCTAssertEqual(value?.val, ListNode([1])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>\\n\\n<p><details>\\n<summary>\\n<b>ListNode</b>\\n</summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n\\n\\tpublic init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        var head = head, node = head, pre: ListNode?\\n        \\n        while node != nil, let next = node!.next {\\n            let cur = next, tmp = cur.next\\n            pre == nil ? (head = cur) : (pre!.next = cur)\\n            cur.next = node\\n            node!.next = tmp\\n            pre = node\\n            node = tmp\\n        }\\n        return head\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.swapPairs(ListNode([1,2,3,4]))\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.swapPairs(ListNode([]))\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n    \\n    func test2() {\\n        let value = solution.swapPairs(ListNode([1]))\\n        XCTAssertEqual(value?.val, ListNode([1])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n\\n\\tpublic init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984266,
                "title": "c-c-simple-short-and-easy-recursive-solution-0ms-faster-than-100",
                "content": "```\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if ((!head) || (!head->next))\\n        return head;\\n    \\n    struct ListNode* tmp = head;\\n    head = head->next;\\n    tmp->next = head->next;\\n    head->next = tmp;\\n    \\n    head->next->next = swapPairs(head->next->next);\\n    return head;\\n}\\n```\\n**Like it? please upvote!\\nHave any comments? I\\'d love to hear...**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if ((!head) || (!head->next))\\n        return head;\\n    \\n    struct ListNode* tmp = head;\\n    head = head->next;\\n    tmp->next = head->next;\\n    head->next = tmp;\\n    \\n    head->next->next = swapPairs(head->next->next);\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163702,
                "title": "python3-simple-recursive-solution-beats-95-00-easily-understandable-with-figure-explanation",
                "content": "## Idea\\n**Recursion**\\n- Base case: list is empty or contains only one node. (In this case there\\'s no need to swap anything)\\n- Recursive case: If the nodes after the first two nodes are already done swapping in pairs,  we just need to swap the first two nodes and then we\\'re done!\\n\\n## Implementation\\n\\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # recursive case\\n        _next = head.next\\n        head.next = self.swapPairs(_next.next)\\n        _next.next = head\\n        \\n        return _next\\n```\\n\\n## Visualization\\n\\n![image](https://assets.leetcode.com/users/images/399f06f6-0361-4b86-a29d-823f0d42a04a_1618696569.132693.png)\\n\\n## Complexity\\n- Time: O(n)\\n- Space: O(n)\\n\\n\\nIf you think this is helpful, please give it a vote.\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # recursive case\\n        _next = head.next\\n        head.next = self.swapPairs(_next.next)\\n        _next.next = head\\n        \\n        return _next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984392,
                "title": "python-o-n-solution-explained",
                "content": "As with a lot of other linked lists, it is good idea to add dummy node before list to avoid cases. Imagine, we have list `1, 2, 3, 4, 5, 6`, let us add `0` node in the beginning, so we have `0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6` now.\\n\\nNow, let us look at the main step of algorithm (for simplicity I will call nodes by its values)\\n1. `pre = 0`, whe check if `pre.next` and `pre.next.next` exists, they are, so define `a = 1` and `b = 2`.\\n2. Now, we need to rewrite links: `0 -> 2`, `2 -> 1` and `1 -> 3`. Note, that we do it all in one step.\\n3. Finally, we say, that `pre = 1`. Also, our list now looks like `0 -> 2 -> 1 -> 3 -> 4 -> 5 -> 6` and as I said `pre = 1` now, so we swapped first two elements and now we on element number 2, which is exaclty what we have previously for smaller list.\\n4. On next step we have `0 -> 2 -> 1 -> 4 -> 3 -> 5 -> 6` and finally `0 -> 2 -> 1 -> 4 -> 3 -> 6 -> 5`, this is exaclty what we need to return.\\n\\n**Complexity**: time complexity is `O(n)`: we iterate over our list once, space complexity is `O(1)`: we did not add any new space and reused already existing nodes.\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pre = dummy\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pre = dummy\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774508,
                "title": "c-easy-to-understand-short-simple-10-lines",
                "content": "# 24. Swap Nodes in Pairs\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n         ListNode* p = head;   // p pointing to head\\n        ListNode* res = head->next; // res is pointed to head -> next\\n        ListNode* q; ListNode* temp; // temporary nodes for links updation\\n        \\n        while(true)\\n        {\\n\\t\\t// for eg 1 2 3 4\\n\\t\\t//this iteration temp is point to 3 and 2 -> 1 will be acheived \\n\\t\\t// more explanation read after end of code\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n\\t\\t// if statement of temp won\\'t execute \\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n       \\n    }\\n};\\n```\\n\\n```\\n{\\n// 1\\'s link with 4 will extablished & value of temp i.e 3 will be stored in p.\\n\\n// now p contains 3 that points to 4.\\n\\n// Same way 2nd iteration will execute and 3->4 will turn into 4->3\\n\\n// if statement inside while loop will execute as temp has become null, \\n\\n// p->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n\\n// return res , which will give 2 -> 1 -> 4 -> 3 -> NULL\\n}\\n```\\n\\n**ANOTHER APPROACH BY SWAPPING VALUES**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n        ListNode* temp = head;    // temporary pointer so that we don\\'t loose reference to head\\n        \\n        while(temp)        // while temp != NULL\\n        {\\n            if(temp->next != NULL)       \\n            {\\n\\t\\t\\t   // if list contain odd no of nodes than at last node the temp->next,\\n\\t\\t\\t   //will be pointing to null and the code crashes, as there is no other node,\\n\\t\\t\\t   // to perform swap opearation\\n                swap(temp->val, temp->next->val);    // swap with the adjacent node\\n                temp = temp->next->next;                 //incrementing pointer with 2 step\\n            }\\n\\t\\t\\t\\telse    // break because last pair of list is odd \\n\\t\\t\\t\\t\\tbreak;\\n        }\\n        \\n        return head;    // return head\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n         ListNode* p = head;   // p pointing to head\\n        ListNode* res = head->next; // res is pointed to head -> next\\n        ListNode* q; ListNode* temp; // temporary nodes for links updation\\n        \\n        while(true)\\n        {\\n\\t\\t// for eg 1 2 3 4\\n\\t\\t//this iteration temp is point to 3 and 2 -> 1 will be acheived \\n\\t\\t// more explanation read after end of code\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n\\t\\t// if statement of temp won\\'t execute \\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n       \\n    }\\n};\\n```\n```\\n{\\n// 1\\'s link with 4 will extablished & value of temp i.e 3 will be stored in p.\\n\\n// now p contains 3 that points to 4.\\n\\n// Same way 2nd iteration will execute and 3->4 will turn into 4->3\\n\\n// if statement inside while loop will execute as temp has become null, \\n\\n// p->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n\\n// return res , which will give 2 -> 1 -> 4 -> 3 -> NULL\\n}\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n        ListNode* temp = head;    // temporary pointer so that we don\\'t loose reference to head\\n        \\n        while(temp)        // while temp != NULL\\n        {\\n            if(temp->next != NULL)       \\n            {\\n\\t\\t\\t   // if list contain odd no of nodes than at last node the temp->next,\\n\\t\\t\\t   //will be pointing to null and the code crashes, as there is no other node,\\n\\t\\t\\t   // to perform swap opearation\\n                swap(temp->val, temp->next->val);    // swap with the adjacent node\\n                temp = temp->next->next;                 //incrementing pointer with 2 step\\n            }\\n\\t\\t\\t\\telse    // break because last pair of list is odd \\n\\t\\t\\t\\t\\tbreak;\\n        }\\n        \\n        return head;    // return head\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751194,
                "title": "javascript-iterative-time-o-n-space-o-1-explanation",
                "content": "```\\nvar swapPairs = function(head) {\\n    // Store head to return list, Only instance of new data so space is O(1)\\n    let dummy = new ListNode(-1);\\n    dummy.next = head;\\n    \\n    let prev = dummy\\n    \\n    // Traverse list\\n    while (head && head.next) {\\n        \\n    // Declare\\n    let n1 = head\\n    let n2 = head.next\\n        \\n        // Swap\\n        prev.next = n2\\n        n1.next = n2.next\\n        n2.next = n1\\n        \\n        // Assign\\n        prev = n1\\n        head = n1.next\\n    }\\n    \\n    // The variable prev has been used to create the dummy list. dummy.next is still the head of new list\\n    return dummy.next;\\n};\\n```\\ntime: O(n)\\nspace: O(1)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    // Store head to return list, Only instance of new data so space is O(1)\\n    let dummy = new ListNode(-1);\\n    dummy.next = head;\\n    \\n    let prev = dummy\\n    \\n    // Traverse list\\n    while (head && head.next) {\\n        \\n    // Declare\\n    let n1 = head\\n    let n2 = head.next\\n        \\n        // Swap\\n        prev.next = n2\\n        n1.next = n2.next\\n        n2.next = n1\\n        \\n        // Assign\\n        prev = n1\\n        head = n1.next\\n    }\\n    \\n    // The variable prev has been used to create the dummy list. dummy.next is still the head of new list\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233501,
                "title": "rust-0ms-100",
                "content": "```\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        head.and_then(|mut n| {\\n            match n.next {\\n                Some(mut m) => {\\n                    n.next = Solution::swap_pairs(m.next);\\n                    m.next = Some(n);\\n                    Some(m)\\n                },\\n                None => Some(n)\\n            }\\n        })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        head.and_then(|mut n| {\\n            match n.next {\\n                Some(mut m) => {\\n                    n.next = Solution::swap_pairs(m.next);\\n                    m.next = Some(n);\\n                    Some(m)\\n                },\\n                None => Some(n)\\n            }\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481145,
                "title": "go-many-clean-solutions-with-images-in-go-golang-0ms-100",
                "content": "Hello Gophers!\\n\\nStart:\\n![swap-nodes-start.png](https://assets.leetcode.com/users/images/f5bbe08e-42e8-42ce-9977-d5f2a58bc653_1690834893.7782896.png)\\n\\nSwap:\\n\\n![swap-nodes-swap.png](https://assets.leetcode.com/users/images/7085cfe8-e298-435b-bc12-739668f3580f_1690834907.7661934.png)\\n\\nEnd:\\n![swap-nodes-end.png](https://assets.leetcode.com/users/images/78c9effb-98e4-4594-b2ff-b91bce480211_1690834920.5882404.png)\\n\\n\\n## Solution 1: Recursive (Easy-Medium)\\n\\nCleaner, but worst space complexity.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)` (recursion)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\thead, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n\\n\\treturn head\\n}\\n\\n```\\n\\nor\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head != nil && head.Next != nil {\\n        head, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n    }\\n    return head\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fb93b1d2-41f9-44b6-a05d-f24d58f76c8f_1661481740.6021497.jpeg)\\n![image](https://assets.leetcode.com/users/images/edacf671-cf94-4da0-8569-d55c1d682b51_1661481740.3160453.jpeg)\\n\\n\\n## Solution 2: Iterative (Medium-Hard)\\n\\n\\nIteration (`for` loop) instead of recursivity (function calling itself).  \\nUglier (imo), but better space complexity.\\n\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n\\n### Solution 2.1: with temp nodes (Medium)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\n### Solution 2.2: Without temp nodes (Hard)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nHow did I get to solution 2.2?\\n\\nStart:\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nRemove \"temp nodes\" `firstNode` and `secondNode`:\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tprev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nBut because `prev` can be nil:\\n\\n```go\\nif prev != nil {\\n    prev.Next = secondNode\\n}\\n```\\n\\nWe need a \"first step\":\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n    // Start\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\n    // Firtst Step (prev is nil)\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\n    // All Next Steps\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nIt works \\uD83E\\uDD2F\\n\\nStart:\\n![swap-nodes-1.png](https://assets.leetcode.com/users/images/d5342873-a9b1-4b5e-938d-7294231bcf9e_1690831346.3609188.png)\\n\\nFirst iteration:\\n![swap-nodes-2.png](https://assets.leetcode.com/users/images/6f6aa2b9-35b1-48eb-abd2-06e701276bca_1690831364.0310698.png)\\n\\nTODO: Finish this\\n\\nI hope it helped!",
                "solutionTags": [
                    "Go",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\thead, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n\\n\\treturn head\\n}\\n\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head != nil && head.Next != nil {\\n        head, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n    }\\n    return head\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tprev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nif prev != nil {\\n    prev.Next = secondNode\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n    // Start\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\n    // Firtst Step (prev is nil)\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\n    // All Next Steps\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517577,
                "title": "c-java-python-javascript-swapping-nodes-fully-explained",
                "content": "# Approach\\n\\n1. Check if the list is empty or contains only one node. If so, there is no need to perform any swaps, so the original head is returned.\\n2. Initialize three pointers: `newHead` to store the new head after swapping, `prev` to keep track of the previous node, and `curr` to iterate through the list.\\n3. Enter a loop that continues as long as both `curr` and `curr->next` are not null.\\n4. Inside the loop, create a pointer `next` to store the next node after `curr`.\\n5. Update the next pointers of `curr` and `next` to perform the swap. Set `curr->next` to `next->next` to connect `curr` with the next pair of nodes.\\n6. Set `next->next` to `curr` to swap the positions of `curr` and `next`.\\n7. If `prev` is not null, update its `next` pointer to `next` to connect the previous pair with the swapped pair.\\n8. Update `prev` to `curr` and `curr` to `curr->next` to move forward in the list.\\n9. After the loop ends, return `newHead`, which stores the new head of the swapped list.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. This is because the algorithm iterates through the list once. The space complexity is O(1) because it uses a constant amount of additional space to store the pointers.\\n\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        ListNode* newHead = head->next;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr && curr->next) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = curr;\\n            \\n            if (prev) {\\n                prev->next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode newHead = head.next;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null && curr.next != null) {\\n            ListNode next = curr.next;\\n            curr.next = next.next;\\n            next.next = curr;\\n            \\n            if (prev != null) {\\n                prev.next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        new_head = head.next\\n        prev = None\\n        curr = head\\n        \\n        while curr and curr.next:\\n            next = curr.next\\n            curr.next = next.next\\n            next.next = curr\\n            \\n            if prev:\\n                prev.next = next\\n            \\n            prev = curr\\n            curr = curr.next\\n        \\n        return new_head\\n```\\n---\\n# JavaScript\\n```\\nvar swapPairs = function(head) {\\n    if (!head || !head.next) {\\n        return head;\\n    }\\n    \\n    var newHead = head.next;\\n    var prev = null;\\n    var curr = head;\\n    \\n    while (curr && curr.next) {\\n        var next = curr.next;\\n        curr.next = next.next;\\n        next.next = curr;\\n        \\n        if (prev) {\\n            prev.next = next;\\n        }\\n        \\n        prev = curr;\\n        curr = curr.next;\\n    }\\n    \\n    return newHead;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        ListNode* newHead = head->next;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr && curr->next) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = curr;\\n            \\n            if (prev) {\\n                prev->next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode newHead = head.next;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null && curr.next != null) {\\n            ListNode next = curr.next;\\n            curr.next = next.next;\\n            next.next = curr;\\n            \\n            if (prev != null) {\\n                prev.next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        new_head = head.next\\n        prev = None\\n        curr = head\\n        \\n        while curr and curr.next:\\n            next = curr.next\\n            curr.next = next.next\\n            next.next = curr\\n            \\n            if prev:\\n                prev.next = next\\n            \\n            prev = curr\\n            curr = curr.next\\n        \\n        return new_head\\n```\n```\\nvar swapPairs = function(head) {\\n    if (!head || !head.next) {\\n        return head;\\n    }\\n    \\n    var newHead = head.next;\\n    var prev = null;\\n    var curr = head;\\n    \\n    while (curr && curr.next) {\\n        var next = curr.next;\\n        curr.next = next.next;\\n        next.next = curr;\\n        \\n        if (prev) {\\n            prev.next = next;\\n        }\\n        \\n        prev = curr;\\n        curr = curr.next;\\n    }\\n    \\n    return newHead;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774796,
                "title": "java-0ms-recursive-code-faster-than-100-of-the-solutions-with-comments",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        /**\\n        * The base condition will be triggered when there is no node left or there is just 1 node.\\n        * If there is just 1 node left, there is nothing that can be swapped, hence we return the node\\n        * itself.\\n        */\\n        if(head == null || head.next == null) return head;\\n        \\n        /**\\n        * If there are more than 1 nodes remaining, we would recursively call the method by passing the\\n        * next.next element.\\n        * This is because we would be swapping the head and the head.next element.\\n        * So, to call the method we would pass the head.next.next element.\\n        * This call will return a head which we would have to attach it to the current head.next element,\\n        AFTER SWAPPING.\\n        */\\n        ListNode tHead = swapPairs(head.next.next);\\n        \\n        /**\\n        * Here, we would write the swapping logic.\\n        * The node which is returned from the above line of code, will be connected with the nodes after\\n        * swapping here.\\n        */\\n        \\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        /**\\n        * The base condition will be triggered when there is no node left or there is just 1 node.\\n        * If there is just 1 node left, there is nothing that can be swapped, hence we return the node\\n        * itself.\\n        */\\n        if(head == null || head.next == null) return head;\\n        \\n        /**\\n        * If there are more than 1 nodes remaining, we would recursively call the method by passing the\\n        * next.next element.\\n        * This is because we would be swapping the head and the head.next element.\\n        * So, to call the method we would pass the head.next.next element.\\n        * This call will return a head which we would have to attach it to the current head.next element,\\n        AFTER SWAPPING.\\n        */\\n        ListNode tHead = swapPairs(head.next.next);\\n        \\n        /**\\n        * Here, we would write the swapping logic.\\n        * The node which is returned from the above line of code, will be connected with the nodes after\\n        * swapping here.\\n        */\\n        \\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 830851,
                "title": "swift-recursive-iterative",
                "content": "**Simple recursion**\\nTime: O(n), Space: O(n)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tif let next = head.next {\\n\\t\\thead.next = swapPairs(next.next)\\n\\t\\tnext.next = head\\n\\t\\treturn next\\n\\t} else {\\n\\t   return head \\n\\t}\\n}\\n```\\n---\\nHow about iterative?\\n**Iterative**\\nTime: O(n), Space: O(n)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tif head == nil || head?.next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlet newHead = head!.next\\n\\n\\tvar stack = [ListNode]()\\n\\tvar node = head\\n\\twhile let cur = node, let next = cur.next { // 2 at a time\\n\\t\\tstack.append(cur)\\n\\t\\tstack.append(next)\\n\\t\\tnode = next.next\\n\\t}\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet next = stack.popLast()!\\n\\t\\tlet cur = stack.popLast()!\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tif let prev = stack.last {\\n\\t\\t\\tprev.next = next\\n\\t\\t}\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\n**Iterative without a stack**\\nTime: O(n), Space: O(1)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tvar dummy = ListNode()\\n\\tvar prev = dummy\\n\\tprev.next = head\\n\\twhile let cur = prev.next, let next = cur.next {\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tprev.next = next\\n\\t\\tprev = cur\\n\\t}\\n\\n\\treturn dummy.next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tif let next = head.next {\\n\\t\\thead.next = swapPairs(next.next)\\n\\t\\tnext.next = head\\n\\t\\treturn next\\n\\t} else {\\n\\t   return head \\n\\t}\\n}\\n```\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tif head == nil || head?.next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlet newHead = head!.next\\n\\n\\tvar stack = [ListNode]()\\n\\tvar node = head\\n\\twhile let cur = node, let next = cur.next { // 2 at a time\\n\\t\\tstack.append(cur)\\n\\t\\tstack.append(next)\\n\\t\\tnode = next.next\\n\\t}\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet next = stack.popLast()!\\n\\t\\tlet cur = stack.popLast()!\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tif let prev = stack.last {\\n\\t\\t\\tprev.next = next\\n\\t\\t}\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tvar dummy = ListNode()\\n\\tvar prev = dummy\\n\\tprev.next = head\\n\\twhile let cur = prev.next, let next = cur.next {\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tprev.next = next\\n\\t\\tprev = cur\\n\\t}\\n\\n\\treturn dummy.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557411,
                "title": "python-recursive-solution-faster-than-99-72",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head:                                           # first (head) node exists\\n            h = head.next                                  # second node\\n            if h:                                          # second node exists => a pair exists\\n                h.next, head.next = head, h.next           # swap node pair, first node with second => \\'h\\' is new head\\n                h.next.next = self.swapPairs(h.next.next)  # recurse on next pair head\\n                return h              # returns the new head of a swapped node pair\\n        return head                   # returns when a node pair doesn\\'t exist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head:                                           # first (head) node exists\\n            h = head.next                                  # second node\\n            if h:                                          # second node exists => a pair exists\\n                h.next, head.next = head, h.next           # swap node pair, first node with second => \\'h\\' is new head\\n                h.next.next = self.swapPairs(h.next.next)  # recurse on next pair head\\n                return h              # returns the new head of a swapped node pair\\n        return head                   # returns when a node pair doesn\\'t exist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529642,
                "title": "c-beats-100-image-explanation-using-dummy-head-and-dummy-tail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will convert the list into the list with dummy head and dummy tail. It will help us to maintain pointer and will save us from writing edge cases for null pointers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEg. Given list is `1 -> 2 -> 3 -> 4`. We will convert it to `-1 -> 1 -> 2 -> 3 -> 4 -> -1`. Now our head will point to dummy head.\\n\\nWe will keep track of three pointer and will reverse every pair of elements,\\n1. prev - which will link the reversed element (from a pair of elements), this pointer is immediate left of the current pair\\n2. cur - first element of current pair\\n3. next - second element of current pair\\n\\nIf we look at this example `-1 -> 1 -> 2 -> 3 -> 4 -> -1`, then in the first iteration prev would be -1, cur would be 1 and next would be 2.\\n\\nAfter swapping a pair list will look like this `-1 -> 2 -> 1 -> 3 -> 4 -> -1`. Now we will have our next pair which is `3 -> 4`. So prev would be 1, curr would be at 3 and next would be at 4. \\n\\nAfter second iteration list will look like `-1 -> 2 -> 1 -> 4 -> 3 -> -1`.\\n\\nNow, The list is swapped in pairs of two elements. We just have to remove dummy head and dummy tail.\\n\\nFinal answer: `2 -> 1 -> 4 -> 3`\\n\\n**NOTE 1:** ***Odd size list handled in the code. Just emit the last element from being swapped with dummy tail.***\\n**NOTE 2:** ***Code is self explanatory.***\\n\\n### Iteration Steps Explanation\\n![image.png](https://assets.leetcode.com/users/images/2deeb1b9-a52a-4694-9bbd-6e681c855146_1684217143.7158692.png)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n    - As we are traversing list only once (ignore adding and deleting dummy head and dummy tail)\\n\\n- Space complexity: $$O(1)$$\\n    - As we have not used any space (containers) except the pointers.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if list is null or contains one element then return the list itself (null => null & `1` => `1`)\\n        if (!head or !head->next)\\n            return head;\\n\\n        // Adding dummy head\\n        ListNode *dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        head = dummyHead;\\n\\n        // Adding dummy tail\\n        ListNode *dummyTail = new ListNode(-1);\\n        ListNode *ptr = head;\\n        while (ptr->next)\\n            ptr = ptr->next;\\n        ptr->next = dummyTail;\\n\\n        // assigning prev, cur and next for first iteration\\n        ListNode *prev = head, *cur = head->next, *next = head->next->next;\\n        while (next and next->val != -1)\\n        {\\n            // Check above image\\n            ListNode *nextCur = next->next; // 1\\n            prev->next = next; // 2\\n            cur->next = next->next; // 3\\n            next->next = cur; // 4\\n\\n            prev = cur; // 5\\n            cur = nextCur; // 6\\n            next = cur->next; // 7\\n        }   \\n\\n        // Remove dummy tail\\n        ListNode *remove = head;\\n        while(remove->next->val != -1)\\n            remove = remove->next;\\n        remove->next = NULL;\\n\\n        // remove dummy head\\n        return head = head->next;\\n    }\\n};\\n```\\n### Upvote if it helped you !!!\\n![image.png](https://assets.leetcode.com/users/images/58838411-f6e7-4acb-b98b-a8427e7453da_1684217764.5259085.png)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if list is null or contains one element then return the list itself (null => null & `1` => `1`)\\n        if (!head or !head->next)\\n            return head;\\n\\n        // Adding dummy head\\n        ListNode *dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        head = dummyHead;\\n\\n        // Adding dummy tail\\n        ListNode *dummyTail = new ListNode(-1);\\n        ListNode *ptr = head;\\n        while (ptr->next)\\n            ptr = ptr->next;\\n        ptr->next = dummyTail;\\n\\n        // assigning prev, cur and next for first iteration\\n        ListNode *prev = head, *cur = head->next, *next = head->next->next;\\n        while (next and next->val != -1)\\n        {\\n            // Check above image\\n            ListNode *nextCur = next->next; // 1\\n            prev->next = next; // 2\\n            cur->next = next->next; // 3\\n            next->next = cur; // 4\\n\\n            prev = cur; // 5\\n            cur = nextCur; // 6\\n            next = cur->next; // 7\\n        }   \\n\\n        // Remove dummy tail\\n        ListNode *remove = head;\\n        while(remove->next->val != -1)\\n            remove = remove->next;\\n        remove->next = NULL;\\n\\n        // remove dummy head\\n        return head = head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528838,
                "title": "easy-solution-of-java-100-faster-code-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n\\n```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        ListNode d = new ListNode(0), a;\\n        d.next = head;\\n        a=d;\\n        while(head!=null&&head.next!=null) {\\n            a.next = head.next;\\n            head.next = head.next.next;\\n            a.next.next = head;\\n            a = a.next.next;\\n            head =  head.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        ListNode d = new ListNode(0), a;\\n        d.next = head;\\n        a=d;\\n        while(head!=null&&head.next!=null) {\\n            a.next = head.next;\\n            head.next = head.next.next;\\n            a.next.next = head;\\n            a = a.next.next;\\n            head =  head.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477540,
                "title": "python-recursive-solution-w-step-by-step-thought-process",
                "content": "Is the point of Leetcode to come up with intensely technical and condensed code, or is it to help us practice systematically solving problems and showing our thought process? Its the latter. This may not be the most condensed solution, but the thought process is clear and sequential.\\n\\n**Overall Thought Process**\\n1. Write out ideally how the algorithm would execute. It\\'ll be easier to see the pattern this way\\n2. Then, I look at pairs and try to come up with a pseudocode\\n3. From that, I can come up with a rough recursive algorithm. To simplify this, I\\'m not thinking of edge cases \\n4. Add in conditionals to account for edge cases\\n5. Convert algorithm into code\\n\\n<br>\\n\\n\\n**Walking through each Step**\\n\\n\\n**1. Write out ideally how the algorithm would execute. It\\'ll be easier to see the pattern this way**\\n\\n```\\nFor linked list -> 1 - 2\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4\\n4.next = 3\\n3.next = None\\n2.next = 1\\n1.next = 4\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4 - 5\\n4.next = 3\\n3.next = 5\\n2.next = 1\\n1.next = 4\\nreturn 2\\n```\\n\\n\\n**2. Then, I look at pairs and try to come up with a pseudocode**\\n```\\nfor each pair (a, b):\\n    a.next = whatever is the first of next pair\\n    b.next = a\\n    return b\\n```\\n\\n**3. From that, I can come up with a rough recursive algorithm. To simplify this, I\\'m not thinking of edge cases yet**\\n```\\nswap_pair(head):\\n    first = head\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\\n\\n**4. Add in conditionals to account for edge cases**\\n```\\nswap_pair(head):\\n    if not head:\\n        return None\\n\\n    first = head\\n    \\n    if not first.next:\\n        return first\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\\n\\n**5. Convert algorithm into code**\\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n\\n        first = head\\n        if not first.next:\\n            return first\\n        second = first.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        return second\\n```",
                "solutionTags": [],
                "code": "```\\nFor linked list -> 1 - 2\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4\\n4.next = 3\\n3.next = None\\n2.next = 1\\n1.next = 4\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4 - 5\\n4.next = 3\\n3.next = 5\\n2.next = 1\\n1.next = 4\\nreturn 2\\n```\n```\\nfor each pair (a, b):\\n    a.next = whatever is the first of next pair\\n    b.next = a\\n    return b\\n```\n```\\nswap_pair(head):\\n    first = head\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\n```\\nswap_pair(head):\\n    if not head:\\n        return None\\n\\n    first = head\\n    \\n    if not first.next:\\n        return first\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n\\n        first = head\\n        if not first.next:\\n            return first\\n        second = first.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        return second\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529141,
                "title": "day-411-brute-better-optimal-100-python-java-c-explained",
                "content": "\\n\\n\\n\\n# BRUTE\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n        List<ListNode> list = new ArrayList<>();\\n        ListNode temNode = head;\\n        while (temNode != null) {\\n            list.add(temNode);\\n            temNode = temNode.next;\\n        }\\n        for (int i = 0; i < list.size() - 1; i += 2) {\\n            int swapElement = list.get(i).val;\\n            list.get(i).val = list.get(i + 1).val;\\n            list.get(i + 1).val = swapElement;\\n        }\\n        return head;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe first check if the input head is null or has only one node. If so, we return the head as it is. Otherwise, we create two nodes first and second and set them to the first and second nodes of the linked list, respectively. We then recursively call the swapPairs function on the next of the second node and set the next of the first node to the result. We then swap the next pointers of the first and second nodes and return the second node.\\n\\n# BETTER\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode first = head;\\n    ListNode second = head.next;\\n    first.next = swapPairs(second.next);\\n    second.next = first;\\n    return second;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(LOG(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# OPTIMAL\\nWe create a dummy node and set its next to the head. We then create a current node and initialize it to the dummy node. We use a single loop to swap every two adjacent nodes. We do this by creating two nodes first and second and swapping their next pointers. We then update the current node to point to the second node and continue the loop. Finally, we return the next of the dummy node.The time complexity of this solution is O(n) as we need to traverse the entire linked list once.\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ListNode current = dummy;\\n    while (current.next != null && current.next.next != null) {\\n        ListNode first = current.next;\\n        ListNode second = current.next.next;\\n        first.next = second.next;\\n        second.next = first;\\n        current.next = second;\\n        current = current.next.next;\\n    }\\n    return dummy.next;\\n}\\n```\\n```c++ []\\nListNode* swapPairs(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* current = dummy;\\n    while (current->next != NULL && current->next->next != NULL) {\\n        ListNode* first = current->next;\\n        ListNode* second = current->next->next;\\n        first->next = second->next;\\n        second->next = first;\\n        current->next = second;\\n        current = current->next->next;\\n    }\\n    return dummy->next;\\n}\\n```\\n```python []\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06 \\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n        List<ListNode> list = new ArrayList<>();\\n        ListNode temNode = head;\\n        while (temNode != null) {\\n            list.add(temNode);\\n            temNode = temNode.next;\\n        }\\n        for (int i = 0; i < list.size() - 1; i += 2) {\\n            int swapElement = list.get(i).val;\\n            list.get(i).val = list.get(i + 1).val;\\n            list.get(i + 1).val = swapElement;\\n        }\\n        return head;\\n}\\n```\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode first = head;\\n    ListNode second = head.next;\\n    first.next = swapPairs(second.next);\\n    second.next = first;\\n    return second;\\n}\\n```\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ListNode current = dummy;\\n    while (current.next != null && current.next.next != null) {\\n        ListNode first = current.next;\\n        ListNode second = current.next.next;\\n        first.next = second.next;\\n        second.next = first;\\n        current.next = second;\\n        current = current.next.next;\\n    }\\n    return dummy.next;\\n}\\n```\n```c++ []\\nListNode* swapPairs(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* current = dummy;\\n    while (current->next != NULL && current->next->next != NULL) {\\n        ListNode* first = current->next;\\n        ListNode* second = current->next->next;\\n        first->next = second->next;\\n        second->next = first;\\n        current->next = second;\\n        current = current->next->next;\\n    }\\n    return dummy->next;\\n}\\n```\n```python []\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1902446,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11236,
                "title": "very-easy-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            ListNode *l=head;\\n            if(head&&head->next){\\n                l=head->next;\\n                head->next=swapPairs(l->next);\\n                l->next=head;\\n            }\\n            return l;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            ListNode *l=head;\\n            if(head&&head->next){\\n                l=head->next;\\n                head->next=swapPairs(l->next);\\n                l->next=head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 300006,
                "title": "go-0-ms-faster-than-100-00-easy-code-recursion",
                "content": "```\\ntype ListNode struct {\\n\\tVal  int\\n\\tNext *ListNode\\n}\\n\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tresult := head.Next\\n\\thead.Next = swapPairs(head.Next.Next)\\n\\tresult.Next = head\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\ntype ListNode struct {\\n\\tVal  int\\n\\tNext *ListNode\\n}\\n\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tresult := head.Next\\n\\thead.Next = swapPairs(head.Next.Next)\\n\\tresult.Next = head\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298168,
                "title": "java-clean-recursive-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode newHead = head.next;\\n        head.next = swapPairs(newHead.next);\\n        newHead.next = head;\\n        return newHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode newHead = head.next;\\n        head.next = swapPairs(newHead.next);\\n        newHead.next = head;\\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278452,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        first = head.next\\n        second = head\\n        second.next = self.swapPairs(first.next)\\n        first.next = second\\n        return first\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        first = head.next\\n        second = head\\n        second.next = self.swapPairs(first.next)\\n        first.next = second\\n        return first\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11361,
                "title": "share-my-accepted-java-solution",
                "content": "    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            ListNode first = head, last = head.next;\\n            first.next = swapPairs(last.next);\\n            last.next = first;\\n            return last;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11216,
                "title": "my-accepted-solution-in-python-quite-fast",
                "content": "    class Solution:\\n        # @param a ListNode\\n        # @return a ListNode\\n        def swapPairs(self, head):\\n            p1 = guard = ListNode(0)\\n            guard.next = head\\n            \\n            try:\\n                while True:\\n                    p0, p1, p2 = p1, p1.next, p1.next.next\\n                    p0.next, p1.next, p2.next = p2, p2.next, p1\\n            except:\\n                return guard.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param a ListNode\\n        # @return a ListNode\\n        def swapPairs(self, head):\\n            p1 = guard = ListNode(0)\\n            guard.next = head\\n            \\n            try:\\n                while True:\\n                    p0, p1, p2 = p1, p1.next, p1.next.next\\n                    p0.next, p1.next, p2.next = p2, p2.next, p1\\n            except:\\n                return guard.next",
                "codeTag": "Java"
            },
            {
                "id": 11254,
                "title": "seeking-for-a-better-solution",
                "content": "Is someone has a better solution? My code can get AC, but I don't think it's good enough. Thanks~~\\n \\n   \\n\\n    public class Solution {\\n            public ListNode swapPairs(ListNode head) {\\n                ListNode cur = head, next1, next2;\\n                if(head == null) return null;\\n                if(head.next == null) return head;\\n                \\n                //head change with next is a special case, so we deal with it first\\n                ListNode temp = cur.next;\\n                cur.next = temp.next;\\n                temp.next = cur;\\n                head = temp;\\n                \\n            \\twhile(cur.next != null && cur.next.next != null) {\\n            \\t\\tnext1 = cur.next;\\n            \\t\\tnext2 = cur.next.next;\\n            \\t\\tswap(cur,next1,next2);\\n            \\t\\tcur = cur.next.next;\\n            \\t}\\n            \\treturn head;\\n            }\\n            \\n            private void swap(ListNode cur, ListNode next1, ListNode next2) {\\n            \\tcur.next = next2;\\n            \\tnext1.next = next2.next;\\n            \\tnext2.next = next1;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public ListNode swapPairs(ListNode head) {\\n                ListNode cur = head, next1, next2;\\n                if(head == null) return null;\\n                if(head.next == null) return head;\\n                \\n                //head change with next is a special case, so we deal with it first\\n                ListNode temp = cur.next;\\n                cur.next = temp.next;\\n                temp.next = cur;\\n                head = temp;\\n                \\n            \\twhile(cur.next != null && cur.next.next != null) {\\n            \\t\\tnext1 = cur.next;\\n            \\t\\tnext2 = cur.next.next;\\n            \\t\\tswap(cur,next1,next2);\\n            \\t\\tcur = cur.next.next;\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2596746,
                "title": "straightforward-0ms-iterative-solution-with-comments",
                "content": "Introduced 2 macros to make the algo more clear: one taking .next node as reference, and one as mutable\\n\\n```\\nmacro_rules! next_node_as_ref {\\n    ($a: expr) => {\\n        $a.as_ref().unwrap().next\\n    };\\n}\\nmacro_rules! next_node_as_mut {\\n    ($a: expr) => {\\n        $a.as_mut().unwrap().next\\n    };\\n}\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut cur_node = &mut head;\\n\\n        // while we have something to work with (.next has something)\\n        while cur_node.is_some() && next_node_as_ref!(cur_node).is_some() {\\n            // .take() Takes the value out of the option, leaving a None in its place.\\n            let mut even_node = next_node_as_mut!(cur_node).take();\\n\\n            // taking next odd node\\'s value\\n            let next_odd_node = next_node_as_mut!(even_node).take();\\n            // cur_node\\'s .next points to next odd node\\n            next_node_as_mut!(cur_node) = next_odd_node;\\n            // even node\\'s .next points to cur_node\\n            next_node_as_mut!(even_node) = cur_node.take();\\n            // switching cur_node with even node\\n            cur_node.replace(even_node.unwrap());\\n            // point cursor to .next.next\\n            cur_node = &mut next_node_as_mut!(next_node_as_mut!(cur_node));\\n        }\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nmacro_rules! next_node_as_ref {\\n    ($a: expr) => {\\n        $a.as_ref().unwrap().next\\n    };\\n}\\nmacro_rules! next_node_as_mut {\\n    ($a: expr) => {\\n        $a.as_mut().unwrap().next\\n    };\\n}\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut cur_node = &mut head;\\n\\n        // while we have something to work with (.next has something)\\n        while cur_node.is_some() && next_node_as_ref!(cur_node).is_some() {\\n            // .take() Takes the value out of the option, leaving a None in its place.\\n            let mut even_node = next_node_as_mut!(cur_node).take();\\n\\n            // taking next odd node\\'s value\\n            let next_odd_node = next_node_as_mut!(even_node).take();\\n            // cur_node\\'s .next points to next odd node\\n            next_node_as_mut!(cur_node) = next_odd_node;\\n            // even node\\'s .next points to cur_node\\n            next_node_as_mut!(even_node) = cur_node.take();\\n            // switching cur_node with even node\\n            cur_node.replace(even_node.unwrap());\\n            // point cursor to .next.next\\n            cur_node = &mut next_node_as_mut!(next_node_as_mut!(cur_node));\\n        }\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11132,
                "title": "very-simple-c-recursive-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if (head == NULL || head->next == NULL) return head;\\n            ListNode *grandChild = swapPairs(head->next->next);\\n            ListNode *child = head->next;\\n            child->next = head;\\n            head->next = grandChild;\\n            return child;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if (head == NULL || head->next == NULL) return head;\\n            ListNode *grandChild = swapPairs(head->next->next);\\n            ListNode *child = head->next;\\n            child->next = head;\\n            head->next = grandChild;\\n            return child;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1788868,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode tHead = swapPairs(head.next.next);\\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode tHead = swapPairs(head.next.next);\\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776487,
                "title": "javascript-time-o-n-space-o-1-simple-approach-with-explanation",
                "content": "1. Check if we have current and next Node or not.\\n2. Do simple swapping using temp variable.\\n3. Take a temporary variable and store value of first node into that.\\n4. Take value of second node and store in first node\\n5. Move to second node and replace value of second node by temp.\\n6. repeat the swapping till end of linked list.\\n\\n```\\nvar swapPairs = function(head) {\\n    let start = new ListNode();  // Taking a pointer for keeping head of linked list safe with us\\n    start = head;  // storing head into result as we\\'ll be updating head further.\\n    while(head != undefined && head.next != undefined){  //loop for itterating through linked list\\n        let temp = head.val;                              // swapping\\n        head.val = head.next.val;                     // swapping\\n        head = head.next;                               // swapping\\n        head.val = temp;                                // swapping\\n        head = head.next;                            // increasing the pointer to next element\\n    }\\n    return start;       // return the starting point of linked list as we modified the same linked list.\\n};\\n```\\n\\nFeel free to comment down if doubts on any steps.\\n\\n**Upvote** if helped.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    let start = new ListNode();  // Taking a pointer for keeping head of linked list safe with us\\n    start = head;  // storing head into result as we\\'ll be updating head further.\\n    while(head != undefined && head.next != undefined){  //loop for itterating through linked list\\n        let temp = head.val;                              // swapping\\n        head.val = head.next.val;                     // swapping\\n        head = head.next;                               // swapping\\n        head.val = temp;                                // swapping\\n        head = head.next;                            // increasing the pointer to next element\\n    }\\n    return start;       // return the starting point of linked list as we modified the same linked list.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517929,
                "title": "c-two-soltn-0-ms-faster-than-100-00",
                "content": "**Soln 1**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(head==0)\\n            return NULL;\\n        if(head->next==0)\\n            return head;\\n        \\n        \\n        ListNode *first=head;\\n        ListNode *second=first->next;\\n        ListNode *newhead=second;\\n        ListNode *prev=first;\\n        while(first && second)\\n        {\\n            prev=first;\\n            first->next=second->next;\\n            second->next=prev;\\n            \\n            first=first->next;\\n            if(first!=0 && first->next!=0)\\n             second=first->next;\\n            else\\n                break;\\n            prev->next=second;\\n            \\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```\\n\\n**Soln 2**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        ListNode *temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode *curr=temp;\\n        \\n        while(curr->next && curr->next->next)\\n        {\\n            ListNode *first=curr->next;\\n            ListNode *second=curr->next->next;\\n            first->next=second->next;\\n            second->next=first;\\n            curr->next=second;\\n            curr=curr->next->next;\\n        }\\n        return temp->next;\\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(head==0)\\n            return NULL;\\n        if(head->next==0)\\n            return head;\\n        \\n        \\n        ListNode *first=head;\\n        ListNode *second=first->next;\\n        ListNode *newhead=second;\\n        ListNode *prev=first;\\n        while(first && second)\\n        {\\n            prev=first;\\n            first->next=second->next;\\n            second->next=prev;\\n            \\n            first=first->next;\\n            if(first!=0 && first->next!=0)\\n             second=first->next;\\n            else\\n                break;\\n            prev->next=second;\\n            \\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        ListNode *temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode *curr=temp;\\n        \\n        while(curr->next && curr->next->next)\\n        {\\n            ListNode *first=curr->next;\\n            ListNode *second=curr->next->next;\\n            first->next=second->next;\\n            second->next=first;\\n            curr->next=second;\\n            curr=curr->next->next;\\n        }\\n        return temp->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549794,
                "title": "3-solutions-easy-to-understand-faster-2-iterative-and-1-recursive-python",
                "content": "```\\ndef recursive(self, head):\\n        def rec(head):\\n            if head and head.next:\\n                rep = rec(head.next.next)\\n                second = head.next\\n                first = head\\n                if second:\\n                    first.next = rep\\n                    second.next = first\\n                    return second\\n                return first\\n            elif head: return head\\n            \\n        return rec(head)\\n    \\n    def in_place_nodes(self, head):\\n        if not head: return head\\n        prev = None\\n        first = head\\n        second = head.next\\n        while first and second:\\n            if prev:\\n                prev.next = second\\n            else:\\n                head = second\\n            forward = second.next\\n            first.next = second.next\\n            second.next = first\\n            prev = first\\n            first = forward\\n            if not first: break\\n            second = first.next\\n        return head\\n    \\n        \\n    def in_place_value(self, head):\\n        if not head: return head\\n        first = head\\n        second = head.next\\n        while first and second:\\n            first.val, second.val = second.val, first.val\\n            first = second.next\\n            if not first: break\\n            second = second.next.next\\n        return head\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef recursive(self, head):\\n        def rec(head):\\n            if head and head.next:\\n                rep = rec(head.next.next)\\n                second = head.next\\n                first = head\\n                if second:\\n                    first.next = rep\\n                    second.next = first\\n                    return second\\n                return first\\n            elif head: return head\\n            \\n        return rec(head)\\n    \\n    def in_place_nodes(self, head):\\n        if not head: return head\\n        prev = None\\n        first = head\\n        second = head.next\\n        while first and second:\\n            if prev:\\n                prev.next = second\\n            else:\\n                head = second\\n            forward = second.next\\n            first.next = second.next\\n            second.next = first\\n            prev = first\\n            first = forward\\n            if not first: break\\n            second = first.next\\n        return head\\n    \\n        \\n    def in_place_value(self, head):\\n        if not head: return head\\n        first = head\\n        second = head.next\\n        while first and second:\\n            first.val, second.val = second.val, first.val\\n            first = second.next\\n            if not first: break\\n            second = second.next.next\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11078,
                "title": "easy-understand-3-lines-solutions-with-comments",
                "content": "before '=': the first node, the second and  the third node\\nafter '='   : the second node, the first  and  the third node returned by recursion.\\n\\n```\\ndef swapPairs(self, head):\\n        if head and head.next:\\n            head, head.next, head.next.next = head.next, head, self.swapPairs(head.next.next)\\n        return head",
                "solutionTags": [],
                "code": "before '=': the first node, the second and  the third node\\nafter '='   : the second node, the first  and  the third node returned by recursion.\\n\\n```\\ndef swapPairs(self, head):\\n        if head and head.next:\\n            head, head.next, head.next.next = head.next, head, self.swapPairs(head.next.next)\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 11204,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively \\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode nxt = head.next;\\n        head.next = swapPairs(nxt.next);\\n        nxt.next = head;\\n        return nxt;\\n    }\\n    \\n    // iteratively\\n    public ListNode swapPairs1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode pre = new ListNode(0), p = head, ret = head.next;\\n        while (p != null && p.next != null) {\\n            ListNode nxt = p.next;\\n            p.next = nxt.next;\\n            nxt.next = p;\\n            pre.next = nxt;\\n            pre = p;\\n            p = p.next;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively \\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode nxt = head.next;\\n        head.next = swapPairs(nxt.next);\\n        nxt.next = head;\\n        return nxt;\\n    }\\n    \\n    // iteratively\\n    public ListNode swapPairs1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode pre = new ListNode(0), p = head, ret = head.next;\\n        while (p != null && p.next != null) {\\n            ListNode nxt = p.next;\\n            p.next = nxt.next;\\n            nxt.next = p;\\n            pre.next = nxt;\\n            pre = p;\\n            p = p.next;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2774348,
                "title": "in-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n    return head;\\n    struct ListNode*x,*y,*z=NULL;\\n    x=head;\\n    y=head->next;\\n    if(head->next->next!=NULL)\\n    {\\n        z=head->next->next;\\n    }\\n    head=y;\\n    while(z!=NULL && z->next!=NULL)\\n    {\\n        y->next=x;\\n        x->next=z->next;\\n        x=z;\\n        y=x->next;\\n        z=y->next;\\n    }\\n    y->next=x;\\n    x->next=z;\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n    return head;\\n    struct ListNode*x,*y,*z=NULL;\\n    x=head;\\n    y=head->next;\\n    if(head->next->next!=NULL)\\n    {\\n        z=head->next->next;\\n    }\\n    head=y;\\n    while(z!=NULL && z->next!=NULL)\\n    {\\n        y->next=x;\\n        x->next=z->next;\\n        x=z;\\n        y=x->next;\\n        z=y->next;\\n    }\\n    y->next=x;\\n    x->next=z;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775417,
                "title": "iterative-solution-with-tuples-and-no-recursion",
                "content": "Pointer swapping can be done in a modern way using tuples:\\n```csharp\\npublic class Solution\\n{\\n    public ListNode SwapPairs(ListNode head)\\n    {\\n        ListNode prev = new();\\n        var a = head;\\n        var b = head?.next;\\n\\n        head = b ?? a;\\n\\n        while (a != null && b != null)\\n        {\\n            (prev.next, a.next, b.next) = (b, b.next, a); //swap the nodes\\n            (prev, a, b) = (a, a.next, a.next?.next); //move on\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Iterator"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public ListNode SwapPairs(ListNode head)\\n    {\\n        ListNode prev = new();\\n        var a = head;\\n        var b = head?.next;\\n\\n        head = b ?? a;\\n\\n        while (a != null && b != null)\\n        {\\n            (prev.next, a.next, b.next) = (b, b.next, a); //swap the nodes\\n            (prev, a, b) = (a, a.next, a.next?.next); //move on\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233188,
                "title": "my-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head)return head;\\n        if(!head->next)return head;\\n        ListNode temp(0);\\n        temp.next = head;\\n        ListNode* current = &temp;\\n        while(current->next!=NULL && current->next->next!=NULL){\\n            ListNode* first = current->next;\\n            ListNode* second = current->next->next;\\n            first->next = second->next;\\n            current->next = second;\\n            current->next->next = first;\\n            current = current->next->next;\\n        }\\n        return temp.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head)return head;\\n        if(!head->next)return head;\\n        ListNode temp(0);\\n        temp.next = head;\\n        ListNode* current = &temp;\\n        while(current->next!=NULL && current->next->next!=NULL){\\n            ListNode* first = current->next;\\n            ListNode* second = current->next->next;\\n            first->next = second->next;\\n            current->next = second;\\n            current->next->next = first;\\n            current = current->next->next;\\n        }\\n        return temp.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231784,
                "title": "javascript-recursion-solution",
                "content": "```\\nvar swapPairs = function(head) {\\n  // base case\\n  if (head === null || head.next === null) return head;\\n  let temp = head.next;\\n  head.next = temp.next;\\n  temp.next = head;\\n  head.next = swapPairs(head.next);\\n  return temp;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar swapPairs = function(head) {\\n  // base case\\n  if (head === null || head.next === null) return head;\\n  let temp = head.next;\\n  head.next = temp.next;\\n  temp.next = head;\\n  head.next = swapPairs(head.next);\\n  return temp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11094,
                "title": "simple-0ms-c-solution-beats-98-08",
                "content": "All we need to do is rearrange the links in the list.If <b>prev </b> is the pevious node,<b> head </b> is the current node,at every alternate node perform operations such that <br>\\nInitial:           prev | head | head->next|head->next->next\\nAfter swap:prev|head->next|head|head->next->next\\n\\n```\\n ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        while(head &&head->next)\\n        {\\n            ListNode* nn=head->next->next;\\n            prev->next=head->next;\\n            head->next->next=head;\\n            head->next=nn;\\n            prev=head;\\n            head=nn;\\n           \\n        }\\n        return dummy->next;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        while(head &&head->next)\\n        {\\n            ListNode* nn=head->next->next;\\n            prev->next=head->next;\\n            head->next->next=head;\\n            head->next=nn;\\n            prev=head;\\n            head=nn;\\n           \\n        }\\n        return dummy->next;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11266,
                "title": "python-solution-using-36ms-with-simple-method",
                "content": "\\nclass Solution(object):\\n\\n    def swapPairs(self, head):\\n\\n        if not head or not head.next:\\n            return head\\n      \\n        first,second = head, head.next\\n        third = second.next\\n        head = second\\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        \\n        return head",
                "solutionTags": [],
                "code": "\\nclass Solution(object):\\n\\n    def swapPairs(self, head):\\n\\n        if not head or not head.next:\\n            return head\\n      \\n        first,second = head, head.next\\n        third = second.next\\n        head = second\\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        \\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 3532106,
                "title": "5-lines-0ms-easy-approach-beasts-100-stepped-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are using a very simple and easy ***recursive*** approach to solve this\\n\\n\\n**Steps:**\\n\\n1. At first we will check, if head value is null we will return null.\\n\\n    `if(head==null) return null;`\\n2. Then we check, if next head value is null we will return current head.\\n\\n    `if (head.next == null) return head;`\\n3. Later we will swap the 2 value of by creating a temp variable & recursively swapping the values.\\n    \\n    - Storing the next head to a temp ListNode that we will return at last. `ListNode temp = head.next;`\\n    - Then we  get the call the function recursively for next head. \\n     `head.next = swapPairs(temp.next);`\\n    - Then we swap value next temp with the head.\\n     `temp.next = head;`\\n4. At last we will return the temp ListNode we created .\\n \\n    `return temp;`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if (head.next == null) return head;\\n\\n        ListNode temp = head.next;\\n        head.next = swapPairs(temp.next);\\n        temp.next = head;\\n\\n        return temp;\\n    }\\n}\\n```\\n\\n<!-- ---\\n**Iterative** \\n```\\npublic ListNode swapPairs1(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode pre = new ListNode(0), p = head, ret = head.next;\\n    while (p != null && p.next != null) {\\n        ListNode nxt = p.next;\\n        p.next = nxt.next;\\n        nxt.next = p;\\n        pre.next = nxt;\\n        pre = p;\\n        p = p.next;\\n    }\\n    return ret;\\n}\\n``` -->\\n\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e835e6d0-5193-493a-9394-e4e90c90e1b0_1684266894.6208477.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if (head.next == null) return head;\\n\\n        ListNode temp = head.next;\\n        head.next = swapPairs(temp.next);\\n        temp.next = head;\\n\\n        return temp;\\n    }\\n}\\n```\n```\\npublic ListNode swapPairs1(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode pre = new ListNode(0), p = head, ret = head.next;\\n    while (p != null && p.next != null) {\\n        ListNode nxt = p.next;\\n        p.next = nxt.next;\\n        nxt.next = p;\\n        pre.next = nxt;\\n        pre = p;\\n        p = p.next;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530416,
                "title": "c-recursive-solution-to-swap-nodes-in-pairs-dlc-16-05-2023-all-testcases-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst intuition that comes to mind is that swap the pairs of nodes and modify the next pointers for each pair of nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe basic ideology of recursion\\n\"Solve the first case, other cases will be handled by Recursion.\"\\n\\nHere, solve for the first pair of nodes, i.e., swap the first two nodes and modify their next pointers. First node will now point to the node where second node was pointing to and second node will point to the first node.\\n\\nCall the function recursively and store the head (first) node of the remaining part of the linked list in the next pointer of the first node.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next==NULL){\\n            return head;\\n        }\\n\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head->next;\\n\\n        temp1->next = temp2->next;\\n        temp2->next = temp1;\\n\\n        if (temp1->next!=NULL){\\n            temp1->next = swapPairs(temp1->next);\\n        }\\n\\n        return temp2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next==NULL){\\n            return head;\\n        }\\n\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head->next;\\n\\n        temp1->next = temp2->next;\\n        temp2->next = temp1;\\n\\n        if (temp1->next!=NULL){\\n            temp1->next = swapPairs(temp1->next);\\n        }\\n\\n        return temp2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471758,
                "title": "c-very-easy-solution-100-beat",
                "content": "\\nclass Solution {\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case \\n        if(head == NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode* forward = NULL;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while(curr != NULL && count < 2){\\n             forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        \\n        if(forward != NULL){\\n            head->next = swapPairs(forward);\\n        }\\n        //sb hogya abb return krde \\n        return prev;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case \\n        if(head == NULL){\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3310367,
                "title": "java-three-line-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ni have used basic concept of linkedlist and recursive call\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode prv=head;\\n        ListNode curr=head.next;\\n        ListNode next=head.next.next;\\n        head=curr;\\n        head.next=prv;\\n        head.next.next=swapPairs(next);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode prv=head;\\n        ListNode curr=head.next;\\n        ListNode next=head.next.next;\\n        head=curr;\\n        head.next=prv;\\n        head.next.next=swapPairs(next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430680,
                "title": "c-code-without-finding-length-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* hp = head;\\n        int x = 0;\\n        while(hp!=nullptr && hp->next!=nullptr){\\n            if(x%2==0){\\n              swap(hp->val , hp->next->val);\\n            }\\n            x++;\\n            hp = hp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* hp = head;\\n        int x = 0;\\n        while(hp!=nullptr && hp->next!=nullptr){\\n            if(x%2==0){\\n              swap(hp->val , hp->next->val);\\n            }\\n            x++;\\n            hp = hp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795879,
                "title": "simple-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode *prev = dummy, *cur = head;\\n\\n        while(cur && cur->next) {\\n        \\t// save pointers\\n        \\tListNode* nxtPair = cur->next->next;\\n        \\tListNode* second = cur->next;\\n\\n        \\t// reverse this pair\\n        \\tsecond->next = cur;\\n        \\tcur->next = nxtPair;\\n        \\tprev->next = second;\\n\\n        \\t// update pointers\\n        \\tprev = cur;\\n        \\tcur = nxtPair;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode *prev = dummy, *cur = head;\\n\\n        while(cur && cur->next) {\\n        \\t// save pointers\\n        \\tListNode* nxtPair = cur->next->next;\\n        \\tListNode* second = cur->next;\\n\\n        \\t// reverse this pair\\n        \\tsecond->next = cur;\\n        \\tcur->next = nxtPair;\\n        \\tprev->next = second;\\n\\n        \\t// update pointers\\n        \\tprev = cur;\\n        \\tcur = nxtPair;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774481,
                "title": "c-recursive-solutions-faster-than-100-00-of-submissions",
                "content": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n      if(head==NULL || head->next == NULL)\\n            return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next);\\n        temp->next = head;\\n        return temp;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n      if(head==NULL || head->next == NULL)\\n            return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next);\\n        temp->next = head;\\n        return temp;  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1133526,
                "title": "js-iterative-and-recursive-w-explanation",
                "content": "Iterative Method\\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    // create a dummy to keep track of the new linked list\\n    let dummy = new ListNode(0, null)\\n    // tail would keep track of the dummy and move as it link more nodes\\n    let tail = dummy\\n    \\n    while (head != null && head.next != null) {\\n        let currHead = head\\n        let nextHead = head.next\\n        let skipHead = head.next.next    \\n        \\n        // reverse the second node with the first node\\n        nextHead.next = currHead\\n        currHead.next = null\\n        \\n        // nextHead = [2,1]\\n        tail.next = nextHead\\n        // dummy = [0,2,1] so tail = [1]\\n        tail = tail.next.next\\n        // point the head to the next part so it can reverse and repeat again\\n        head = skipHead\\n    }\\n    \\n    // this is for odd amount of nodes\\n    // since previous is tail.next = nextHead, which skips 2\\n    // for even, it won\\'t affect it\\n    tail.next = head\\n    \\n    // dummy.next holds the newly reversed linked list\\n    return dummy.next\\n};\\n```\\n\\n\\nRecursive Method\\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    let currHead = head\\n    let nextHead = head.next\\n    let skipHead = head.next.next\\n    \\n    // relink the second node to the first node\\n    nextHead.next = currHead\\n    \\n    // the firstNode\\'s next would be the result of the swap\\n    currHead.next = swapPairs(skipHead)\\n    \\n    // nextHead targets the 2nd node, which would be the first node if it reversed\\n    return nextHead\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    // create a dummy to keep track of the new linked list\\n    let dummy = new ListNode(0, null)\\n    // tail would keep track of the dummy and move as it link more nodes\\n    let tail = dummy\\n    \\n    while (head != null && head.next != null) {\\n        let currHead = head\\n        let nextHead = head.next\\n        let skipHead = head.next.next    \\n        \\n        // reverse the second node with the first node\\n        nextHead.next = currHead\\n        currHead.next = null\\n        \\n        // nextHead = [2,1]\\n        tail.next = nextHead\\n        // dummy = [0,2,1] so tail = [1]\\n        tail = tail.next.next\\n        // point the head to the next part so it can reverse and repeat again\\n        head = skipHead\\n    }\\n    \\n    // this is for odd amount of nodes\\n    // since previous is tail.next = nextHead, which skips 2\\n    // for even, it won\\'t affect it\\n    tail.next = head\\n    \\n    // dummy.next holds the newly reversed linked list\\n    return dummy.next\\n};\\n```\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    let currHead = head\\n    let nextHead = head.next\\n    let skipHead = head.next.next\\n    \\n    // relink the second node to the first node\\n    nextHead.next = currHead\\n    \\n    // the firstNode\\'s next would be the result of the swap\\n    currHead.next = swapPairs(skipHead)\\n    \\n    // nextHead targets the 2nd node, which would be the first node if it reversed\\n    return nextHead\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717219,
                "title": "go-golang-two-solutions",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Swap Nodes in Pairs.\\nMemory Usage: 2.1 MB, less than 13.25% of Go online submissions for Swap Nodes in Pairs.\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    ans := &ListNode{0, head}\\n    dummy := ans\\n    for dummy.Next != nil && dummy.Next.Next != nil {\\n        a := dummy.Next\\n        b := dummy.Next.Next\\n        a.Next = b.Next\\n        dummy.Next = b\\n        dummy.Next.Next = a\\n        dummy = dummy.Next.Next\\n    }\\n    return ans.Next\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for Swap Nodes in Pairs.\\nMemory Usage: 2.1 MB, less than 99.40% of Go online submissions for Swap Nodes in Pairs.\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil { return head }\\n    tmp := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    tmp.Next = head\\n    return tmp\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    ans := &ListNode{0, head}\\n    dummy := ans\\n    for dummy.Next != nil && dummy.Next.Next != nil {\\n        a := dummy.Next\\n        b := dummy.Next.Next\\n        a.Next = b.Next\\n        dummy.Next = b\\n        dummy.Next.Next = a\\n        dummy = dummy.Next.Next\\n    }\\n    return ans.Next\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil { return head }\\n    tmp := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    tmp.Next = head\\n    return tmp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 580838,
                "title": "python-js-java-c-o-n-recursive-sol-w-visualization",
                "content": "Python/Java/JS/C++ O(n) recusrion sol.\\n\\n[Tutorial video to Swap nodes in pairs [ Chinese \\u4E2D\\u6587\\u8B1B\\u89E3\\u5F71\\u7247]](https://youtu.be/DIHuNQ-PQZg)\\n\\n---\\n\\n**Visualization**\\n\\n1. Reverse next node linkage\\n```\\nnext_node.next = node\\n```\\n  \\n2. Update node linkage to next pair\\n```\\nnode.next = helper( next_pair)\\n```\\n![image.png](https://assets.leetcode.com/users/images/b903dd7c-983c-44c2-8166-289928c97fff_1684213084.129816.png)\\n\\n\\n---\\n\\n**Hint**:\\n\\nRecurvisely reverse each pair and build new linkage between reversed pairs.\\n\\n---\\n\\n**Implementation** by Python:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        cur = head\\n               \\n        try:\\n            \\n            # locate head of next pair\\n            next_pair = cur.next.next\\n            \\n            # reverse next pair\\n            junction = self.swapPairs( next_pair )\\n            \\n            # reverse current pair\\n            original_next = cur.next\\n            \\n            original_next.next = cur\\n            \\n            # build new linkage from current pair to next pair\\n            cur.next = junction\\n            \\n            return original_next\\n            \\n        except:\\n            \\n            # Base case:\\n            # Either one node or None remaining\\n            return cur\\n\\n```\\n\\n---\\n\\nShare another implementation:\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def helper( node ):\\n\\n            # Base case: empty node, or only one node\\n            if not node or not node.next:\\n                return node\\n\\n\\n            # General case:\\n            next_node = node.next\\n            next_pair = next_node.next\\n\\n            # Reverse next node linkage\\n            next_node.next = node\\n\\n            # Update node linkage to next pair\\n            node.next = helper( next_pair)\\n\\n            # return new head after swap\\n            return next_node\\n        \\n        # ------------------------------\\n\\n        return helper( head )\\n```\\n\\n---\\n\\n**Implementation** by Java:\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if( head == null || head.next == null){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original pointer\\n        ListNode right = head.next;\\n        ListNode nextHop = right.next;\\n        \\n        // reverse linkage of current pair\\n        right.next = head;\\n            \\n        // reverse next pair and get the node of current head\\'s next node\\n        head.next = swapPairs( nextHop );\\n            \\n        return right;\\n        \\n    }\\n}\\n```\\n\\n---\\n\\n**Implementation** by C++\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if( head == nullptr || head->next == nullptr ){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original node\\n        ListNode *right = head->next, *nextPair = head->next->next;\\n        \\n        // reverse current pair\\n        right->next = head;\\n        \\n        // swap next pair recursively\\n        head->next = swapPairs( nextPair );\\n        \\n        return right;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n**Implementation** by Javascript:\\n\\n```\\nvar swapPairs = function(head) {\\n    \\n    if( head == null || head.next == null ){\\n        \\n        // Base case aka stop condition\\n        return head;\\n    }\\n    \\n    // General cases:\\n    let [right, nextPair] = [head.next, head.next.next];\\n    \\n    // Reverse current pair\\n    right.next = head;\\n    \\n    // Reverse next pair recursively\\n    head.next = swapPairs( nextPair );\\n    \\n    return right;\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nnext_node.next = node\\n```\n```\\nnode.next = helper( next_pair)\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        cur = head\\n               \\n        try:\\n            \\n            # locate head of next pair\\n            next_pair = cur.next.next\\n            \\n            # reverse next pair\\n            junction = self.swapPairs( next_pair )\\n            \\n            # reverse current pair\\n            original_next = cur.next\\n            \\n            original_next.next = cur\\n            \\n            # build new linkage from current pair to next pair\\n            cur.next = junction\\n            \\n            return original_next\\n            \\n        except:\\n            \\n            # Base case:\\n            # Either one node or None remaining\\n            return cur\\n\\n```\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def helper( node ):\\n\\n            # Base case: empty node, or only one node\\n            if not node or not node.next:\\n                return node\\n\\n\\n            # General case:\\n            next_node = node.next\\n            next_pair = next_node.next\\n\\n            # Reverse next node linkage\\n            next_node.next = node\\n\\n            # Update node linkage to next pair\\n            node.next = helper( next_pair)\\n\\n            # return new head after swap\\n            return next_node\\n        \\n        # ------------------------------\\n\\n        return helper( head )\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if( head == null || head.next == null){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original pointer\\n        ListNode right = head.next;\\n        ListNode nextHop = right.next;\\n        \\n        // reverse linkage of current pair\\n        right.next = head;\\n            \\n        // reverse next pair and get the node of current head\\'s next node\\n        head.next = swapPairs( nextHop );\\n            \\n        return right;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if( head == nullptr || head->next == nullptr ){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original node\\n        ListNode *right = head->next, *nextPair = head->next->next;\\n        \\n        // reverse current pair\\n        right->next = head;\\n        \\n        // swap next pair recursively\\n        head->next = swapPairs( nextPair );\\n        \\n        return right;\\n        \\n    }\\n};\\n```\n```\\nvar swapPairs = function(head) {\\n    \\n    if( head == null || head.next == null ){\\n        \\n        // Base case aka stop condition\\n        return head;\\n    }\\n    \\n    // General cases:\\n    let [right, nextPair] = [head.next, head.next.next];\\n    \\n    // Reverse current pair\\n    right.next = head;\\n    \\n    // Reverse next pair recursively\\n    head.next = swapPairs( nextPair );\\n    \\n    return right;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273702,
                "title": "python-solution-in-place",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head and head.next:\\n            dummy = head\\n            head = head.next\\n            dummy.next = head.next\\n            head.next = dummy\\n            head.next.next = self.swapPairs(head.next.next)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head and head.next:\\n            dummy = head\\n            head = head.next\\n            dummy.next = head.next\\n            head.next = dummy\\n            head.next.next = self.swapPairs(head.next.next)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11194,
                "title": "java-recursive-and-iterative-solutions-both-cost-0ms",
                "content": "Recursive:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn head;\\n    \\t\\tListNode p1 = head, p2 = head.next, p3 = p2.next;\\n    \\t\\tp1.next = p3;\\n    \\t\\tp2.next = p1;\\n    \\t\\t\\n    \\t\\tif (p3 != null) {\\n    \\t\\t\\tp1.next = swapPairs(p3);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn p2;\\n    \\t}\\n\\nIterative:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn head;\\n    \\t\\tListNode curr = head;\\n    \\t\\tListNode next = head.next;\\n    \\t\\tListNode newHead = next;\\n    \\t\\t\\n    \\t\\tcurr.next = next.next;\\n    \\t\\tnext.next = curr;\\n    \\t\\t\\n    \\t\\tif (curr.next == null)\\n    \\t\\t\\treturn newHead;\\n    \\t\\t\\n    \\t\\twhile (curr.next.next != null) {\\n    \\t\\t\\tListNode prev = curr;\\n    \\t\\t\\tcurr = curr.next;\\n    \\t\\t\\tnext = curr.next;\\n    \\t\\t\\n    \\t\\t\\tprev.next = next;\\n    \\t\\t\\tcurr.next = next.next;\\n    \\t\\t\\tnext.next = curr;\\n    \\t\\t\\t\\n    \\t\\t\\tif (curr.next == null || curr.next.next == null)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn newHead;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "Recursive:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn head;\\n    \\t\\tListNode p1 = head, p2 = head.next, p3 = p2.next;\\n    \\t\\tp1.next = p3;\\n    \\t\\tp2.next = p1;\\n    \\t\\t\\n    \\t\\tif (p3 != null) {\\n    \\t\\t\\tp1.next = swapPairs(p3);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn p2;\\n    \\t}\\n\\nIterative:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn head;\\n    \\t\\tListNode curr = head;\\n    \\t\\tListNode next = head.next;\\n    \\t\\tListNode newHead = next;\\n    \\t\\t\\n    \\t\\tcurr.next = next.next;\\n    \\t\\tnext.next = curr;\\n    \\t\\t\\n    \\t\\tif (curr.next == null)\\n    \\t\\t\\treturn newHead;\\n    \\t\\t\\n    \\t\\twhile (curr.next.next != null) {\\n    \\t\\t\\tListNode prev = curr;\\n    \\t\\t\\tcurr = curr.next;\\n    \\t\\t\\tnext = curr.next;\\n    \\t\\t\\n    \\t\\t\\tprev.next = next;\\n    \\t\\t\\tcurr.next = next.next;\\n    \\t\\t\\tnext.next = curr;\\n    \\t\\t\\t\\n    \\t\\t\\tif (curr.next == null || curr.next.next == null)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn newHead;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 11267,
                "title": "c-solution-easy-to-understand-with-comments-and-explanations",
                "content": "<h1>Renewed Solution</h1>\\n\\nThe main point is that if there are 2 more nodes (which is a pair) following, then swap them, otherwise, end the process.\\n\\n    bool SwapHelper(ListNode *p)\\n    {\\n        if (p->next and p->next->next)\\n        {\\n            ListNode *n1 = p->next;\\n            ListNode *n2 = p->next->next;\\n            \\n            p->next = n2;\\n            n1->next = n2->next;\\n            n2->next = n1;\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    ListNode *swapPairs(ListNode *head) \\n    {\\n        if (!head) \\n            return nullptr;\\n        \\n        // Create a head Node\\n        ListNode new_head(-1);\\n        new_head.next = head;\\n        \\n        ListNode *p = &new_head;\\n        \\n        // While has two more node and swap succeeded\\n        while (SwapHelper(p)) \\n            p = p->next->next;\\n        \\n        return new_head.next;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "<h1>Renewed Solution</h1>\\n\\nThe main point is that if there are 2 more nodes (which is a pair) following, then swap them, otherwise, end the process.\\n\\n    bool SwapHelper(ListNode *p)\\n    {\\n        if (p->next and p->next->next)\\n        {\\n            ListNode *n1 = p->next;\\n            ListNode *n2 = p->next->next;\\n            \\n            p->next = n2;\\n            n1->next = n2->next;\\n            n2->next = n1;\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    ListNode *swapPairs(ListNode *head) \\n    {\\n        if (!head) \\n            return nullptr;\\n        \\n        // Create a head Node\\n        ListNode new_head(-1);\\n        new_head.next = head;\\n        \\n        ListNode *p = &new_head;\\n        \\n        // While has two more node and swap succeeded\\n        while (SwapHelper(p)) \\n            p = p->next->next;\\n        \\n        return new_head.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529195,
                "title": "easy-java-solution-with-explanation-beating-100-in-tc",
                "content": "# Please Upvote!!!\\n\\n\\n![Screenshot 2023-05-16 at 09.08.07.png](https://assets.leetcode.com/users/images/6223796e-4c86-4b23-8b51-880f70453355_1684208465.7977593.png)\\n\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo swap every two adjacent nodes in a linked list without modifying the node values, you can manipulate the pointers of the nodes. Here\\'s an algorithm to solve the problem:\\n\\nInitialize a dummy node and set its next pointer to the head of the given linked list. This dummy node will be useful as the new head of the modified list.\\nInitialize three pointers: prev, curr, and next. Set prev to the dummy node and curr to the head of the list.\\nIterate through the list while curr and curr.next are not null:\\nSet next to curr.next.\\nPoint curr.next to next.next.\\nPoint next.next to curr.\\nPoint prev.next to next.\\nMove prev to curr.\\nMove curr to curr.next.\\nReturn the modified list\\'s head, which is the dummy node\\'s next node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode nodeSlow = null, nodeFast = head.next;\\n        ListNode temp = head;\\n        temp.next = nodeFast.next;\\n        nodeFast.next = temp;\\n        head = nodeFast;\\n        nodeFast = nodeFast.next;\\n        nodeSlow = head;\\n        while(nodeFast.next!=null){\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n\\n            if(nodeFast.next!=null) {\\n                nodeSlow.next = nodeFast.next;\\n                temp = nodeFast.next.next;\\n                nodeSlow.next.next = nodeFast;\\n                nodeFast.next = temp;\\n                nodeSlow = nodeSlow.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode nodeSlow = null, nodeFast = head.next;\\n        ListNode temp = head;\\n        temp.next = nodeFast.next;\\n        nodeFast.next = temp;\\n        head = nodeFast;\\n        nodeFast = nodeFast.next;\\n        nodeSlow = head;\\n        while(nodeFast.next!=null){\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n\\n            if(nodeFast.next!=null) {\\n                nodeSlow.next = nodeFast.next;\\n                temp = nodeFast.next.next;\\n                nodeSlow.next.next = nodeFast;\\n                nodeFast.next = temp;\\n                nodeSlow = nodeSlow.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528787,
                "title": "c-best-shortest-3-lines-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck if the linked list is empty or has only one node. If so, return the head of the linked list. \\n\\nOtherwise, create a pointer next to the second node in the linked list.\\n\\nSet the next pointer of the first node to the result of recursively calling swapPairs on the third node (if it exists) and beyond.\\n\\nSet the next pointer of the next node to the first node.\\nReturn the next node as the new head of the linked list.\\nDone !!!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if (!head || !head->next) {\\n        return head;\\n    }\\n    ListNode* next = head->next;\\n    head->next = swapPairs(next->next);\\n    next->next = head;\\n    return next;\\n}\\n\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/ab237660-fad0-4f6c-b23d-642be5c4aa75_1684195692.93272.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion",
                    "Doubly-Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if (!head || !head->next) {\\n        return head;\\n    }\\n    ListNode* next = head->next;\\n    head->next = swapPairs(next->next);\\n    next->next = head;\\n    return next;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528782,
                "title": "java-recursion-beats-100-12-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Recursively traverse the list to the end.\\n2. On the way back return every node at an even number position.\\n3. Update the `next` pointers for nodes at odd and even positions with their own logic.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int cnt = 0;\\n\\n  public ListNode swapPairs(ListNode node) {\\n    if (node == null) return null;\\n\\n    cnt++;\\n    var ret = swapPairs(node.next);\\n\\n    if (cnt % 2 == 1 && ret != null) {\\n      // node -> the first (left) node in each pair\\n      node.next = ret.next;\\n      ret.next = node;\\n    } else {\\n      // node -> the second (right) node in each pair\\n      node.next = ret;\\n      ret = node;\\n    }\\n    cnt--;\\n    return ret;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  int cnt = 0;\\n\\n  public ListNode swapPairs(ListNode node) {\\n    if (node == null) return null;\\n\\n    cnt++;\\n    var ret = swapPairs(node.next);\\n\\n    if (cnt % 2 == 1 && ret != null) {\\n      // node -> the first (left) node in each pair\\n      node.next = ret.next;\\n      ret.next = node;\\n    } else {\\n      // node -> the second (right) node in each pair\\n      node.next = ret;\\n      ret = node;\\n    }\\n    cnt--;\\n    return ret;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142432,
                "title": "c-solution-easy-to-understand-recursion",
                "content": "# Intuition\\nA pretty simple approach using recursion\\n\\n# Approach\\n1. We have to keep in mind that while swapping, we are only working with two nodes at a time.\\n2. I have written the swapping steps under the comment in the code. Take a piece of paper and try to dry run it on two nodes, You will get it.\\n3. Now we know how I am swapping them, One case is solved, rest will be done by recursion.\\n4. After swapping the first two nodes, we will attach the result of swapping after the recursion has done it\\'s work.\\n5. we will have to return the temp as it will be pointing to the first node of the swapping result.\\n6. and we\\'re DONE !!\\n\\nMy solution is not the best, but is easy to understand for the beginners. \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL)\\n            return NULL;\\n\\n        if(head->next == NULL)\\n            return head;\\n\\n        ListNode* tempHead = head;\\n\\n        //swapping\\n        ListNode* temp = tempHead->next;\\n        tempHead->next = tempHead->next->next;\\n        temp->next = tempHead;\\n        //tempHead = tempHead->next;\\n\\n        tempHead->next = swapPairs(tempHead->next);\\n\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL)\\n            return NULL;\\n\\n        if(head->next == NULL)\\n            return head;\\n\\n        ListNode* tempHead = head;\\n\\n        //swapping\\n        ListNode* temp = tempHead->next;\\n        tempHead->next = tempHead->next->next;\\n        temp->next = tempHead;\\n        //tempHead = tempHead->next;\\n\\n        tempHead->next = swapPairs(tempHead->next);\\n\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774660,
                "title": "easy-c-100-faster-solution",
                "content": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL or head->next==NULL) return head;\\n        ListNode* a = NULL;\\n        ListNode* b = head;\\n        ListNode* c = head->next;\\n        \\n        while(b!=NULL && c!=NULL){\\n            if(a==NULL){\\n                b->next = c->next;\\n                c->next = b;\\n                head = c;\\n            }else{\\n                a->next = c;\\n                b->next = c->next;\\n                c->next = b;\\n            }\\n            a = b;\\n            b = b->next;\\n            if(b) c = b->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL or head->next==NULL) return head;\\n        ListNode* a = NULL;\\n        ListNode* b = head;\\n        ListNode* c = head->next;\\n        \\n        while(b!=NULL && c!=NULL){\\n            if(a==NULL){\\n                b->next = c->next;\\n                c->next = b;\\n                head = c;\\n            }else{\\n                a->next = c;\\n                b->next = c->next;\\n                c->next = b;\\n            }\\n            a = b;\\n            b = b->next;\\n            if(b) c = b->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487511,
                "title": "python-easy-with-dummy-head-clean-concise",
                "content": "```python\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        \\n        def addNode(node):\\n            nonlocal curHead\\n            curHead.next = node\\n            curHead = curHead.next\\n        \\n        while head != None and head.next != None:\\n            nxt = head.next\\n            nxt2 = nxt.next\\n            \\n            addNode(nxt)  # Add nxt node\\n            addNode(head) # Add cur node\\n            \\n            head = nxt2\\n            \\n        if head != None:  # If there is a left node -> Add that node\\n            addNode(head)\\n        curHead.next = None\\n        \\n        return dummyHead.next\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is number of nodes in the linked list.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        \\n        def addNode(node):\\n            nonlocal curHead\\n            curHead.next = node\\n            curHead = curHead.next\\n        \\n        while head != None and head.next != None:\\n            nxt = head.next\\n            nxt2 = nxt.next\\n            \\n            addNode(nxt)  # Add nxt node\\n            addNode(head) # Add cur node\\n            \\n            head = nxt2\\n            \\n        if head != None:  # If there is a left node -> Add that node\\n            addNode(head)\\n        curHead.next = None\\n        \\n        return dummyHead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485546,
                "title": "c-easytounderstand-recursion-faster-than-100-less-memory-than-99-88",
                "content": "If you have any queries, be sure to ask \\u270C.\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next == NULL){  // If List is empty otr has only 1 node return;\\n            return head;\\n        }\\n        \\n        ListNode* first = head; // first pointer to List\\'s first node\\n        ListNode* second = head->next; // second pointer to List\\'s second node\\n        ListNode* third = head->next->next; // third pointer to List\\'s third node\\n        \\n        second->next = first; // Made second\\'s next point to first instead of third. So, it\\'s like first\\'s next and second\\'s next are pointing to second and first respectively.\\n\\t\\t\\n        first->next = swapPairs(third); // made first\\'s next point to swapPairs(third), because we assume, recursion will swap the rest of the pairs and whatever it will return first\\'s next will point to that node.\\n        \\n        return second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next == NULL){  // If List is empty otr has only 1 node return;\\n            return head;\\n        }\\n        \\n        ListNode* first = head; // first pointer to List\\'s first node\\n        ListNode* second = head->next; // second pointer to List\\'s second node\\n        ListNode* third = head->next->next; // third pointer to List\\'s third node\\n        \\n        second->next = first; // Made second\\'s next point to first instead of third. So, it\\'s like first\\'s next and second\\'s next are pointing to second and first respectively.\\n\\t\\t\\n        first->next = swapPairs(third); // made first\\'s next point to swapPairs(third), because we assume, recursion will swap the rest of the pairs and whatever it will return first\\'s next will point to that node.\\n        \\n        return second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430366,
                "title": "c-well-commented",
                "content": "```\\nLets take an example : 1 2 3 4\\nBase condition at top is if linked list has no element or 1 element just return the head itself .\\nNow we have 2 pointers p pointing to head i.e. 1 and res pointing to head->next i.e. 2\\nTwo more pointers q and temp of ListNode type.\\nWhile(true)\\n{\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n\\t\\t\\t\\nthis above statements simply means in first iteration :  temp will point to 3 and 2->1 will be achieved , if statement of temp wont execute \\n\\n            p->next = temp->next;\\n            p = temp;\\n\\t\\t\\t\\nAbove 2 statements means : 1\\'s link with 4 will be established and value of temp i.e 3 will be stored in p, so now p contains 3 that points to 4.\\nSame way 2nd iteration will execute and 3->4 will turn into 4->3 and this time if statement inside while loop will execute as temp has become null, \\np->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n}\\nWe are returning res as it points to 2 which can give us entire linked list i.e : 2 -> 1 -> 4 -> 3 -> NULL\\nupvote if u like it .\\n```\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) \\n            return head;\\n        \\n        ListNode* p = head;\\n        ListNode* res = head->next;\\n        ListNode* q; ListNode* temp;\\n        \\n        while(true)\\n        {\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nLets take an example : 1 2 3 4\\nBase condition at top is if linked list has no element or 1 element just return the head itself .\\nNow we have 2 pointers p pointing to head i.e. 1 and res pointing to head->next i.e. 2\\nTwo more pointers q and temp of ListNode type.\\nWhile(true)\\n{\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n\\t\\t\\t\\nthis above statements simply means in first iteration :  temp will point to 3 and 2->1 will be achieved , if statement of temp wont execute \\n\\n            p->next = temp->next;\\n            p = temp;\\n\\t\\t\\t\\nAbove 2 statements means : 1\\'s link with 4 will be established and value of temp i.e 3 will be stored in p, so now p contains 3 that points to 4.\\nSame way 2nd iteration will execute and 3->4 will turn into 4->3 and this time if statement inside while loop will execute as temp has become null, \\np->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n}\\nWe are returning res as it points to 2 which can give us entire linked list i.e : 2 -> 1 -> 4 -> 3 -> NULL\\nupvote if u like it .\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) \\n            return head;\\n        \\n        ListNode* p = head;\\n        ListNode* res = head->next;\\n        ListNode* q; ListNode* temp;\\n        \\n        while(true)\\n        {\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422154,
                "title": "c-easy-to-understand-swap-nodes-two-methods",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Iterative**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if(head==NULL)\\n    return NULL;\\n    if(head->next==NULL)\\n    return head;\\n    ListNode *dummy=new ListNode(-1);\\n    ListNode* curr=head;\\n    ListNode* prev=dummy;    \\n    prev->next=curr;\\n    while(curr&&curr->next)\\n    {\\n    prev->next=curr->next;\\n    curr->next=curr->next->next;\\n    prev->next->next=curr;\\n    prev=prev->next->next;\\n    curr=curr->next;\\n    }   \\n return dummy->next;   \\n}\\n};\\n```\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        //base case\\n        if(!head || !head->next) return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next); \\n        temp->next = head;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if(head==NULL)\\n    return NULL;\\n    if(head->next==NULL)\\n    return head;\\n    ListNode *dummy=new ListNode(-1);\\n    ListNode* curr=head;\\n    ListNode* prev=dummy;    \\n    prev->next=curr;\\n    while(curr&&curr->next)\\n    {\\n    prev->next=curr->next;\\n    curr->next=curr->next->next;\\n    prev->next->next=curr;\\n    prev=prev->next->next;\\n    curr=curr->next;\\n    }   \\n return dummy->next;   \\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        //base case\\n        if(!head || !head->next) return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next); \\n        temp->next = head;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301987,
                "title": "c-solution",
                "content": "**Intuition**\\nSwap the node pairs is not difficult, but link node paris after swapping is tricky. We need to use ```prev``` to record the first node ```s1``` of the previous node pair, and then link it to the next node pair.\\n\\n![image](https://assets.leetcode.com/users/images/773756a7-225c-41cb-895b-aecc89dddfa2_1634282202.369622.png)\\n\\n**complexity**\\n- time: O(N)\\n- space: O(1)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode s1 = null;\\n        ListNode s2 = null;\\n        \\n        while(prev != null && prev.next != null && prev.next.next != null)\\n        {\\n            s1 = prev.next;\\n            s2 = prev.next.next;\\n            prev.next = s2;\\n            s1.next = s2.next;\\n            s2.next = s1;\\n            prev = s1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```prev```\n```s1```\n```\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode s1 = null;\\n        ListNode s2 = null;\\n        \\n        while(prev != null && prev.next != null && prev.next.next != null)\\n        {\\n            s1 = prev.next;\\n            s2 = prev.next.next;\\n            prev.next = s2;\\n            s1.next = s2.next;\\n            s2.next = s1;\\n            prev = s1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683353,
                "title": "javascript",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let cur = head;\\n    let newHead = head && head.next ? head.next : head;\\n        \\n    while (cur && cur.next) {\\n        let next = cur.next;\\n        let temp = next.next;\\n        \\n        next.next = cur;\\n        cur.next = temp && temp.next ? temp.next : temp;\\n        \\n        cur = temp;\\n    }\\n\\n    \\n    return newHead;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let cur = head;\\n    let newHead = head && head.next ? head.next : head;\\n        \\n    while (cur && cur.next) {\\n        let next = cur.next;\\n        let temp = next.next;\\n        \\n        next.next = cur;\\n        cur.next = temp && temp.next ? temp.next : temp;\\n        \\n        cur = temp;\\n    }\\n\\n    \\n    return newHead;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674270,
                "title": "c-o-n-solution-beats-100-in-time-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/swap-nodes-in-pairs/\\n    \\n    Idea is to take 2 ndoes at a time and swap them, then make the\\n    2st node connected to the 3rd node if there and continue with the 3rd node.\\n    TC: O(N), SC:O(1)\\n*/\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // We use a dummy head node to make handling head operations simpler\\n        ListNode *dummy = new ListNode(-1), *tail = dummy;\\n        // add the dummy node to list\\n        tail->next = head;\\n        \\n        while(head && head->next) {\\n            ListNode *nextptr = head->next->next;\\n            // swap the adjacent nodes\\n            // 2nd node comes to 1st pos \\n            tail->next = head->next;\\n            // connecting 2nd node to 1st node\\n            (head->next)->next = head;\\n            // make the 1st node connected to next node on list\\n            tail = head;\\n            tail->next = nextptr;\\n            head = nextptr;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/swap-nodes-in-pairs/\\n    \\n    Idea is to take 2 ndoes at a time and swap them, then make the\\n    2st node connected to the 3rd node if there and continue with the 3rd node.\\n    TC: O(N), SC:O(1)\\n*/\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // We use a dummy head node to make handling head operations simpler\\n        ListNode *dummy = new ListNode(-1), *tail = dummy;\\n        // add the dummy node to list\\n        tail->next = head;\\n        \\n        while(head && head->next) {\\n            ListNode *nextptr = head->next->next;\\n            // swap the adjacent nodes\\n            // 2nd node comes to 1st pos \\n            tail->next = head->next;\\n            // connecting 2nd node to 1st node\\n            (head->next)->next = head;\\n            // make the 1st node connected to next node on list\\n            tail = head;\\n            tail->next = nextptr;\\n            head = nextptr;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501576,
                "title": "java-100-and-only-11-lines",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null){\\n            return head;\\n        }\\n        ListNode l = head.next;\\n        head.next = swapPairs(head.next.next);\\n        l.next = head;\\n        return l;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11241,
                "title": "my-simple-recursive-c-solution-in-6-lines-4ms",
                "content": "    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL) { return NULL; }\\n        if (head ->next == NULL) { return head; }\\n        \\n        ListNode *newHead = head->next;\\n        head->next = swapPairs(head->next->next);\\n        newHead->next = head;\\n        return newHead;\\n    }",
                "solutionTags": [
                    "Linked List",
                    "Recursion"
                ],
                "code": "    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL) { return NULL; }\\n        if (head ->next == NULL) { return head; }\\n        \\n        ListNode *newHead = head->next;\\n        head->next = swapPairs(head->next->next);\\n        newHead->next = head;\\n        return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11278,
                "title": "ac-java-solution",
                "content": "    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode n1 = head;\\n        ListNode n2 = head.next;\\n        \\n        n1.next = n2.next;\\n        n2.next = n1;\\n        \\n        n1.next = swapPairs(n1.next);\\n        \\n        return n2;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode n1 = head;\\n        ListNode n2 = head.next;\\n        \\n        n1.next = n2.next;\\n        n2.next = n1;\\n        \\n        n1.next = swapPairs(n1.next);\\n        \\n        return n2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3531484,
                "title": "think-recursive-python-c-golang",
                "content": "# Intuition\\nLet\\'s solve a very basic problem, like if we have only two nodes in linked list something like this\\n![Screenshot from 2023-05-16 21-18-05.png](https://assets.leetcode.com/users/images/1d8eaf14-3512-4e3d-bc46-57e3dd6746f0_1684253393.1944199.png)\\n\\nThen, our approach is divided into 3 steps\\n* ***Step1*** Set CurrNode\\'s next to NextNode\\'s next\\n![Screenshot from 2023-05-16 21-21-08.png](https://assets.leetcode.com/users/images/0409e8be-a0f4-49de-8ca8-7cf14ba869be_1684253489.2341714.png)\\n\\n* ***Step2*** Set NextNode\\'s next to CurrNode\\n![Screenshot from 2023-05-16 21-25-06.png](https://assets.leetcode.com/users/images/362d02de-00fc-4e49-a1c2-2c80404593c9_1684253531.1400237.png)\\n\\n* ***Step3*** We are done with swapping now, we have to return the NextNode as our new head.\\n![Screenshot from 2023-05-16 21-28-32.png](https://assets.leetcode.com/users/images/dc72258a-ac45-4dfe-8045-4d4cb40b279a_1684253573.5092244.png)\\n\\nWe have solved our problem, now we have to implement this logic\\n\\n# Approach\\n* If Head node is empty or Head\\'s next is empty, return Head ecause we don\\'t have anything to perform our logic\\n\\n* Set NextNode to Head->next\\n\\n* Now, Set recursion result to Head->next\\n\\n* Now, Set NextNode->next to head\\n\\n* Finally, return the NextNode which is our ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nWhere n is the length of the linked list.\\n`Note: We have traversed only half linked list.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\nBecause we haven\\'t consumed any extra space.\\n`Note: We consumed some auxiliary space for recursion stack.`\\n\\n# Code\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        nextNode = head.next\\n        head.next = self.swapPairs(head.next.next)\\n        nextNode.next = head\\n\\n        return nextNode\\n\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head or !head->next) return head;\\n\\n        ListNode* nextNode = head->next;\\n        head->next = swapPairs(head->next->next);\\n        nextNode->next = head;\\n\\n        return nextNode;\\n    }\\n};\\n```\\n```Go []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return head\\n    }\\n\\n    nextNode := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    nextNode.Next = head\\n\\n    return nextNode    \\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Go",
                    "Recursion"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        nextNode = head.next\\n        head.next = self.swapPairs(head.next.next)\\n        nextNode.next = head\\n\\n        return nextNode\\n\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head or !head->next) return head;\\n\\n        ListNode* nextNode = head->next;\\n        head->next = swapPairs(head->next->next);\\n        nextNode->next = head;\\n\\n        return nextNode;\\n    }\\n};\\n```\n```Go []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return head\\n    }\\n\\n    nextNode := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    nextNode.Next = head\\n\\n    return nextNode    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528845,
                "title": "python-3-4-lines-t-m-98-65",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```\\n[https://leetcode.com/submissions/detail/582543531/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151844,
                "title": "beats-100-java-recursive-approach-swapping-nodes-simple-solution",
                "content": "# Intuition\\nWe can solve it by doing simple swapping of nodes!\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(n) [Recursion stack]\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode temp = head.next;\\n        swapper(head);\\n        return temp;\\n    }\\n    void swapper(ListNode head)\\n    {\\n        if(head == null || head.next == null) return;\\n        ListNode temp = head.next;\\n        head.next = head.next.next;\\n        temp.next = head;\\n        ListNode temp2 = null;\\n        if(head.next != null)\\n         temp2 = head.next.next;\\n        swapper(head.next);\\n        if(temp2 != null)\\n        head.next = temp2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode temp = head.next;\\n        swapper(head);\\n        return temp;\\n    }\\n    void swapper(ListNode head)\\n    {\\n        if(head == null || head.next == null) return;\\n        ListNode temp = head.next;\\n        head.next = head.next.next;\\n        temp.next = head;\\n        ListNode temp2 = null;\\n        if(head.next != null)\\n         temp2 = head.next.next;\\n        swapper(head.next);\\n        if(temp2 != null)\\n        head.next = temp2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044431,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* temp=head->next;\\n        head->next=swapPairs(head->next->next);\\n        temp->next=head;\\n        return temp;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* temp=head->next;\\n        head->next=swapPairs(head->next->next);\\n        temp->next=head;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014145,
                "title": "100-beats-java-solution-executed-in-0ms-using-three-pointer-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Three Pointer Iterative Approach where the swapping is done with help of Three Pointers**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to solve this problem is the three pointer approach, where I have taken the three pointers and with the help of that the swapping of nodes is done, The programming language used is Java. Here the three nodes p for previous, c for current and cn for current_next is taken and also the d node is taken at the starting which will act as p in the first iteration. \\n\\nSuppose the linked list is given\\n1-->2-->3-->4-->null\\nthen first we have declared the d node such that it\\'s next pointer points to the head of the linked list hence\\nD-->1-->2-->3-->4-->null\\nNow During the first Iteration\\n![Untitled.jpg](https://assets.leetcode.com/users/images/036ca02f-24e3-4523-8a2e-61e7b6676f0a_1673101141.142306.jpeg)\\nAfter First Iteration \\n![Untitled.jpg](https://assets.leetcode.com/users/images/78144949-1a21-4c30-837d-297959ae7f54_1673101304.5513315.jpeg)\\nHence as the processing of swapping will be done the pointers will be moved as \\n![Untitled.jpg](https://assets.leetcode.com/users/images/ae9c0caf-c34e-41f3-8162-a6104bce1311_1673101484.9050355.jpeg)\\nAnd again the processing of swapping will be done\\nTill the c and cn is null.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**Time Complexity - O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Space Compleixty - O(1)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode d = new ListNode(0);\\n        d.next = head;\\n        ListNode p = d;\\n        ListNode c = d.next;\\n        while(c!=null){\\n            ListNode cn = c.next;\\n            if(cn==null){\\n                break;\\n            }\\n            c.next = cn.next;\\n            cn.next=p.next;\\n            p.next = cn;\\n            p = c;\\n            c = c.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode d = new ListNode(0);\\n        d.next = head;\\n        ListNode p = d;\\n        ListNode c = d.next;\\n        while(c!=null){\\n            ListNode cn = c.next;\\n            if(cn==null){\\n                break;\\n            }\\n            c.next = cn.next;\\n            cn.next=p.next;\\n            p.next = cn;\\n            p = c;\\n            c = c.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882193,
                "title": "simple-rust-recursive-solution",
                "content": "# Approach\\nSwaps the first pair, then recurses to handle the rest of the list\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ additional space\\n\\n# Code\\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        match head {\\n            Some(mut h) => {\\n                match h.next {\\n                    Some(mut n) => {\\n                        h.next = Solution::swap_pairs(n.next);\\n                        n.next = Some(h);\\n                        Some(n)\\n                    },\\n                    _ => Some(h),\\n                }\\n            },\\n            _ => head,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        match head {\\n            Some(mut h) => {\\n                match h.next {\\n                    Some(mut n) => {\\n                        h.next = Solution::swap_pairs(n.next);\\n                        n.next = Some(h);\\n                        Some(n)\\n                    },\\n                    _ => Some(h),\\n                }\\n            },\\n            _ => head,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2374316,
                "title": "easy-to-understand-simple-java-0ms-100-faster-solution-singlylinkedlist-space",
                "content": "**Please  \\uD83D\\uDC4D this.solution if(you understood == true)**\\n\\n```\\n// Best Approach : Recursive\\n// Space Complexity : O(n)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if ((head == null)||(head.next == null))\\n            return head;\\n        ListNode n = head.next;\\n        head.next = swapPairs(head.next.next);\\n        n.next = head;\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Best Approach : Recursive\\n// Space Complexity : O(n)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if ((head == null)||(head.next == null))\\n            return head;\\n        ListNode n = head.next;\\n        head.next = swapPairs(head.next.next);\\n        n.next = head;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303855,
                "title": "easy-0-ms-100-faster-fully-explained-c-java-c-language-js",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode* tmp = new ListNode(0);\\n        tmp->next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode* curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr->next && curr->next->next){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode* n1 = curr->next;\\n            ListNode* n2 = curr->next->next;\\n            \\n            n1->next = n2->next;              // Point the next of n1 to the node after n2\\n            curr->next = n2;                 // Now n2 node should be the curr.next node.\\n            curr->next->next = n1;            // Linking n2 to the n1 node.\\n            curr = curr->next->next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp->next;    //at last return the tmp.next\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        //Base condition\\n        if(head == null || head.next == null)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode tmp = new ListNode(0);\\n        tmp.next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr.next != null && curr.next.next != null){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode n1 = curr.next;\\n            ListNode n2 = curr.next.next;\\n            \\n            n1.next = n2.next;              // Point the next of n1 to the node after n2\\n            curr.next = n2;                 // Now n2 node should be the curr.next node.\\n            curr.next.next = n1;            // Linking n2 to the n1 node.\\n            curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp.next;    //at last return the tmp.next\\n    }\\n}\\n```\\n\\n# **C Language:**\\n```\\n//Another approach is here...\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    struct ListNode* temp = head->next;\\n    head->next = swapPairs(temp->next);  //call recursively.\\n    temp->next = head;\\n    return temp;\\n}\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar swapPairs = function(head) {\\n    \\n    //Base condition\\n    if(head == null || head.next == null)   \\n    return head;\\n        \\n    //Create a tmp node whose next pointer will point to the current head\\n    const tmp = new ListNode(0);\\n    tmp.next = head;\\n        \\n    //Now take a curr node which will be used to traverse the list\\n    let curr = tmp;\\n        \\n    // Loop until we reach to the second last node...\\n    while(curr.next != null && curr.next.next != null){\\n            \\n        //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n        let n1 = curr.next;\\n        let n2 = curr.next.next;\\n            \\n        n1.next = n2.next;              // Point the next of n1 to the node after n2\\n        curr.next = n2;                 // Now n2 node should be the curr.next node.\\n        curr.next.next = n1;            // Linking n2 to the n1 node.\\n        curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n    return tmp.next;    //at last return the tmp.next\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode* tmp = new ListNode(0);\\n        tmp->next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode* curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr->next && curr->next->next){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode* n1 = curr->next;\\n            ListNode* n2 = curr->next->next;\\n            \\n            n1->next = n2->next;              // Point the next of n1 to the node after n2\\n            curr->next = n2;                 // Now n2 node should be the curr.next node.\\n            curr->next->next = n1;            // Linking n2 to the n1 node.\\n            curr = curr->next->next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp->next;    //at last return the tmp.next\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        //Base condition\\n        if(head == null || head.next == null)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode tmp = new ListNode(0);\\n        tmp.next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr.next != null && curr.next.next != null){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode n1 = curr.next;\\n            ListNode n2 = curr.next.next;\\n            \\n            n1.next = n2.next;              // Point the next of n1 to the node after n2\\n            curr.next = n2;                 // Now n2 node should be the curr.next node.\\n            curr.next.next = n1;            // Linking n2 to the n1 node.\\n            curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp.next;    //at last return the tmp.next\\n    }\\n}\\n```\n```\\n//Another approach is here...\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    struct ListNode* temp = head->next;\\n    head->next = swapPairs(temp->next);  //call recursively.\\n    temp->next = head;\\n    return temp;\\n}\\n```\n```\\nvar swapPairs = function(head) {\\n    \\n    //Base condition\\n    if(head == null || head.next == null)   \\n    return head;\\n        \\n    //Create a tmp node whose next pointer will point to the current head\\n    const tmp = new ListNode(0);\\n    tmp.next = head;\\n        \\n    //Now take a curr node which will be used to traverse the list\\n    let curr = tmp;\\n        \\n    // Loop until we reach to the second last node...\\n    while(curr.next != null && curr.next.next != null){\\n            \\n        //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n        let n1 = curr.next;\\n        let n2 = curr.next.next;\\n            \\n        n1.next = n2.next;              // Point the next of n1 to the node after n2\\n        curr.next = n2;                 // Now n2 node should be the curr.next node.\\n        curr.next.next = n1;            // Linking n2 to the n1 node.\\n        curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n    return tmp.next;    //at last return the tmp.next\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260102,
                "title": "2-pointer-approach-with-diagram-in-c",
                "content": "![image](https://assets.leetcode.com/users/images/61041d00-400c-4eaf-b071-a8a9355894cf_1657454552.3188987.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        ListNode* prev = dummy;\\n        \\n        ListNode* curr = head;\\n        ListNode *second, *nextPair;\\n        \\n        if(head == NULL || head -> next == NULL)\\n            return head;\\n        \\n        while(curr && curr -> next){\\n            second = curr -> next;\\n            nextPair = curr -> next -> next;\\n            \\n            second -> next = curr;\\n            curr -> next = nextPair;\\n            prev -> next = second;\\n            \\n            prev = curr;\\n            curr = nextPair;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n[Further Explanation : NeetCode](https://youtu.be/o811TZLAWOo)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        ListNode* prev = dummy;\\n        \\n        ListNode* curr = head;\\n        ListNode *second, *nextPair;\\n        \\n        if(head == NULL || head -> next == NULL)\\n            return head;\\n        \\n        while(curr && curr -> next){\\n            second = curr -> next;\\n            nextPair = curr -> next -> next;\\n            \\n            second -> next = curr;\\n            curr -> next = nextPair;\\n            prev -> next = second;\\n            \\n            prev = curr;\\n            curr = nextPair;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150670,
                "title": "fastest-100-faster-0ms-java-solution",
                "content": "ListNode cur=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        ListNode first=head;\\n        int c=1;\\n        while(cur!=null&&c<3){\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n            if(c==2)\\n                first.next=swapPairs(cur);\\n            c++;\\n        }\\n        return prev;",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "ListNode cur=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        ListNode first=head;\\n        int c=1;\\n        while(cur!=null&&c<3){\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n            if(c==2)\\n                first.next=swapPairs(cur);\\n            c++;\\n        }\\n        return prev;",
                "codeTag": "Unknown"
            },
            {
                "id": 2037031,
                "title": "java-0ms-100-faster-2-methods",
                "content": "*1. First way using iteration :-*\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n       ListNode curr = head.next;\\n      ListNode prev = head;\\n      ListNode next = null;\\n      ListNode newHead = curr;\\n      while(curr != null)\\n      {\\n        next = curr.next;\\n        curr.next = prev;\\n        if(next == null || next.next == null)\\n        {\\n          prev.next = next;\\n          curr = null;\\n        }\\n        else\\n        {\\n          curr = next.next;\\n          prev.next = curr;\\n          prev = next;\\n        }\\n      }\\n      return newHead;\\n    }\\n}\\n```\\n\\n*2. Second way using recursion :-*\\n\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next = head;\\n\\t\\thead.next = swapPairs(third);\\n\\t\\treturn second;\\n\\t}\\n}\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n       ListNode curr = head.next;\\n      ListNode prev = head;\\n      ListNode next = null;\\n      ListNode newHead = curr;\\n      while(curr != null)\\n      {\\n        next = curr.next;\\n        curr.next = prev;\\n        if(next == null || next.next == null)\\n        {\\n          prev.next = next;\\n          curr = null;\\n        }\\n        else\\n        {\\n          curr = next.next;\\n          prev.next = curr;\\n          prev = next;\\n        }\\n      }\\n      return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775381,
                "title": "my-java-code-faster-than-100-without-recursion",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null){\\n            return null;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        \\n        \\n        ListNode current = head;\\n        ListNode dummy = new ListNode(-1); // dummy node\\n        ListNode prev =dummy;\\n        while(current != null && current.next != null){\\n            prev.next = current.next;\\n            current.next = current.next.next;\\n            prev.next.next = current;\\n            \\n            // now update the current and prev \\n            current = current.next;\\n            prev = prev.next.next;\\n        }\\n        return dummy.next;\\n    }\\n```\\nFor solving any linked list problem like this, it will be good to use the help of dummy node\\nSo we will create a dummy node with any value (let suppose -1 ) and we will return dummy.next because its gonna be our new head.\\n\\nDry Run - 1-->2-->3-->4 ,      dummy node ->  -1 \\ncurrent = head   ->  current is at 1 \\nprev = dummy  -> prev is at -1\\n\\nrun a for loop and check if current node and its next node not be equal to null\\n```prev.next = current.next;```  ->   -1 (prev)  --> 2(next node of current)\\n```current.next = current.next.next;```  ->   1  --> 3 \\n```prev.next.next = current;``` -> -1-->2-->1 (prev is -1, prev.next is 2 and next of 2 is set to 1)\\n\\nnow update the pointers position\\n```current = current.next;``` -> current = 3 \\n```prev = prev.next.next``` -> prev = 1\\n\\nrun all the steps again for current and prev until condition satisfy. \\nI am sharing the code for the first time. If i did any mistake in this post then please forgive me\\uD83D\\uDE42. \\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null){\\n            return null;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        \\n        \\n        ListNode current = head;\\n        ListNode dummy = new ListNode(-1); // dummy node\\n        ListNode prev =dummy;\\n        while(current != null && current.next != null){\\n            prev.next = current.next;\\n            current.next = current.next.next;\\n            prev.next.next = current;\\n            \\n            // now update the current and prev \\n            current = current.next;\\n            prev = prev.next.next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```prev.next = current.next;```\n```current.next = current.next.next;```\n```prev.next.next = current;```\n```current = current.next;```\n```prev = prev.next.next```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775317,
                "title": "c-c-simplest-recursive-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if ((!head) || (!head->next))\\n            return head;\\n\\n        struct ListNode* tmp = head;\\n        head = head->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n\\n        head->next->next = swapPairs(head->next->next);\\n        return head;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if ((!head) || (!head->next))\\n            return head;\\n\\n        struct ListNode* tmp = head;\\n        head = head->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n\\n        head->next->next = swapPairs(head->next->next);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775223,
                "title": "java-simple-recursion-faster-than-100",
                "content": "**Solution 1**\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode temp=head;\\n        while(temp!=null && temp.next!=null){\\n            int x=temp.val;\\n            temp.val=temp.next.val;\\n            temp.next.val=x;\\n            temp=temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n**Solution 2 (without changing values)**\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null)\\n            return null;\\n        return swapPairs(head,head.next);\\n    }\\n    public ListNode swapPairs(ListNode n1,ListNode n2){\\n        if(n1==null || n2==null){\\n            return n1;\\n        }\\n        n1.next=swapPairs(n1.next!=null?n1.next.next:null,n2.next!=null?n2.next.next:null);\\n        n2.next=n1;\\n        return n2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode temp=head;\\n        while(temp!=null && temp.next!=null){\\n            int x=temp.val;\\n            temp.val=temp.next.val;\\n            temp.next.val=x;\\n            temp=temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null)\\n            return null;\\n        return swapPairs(head,head.next);\\n    }\\n    public ListNode swapPairs(ListNode n1,ListNode n2){\\n        if(n1==null || n2==null){\\n            return n1;\\n        }\\n        n1.next=swapPairs(n1.next!=null?n1.next.next:null,n2.next!=null?n2.next.next:null);\\n        n2.next=n1;\\n        return n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774872,
                "title": "beginner-friendly-python-solution-with-comments",
                "content": "The main logic used is the swapping of values\\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        \\n        node=head\\n        c=0\\n        while node:  #loop to check the length of linkedlist\\n            c+=1\\n            node=node.next\\n            \\n        node=head\\n        if c%2!=0:    #If the length of linkedlist is odd then this loop will be executed\\n            while node.next is not None:\\n                node.next.val, node.val=node.val, node.next.val  #swapping the values\\n                node=node.next.next\\n        else:\\n            while node is not None:\\n                node.val, node.next.val=node.next.val, node.val #swapping the values\\n                node=node.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        \\n        node=head\\n        c=0\\n        while node:  #loop to check the length of linkedlist\\n            c+=1\\n            node=node.next\\n            \\n        node=head\\n        if c%2!=0:    #If the length of linkedlist is odd then this loop will be executed\\n            while node.next is not None:\\n                node.next.val, node.val=node.val, node.next.val  #swapping the values\\n                node=node.next.next\\n        else:\\n            while node is not None:\\n                node.val, node.next.val=node.next.val, node.val #swapping the values\\n                node=node.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703662,
                "title": "c-iteration",
                "content": "C# solution by iteration \\n**Runtime: 84 ms, faster than 70.48% of C# online submissions for Swap Nodes in Pairs.\\nMemory Usage: 37.3 MB, less than 48.11% of C# online submissions for Swap Nodes in Pairs.**\\n\\n```\\npublic ListNode SwapPairs(ListNode head) {\\n       \\n\\t\\tListNode tempNode = new ListNode(-1, head);\\n        ListNode prevNode = tempNode;\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null)\\n        {\\n            ListNode firstNode = prevNode.next;\\n            ListNode secondNode= prevNode.next.next;\\n            \\n            firstNode.next = secondNode.next;\\n            secondNode.next = firstNode;\\n            \\n            prevNode.next = secondNode;\\n            \\n            /*resetting the value for prevNode for iteraton*/\\n            prevNode = firstNode;\\n        }\\n        return tempNode.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode SwapPairs(ListNode head) {\\n       \\n\\t\\tListNode tempNode = new ListNode(-1, head);\\n        ListNode prevNode = tempNode;\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null)\\n        {\\n            ListNode firstNode = prevNode.next;\\n            ListNode secondNode= prevNode.next.next;\\n            \\n            firstNode.next = secondNode.next;\\n            secondNode.next = firstNode;\\n            \\n            prevNode.next = secondNode;\\n            \\n            /*resetting the value for prevNode for iteraton*/\\n            prevNode = firstNode;\\n        }\\n        return tempNode.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534508,
                "title": "iterative-easy-soln-runtime-0-ms-faster-than-100-00-of-c",
                "content": "\\n\\n        \\n\\tListNode* swapPairs(ListNode* head)\\n\\t{\\n\\t\\tListNode* dummy = new ListNode(-1);\\n\\t\\tdummy->next = head;\\n\\t\\tListNode* prev = dummy;\\n        while(prev->next !=NULL && prev->next->next !=NULL)\\n        {\\n            ListNode* curr = prev->next;\\n            ListNode* forw = curr->next;\\n            ListNode* temp = forw->next;\\n            \\n            prev->next = forw;\\n            forw->next = curr;\\n            curr->next = temp;\\n            \\n            prev = curr;\\n        }\\n        return dummy->next;\\n        \\n    }\\n\\t",
                "solutionTags": [],
                "code": "\\n\\n        \\n\\tListNode* swapPairs(ListNode* head)\\n\\t{\\n\\t\\tListNode* dummy = new ListNode(-1);\\n\\t\\tdummy->next = head;\\n\\t\\tListNode* prev = dummy;\\n        while(prev->next !=NULL && prev->next->next !=NULL)\\n        {\\n            ListNode* curr = prev->next;\\n            ListNode* forw = curr->next;\\n            ListNode* temp = forw->next;\\n            \\n            prev->next = forw;\\n            forw->next = curr;\\n            curr->next = temp;\\n            \\n            prev = curr;\\n        }\\n        return dummy->next;\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1101344,
                "title": "python-recursion",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # recursion\\n        if not head or not head.next: return head\\n        new_head = head.next\\n        head.next = self.swapPairs(new_head.next)\\n        new_head.next = head\\n        return new_head\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # recursion\\n        if not head or not head.next: return head\\n        new_head = head.next\\n        head.next = self.swapPairs(new_head.next)\\n        new_head.next = head\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910322,
                "title": "javascript-solution-24",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet swapPairs = function(head) {\\n    let dummy=new ListNode();\\n    dummy.next = head;\\n    let result = dummy;\\n    while(dummy.next && dummy.next.next){\\n        let p=dummy.next,q = dummy.next.next;\\n        dummy.next = q;\\n        p.next = q.next;\\n        q.next = p;\\n        dummy = p\\n    }\\n    return result.next\\n};\\n```\\n\\n**Runtime: 72 ms, faster than 87.88% of JavaScript online submissions for Swap Nodes in Pairs.**\\n\\n**Memory Usage: 38.8 MB, less than 40.76% of JavaScript online submissions for Swap Nodes in Pairs.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet swapPairs = function(head) {\\n    let dummy=new ListNode();\\n    dummy.next = head;\\n    let result = dummy;\\n    while(dummy.next && dummy.next.next){\\n        let p=dummy.next,q = dummy.next.next;\\n        dummy.next = q;\\n        p.next = q.next;\\n        q.next = p;\\n        dummy = p\\n    }\\n    return result.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748467,
                "title": "python-clean-recursive-and-iterative-solution",
                "content": "Variable names should help understand the solutions easily.\\nRecursive:\\n```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    if head is None or head.next is None:\\n        return head\\n    newHead = head.next\\n    head.next = self.swapPairs(newHead.next)\\n    newHead.next = head\\n    return newHead\\n```\\nE.g: [1,2,3,4] -> [2,1,4,3]\\nThere will be 3 calls to swapPairs ( 1 normal call + 2 recursive calls)\\n```\\nswapPairs(1)\\n         swapPairs(3)\\n                  swapPairs(None):\\n                  returns None # swapPairs(None)\\n         returns 4 #swapPairs(3)\\nreturns 2 #swapPairs(1)\\n```\\n\\nIterative:\\n```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n\\tif head is None or head.next is None:\\n\\t\\treturn head\\n\\tfirst, newHead, previous = head, head.next, None\\n\\twhile first and first.next:\\n\\t\\tif previous:\\n\\t\\t\\tprevious.next = first.next\\n\\t\\tsecond = first.next\\n\\t\\tfirst.next = second.next\\n\\t\\tsecond.next = first\\n\\t\\tprevious = first\\n\\t\\tfirst = first.next\\n\\treturn newHead\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    if head is None or head.next is None:\\n        return head\\n    newHead = head.next\\n    head.next = self.swapPairs(newHead.next)\\n    newHead.next = head\\n    return newHead\\n```\n```\\nswapPairs(1)\\n         swapPairs(3)\\n                  swapPairs(None):\\n                  returns None # swapPairs(None)\\n         returns 4 #swapPairs(3)\\nreturns 2 #swapPairs(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 655218,
                "title": "c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        // get length \\n        ListNode* cur = head; int len=0;\\n        while(cur) {\\n            cur=cur->next; ++len;\\n        }\\n        \\n        ListNode* cur1 = head;   ListNode* cur2 = head->next;  ListNode* head2 = cur2;\\n        ListNode* cur3=NULL;\\n        \\n        while (cur2->next!=NULL) {\\n            \\n            cur1->next = cur2->next;\\n            cur2->next = cur1;\\n            \\n            cur3 = cur1;\\n            \\n            if(cur1->next->next!=NULL) { // so that cur2 is not NULL\\n                cur1 = cur1->next;\\n                cur2 = cur1->next;\\n          \\n                cur3->next = cur2;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        if(len%2==0) {\\n            cur2->next = cur1;\\n            cur1->next = NULL;\\n        }\\n        \\n        return head2;\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/duttaani/image_1590587889.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        // get length \\n        ListNode* cur = head; int len=0;\\n        while(cur) {\\n            cur=cur->next; ++len;\\n        }\\n        \\n        ListNode* cur1 = head;   ListNode* cur2 = head->next;  ListNode* head2 = cur2;\\n        ListNode* cur3=NULL;\\n        \\n        while (cur2->next!=NULL) {\\n            \\n            cur1->next = cur2->next;\\n            cur2->next = cur1;\\n            \\n            cur3 = cur1;\\n            \\n            if(cur1->next->next!=NULL) { // so that cur2 is not NULL\\n                cur1 = cur1->next;\\n                cur2 = cur1->next;\\n          \\n                cur3->next = cur2;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        if(len%2==0) {\\n            cur2->next = cur1;\\n            cur1->next = NULL;\\n        }\\n        \\n        return head2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284762,
                "title": "js-solution-faster-than-100",
                "content": "```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function (head) {\\n    //dummy node\\n    dummy = new ListNode(0)\\n    dummy.next = head\\n\\n    current = dummy\\n    while (current.next && current.next.next) {\\n        temp1 = current.next\\n        temp2 = current.next.next\\n\\n        current.next.next = current.next.next.next\\n        current.next = temp2\\n        current.next.next = temp1\\n\\n        //current move to next 2 pos\\n        current = current.next.next\\n    }\\n\\n    return dummy.next\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function (head) {\\n    //dummy node\\n    dummy = new ListNode(0)\\n    dummy.next = head\\n\\n    current = dummy\\n    while (current.next && current.next.next) {\\n        temp1 = current.next\\n        temp2 = current.next.next\\n\\n        current.next.next = current.next.next.next\\n        current.next = temp2\\n        current.next.next = temp1\\n\\n        //current move to next 2 pos\\n        current = current.next.next\\n    }\\n\\n    return dummy.next\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176015,
                "title": "simple-go-solution",
                "content": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n        list := &ListNode{Next: head}\\n        for prev, node := list, list.Next; node != nil; node = node.Next {\\n                if node.Next != nil {\\n                        swapNode(prev, node, node.Next)\\n                        prev = node\\n                }\\n        }\\n        return list.Next\\n}\\n\\nfunc swapNode(prev, node, next *ListNode) {\\n        prev.Next = next\\n        node.Next = next.Next\\n        next.Next = node\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n        list := &ListNode{Next: head}\\n        for prev, node := list, list.Next; node != nil; node = node.Next {\\n                if node.Next != nil {\\n                        swapNode(prev, node, node.Next)\\n                        prev = node\\n                }\\n        }\\n        return list.Next\\n}\\n\\nfunc swapNode(prev, node, next *ListNode) {\\n        prev.Next = next\\n        node.Next = next.Next\\n        next.Next = node\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11195,
                "title": "java-0ms-using-recusion",
                "content": "    public ListNode swapPairs(ListNode head) {\\n\\t\\tif(head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode p1 = head, p2 = head.next, p3 = null;\\n\\t\\tp3 = p2.next;\\n\\t\\tp2.next = null;\\n\\t\\tp1.next.next = p1;\\n\\t\\tp1.next = p3;\\n\\t\\t\\n\\t\\tif(p3 != null)\\n\\t\\t\\tp1.next = swapPairs(p3);\\n\\t\\t\\n\\t\\treturn p2;\\n\\t}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    public ListNode swapPairs(ListNode head) {\\n\\t\\tif(head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode p1 = head, p2 = head.next, p3 = null;\\n\\t\\tp3 = p2.next;\\n\\t\\tp2.next = null;\\n\\t\\tp1.next.next = p1;\\n\\t\\tp1.next = p3;\\n\\t\\t\\n\\t\\tif(p3 != null)\\n\\t\\t\\tp1.next = swapPairs(p3);\\n\\t\\t\\n\\t\\treturn p2;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 11222,
                "title": "my-solution-c",
                "content": "        ListNode* swapPairs(ListNode* head) {\\n            ListNode* p1;       \\n            if(head && head->next){  \\n                p1 = head->next; \\n                head->next = swapPairs(head->next->next);\\n                p1->next = head;\\n                head = p1; \\n           }\\n           return head;\\n    }",
                "solutionTags": [],
                "code": "        ListNode* swapPairs(ListNode* head) {\\n            ListNode* p1;       \\n            if(head && head->next){  \\n                p1 = head->next; \\n                head->next = swapPairs(head->next->next);\\n                p1->next = head;\\n                head = p1; \\n           }\\n           return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11343,
                "title": "runtime-0ms-in-c",
                "content": "struct ListNode* swapPairs(struct ListNode* head) {\\n    \\n    struct ListNode* dummy=head;\\n    struct ListNode* prev=NULL;\\n    struct ListNode* Nextnode=NULL;\\n\\n\\n    if(!dummy)\\n          return head;\\n    \\n    while(dummy!=NULL && dummy->next!=NULL){\\n        \\n        Nextnode=dummy->next;\\n        dummy->next=Nextnode->next;\\n        \\n        if(prev)\\n          prev->next=Nextnode;\\n        else\\n          head=Nextnode;\\n          \\n        Nextnode->next=dummy;\\n        \\n        prev=dummy;\\n\\n        dummy=dummy->next;\\n           \\n           \\n    }\\n    \\n    return head;\\n}",
                "solutionTags": [],
                "code": "struct ListNode* swapPairs(struct ListNode* head) {\\n    \\n    struct ListNode* dummy=head;\\n    struct ListNode* prev=NULL;\\n    struct ListNode* Nextnode=NULL;\\n\\n\\n    if(!dummy)\\n          return head;\\n    \\n    while(dummy!=NULL && dummy->next!=NULL){\\n        \\n        Nextnode=dummy->next;\\n        dummy->next=Nextnode->next;\\n        \\n        if(prev)\\n          prev->next=Nextnode;\\n        else\\n          head=Nextnode;\\n          \\n        Nextnode->next=dummy;\\n        \\n        prev=dummy;\\n\\n        dummy=dummy->next;\\n           \\n           \\n    }\\n    \\n    return head;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3585152,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        while (head != NULL && head->next != NULL) {\\n            ListNode* cur = head->next->next;\\n            temp->next = head->next;\\n            temp = head;\\n            head->next->next = head;\\n            head->next = cur;\\n            head = cur;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        while (head != NULL && head->next != NULL) {\\n            ListNode* cur = head->next->next;\\n            temp->next = head->next;\\n            temp = head;\\n            head->next->next = head;\\n            head->next = cur;\\n            head = cur;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534681,
                "title": "100-beats-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        ListNode* p = head,*q=head->next;\\n        while(true){\\n            swap(p->val,q->val);\\n            if(!(q->next && q->next->next))break;\\n            p = p->next->next;\\n            q = q->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        ListNode* p = head,*q=head->next;\\n        while(true){\\n            swap(p->val,q->val);\\n            if(!(q->next && q->next->next))break;\\n            p = p->next->next;\\n            q = q->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531446,
                "title": "c-by-swapping-the-values-of-the-adjacent-nodes-t-c-o-n",
                "content": "# Intuition\\nTraverse the list and swap pairs of nodes one by one.\\n# Approach\\n![53a7a769-ce39-4d7d-9e37-cd0420f72bf0_1644988593.5987253.jpeg](https://assets.leetcode.com/users/images/1c079065-d5e5-478f-80bb-c20f4881d340_1684253393.321737.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)(where n is number of nodes in the linked list)\\n\\n- Space complexity:\\nO(1)-> since we are just changing the value of the nodes by swapping so no extra space is used.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n    class Solution {\\n\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n\\n        if(head==NULL)return head;\\n\\n        if(head->next==NULL)return head;\\n\\n        \\n\\n        ListNode*curr=head->next;\\n\\n        ListNode*prev=head;\\n\\n        swap(curr->val,prev->val);\\n\\n        while(prev->next->next!=NULL&&curr->next->next!=NULL){\\n\\n            prev=prev->next->next;\\n\\n            curr=curr->next->next;\\n\\n            swap(curr->val,prev->val);\\n\\n        }\\n\\n        return head;\\n\\n        \\n\\n    }\\n\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n    class Solution {\\n\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n\\n        if(head==NULL)return head;\\n\\n        if(head->next==NULL)return head;\\n\\n        \\n\\n        ListNode*curr=head->next;\\n\\n        ListNode*prev=head;\\n\\n        swap(curr->val,prev->val);\\n\\n        while(prev->next->next!=NULL&&curr->next->next!=NULL){\\n\\n            prev=prev->next->next;\\n\\n            curr=curr->next->next;\\n\\n            swap(curr->val,prev->val);\\n\\n        }\\n\\n        return head;\\n\\n        \\n\\n    }\\n\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531230,
                "title": "python-3-4-lines-recursion-t-m-98-65",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```\\n[https://leetcode.com/submissions/detail/582543531/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531172,
                "title": "easy-solution-java-iterative-swap",
                "content": "# Approach\\nThe provided code implements a method called `swapPairs` in a class. This method swaps adjacent pairs of nodes in a singly linked list. Here\\'s the breakdown of the approach used:\\n\\n1. The method takes a parameter `head`, which represents the head node of the linked list.\\n\\n2. The first step is to check if the `head` is `null` or if there is only one node in the list (`head.next == null`). In either case, there is no need to swap any nodes, so the method returns the `head` as it is.\\n\\n3. If there are at least two nodes in the list, a new dummy node called `ans` is created with a value of 0. The `ans.next` is set to the original `head` of the list. This dummy node serves as the new head of the modified list, which will make it easier to handle the edge case of swapping the first two nodes.\\n\\n4. Two pointers, `temp` and `temp1`, are initialized with `head` and `ans` respectively. These pointers will be used to traverse the list and perform the node swaps.\\n\\n5. The main loop runs as long as `temp` is not `null` and `temp.next` is not `null`. This loop processes pairs of nodes in the list until there are no more pairs left to swap.\\n\\n6. Inside the loop, a new node `forw` is assigned as the next node after `temp`. This node represents the second node of the current pair.\\n\\n7. The following steps perform the swapping:\\n   - `temp.next` is updated to skip the second node (`forw`).\\n   - `forw.next` is set to `temp`, making `temp` the second node in the pair.\\n   - `temp1.next` is set to `forw`, connecting the swapped pair to the modified list.\\n   - `temp1` is updated to `temp`, so it now represents the last node that was swapped.\\n   - `temp` is updated to `temp.next` to move to the next pair of nodes.\\n\\n8. Once the loop is completed, the modified list is obtained by accessing `ans.next`. This returns the head of the modified linked list.\\n\\n9. Finally, the modified list is returned as the result.\\n\\nOverall, this approach uses iterative traversal and manipulation of the linked list to swap adjacent pairs of nodes. It employs a dummy node to simplify the handling of the first pair.\\n\\n# Complexity\\n- Time complexity:\\n    - The time complexity of the swapPairs method is O(n).\\n- Space complexity:\\n    - The space complexity of the method is O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }        \\n        ListNode ans = new ListNode(0);\\n        ans.next = head;       \\n        ListNode temp = head;\\n        ListNode temp1 = ans;\\n        \\n        while (temp != null && temp.next != null) {\\n            ListNode forw = temp.next;\\n            temp.next = forw.next;\\n            forw.next = temp;\\n            temp1.next = forw;\\n            temp1 = temp;\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }        \\n        ListNode ans = new ListNode(0);\\n        ans.next = head;       \\n        ListNode temp = head;\\n        ListNode temp1 = ans;\\n        \\n        while (temp != null && temp.next != null) {\\n            ListNode forw = temp.next;\\n            temp.next = forw.next;\\n            forw.next = temp;\\n            temp1.next = forw;\\n            temp1 = temp;\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529795,
                "title": "beats-100-time-ands-90-space",
                "content": "**Italic**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ans(ListNode*&temp,ListNode*&curr,ListNode*a){\\n        a=curr;\\n        if(temp==NULL || temp->next==NULL)return;\\n        temp->next=NULL;\\n        temp->next=curr->next;\\n        curr->next=temp;\\n        ListNode*prev = temp;\\n\\n        temp=temp->next;\\n        if(temp==NULL || temp->next==NULL)return;\\n        curr=temp->next;\\n        prev->next=curr;\\n        ans(temp,curr,a);\\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return head;\\n        ListNode*temp=head;\\n        ListNode*curr = head->next;\\n        ListNode*a=curr;\\n        ans(temp,curr,a);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ans(ListNode*&temp,ListNode*&curr,ListNode*a){\\n        a=curr;\\n        if(temp==NULL || temp->next==NULL)return;\\n        temp->next=NULL;\\n        temp->next=curr->next;\\n        curr->next=temp;\\n        ListNode*prev = temp;\\n\\n        temp=temp->next;\\n        if(temp==NULL || temp->next==NULL)return;\\n        curr=temp->next;\\n        prev->next=curr;\\n        ans(temp,curr,a);\\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return head;\\n        ListNode*temp=head;\\n        ListNode*curr = head->next;\\n        ListNode*a=curr;\\n        ans(temp,curr,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529774,
                "title": "easy-java-solution-detailed-explanation-two-pointers-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question by two ways that are Two Pointers and Recursion.\\nHere I have use two pointer approach, Folks who does not wanted recursive space can go through my approach.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I have taken dummy Node which next will points to head of LikedList. Use of this dummy node is that we have to return head of LinkedList and if we swap then head will change, so we can return dummy.next (new head).\\n1. I have taken two pointers that are pre and curr, pre will points to dummy node and curr will points head of LinkedList\\n![WhatsApp Image 2023-05-16 at 11.29.57 AM.jpeg](https://assets.leetcode.com/users/images/05ec86d4-6fc7-4c8b-80b2-17d9c22e173b_1684219328.4818847.jpeg)\\n\\n2. Here I have done connetion of pre\\'s next node to curr\\'s node next node.\\n```java []\\npre.next=curr.next;\\n```\\n\\n![WhatsApp Image 2023-05-16 at 11.38.00 AM.jpeg](https://assets.leetcode.com/users/images/af90cb2b-1003-4027-ae43-3e67f2a59cca_1684219425.2694046.jpeg)\\n\\n3. After this, I break curr\\'s next node (node 2) connection and establish it\\'s next connection to pre\\'s next of next node (node 3).\\n```java []\\ncurr.next=pre.next.next;\\n```\\n\\n![WhatsApp Image 2023-05-16 at 11.45.00 AM.jpeg](https://assets.leetcode.com/users/images/f62f9709-1fa5-42bc-8523-07cb507f1e42_1684219589.7843626.jpeg)\\n\\n4. This is the main step, here the swapping of node are done by doing pre\\'s next of next node to curr node.\\n```java []\\npre.next.next=curr;\\n```\\n![WhatsApp Image 2023-05-16 at 11.53.43 AM.jpeg](https://assets.leetcode.com/users/images/43ca3fc2-d1ec-47a5-85d9-bd6eddc3ce47_1684219689.5950298.jpeg)\\n\\n5. Here we simply update our pre node (node 0) to curr node (node 1) and curr node (node 1) to pre next node (node 3).\\n```java []\\npre=curr;\\ncurr=pre.next;\\n```\\n![WhatsApp Image 2023-05-16 at 12.00.35 PM.jpeg](https://assets.leetcode.com/users/images/a4910cb9-5d0c-45bd-a08e-b181626953cf_1684219778.19854.jpeg)\\n\\n6. While loop will get false when either curr will become null of curr next node will beacome null, and last dummy\\'s next node will return.\\n```java []\\nreturn dummy.next;\\n```\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        ListNode curr=pre.next;\\n\\n        while(curr!=null && curr.next!=null){\\n            pre.next=curr.next;\\n            curr.next=pre.next.next;\\n            pre.next.next=curr;\\n\\n            pre=curr;\\n            curr=pre.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java []\\npre.next=curr.next;\\n```\n```java []\\ncurr.next=pre.next.next;\\n```\n```java []\\npre.next.next=curr;\\n```\n```java []\\npre=curr;\\ncurr=pre.next;\\n```\n```java []\\nreturn dummy.next;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        ListNode curr=pre.next;\\n\\n        while(curr!=null && curr.next!=null){\\n            pre.next=curr.next;\\n            curr.next=pre.next.next;\\n            pre.next.next=curr;\\n\\n            pre=curr;\\n            curr=pre.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529173,
                "title": "very-easy-c-soln-beats-100-beginner-friendly",
                "content": "**Please upVote if it helps.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* prev=head,*curr=head->next,*ans=head->next;\\n        \\n        while(1)\\n        {\\n            prev->next = curr->next;\\n            curr->next=prev;\\n            ListNode* temp=prev->next;\\n            if(temp==NULL)\\n                break;\\n            curr=temp->next;\\n            if(curr==NULL)\\n                break;\\n            prev->next=curr;\\n            prev=temp;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* prev=head,*curr=head->next,*ans=head->next;\\n        \\n        while(1)\\n        {\\n            prev->next = curr->next;\\n            curr->next=prev;\\n            ListNode* temp=prev->next;\\n            if(temp==NULL)\\n                break;\\n            curr=temp->next;\\n            if(curr==NULL)\\n                break;\\n            prev->next=curr;\\n            prev=temp;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132394,
                "title": "easy-python-solution-using-lists-runtime-97",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        ans=[]\\n        for i in range(0,len(lst),2):\\n            val=lst[i:i+2]\\n            ans+=val[::-1]\\n        final=ListNode(0)\\n        tmp=final\\n        for i in ans:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        ans=[]\\n        for i in range(0,len(lst),2):\\n            val=lst[i:i+2]\\n            ans+=val[::-1]\\n        final=ListNode(0)\\n        tmp=final\\n        for i in ans:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070647,
                "title": "95-javascript-very-easy-to-understand-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/p8x7qjD1wEM\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    let len = arr.length % 2 ==0 ? arr.length : arr.length-1;\\n    \\n    for(let i =0; i <len; i++){\\n        if(i % 2 == 0) copy.next = new ListNode(arr[i+1])\\n        else copy.next = new ListNode(arr[i-1])\\n        copy = copy.next;\\n    }\\n    if(arr.length % 2 ==1){\\n        copy.next = new ListNode(arr[arr.length-1])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    let len = arr.length % 2 ==0 ? arr.length : arr.length-1;\\n    \\n    for(let i =0; i <len; i++){\\n        if(i % 2 == 0) copy.next = new ListNode(arr[i+1])\\n        else copy.next = new ListNode(arr[i-1])\\n        copy = copy.next;\\n    }\\n    if(arr.length % 2 ==1){\\n        copy.next = new ListNode(arr[arr.length-1])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955805,
                "title": "c-easy-recursive-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* node1 = head;\\n        ListNode* node2 = head->next;\\n        node1->next = swapPairs(node2->next);\\n        node2->next = node1;\\n        return node2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* node1 = head;\\n        ListNode* node2 = head->next;\\n        node1->next = swapPairs(node2->next);\\n        node2->next = node1;\\n        return node2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654022,
                "title": "24-super-easy-connection",
                "content": "**time complexity - O(n) space-O(1)**\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # MAKE a dummy node\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n        \\n        # prev-a-b-c-d-e\\n        # prev-b-a-c\\n        while head and head.next:\\n            a = head \\n            b = a.next \\n            c = b.next \\n            \\n            prev.next = b \\n            b.next = a \\n            a.next = c\\n            \\n            prev= a\\n            head= c\\n        \\n        \\n        return dummy.next\\n\\t\\t\\n\\t\\t\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # MAKE a dummy node\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n        \\n        # prev-a-b-c-d-e\\n        # prev-b-a-c\\n        while head and head.next:\\n            a = head \\n            b = a.next \\n            c = b.next \\n            \\n            prev.next = b \\n            b.next = a \\n            a.next = c\\n            \\n            prev= a\\n            head= c\\n        \\n        \\n        return dummy.next\\n\\t\\t\\n\\t\\t\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2588735,
                "title": "recursion-7-lines-python-solution",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def swap(node):\\n            if not node or not node.next:\\n                return node\\n            first, second = node, node.next\\n            first.next, second.next = second.next,first\\n            first.next = swap(first.next)\\n            return second\\n       \\n        return swap(head)\\n   ```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def swap(node):\\n            if not node or not node.next:\\n                return node\\n            first, second = node, node.next\\n            first.next, second.next = second.next,first\\n            first.next = swap(first.next)\\n            return second\\n       \\n        return swap(head)\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2420385,
                "title": "java-solution-with-pointer",
                "content": "The code is commented and if you are familiar with using pointers and linkedlist you may be able to understand it \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode currentPtr = dummy ; // for iteration\\n        \\n        while(currentPtr.next != null && currentPtr.next.next != null ){\\n            ListNode firstNode = currentPtr.next ; \\n            ListNode secondNode  = currentPtr.next.next;\\n            // swaping nodes by replacing next wrt the currentPtr, which points to dummy atm\\n            firstNode.next = secondNode.next;\\n            currentPtr.next = secondNode;\\n            currentPtr.next.next = firstNode; \\n            \\n            // now, currentPtr will move to the 2nd node, then currentPtr.next will become first             //   node for the second pair\\n            currentPtr = currentPtr.next.next;\\n            \\n        }\\n        // our dummy is empty so after that lies our first node(head of the new list)\\n        return dummy.next;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode currentPtr = dummy ; // for iteration\\n        \\n        while(currentPtr.next != null && currentPtr.next.next != null ){\\n            ListNode firstNode = currentPtr.next ; \\n            ListNode secondNode  = currentPtr.next.next;\\n            // swaping nodes by replacing next wrt the currentPtr, which points to dummy atm\\n            firstNode.next = secondNode.next;\\n            currentPtr.next = secondNode;\\n            currentPtr.next.next = firstNode; \\n            \\n            // now, currentPtr will move to the 2nd node, then currentPtr.next will become first             //   node for the second pair\\n            currentPtr = currentPtr.next.next;\\n            \\n        }\\n        // our dummy is empty so after that lies our first node(head of the new list)\\n        return dummy.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347917,
                "title": "c-100-faster-recursive-solution",
                "content": "```\\nvoid swa(ListNode*head)\\n    {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n            return;\\n        ListNode*t=head->next;\\n        head->next=t->next;\\n        t->next=t->next->next;\\n        head->next->next=t;\\n        swa(head->next->next);\\n        \\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        // return NULL;\\n        if(!head || !head->next)return head;\\n       ListNode*temp=head->next;\\n        head->next=temp->next;\\n        temp->next=head;\\n        head=temp;\\n        swa(head->next);\\n       return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid swa(ListNode*head)\\n    {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n            return;\\n        ListNode*t=head->next;\\n        head->next=t->next;\\n        t->next=t->next->next;\\n        head->next->next=t;\\n        swa(head->next->next);\\n        \\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        // return NULL;\\n        if(!head || !head->next)return head;\\n       ListNode*temp=head->next;\\n        head->next=temp->next;\\n        temp->next=head;\\n        head=temp;\\n        swa(head->next);\\n       return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2245683,
                "title": "simple-python-reccursion-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        third = second.next\\n        \\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        return second\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        third = second.next\\n        \\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        return second\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990913,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic ListNode swapPairs(ListNode leftNode){\\n        if (leftNode == null || leftNode.next == null){\\n            return leftNode;\\n        }\\n        \\n        ListNode rightNode = leftNode.next;\\n        leftNode.next = swapPairs(rightNode.next);\\n        rightNode.next = leftNode;\\n        return rightNode;\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n\\tListNode* swapPairs(ListNode* head) {\\n\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\n\\t\\tListNode* prev=head;ListNode* curr=head;\\n\\t\\thead=head->next;\\n\\t\\twhile(curr && curr->next){\\n\\t\\t\\tprev->next=curr->next;\\n\\n\\t\\t\\tprev=curr;\\n\\t\\t\\tcurr=curr->next;\\n\\t\\t\\tprev->next=curr->next;\\n\\t\\t\\tcurr->next=prev;\\n\\t\\t\\tcurr=curr->next->next;}\\n\\t\\treturn head;\\n\\n\\t}\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nconst swapPairs = data => {\\n  let current = data;\\n  let count = 0;\\n  while (current) {\\n    if (count % 2 === 0 && current.next) {\\n      const tmp = current.val;\\n      current.val = current.next.val;\\n      current.next.val = tmp; \\n    }\\n    count++;\\n    current = current.next;\\n  }\\n  return data;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n\\t\\n\\t\\t// if we got empty list return null\\n        head ?: return null\\n\\n\\t\\t// create a pointer, pointing to second element in the list \\n\\t\\t// we will handle the case of swapping first two elements\\n\\t\\t// in the list later\\n        var ptr: ListNode? = head?.next\\n\\n        // in case of list with single element, return the list as\\n\\t\\t// swapping is not possible with just one element\\n        ptr ?: return head\\n\\n        while (ptr?.next != null) {\\n\\t\\t\\t// assign a temp pointer pointing to first of the two elements\\n\\t\\t\\t// to be swapped (we\\'re swapping in chunks on two in entire list)\\n\\t\\t\\t// so, for eg, if the list is 1 -> 2 -> 3 -> 4 -> 5, variable ptr \\n\\t\\t\\t// will point to 2 and variable temp will point to 3 in first pass\\n\\t\\t\\t// of this while loop\\n            val temp = ptr?.next \\n\\n\\t\\t\\t// check if the next chunk of two numbers exist or not\\n\\t\\t\\t// this check will handle lists with odd number of nodes\\n\\t\\t\\t// as the last nodes will not end up being swapped\\n            if (ptr?.next?.next != null) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the two nodes\\n                ptr?.next = ptr?.next?.next \\n                temp?.next = ptr?.next?.next \\n                ptr?.next?.next = temp\\n            }\\n\\n\\t\\t\\t// move the pointer by two nodes, remember we\\'re swapping\\n\\t\\t\\t// in chunks of two?\\n            ptr = ptr?.next?.next\\n        }\\n\\n        // swap elements at head\\n        ptr = head\\n        val temp: ListNode? = head?.next\\n        ptr?.next = temp?.next\\n        temp?.next = ptr\\n        return temp\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic ListNode swapPairs(ListNode leftNode){\\n        if (leftNode == null || leftNode.next == null){\\n            return leftNode;\\n        }\\n        \\n        ListNode rightNode = leftNode.next;\\n        leftNode.next = swapPairs(rightNode.next);\\n        rightNode.next = leftNode;\\n        return rightNode;\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n\\tListNode* swapPairs(ListNode* head) {\\n\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\n\\t\\tListNode* prev=head;ListNode* curr=head;\\n\\t\\thead=head->next;\\n\\t\\twhile(curr && curr->next){\\n\\t\\t\\tprev->next=curr->next;\\n\\n\\t\\t\\tprev=curr;\\n\\t\\t\\tcurr=curr->next;\\n\\t\\t\\tprev->next=curr->next;\\n\\t\\t\\tcurr->next=prev;\\n\\t\\t\\tcurr=curr->next->next;}\\n\\t\\treturn head;\\n\\n\\t}\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\n```\\n```\n```\\n```\n```\\nconst swapPairs = data => {\\n  let current = data;\\n  let count = 0;\\n  while (current) {\\n    if (count % 2 === 0 && current.next) {\\n      const tmp = current.val;\\n      current.val = current.next.val;\\n      current.next.val = tmp; \\n    }\\n    count++;\\n    current = current.next;\\n  }\\n  return data;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n\\t\\n\\t\\t// if we got empty list return null\\n        head ?: return null\\n\\n\\t\\t// create a pointer, pointing to second element in the list \\n\\t\\t// we will handle the case of swapping first two elements\\n\\t\\t// in the list later\\n        var ptr: ListNode? = head?.next\\n\\n        // in case of list with single element, return the list as\\n\\t\\t// swapping is not possible with just one element\\n        ptr ?: return head\\n\\n        while (ptr?.next != null) {\\n\\t\\t\\t// assign a temp pointer pointing to first of the two elements\\n\\t\\t\\t// to be swapped (we\\'re swapping in chunks on two in entire list)\\n\\t\\t\\t// so, for eg, if the list is 1 -> 2 -> 3 -> 4 -> 5, variable ptr \\n\\t\\t\\t// will point to 2 and variable temp will point to 3 in first pass\\n\\t\\t\\t// of this while loop\\n            val temp = ptr?.next \\n\\n\\t\\t\\t// check if the next chunk of two numbers exist or not\\n\\t\\t\\t// this check will handle lists with odd number of nodes\\n\\t\\t\\t// as the last nodes will not end up being swapped\\n            if (ptr?.next?.next != null) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the two nodes\\n                ptr?.next = ptr?.next?.next \\n                temp?.next = ptr?.next?.next \\n                ptr?.next?.next = temp\\n            }\\n\\n\\t\\t\\t// move the pointer by two nodes, remember we\\'re swapping\\n\\t\\t\\t// in chunks of two?\\n            ptr = ptr?.next?.next\\n        }\\n\\n        // swap elements at head\\n        ptr = head\\n        val temp: ListNode? = head?.next\\n        ptr?.next = temp?.next\\n        temp?.next = ptr\\n        return temp\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965896,
                "title": "python-iterative-solution-w-o-temporary-variables",
                "content": "```\\n def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(val=None,next=head)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n        while cur and cur.next:\\n            \\n            prev.next, cur.next.next, cur.next, prev, cur = cur.next, cur, cur.next.next, cur, cur.next.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(val=None,next=head)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n        while cur and cur.next:\\n            \\n            prev.next, cur.next.next, cur.next, prev, cur = cur.next, cur, cur.next.next, cur, cur.next.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1775864,
                "title": "c-o-n-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp = new ListNode;\\n        temp->next = head;\\n        ListNode* prev = temp;\\n        ListNode* cur = head;\\n        while(cur && cur->next){\\n            prev->next = cur->next;\\n            prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp = new ListNode;\\n        temp->next = head;\\n        ListNode* prev = temp;\\n        ListNode* cur = head;\\n        while(cur && cur->next){\\n            prev->next = cur->next;\\n            prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775090,
                "title": "2-java-solution-with-comments-recursive-and-iterative",
                "content": "1.take three pointers. prev, curr, next. and create arbitary node with dummy value and point it to head. by this we don\\'t need to handle head conditions.\\n2.initially curr will point to head and prev to dummynode and next to curr.next node.\\n3.loop till we curr and curr.next available. and perform below step.\\n4.just swap nodes next and curr. and after that reassign values of prev, curr and next to right position so that we can again swap curr with next.\\n\\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) {\\n            return head;\\n        }\\n        ListNode tempHead = new ListNode(-1);\\n        ListNode prev = tempHead;\\n        ListNode curr=head;\\n        while(curr!=null && curr.next!=null) {\\n            ListNode next=curr.next;\\n            curr.next=next.next;\\n            next.next=curr;\\n            prev.next=next;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return tempHead.next;\\n    }\\n```\\n\\nRecursive ->\\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next=(head);\\n\\t\\thead.next=(swapPairs(third));\\n\\t\\treturn second;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) {\\n            return head;\\n        }\\n        ListNode tempHead = new ListNode(-1);\\n        ListNode prev = tempHead;\\n        ListNode curr=head;\\n        while(curr!=null && curr.next!=null) {\\n            ListNode next=curr.next;\\n            curr.next=next.next;\\n            next.next=curr;\\n            prev.next=next;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return tempHead.next;\\n    }\\n```\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next=(head);\\n\\t\\thead.next=(swapPairs(third));\\n\\t\\treturn second;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774677,
                "title": "c-code-using-a-vector",
                "content": "-> used a vector to store sum of every pair node. \\n-> the traverse through the vector and current node value is replaced by (v[i] - (curr->val)\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* temp = curr;\\n        vector<int> v;\\n        while(head && head->next )\\n        {\\n            v.push_back(head->val + head->next->val);\\n            head = head->next->next;\\n        }\\n        int k = v.size();\\n        int i = 0;\\n        while(i<k)\\n        {\\n            curr->val = v[i]-(curr->val);\\n            curr->next->val = v[i]-(curr->next->val);\\n            curr = curr->next->next;\\n            i++;\\n        }\\n        \\n        return temp;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* temp = curr;\\n        vector<int> v;\\n        while(head && head->next )\\n        {\\n            v.push_back(head->val + head->next->val);\\n            head = head->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1722643,
                "title": "four-recursive-and-iterative-solutions-in-python",
                "content": "## Approach 1. recursion with modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n\\n            self.swapPairs(head.next.next)\\n\\n        return head\\n```\\n## Approach 2. iteration with modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            curr.val, curr.next.val = curr.next.val, curr.val\\n\\n            curr = curr.next.next\\n\\n        return head\\n```\\n\\n## Approach 3. recursion without modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        first, second = head, head.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n\\n        return second\\n```\\n\\n## Approach 4. iteration without modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n\\n        prev = dummy\\n\\n        while head and head.next:\\n            first, second = head, head.next\\n\\n            prev.next = second\\n            first.next = second.next\\n            second.next = first\\n\\n            prev = first\\n            head = head.first\\n\\n        return dummy.next\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n\\n            self.swapPairs(head.next.next)\\n\\n        return head\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            curr.val, curr.next.val = curr.next.val, curr.val\\n\\n            curr = curr.next.next\\n\\n        return head\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        first, second = head, head.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n\\n        return second\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n\\n        prev = dummy\\n\\n        while head and head.next:\\n            first, second = head, head.next\\n\\n            prev.next = second\\n            first.next = second.next\\n            second.next = first\\n\\n            prev = first\\n            head = head.first\\n\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585587,
                "title": "python-recursion-with-example",
                "content": "```\\ndef swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        \\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        \\n        return second\\n```\\n\\nThe recursive function is called on the 1st node of each pair. The recursive flow will be as follows:\\n\\nConsider the example : 1 --> 2 --> 3 --> 4 --> 5\\n\\n```\\nswap(1) --> first = 1\\n\\t\\t\\tsecond = 2\\n\\t\\t\\t1.next = swap(3) --> first = 3\\n\\t\\t\\t2.next = 1           second = 4\\n\\t\\t\\treturn 2\\t\\t\\t 3.next = swap(5) -- > return 5\\n\\t\\t\\t\\t\\t\\t\\t\\t 4.next = 3\\n\\t\\t\\t\\t\\t\\t\\t\\t return 4\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        \\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        \\n        return second\\n```\n```\\nswap(1) --> first = 1\\n\\t\\t\\tsecond = 2\\n\\t\\t\\t1.next = swap(3) --> first = 3\\n\\t\\t\\t2.next = 1           second = 4\\n\\t\\t\\treturn 2\\t\\t\\t 3.next = swap(5) -- > return 5\\n\\t\\t\\t\\t\\t\\t\\t\\t 4.next = 3\\n\\t\\t\\t\\t\\t\\t\\t\\t return 4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1489575,
                "title": "easy-c-solution",
                "content": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL) return head;\\n        int sum=0;\\n        ListNode* start=head,*temp=head;\\n        start=head;\\n        while(start){\\n            sum++;\\n            start=start->next;\\n        }\\n        if(sum==1) return head;\\n        else if(sum%2==0){\\n            start=head;\\n            while(start){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }else if(sum%2==1){\\n            start=head;\\n            while(start->next){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL) return head;\\n        int sum=0;\\n        ListNode* start=head,*temp=head;\\n        start=head;\\n        while(start){\\n            sum++;\\n            start=start->next;\\n        }\\n        if(sum==1) return head;\\n        else if(sum%2==0){\\n            start=head;\\n            while(start){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }else if(sum%2==1){\\n            start=head;\\n            while(start->next){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453499,
                "title": "java-beats-100-simple-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null){\\n            return head;\\n        }\\n        \\n        ListNode dummyHead = new ListNode(-1);\\n        ListNode prev = dummyHead;\\n        ListNode curr = head;\\n        \\n        while(curr != null && curr.next != null){\\n            prev.next = curr.next;\\n            curr.next = curr.next.next;\\n            prev.next.next = curr;\\n            curr = curr.next;\\n            prev = prev.next.next;\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null){\\n            return head;\\n        }\\n        \\n        ListNode dummyHead = new ListNode(-1);\\n        ListNode prev = dummyHead;\\n        ListNode curr = head;\\n        \\n        while(curr != null && curr.next != null){\\n            prev.next = curr.next;\\n            curr.next = curr.next.next;\\n            prev.next.next = curr;\\n            curr = curr.next;\\n            prev = prev.next.next;\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318487,
                "title": "python-easy-solution-with-comments-and-explanation",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        \\n        # dummy -> A -> B -> C \\n        \\n        # we want to swap A and B so we have to make dummy to point towards B and B towards A and A towards C \\n        \\n        \\n        # dummy >>>>> B\\n        # B >>>>> A\\n        # A >>>>> C \\n        # all steps simultaneously\\n        \\n        \\n        dummy = ListNode(0)\\n        \\n        dummy.next = head\\n        \\n        start = dummy\\n        \\n        \\n        while dummy.next and dummy.next.next:\\n            \\n            temp1 = dummy.next # A\\n            temp2 = temp1.next # B\\n            \\n            dummy.next ,temp2.next , temp1.next = temp2 , temp1, temp2.next\\n            \\n            dummy = temp1\\n            \\n        return start.next\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        \\n        # dummy -> A -> B -> C \\n        \\n        # we want to swap A and B so we have to make dummy to point towards B and B towards A and A towards C \\n        \\n        \\n        # dummy >>>>> B\\n        # B >>>>> A\\n        # A >>>>> C \\n        # all steps simultaneously\\n        \\n        \\n        dummy = ListNode(0)\\n        \\n        dummy.next = head\\n        \\n        start = dummy\\n        \\n        \\n        while dummy.next and dummy.next.next:\\n            \\n            temp1 = dummy.next # A\\n            temp2 = temp1.next # B\\n            \\n            dummy.next ,temp2.next , temp1.next = temp2 , temp1, temp2.next\\n            \\n            dummy = temp1\\n            \\n        return start.next\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269068,
                "title": "python-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        else:\\n            # Swap the 2 nodes\\n            temp = head \\n            head = head.next\\n            temp.next = head.next\\n            head.next = temp\\n            \\n            # call function recursively for next nodes\\n            temp.next = self.swapPairs(temp.next)\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        else:\\n            # Swap the 2 nodes\\n            temp = head \\n            head = head.next\\n            temp.next = head.next\\n            head.next = temp\\n            \\n            # call function recursively for next nodes\\n            temp.next = self.swapPairs(temp.next)\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984754,
                "title": "easy-understandable-python-solution",
                "content": "```\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        head2 = head\\n        while head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n            head = head.next.next\\n            \\n        return head2\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        head2 = head\\n        while head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n            head = head.next.next\\n            \\n        return head2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 984473,
                "title": "python-o-n-easy-clear-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef swapPairs(self, head: ListNode) -> ListNode:\\n\\t\\t\\tif not head or not head.next:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\t\\n\\t\\t\\ttmp = head\\n\\t\\t\\thead = head.next\\n\\t\\t\\ttmp.next = head.next\\n\\t\\t\\thead.next = tmp\\n\\t\\t\\t\\n\\t\\t\\ttmp.next = self.swapPairs(tmp.next)\\n\\t\\t\\t\\n\\t\\t\\treturn head",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef swapPairs(self, head: ListNode) -> ListNode:\\n\\t\\t\\tif not head or not head.next:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\t\\n\\t\\t\\ttmp = head\\n\\t\\t\\thead = head.next\\n\\t\\t\\ttmp.next = head.next\\n\\t\\t\\thead.next = tmp\\n\\t\\t\\t\\n\\t\\t\\ttmp.next = self.swapPairs(tmp.next)\\n\\t\\t\\t\\n\\t\\t\\treturn head",
                "codeTag": "Java"
            },
            {
                "id": 984443,
                "title": "swap-nodes-in-pair-c-faster-than-100-00-solutions-o-n-time-o-1-space-0ms-runtime",
                "content": "Time: O(n)\\nSpace: O(1)\\nThis is a very easy-to-follow solution. It beats 100% of the submitted C++ solutions according to my submission on Leetcode:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\nAny question let me know. If you like the post please upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877607,
                "title": "rust-straightforward-non-recursive-i-e-o-1-space",
                "content": "```rust\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut curr: &mut Option<Box<ListNode>> = &mut head;\\n        // Man, if-let chains or box patterns would be so nice...\\n        while curr.is_some() && curr.as_ref().unwrap().next.is_some() {\\n            let mut node1 = curr.take().unwrap();\\n            let mut node2 = node1.next.take().unwrap();\\n            let rest = node2.next.take();\\n            node1.next = rest;\\n            node2.next = Some(node1);\\n            *curr = Some(node2);\\n            curr = &mut curr.as_mut().unwrap().next.as_mut().unwrap().next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut curr: &mut Option<Box<ListNode>> = &mut head;\\n        // Man, if-let chains or box patterns would be so nice...\\n        while curr.is_some() && curr.as_ref().unwrap().next.is_some() {\\n            let mut node1 = curr.take().unwrap();\\n            let mut node2 = node1.next.take().unwrap();\\n            let rest = node2.next.take();\\n            node1.next = rest;\\n            node2.next = Some(node1);\\n            *curr = Some(node2);\\n            curr = &mut curr.as_mut().unwrap().next.as_mut().unwrap().next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820212,
                "title": "c-monster-oneliner-solution-vs-iterative-approach-explained-100-time-90-space",
                "content": "This is a rather simple to understand and not necessarily trivial to solve problem, so I decided to give myself a good extra challenge and to solve it first of all with a recursive approach.\\n\\nAnd doing it in one line.\\n\\nMy original code, the blasphemous oneliner:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head, ListNode *originalHead = NULL, ListNode *tmp = NULL) {\\n        return (originalHead = originalHead ? originalHead : head && head->next ? head->next : head, head) && head->next ? swapPairs(head->next->next, originalHead, (tmp = head->next, head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next, tmp->next = head)) : originalHead;\\n    }\\n};\\n```\\n\\nNow, for the sake of exercise and possibly for the joy of some of my most affectionate readers, I converted it into an iterative approach.\\n\\nFirst of all we move the variable declaration where they belong (in the recursive approach, I used the trick of setting them as additional parameters).\\n\\nAnd we get the first tricky part: `originalHead` needs to be `head->next` (because we are going to swap the first 2 elements too), provided it exists, otherwise it is going to be just `head` (if it is a valid node or `NULL`), so we initialise it to `head && head->next ? head->next : head`; `tmp` does not need to be initialised. And anyway nobody ever loved `tmp` and its parent were not even proud of `tmp`, so `tmp` does not deserve any initial value! In this version we will also need another pointer that I could avoid using previously, `nextHead`.\\n\\nBut enough with pointers\\' drama: we move on and convert the bulk of the rest of the logic to fit into a `while` loop with a `head && head->next` condition, again matching the logic of our oversized oneliner.\\n\\nInside our loop we can first of all store the value of the element after the current `head` in `tmp` and the value of the next `head` into `nextHead`.\\n\\nThen we have to update `head->next`: it has to be an element 3 steps to the right, if such an element exist, otherwise it is going to be an element 2 steps to the right (as it is the case for when we encounter the last element in an odd-lengthed list).\\n\\nTime to switch, so we set `tmp->next = head` and, since we are done with the logic for this run, all that we are missing is just to set it for the next iteration, with `head = nextHead`.\\n\\nOnce we are done looping, we can just return `originalHead`.\\n\\nThe refactored (and significantly more readable) code, which curiously seems to run a bit slower:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head) {\\n        ListNode *originalHead = head && head->next ? head->next : head, *tmp, *nextHead;\\n        while (head && head->next) {\\n            // storing the current value of the node following head\\n            tmp = head->next;\\n            // storing the head of the next loop\\n            nextHead = head->next->next;\\n            // updating head->next\\n            head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next;\\n            // switching head and its previous next position\\n            tmp->next = head;\\n            // setting the head of the next loop\\n            head = nextHead;\\n        }\\n        return originalHead;\\n    }\\n};\\n```\\n\\nAnd that was me months ago; I forgot about having solved the problem already, so I came up with another solution using one less variable.\\n\\nIn it I just declare `nextHead`, initialised to be `head->next`, provided both it and `head` exist, then I assign `head->next` the result of a recursive call, swap `head` and `nextHead` and return the latter.\\n\\nThe updated code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case: we are at the end of the line\\n        if (!head || !head->next) return head; \\n        // support variable\\n        ListNode *nextHead = head->next;\\n        // swapping positions\\n        head->next = swapPairs(nextHead->next);\\n        nextHead->next = head;\\n        return nextHead;\\n    }\\n};\\n```\\n\\nEven turning it into one liner is much more concise \\uD83D\\uDE09 :\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head, ListNode *nextHead = NULL) {\\n        return head && head->next ? nextHead = head->next, head->next = swapPairs(nextHead->next), nextHead->next = head, nextHead : head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head, ListNode *originalHead = NULL, ListNode *tmp = NULL) {\\n        return (originalHead = originalHead ? originalHead : head && head->next ? head->next : head, head) && head->next ? swapPairs(head->next->next, originalHead, (tmp = head->next, head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next, tmp->next = head)) : originalHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head) {\\n        ListNode *originalHead = head && head->next ? head->next : head, *tmp, *nextHead;\\n        while (head && head->next) {\\n            // storing the current value of the node following head\\n            tmp = head->next;\\n            // storing the head of the next loop\\n            nextHead = head->next->next;\\n            // updating head->next\\n            head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next;\\n            // switching head and its previous next position\\n            tmp->next = head;\\n            // setting the head of the next loop\\n            head = nextHead;\\n        }\\n        return originalHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case: we are at the end of the line\\n        if (!head || !head->next) return head; \\n        // support variable\\n        ListNode *nextHead = head->next;\\n        // swapping positions\\n        head->next = swapPairs(nextHead->next);\\n        nextHead->next = head;\\n        return nextHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head, ListNode *nextHead = NULL) {\\n        return head && head->next ? nextHead = head->next, head->next = swapPairs(nextHead->next), nextHead->next = head, nextHead : head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793729,
                "title": "3-lines-in-python-recursion",
                "content": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        head.next.next, head.next, head = head, self.swapPairs(head.next.next), head.next\\n        return head\\n```\\n\\nAnd, non-recursion in 5 lines:\\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        prev, cur = dummy, dummy.next = ListNode(0), head\\n        while cur and cur.next:\\n            cur.next.next, cur.next, prev.next = prev.next, cur.next.next, cur.next\\n            prev, cur = cur, cur.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        head.next.next, head.next, head = head, self.swapPairs(head.next.next), head.next\\n        return head\\n```\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        prev, cur = dummy, dummy.next = ListNode(0), head\\n        while cur and cur.next:\\n            cur.next.next, cur.next, prev.next = prev.next, cur.next.next, cur.next\\n            prev, cur = cur, cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393307,
                "title": "very-short-line-of-kotlin-code",
                "content": "Hope if you guys love it\\n\\n```\\nfun swapPairs(head: ListNode?): ListNode? {\\n    if(head?.next == null) return head\\n    val remaining = swapPairs(head.next?.next)\\n    val newHead = head.next!!\\n    newHead.next = head\\n    newHead.next!!.next = remaining\\n    return newHead\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun swapPairs(head: ListNode?): ListNode? {\\n    if(head?.next == null) return head\\n    val remaining = swapPairs(head.next?.next)\\n    val newHead = head.next!!\\n    newHead.next = head\\n    newHead.next!!.next = remaining\\n    return newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 303149,
                "title": "c-recursive-solution-short-simple-with-comments",
                "content": "```\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head != NULL && head->next != NULL)\\n        {\\n            ListNode *temp = head->next;                // temp = 2\\n            head->next = swapPairs(head->next->next);   // 1->3\\n            temp->next = head;                          // 2->1 \\n            head = temp;                                // head = 2\\n        }\\n        return head; // if head is NULL, head->next is NULL, or we\\'re done swapping\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head != NULL && head->next != NULL)\\n        {\\n            ListNode *temp = head->next;                // temp = 2\\n            head->next = swapPairs(head->next->next);   // 1->3\\n            temp->next = head;                          // 2->1 \\n            head = temp;                                // head = 2\\n        }\\n        return head; // if head is NULL, head->next is NULL, or we\\'re done swapping\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574728,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895922,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566737,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1783820,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1836468,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1827949,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566051,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895437,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1671797,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1571062,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1574728,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895922,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566737,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1783820,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1836468,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1827949,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566051,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895437,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1671797,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1571062,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895928,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1576659,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1896284,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1573008,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2057965,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2034957,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2013646,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1997607,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1988499,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1985704,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1984894,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1972364,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1972265,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1968740,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1958756,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1896214,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895915,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895810,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895807,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895616,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895609,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895543,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895531,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895521,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895482,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895451,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895446,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895389,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1883859,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1817742,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1808252,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1804363,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1803290,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1799258,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1786274,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1785572,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1764185,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1763737,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1760984,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1760448,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Maximum Path Sum",
        "question_content": "<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>\n\n<p>The <strong>path sum</strong> of a path is the sum of the node&#39;s values in the path.</p>\n\n<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [-10,9,20,null,null,15,7]\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 603423,
                "title": "python-recursion-stack-thinking-process-diagram",
                "content": "This problem requires quite a bit of quirky thinking steps. Take it slow until you fully grasp it.\\n\\n# **Basics**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177330.png)\\n\\n\\n# **Base cases**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177335.png)\\n\\n\\n# **Important Observations**\\n* These important observations are very important to understand `Line 9` and `Line 10` in the code.\\n\\t* For example, in the code (`Line 9`), we do something like `max(get_max_gain(node.left), 0)`. The important part is: why do we take maximum value between 0 and maximum gain we can get from left branch? Why 0?\\n\\t* Check the two images below first.\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177343.png)\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177349.png)\\n\\n* The important thing is \"We can only get any sort of gain IF our branches are not below zero. If they are below zero, why do we even bother considering them? Just pick 0 in that case. Therefore, we do `max(<some gain we might get or not>, 0)`.\\n\\n# **Going down the recursion stack for one example**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177356.png)\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177362.png)\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177368.png)\\n\\n* Because of this, we do `Line 12` and `Line 13`. It is important to understand the different between looking for the maximum path INVOLVING the current node in process and what we return for the node which starts the recursion stack. `Line 12` and `Line 13` takes care of the former issue and `Line 15` (and the image below) takes care of the latter issue.\\n\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177373.png)\\n\\n* Because of this fact, we have to return like `Line 15`. For our example, for node 1, which is the recursion call that node 3 does for `max(get_max_gain(node.left), 0)`, node 1 cannot include both node 6 and node 7 for a path to include node 3. Therefore, we can only pick the max gain from left path or right path of node 1.\\n\\n\\n**Python**\\n``` python\\n1. class Solution:\\n2.     def maxPathSum(self, root: TreeNode) -> int:\\n3. \\t\\tmax_path = float(\"-inf\") # placeholder to be updated\\n4. \\t\\tdef get_max_gain(node):\\n5. \\t\\t\\tnonlocal max_path # This tells that max_path is not a local variable\\n6. \\t\\t\\tif node is None:\\n7. \\t\\t\\t\\treturn 0\\n8. \\t\\t\\t\\t\\n9. \\t\\t\\tgain_on_left = max(get_max_gain(node.left), 0) # Read the part important observations\\n10. \\t\\tgain_on_right = max(get_max_gain(node.right), 0)  # Read the part important observations\\n11. \\t\\t\\t\\n12. \\t\\tcurrent_max_path = node.val + gain_on_left + gain_on_right # Read first three images of going down the recursion stack\\n13. \\t\\tmax_path = max(max_path, current_max_path) # Read first three images of going down the recursion stack\\n14. \\t\\t\\t\\n15. \\t\\treturn node.val + max(gain_on_left, gain_on_right) # Read the last image of going down the recursion stack\\n16. \\t\\t\\t\\n17. \\t\\t\\t\\n18. \\tget_max_gain(root) # Starts the recursion chain\\n19. \\treturn max_path\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "``` python\\n1. class Solution:\\n2.     def maxPathSum(self, root: TreeNode) -> int:\\n3. \\t\\tmax_path = float(\"-inf\") # placeholder to be updated\\n4. \\t\\tdef get_max_gain(node):\\n5. \\t\\t\\tnonlocal max_path # This tells that max_path is not a local variable\\n6. \\t\\t\\tif node is None:\\n7. \\t\\t\\t\\treturn 0\\n8. \\t\\t\\t\\t\\n9. \\t\\t\\tgain_on_left = max(get_max_gain(node.left), 0) # Read the part important observations\\n10. \\t\\tgain_on_right = max(get_max_gain(node.right), 0)  # Read the part important observations\\n11. \\t\\t\\t\\n12. \\t\\tcurrent_max_path = node.val + gain_on_left + gain_on_right # Read first three images of going down the recursion stack\\n13. \\t\\tmax_path = max(max_path, current_max_path) # Read first three images of going down the recursion stack\\n14. \\t\\t\\t\\n15. \\t\\treturn node.val + max(gain_on_left, gain_on_right) # Read the last image of going down the recursion stack\\n16. \\t\\t\\t\\n17. \\t\\t\\t\\n18. \\tget_max_gain(root) # Starts the recursion chain\\n19. \\treturn max_path\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39775,
                "title": "accepted-short-solution-in-java",
                "content": "Here's my ideas:\\n\\n - A path from start to end, goes up on the tree for 0 or more steps, then goes down for 0 or more steps. Once it goes down, it can't go up. Each path has a highest node, which is also the lowest common ancestor of all other nodes on the path.\\n - A recursive method `maxPathDown(TreeNode node)` (1) computes the maximum path sum with highest node is the input node, update maximum if necessary (2) returns the maximum sum of the path that can be extended to input node's parent.\\n\\nCode:\\n\\n    public class Solution {\\n        int maxValue;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            maxValue = Integer.MIN_VALUE;\\n            maxPathDown(root);\\n            return maxValue;\\n        }\\n        \\n        private int maxPathDown(TreeNode node) {\\n            if (node == null) return 0;\\n            int left = Math.max(0, maxPathDown(node.left));\\n            int right = Math.max(0, maxPathDown(node.right));\\n            maxValue = Math.max(maxValue, left + right + node.val);\\n            return Math.max(left, right) + node.val;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int maxValue;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            maxValue = Integer.MIN_VALUE;\\n            maxPathDown(root);\\n            return maxValue;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 389609,
                "title": "full-explanation-article-with-pseudo-code-beats-java-100-time-and-100-space-solution",
                "content": "A lot of the discussions here left me wondering with the magic that was happening between the lines and did not clearly explain the concept of the solution.\\nHere is a step by step solution of what would probably be easier to understand.\\n\\nOur goal is to find the maximum path sum. Now consider the following example.\\n\\n       10\\n\\t  /  \\\\\\n\\tnull null\\n\\t\\n\\t\\nIn this simple case we know that the max sum would be just the root node itself and the answer would be 10. So fo all `leaf`  nodes the max sum path is the value of the node itself.\\n\\nNow let\\'s consider the following example.\\n\\n ```\\n    20\\n   /  \\\\\\n 10    30\\n```\\n\\nHere there are multiple possibilities and we need to take care of the following **FOUR PATHS** that could be our max.\\n1.  The root iself : `20 `\\n2.  The root with the maximum from it\\'s left subTree : \\n\\t```\\n\\t\\t20\\n\\t\\t/\\n\\t  10\\n```\\t\\n3. The root with the maximum from it\\'s right subTree : \\n\\t\\n\\t\\t20\\n\\t\\t  \\\\\\n\\t       30\\n```\\t\\n4. The root with it\\'s left, right and itself\\n ```\\n\\t\\t 20\\n\\t\\t / \\\\\\n\\t 10  30\\n```\\n\\nIn case you are wondering  why we did not choose the root.left (10) or root.right(30) alone in the calculation ( like I wondered ), that\\'s because we would have already computed the result of it as a node in our recursion separately.\\n\\nThis actually breaks down our code to a very simple pseudo code:\\n\\n```\\nif( root == null) return 0;\\nleft = recurse(leftChild);\\nright = recurse(rightChild);\\n\\n// now find the max of all the four paths\\nleftPath = root.value + left;\\nrightPath = root.value + right;\\ncompletePath = root.value + right + left;\\n\\nresult = max( root.value, leftPath, rightPath, completePath );\\n\\nreturn max(root.value, leftPath, rightPath);\\n```\\n\\n*What\\'s  interesting to note here is the last line of the code* :\\n\\n```\\nreturn max(root.value, leftPath, rightPath);\\n```\\n\\n**Wondering why  did we do that ?**\\n\\nWell,  we know that we did all the calculations possible if the tree only consists of the current node as root in any possible recursion cycle. And the result of that cycle would have been stored in the `result` variable.\\nBut, what if the current node is just a child of it\\'s parent. Then it needs to return a value, such that the root had to be part of the answer. \\nSo if the root has to be part of the answer, it should return what\\'s the maximum value it can return if it\\'s part of it.\\nThat would be either of the three cases here :\\n1.  The root iself : `20 `\\n2.  The root with the maximum from it\\'s left subTree : \\n\\t```\\n\\t\\t20\\n\\t\\t/\\n\\t  10\\n```\\t\\n3. The root with the maximum from it\\'s right subTree : \\n\\t\\n\\t\\t20\\n\\t\\t  \\\\\\n\\t       30\\n```\\t\\nThis concludes us to the following code :\\n\\n```\\npublic class BinaryTreeMaximumPathSum {\\n    private int maxSum;\\n\\n    public int maxSumHelper(TreeNode root) {\\n\\t\\t\\n\\t\\t// base case\\n        if (root == null) return 0; \\n\\t\\t\\n\\t\\t// recursing through left and right subtree\\n        int leftMax = maxSumHelper(root.left);\\n        int rightMax = maxSumHelper(root.right);\\n\\n\\t\\t// finding all the four paths and the maximum between all of them\\n        int maxRightLeft = Math.max(leftMax, rightMax);\\n        int maxOneNodeRoot = Math.max(root.val, (root.val + maxRightLeft));\\n        int maxAll = Math.max(maxOneNodeRoot, leftMax + rightMax + root.val);\\n\\t\\t\\n\\t\\t// Storing the result in the maxSum holder\\n        maxSum = Math.max(maxSum, maxAll);\\n\\t\\t\\n\\t\\t// returning the value if root was part of the answer\\n        return maxOneNodeRoot;\\n\\n    }\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxSumHelper(root);\\n        return maxSum; // as maxSum will always store the result\\n\\n    }\\n}\\n\\n```\\nHope this post helps you clear your doubts !\\n",
                "solutionTags": [],
                "code": "```\\n    20\\n   /  \\\\\\n 10    30\\n```\n```\\n\\t\\t20\\n\\t\\t/\\n\\t  10\\n```\n```\\t\\n4. The root with it\\'s left, right and itself\\n ```\n```\\n\\nIn case you are wondering  why we did not choose the root.left (10) or root.right(30) alone in the calculation ( like I wondered ), that\\'s because we would have already computed the result of it as a node in our recursion separately.\\n\\nThis actually breaks down our code to a very simple pseudo code:\\n\\n```\n```\\n\\n*What\\'s  interesting to note here is the last line of the code* :\\n\\n```\n```\\n\\n**Wondering why  did we do that ?**\\n\\nWell,  we know that we did all the calculations possible if the tree only consists of the current node as root in any possible recursion cycle. And the result of that cycle would have been stored in the `result` variable.\\nBut, what if the current node is just a child of it\\'s parent. Then it needs to return a value, such that the root had to be part of the answer. \\nSo if the root has to be part of the answer, it should return what\\'s the maximum value it can return if it\\'s part of it.\\nThat would be either of the three cases here :\\n1.  The root iself : `20 `\\n2.  The root with the maximum from it\\'s left subTree : \\n\\t```\n```\\t\\n3. The root with the maximum from it\\'s right subTree : \\n\\t\\n\\t\\t20\\n\\t\\t  \\\\\\n\\t       30\\n```\n```\\npublic class BinaryTreeMaximumPathSum {\\n    private int maxSum;\\n\\n    public int maxSumHelper(TreeNode root) {\\n\\t\\t\\n\\t\\t// base case\\n        if (root == null) return 0; \\n\\t\\t\\n\\t\\t// recursing through left and right subtree\\n        int leftMax = maxSumHelper(root.left);\\n        int rightMax = maxSumHelper(root.right);\\n\\n\\t\\t// finding all the four paths and the maximum between all of them\\n        int maxRightLeft = Math.max(leftMax, rightMax);\\n        int maxOneNodeRoot = Math.max(root.val, (root.val + maxRightLeft));\\n        int maxAll = Math.max(maxOneNodeRoot, leftMax + rightMax + root.val);\\n\\t\\t\\n\\t\\t// Storing the result in the maxSum holder\\n        maxSum = Math.max(maxSum, maxAll);\\n\\t\\t\\n\\t\\t// returning the value if root was part of the answer\\n        return maxOneNodeRoot;\\n\\n    }\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxSumHelper(root);\\n        return maxSum; // as maxSum will always store the result\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603072,
                "title": "c-solution-o-n-with-detailed-explanation",
                "content": "```\\nThe way to think of a solution to this is that when we are looking a path in a tree its unidirectional and cannot retrace back what i mean by that is:\\n    _\\n  / 1 \\\\ \\n / / \\\\ \\\\ <-----path that goes like a depth first search without backtracking\\n/ 2   3 v  \\n\\nSo a way to solve this is that if i am at a node i can choose a left or right subtree but if i choose both this is the only subtree that will contain my maximum\\n\\nI first set my max_sum to INT_MIN.\\nI can do either either of the options presented:\\n1.I can choose to take up the left subtree or drop it.\\n2.I can either choose to take up the right subtree or drop it.\\n3.I check for a possibility whether if i were to take both left subtree and right subtree would that beat my current max_sum?\\nLets consider\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\nI do my postorder traversal with a bit of variation:-\\n\\nint l=max(max_gain(root->left),0);\\nint r=max(max_gain(root->right),0);\\nBut why?\\nThis is because I have the option to choose the left or right subtree or whether i will just settle with my root value.\\n\\nSo I do my regular postorder traversal and do the above steps\\nI hit 9\\n\\n    9\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was INT_MIN it gets updated to 9\\n\\nNow we explore the right tree of root which reaches 15\\n\\n    15\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was 9 it gets updated to 15\\n\\nSimilarly with 7 but 7 doesnt beat the max_sum so nothing happens.\\n\\nNow we backtrack 20\\nhere int r=7(as 7>0)\\n     int l=15(as 15>0)\\n now i check whether 20+15+7(considering this subtree to be my maximum)\\n as 42>15 max_sum=42\\n Now what if we dont consider this subtree?\\n\\n Then we choose 20 and maximum of its left or right subtree\\n so we send return root->val+max(l,r) to our recursion stack\\n so when i reach the root it would be like this\\n           -10\\n           /  \\\\    <----I considered 15 and 20 because its along a path and is greater than 20+7\\n          9    35\\n  int l=9\\n      r=35\\n      check whether 9+35+-10=34 beats max_sum\\n      34<42 so nothing happens and we return -10+max(9,35)=25 to the caller after which we break out of the helper function and we get max_sum as 42.\\n\\n    int max_sum=INT_MIN;\\n    int max_gain(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        int l=max(max_gain(root->left),0);\\n        int r=max(max_gain(root->right),0);\\n        int new_price=root->val+l+r;\\n        max_sum=max(max_sum,new_price);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        max_gain(root);\\n        return max_sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nThe way to think of a solution to this is that when we are looking a path in a tree its unidirectional and cannot retrace back what i mean by that is:\\n    _\\n  / 1 \\\\ \\n / / \\\\ \\\\ <-----path that goes like a depth first search without backtracking\\n/ 2   3 v  \\n\\nSo a way to solve this is that if i am at a node i can choose a left or right subtree but if i choose both this is the only subtree that will contain my maximum\\n\\nI first set my max_sum to INT_MIN.\\nI can do either either of the options presented:\\n1.I can choose to take up the left subtree or drop it.\\n2.I can either choose to take up the right subtree or drop it.\\n3.I check for a possibility whether if i were to take both left subtree and right subtree would that beat my current max_sum?\\nLets consider\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\nI do my postorder traversal with a bit of variation:-\\n\\nint l=max(max_gain(root->left),0);\\nint r=max(max_gain(root->right),0);\\nBut why?\\nThis is because I have the option to choose the left or right subtree or whether i will just settle with my root value.\\n\\nSo I do my regular postorder traversal and do the above steps\\nI hit 9\\n\\n    9\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was INT_MIN it gets updated to 9\\n\\nNow we explore the right tree of root which reaches 15\\n\\n    15\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was 9 it gets updated to 15\\n\\nSimilarly with 7 but 7 doesnt beat the max_sum so nothing happens.\\n\\nNow we backtrack 20\\nhere int r=7(as 7>0)\\n     int l=15(as 15>0)\\n now i check whether 20+15+7(considering this subtree to be my maximum)\\n as 42>15 max_sum=42\\n Now what if we dont consider this subtree?\\n\\n Then we choose 20 and maximum of its left or right subtree\\n so we send return root->val+max(l,r) to our recursion stack\\n so when i reach the root it would be like this\\n           -10\\n           /  \\\\    <----I considered 15 and 20 because its along a path and is greater than 20+7\\n          9    35\\n  int l=9\\n      r=35\\n      check whether 9+35+-10=34 beats max_sum\\n      34<42 so nothing happens and we return -10+max(9,35)=25 to the caller after which we break out of the helper function and we get max_sum as 42.\\n\\n    int max_sum=INT_MIN;\\n    int max_gain(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        int l=max(max_gain(root->left),0);\\n        int r=max(max_gain(root->right),0);\\n        int new_price=root->val+l+r;\\n        max_sum=max(max_sum,new_price);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        max_gain(root);\\n        return max_sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39875,
                "title": "elegant-java-solution",
                "content": "    public class Solution {\\n        int max = Integer.MIN_VALUE;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            helper(root);\\n            return max;\\n        }\\n        \\n        // helper returns the max branch \\n        // plus current node's value\\n        int helper(TreeNode root) {\\n            if (root == null) return 0;\\n            \\n            int left = Math.max(helper(root.left), 0);\\n            int right = Math.max(helper(root.right), 0);\\n            \\n            max = Math.max(max, root.val + left + right);\\n            \\n            return root.val + Math.max(left, right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        int max = Integer.MIN_VALUE;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            helper(root);\\n            return max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39869,
                "title": "simple-o-n-algorithm-with-one-traversal-through-the-tree",
                "content": "    class Solution {\\n        int maxToRoot(TreeNode *root, int &re) {\\n            if (!root) return 0;\\n            int l = maxToRoot(root->left, re);\\n            int r = maxToRoot(root->right, re);\\n            if (l < 0) l = 0;\\n            if (r < 0) r = 0;\\n            if (l + r + root->val > re) re = l + r + root->val;\\n            return root->val += max(l, r);\\n        }\\n    public:\\n        int maxPathSum(TreeNode *root) {\\n            int max = -2147483648;\\n            maxToRoot(root, max);\\n            return max;\\n        }\\n    };\\n\\nupdate the val of each node of the tree bottom-up, the new val of TreeNode *x stands for the max sum started from any node in subtree x and ended in x, mataining the re for result in traversal at the same time.",
                "solutionTags": [],
                "code": "class Solution {\\n        int maxToRoot(TreeNode *root, int &re) {\\n            if (!root) return 0;\\n            int l = maxToRoot(root->left, re);\\n            int r = maxToRoot(root->right, re);\\n            if (l < 0) l = 0;\\n            if (r < 0) r = 0;\\n            if (l + r + root->val > re) re = l + r + root->val;\\n            return root->val += max(l, r);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 370666,
                "title": "concise-dfs-solution-with-detailed-explanation-python",
                "content": "The idea is to **update node values with the biggest, positive cumulative sum gathered by its children**:\\n* If both contributions are negative, no value is added. \\n* If both are positive, only the biggest one is added, so that we don\\'t include both children during the rest of the tree exploration. \\n* Leaves return its own value and we recursively work our way upwards.\\n\\nA global maximum sum variable is maintained so that **every path can be individually checked**, while updated node values on the tree **allow for exploration of other valid paths outside of the current subtree**. \\nMore details in the code comments:\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max_sum = float(\\'-inf\\')\\n        self.dfs(root)\\n        return self.max_sum\\n    \\n    def dfs(self, node):\\n        if not node: return 0\\n        \\n        # only add positive contributions\\n        leftST_sum = max(0, self.dfs(node.left))\\n        rightST_sum = max(0, self.dfs(node.right))\\n\\n        # check if cumulative sum at current node > global max sum so far\\n        # this evaluates a candidate path\\n        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)\\n        \\n        # add to the current node ONLY one of the children contributions\\n        # in order to maintain the constraint of considering only paths\\n        # if not, we would be exploring explore the whole tree - against problem definition\\n        return max(leftST_sum, rightST_sum) + node.val\\n```\\n\\nThe key is to always choose the maximum cumulative sum path, while updating the \"global\" maximum value, from the leaves upwards.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max_sum = float(\\'-inf\\')\\n        self.dfs(root)\\n        return self.max_sum\\n    \\n    def dfs(self, node):\\n        if not node: return 0\\n        \\n        # only add positive contributions\\n        leftST_sum = max(0, self.dfs(node.left))\\n        rightST_sum = max(0, self.dfs(node.right))\\n\\n        # check if cumulative sum at current node > global max sum so far\\n        # this evaluates a candidate path\\n        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)\\n        \\n        # add to the current node ONLY one of the children contributions\\n        # in order to maintain the constraint of considering only paths\\n        # if not, we would be exploring explore the whole tree - against problem definition\\n        return max(leftST_sum, rightST_sum) + node.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39919,
                "title": "8-10-lines-two-solutions",
                "content": "Two solutions:\\n\\n---\\n\\n**Solution 1: *Helper returning two values*:** (240 ms, 8 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxsums(node):\\n            if not node:\\n                return [-2**31] * 2\\n            left = maxsums(node.left)\\n            right = maxsums(node.right)\\n            return [node.val + max(left[0], right[0], 0),\\n                    max(left + right + [node.val + left[0] + right[0]])]\\n        return max(maxsums(root))\\n\\nMy helper function returns two values:\\n\\n 1. The max sum of all paths ending in the given node (can be extended through the parent)\\n 2. The max sum of all paths anywhere in tree rooted at the given node (can *not* be extended through the parent).\\n\\n\\n---\\n\\n**Solution 2: *Helper updating a \"global\" maximum*:** (172 ms, 10 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxend(node):\\n            if not node:\\n                return 0\\n            left = maxend(node.left)\\n            right = maxend(node.right)\\n            self.max = max(self.max, left + node.val + right)\\n            return max(node.val + max(left, right), 0)\\n        self.max = None\\n        maxend(root)\\n        return self.max\\n\\nHere the helper is similar, but only returns the first of the two values (the max sum of all paths ending in the given node). Instead of returning the second value (the max sum of all paths anywhere in tree rooted at the given node), it updates a \"global\" maximum.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Two solutions:\\n\\n---\\n\\n**Solution 1: *Helper returning two values*:** (240 ms, 8 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxsums(node):\\n            if not node:\\n                return [-2**31] * 2\\n            left = maxsums(node.left)\\n            right = maxsums(node.right)\\n            return [node.val + max(left[0], right[0], 0),\\n                    max(left + right + [node.val + left[0] + right[0]])]\\n        return max(maxsums(root))\\n\\nMy helper function returns two values:\\n\\n 1. The max sum of all paths ending in the given node (can be extended through the parent)\\n 2. The max sum of all paths anywhere in tree rooted at the given node (can *not* be extended through the parent).\\n\\n\\n---\\n\\n**Solution 2: *Helper updating a \"global\" maximum*:** (172 ms, 10 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxend(node):\\n            if not node:\\n                return 0\\n            left = maxend(node.left)\\n            right = maxend(node.right)\\n            self.max = max(self.max, left + node.val + right)\\n            return max(node.val + max(left, right), 0)\\n        self.max = None\\n        maxend(root)\\n        return self.max\\n\\nHere the helper is similar, but only returns the first of the two values (the max sum of all paths ending in the given node). Instead of returning the second value (the max sum of all paths anywhere in tree rooted at the given node), it updates a \"global\" maximum.",
                "codeTag": "Python3"
            },
            {
                "id": 39873,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n        int sum;\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            sum=INT_MIN;\\n            help(root);\\n            return sum;\\n        }\\n        \\n        /*** return the max-value-ended-at-root-node ***/\\n        int help(TreeNode* root){\\n            if(!root)   return 0;\\n            int left = max(0, help(root->left));\\n            int right = max(0, help(root->right));\\n            /*** key parts : embedding the max-value-find in the recursion process ***/\\n            sum = max(sum, left+right+root->val);\\n            /*** get the max-value-ended-at-root ***/\\n            return max(left, right)+root->val;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        int sum;\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            sum=INT_MIN;\\n            help(root);\\n            return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1288024,
                "title": "c-easy-to-understand-full-explanation-article-with-code",
                "content": "```\\nLet\\'s think what can be the possible cases for this question:\\n1) The MaxPathSum can pass through root node.\\n    eg: \\n            10  <- MaxPathSum passes through this node ( considering 10 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n2) MaxPathSum can be present in the left Subtree.\\n    eg:\\n           -100  <- MaxPathSum passes lies in the left Subtree ( considering -100 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n    \\n\\n3) MaxPathSum can be present int the right Subtree.\\n\\n    eg:\\n           -100  <- MaxPathSum passes lies in the right Subtree ( considering -100 as root ).\\n            /\\\\\\n         -200  1000\\n          /\\\\    \\\\\\n         20 1   200 \\n\\nSo, we just have to write for the case when it passes through the root node. Recursion will take care of the rest.\\n\\nAnother thing, we have to also keep a track of max branch sum. Here is an example why:\\n    eg: \\n\\n        Lets say the left branch sum of this subtree is 20 and right branch is 30.\\n            10\\n           /  \\\\                         BS = Branch Sum\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n But it may be possible that we can find even better answer which includes this subtree. \\n In that case we have to pick a single branch of this subtree.\\n Since path can only be in one direction from a node, i.e, either we can go left or right from a node.\\n like, \\n\\n              50            MaxPathSum = 30 + 10 + 50 + 7\\n             /  \\\\ \\n            10   7\\n           /  \\\\\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n So, here the root 50 should know what is the maxBranchSum in the left to find the maxPathSum.\\nSo, 10 will return the branch sum as [max(leftBranchSum , rightBranchSum) + root->val] to its parent.\\n```\\n\\n\\nOnce you have figured that out, then the answer is pretty simple.\\n\\nthe ans can be :\\nmax({\\n    root->val,                                    //root can be ans\\n    leftBS,   //BS = BranchSum        //left branch of the root may have the ans\\n    rightBS,  //BS = BranchSum      //right branch of the root may have the ans\\n    leftBS + rightBS + root->val   //left branch + root + right branch can be the ans\\n});\\nLets have a look at the code:\\n```\\n\\nint maxSum(TreeNode* root, int& ans) {\\n    /* This function return the Branch Sum......\\n    So if the node is NULL then it won\\'t have a branch....so the branch sum will be 0.\\n    */\\n    //Base Case\\n    if(root == NULL){\\n        return 0;\\n    }\\n    \\n    //Recursive Case \\n    //BS = Branch Sum\\n    int leftBS = root->val + maxSum( root->left , ans );\\n    int rightBS = root->val + maxSum( root->right , ans );\\n    \\n    ans = max({\\n                ans,            //we may have found the maximum ans already\\n                root->val,      //may be the current root val is the maximum sum possible\\n                leftBS,         //may be the answer contain root->val + left branch value\\n                rightBS,        //may be the answer contain root->val + right branch value\\n                leftBS + rightBS - root->val   // may be ans conatin left branch + right branch + root->val\\n                                               // Since the root val is added twice from leftBS and rightBS so we are sunstracting it.\\n            });\\n    \\n    //Return the max branch Sum\\n    return max({ leftBS , rightBS , root->val });\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    int ans = INT_MIN;\\n    maxSum(root, ans);\\n    return ans;\\n}\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nLet\\'s think what can be the possible cases for this question:\\n1) The MaxPathSum can pass through root node.\\n    eg: \\n            10  <- MaxPathSum passes through this node ( considering 10 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n2) MaxPathSum can be present in the left Subtree.\\n    eg:\\n           -100  <- MaxPathSum passes lies in the left Subtree ( considering -100 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n    \\n\\n3) MaxPathSum can be present int the right Subtree.\\n\\n    eg:\\n           -100  <- MaxPathSum passes lies in the right Subtree ( considering -100 as root ).\\n            /\\\\\\n         -200  1000\\n          /\\\\    \\\\\\n         20 1   200 \\n\\nSo, we just have to write for the case when it passes through the root node. Recursion will take care of the rest.\\n\\nAnother thing, we have to also keep a track of max branch sum. Here is an example why:\\n    eg: \\n\\n        Lets say the left branch sum of this subtree is 20 and right branch is 30.\\n            10\\n           /  \\\\                         BS = Branch Sum\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n But it may be possible that we can find even better answer which includes this subtree. \\n In that case we have to pick a single branch of this subtree.\\n Since path can only be in one direction from a node, i.e, either we can go left or right from a node.\\n like, \\n\\n              50            MaxPathSum = 30 + 10 + 50 + 7\\n             /  \\\\ \\n            10   7\\n           /  \\\\\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n So, here the root 50 should know what is the maxBranchSum in the left to find the maxPathSum.\\nSo, 10 will return the branch sum as [max(leftBranchSum , rightBranchSum) + root->val] to its parent.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39927,
                "title": "iterative-java-solution",
                "content": "Hi guys!\\n\\nThe idea of mine approach is similar to recursive solutions which can be found in other posts but made in iterative manner. We just need to traverse the nodes in post-order (the same as the order of topological sorting, actually) storing the maximum root paths in a cache and updating the result value. Here's how it looks like in Java:\\n\\n    // just returns the nodes in post-order\\n    public Iterable<TreeNode> topSort(TreeNode root) {\\n        Deque<TreeNode> result = new LinkedList<>();\\n        if (root != null) {\\n            Deque<TreeNode> stack = new LinkedList<>();\\n            stack.push(root);\\n            while (!stack.isEmpty()) {\\n                TreeNode curr = stack.pop();\\n                result.push(curr);\\n                if (curr.right != null) stack.push(curr.right);\\n                if (curr.left != null) stack.push(curr.left);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int maxPathSum(TreeNode root) {\\n        int result = Integer.MIN_VALUE;\\n        Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n        maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n        for (TreeNode node : topSort(root)) {\\n            // as we process nodes in post-order their children are already cached\\n            int left = Math.max(maxRootPath.get(node.left), 0);\\n            int right = Math.max(maxRootPath.get(node.right), 0); \\n            maxRootPath.put(node, Math.max(left, right) + node.val);\\n            result = Math.max(left + right + node.val, result);\\n        }\\n        return result;\\n    }\\n\\nHappy coding!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe idea of mine approach is similar to recursive solutions which can be found in other posts but made in iterative manner. We just need to traverse the nodes in post-order (the same as the order of topological sorting, actually) storing the maximum root paths in a cache and updating the result value. Here's how it looks like in Java:\\n\\n    // just returns the nodes in post-order\\n    public Iterable<TreeNode> topSort(TreeNode root) {\\n        Deque<TreeNode> result = new LinkedList<>();\\n        if (root != null) {\\n            Deque<TreeNode> stack = new LinkedList<>();\\n            stack.push(root);\\n            while (!stack.isEmpty()) {\\n                TreeNode curr = stack.pop();\\n                result.push(curr);\\n                if (curr.right != null) stack.push(curr.right);\\n                if (curr.left != null) stack.push(curr.left);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int maxPathSum(TreeNode root) {\\n        int result = Integer.MIN_VALUE;\\n        Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n        maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n        for (TreeNode node : topSort(root)) {\\n            // as we process nodes in post-order their children are already cached\\n            int left = Math.max(maxRootPath.get(node.left), 0);\\n            int right = Math.max(maxRootPath.get(node.right), 0); \\n            maxRootPath.put(node, Math.max(left, right) + node.val);\\n            result = Math.max(left + right + node.val, result);\\n        }\\n        return result;\\n    }\\n\\nHappy coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 39807,
                "title": "a-very-concise-recursive-solution",
                "content": "    int maxPathSum(TreeNode *root) {\\n        int maxPath = INT_MIN;\\n        dfsMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n    \\n    int dfsMaxPath(TreeNode *root, int &maxPath) {\\n        if (!root) return 0;\\n        int l = max(0, dfsMaxPath(root->left, maxPath));\\n        int r = max(0, dfsMaxPath(root->right, maxPath));\\n        maxPath = max(maxPath, l + r + root->val);\\n        return root->val + max(l, r);\\n    }",
                "solutionTags": [],
                "code": "    int maxPathSum(TreeNode *root) {\\n        int maxPath = INT_MIN;\\n        dfsMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n    \\n    int dfsMaxPath(TreeNode *root, int &maxPath) {\\n        if (!root) return 0;\\n        int l = max(0, dfsMaxPath(root->left, maxPath));\\n        int r = max(0, dfsMaxPath(root->right, maxPath));\\n        maxPath = max(maxPath, l + r + root->val);\\n        return root->val + max(l, r);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39884,
                "title": "python-solution-beats-97",
                "content": "    class Solution(object):\\n        current_max = float('-inf')\\n        def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n            self.maxPathSumHelper(root)\\n            return self.current_max\\n    \\n        def maxPathSumHelper(self, root):\\n            \"\"\"Helper method\"\"\"\\n            if root is None:\\n                return root\\n            left = self.maxPathSumHelper(root.left)\\n            right = self.maxPathSumHelper(root.right)\\n            left = 0 if left is None else (left if left > 0 else 0)\\n            right = 0 if right is None else (right if right > 0 else 0)\\n            self.current_max = max(left+right+root.val, self.current_max)\\n            return max(left, right) + root.val\\n\\nThis is my first post and I thought I would share my solution since it beats 97% of submissions. I keep a global variable current_max and update it whenever the sum of the root and its children are greater than the current max. I don't consider a child if its value is negative(set it to zero). Each parent returns its maximum child plus its own value.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        current_max = float('-inf')\\n        def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n            self.maxPathSumHelper(root)\\n            return self.current_max\\n    \\n        def maxPathSumHelper(self, root):\\n            \"\"\"Helper method\"\"\"\\n            if root is None:\\n                return root\\n            left = self.maxPathSumHelper(root.left)\\n            right = self.maxPathSumHelper(root.right)\\n            left = 0 if left is None else (left if left > 0 else 0)\\n            right = 0 if right is None else (right if right > 0 else 0)\\n            self.current_max = max(left+right+root.val, self.current_max)\\n            return max(left, right) + root.val\\n\\nThis is my first post and I thought I would share my solution since it beats 97% of submissions. I keep a global variable current_max and update it whenever the sum of the root and its children are greater than the current max. I don't consider a child if its value is negative(set it to zero). Each parent returns its maximum child plus its own value.",
                "codeTag": "Java"
            },
            {
                "id": 982696,
                "title": "javascript-o-n-time-easy-to-understand-with-explanation",
                "content": "It\\'s important to point out that we are looking for the **maximum path**. In the most simple case, a single node can be the max path, or even the entire tree could be the max path. To keep the max variable up to date, I create a global variable that will be updated over the run of the functions.\\n\\nWe are doing a DFS recursive function here.\\n\\nWe need a base case, and that base case is if we hit a null, we return 0. We are going going to finish the left subtree before going to the right subtree, which is denoted by `findSums(node.left)` then after is `findSums(node.right)`. After the left and right subtree are done (for an example, look at a single node), we have three different sums. All three nodes (left, right and node.val), left side (node.val and left), right side (node.val and right) or just the single node. We use these values (with the current max) to find the max.\\n\\nThe most important part is **what do we return for this recursive function?** The answer is we are returning\\n\\n\\tThe Max Path from this node\\n\\t\\nThat can be node.val, leftNodeSum, or rightNodeSum. We cannot return allSum since that would not be a path. Very, very important to point that out.\\n\\n```\\nconst maxPathSum = (root) => {\\n\\tlet max = -Infinity;\\n\\n\\tconst findSums = (node) => {\\n\\t\\t// Base case / hit a null\\n\\t\\tif (!node) return 0;\\n\\n\\t\\tlet left = findSums(node.left),\\n\\t\\t\\tright = findSums(node.right),\\n\\t\\t\\tallSum = left + right + node.val,\\n\\t\\t\\tleftNodeSum = left + node.val,\\n\\t\\t\\trightNodeSum = right + node.val;\\n\\n\\t\\t// Max is all possible combinations\\n\\t\\tmax = Math.max(max, node.val, allSum, leftNodeSum, rightNodeSum);\\n\\t\\t\\n\\t\\t// Return the MAX path, which can be node.val, left + node.val, or right + node.val\\n\\t\\treturn Math.max(leftNodeSum, rightNodeSum, node.val);\\n\\t};\\n\\n\\tfindSums(root);\\n\\n\\treturn max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst maxPathSum = (root) => {\\n\\tlet max = -Infinity;\\n\\n\\tconst findSums = (node) => {\\n\\t\\t// Base case / hit a null\\n\\t\\tif (!node) return 0;\\n\\n\\t\\tlet left = findSums(node.left),\\n\\t\\t\\tright = findSums(node.right),\\n\\t\\t\\tallSum = left + right + node.val,\\n\\t\\t\\tleftNodeSum = left + node.val,\\n\\t\\t\\trightNodeSum = right + node.val;\\n\\n\\t\\t// Max is all possible combinations\\n\\t\\tmax = Math.max(max, node.val, allSum, leftNodeSum, rightNodeSum);\\n\\t\\t\\n\\t\\t// Return the MAX path, which can be node.val, left + node.val, or right + node.val\\n\\t\\treturn Math.max(leftNodeSum, rightNodeSum, node.val);\\n\\t};\\n\\n\\tfindSums(root);\\n\\n\\treturn max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419793,
                "title": "python-recursive-solution-beats-98-in-time-and-75-in-memory",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.res = float(\\'-inf\\')\\n        self.helper(root)\\n        return self.res \\n        \\n    def helper(self, root):\\n        if not root:\\n            return 0\\n        left, right = self.helper(root.left), self.helper(root.right)\\n        self.res = max(self.res, root.val + left + right)\\n        return max(root.val + max(left, right), 0)\\n   ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.res = float(\\'-inf\\')\\n        self.helper(root)\\n        return self.res \\n        \\n    def helper(self, root):\\n        if not root:\\n            return 0\\n        left, right = self.helper(root.left), self.helper(root.right)\\n        self.res = max(self.res, root.val + left + right)\\n        return max(root.val + max(left, right), 0)\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 39908,
                "title": "python-solution-with-comments",
                "content": "    \\n    # Recursively \\n    def maxPathSum(self, root):\\n        self.res = -sys.maxsize-1\\n        self.oneSideSum(root)\\n        return self.res\\n        \\n    # compute one side maximal sum, \\n    # (root+left children, or root+right children),\\n    # root is the included top-most node \\n    def oneSideSum(self, root):\\n        if not root:\\n            return 0\\n        l = max(0, self.oneSideSum(root.left))\\n        r = max(0, self.oneSideSum(root.right))\\n        self.res = max(self.res, l+r+root.val)\\n        return max(l, r)+root.val",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "    \\n    # Recursively \\n    def maxPathSum(self, root):\\n        self.res = -sys.maxsize-1\\n        self.oneSideSum(root)\\n        return self.res\\n        \\n    # compute one side maximal sum, \\n    # (root+left children, or root+right children),\\n    # root is the included top-most node \\n    def oneSideSum(self, root):\\n        if not root:\\n            return 0\\n        l = max(0, self.oneSideSum(root.left))\\n        r = max(0, self.oneSideSum(root.right))\\n        self.res = max(self.res, l+r+root.val)\\n        return max(l, r)+root.val",
                "codeTag": "Python3"
            },
            {
                "id": 39862,
                "title": "easy-understand-34ms-c-dfs-solution",
                "content": "    class Solution {\\n    private:\\n        int dfs(TreeNode* root, int& maxsum) {\\n            if(!root) return 0;\\n            int l = max(0,dfs(root->left,maxsum));\\n            int r = max(0,dfs(root->right,maxsum));\\n            maxsum = max(l+r+root->val, maxsum);\\n            return root->val + max(l,r);\\n        }\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            int maxsum = INT_MIN;\\n            dfs(root,maxsum);\\n            return maxsum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private:\\n        int dfs(TreeNode* root, int& maxsum) {\\n            if(!root) return 0;\\n            int l = max(0,dfs(root->left,maxsum));\\n            int r = max(0,dfs(root->right,maxsum));\\n            maxsum = max(l+r+root->val, maxsum);\\n            return root->val + max(l,r);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39767,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        self.msum = float('-inf')\\n        self.get_sum(root)\\n        return self.msum\\n    \\n    def get_sum(self, node):\\n        if not node:\\n            return 0\\n        \\n        ls, rs = self.get_sum(node.left), self.get_sum(node.right)\\n        max_single_path = max(node.val+max(ls,rs), node.val)\\n        self.msum = max(self.msum, max_single_path , node.val+ls+rs)\\n        return max_single_path\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        self.msum = float('-inf')\\n        self.get_sum(root)\\n        return self.msum\\n    \\n    def get_sum(self, node):\\n        if not node:\\n            return 0\\n        \\n        ls, rs = self.get_sum(node.left), self.get_sum(node.right)\\n        max_single_path = max(node.val+max(ls,rs), node.val)\\n        self.msum = max(self.msum, max_single_path , node.val+ls+rs)\\n        return max_single_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39779,
                "title": "8-lines-c-similar-to-diameter-of-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        DFS(root, maxSum);\\n        return maxSum;\\n    }\\n    \\n    int DFS(TreeNode* root, int& maxSum){\\n        if(!root) return 0;\\n        int left = max(0, DFS(root->left, maxSum));\\n        int right = max(0, DFS(root->right, maxSum));\\n        maxSum = max(maxSum, left + right + root->val);\\n        return max(left, right) + root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        DFS(root, maxSum);\\n        return maxSum;\\n    }\\n    \\n    int DFS(TreeNode* root, int& maxSum){\\n        if(!root) return 0;\\n        int left = max(0, DFS(root->left, maxSum));\\n        int right = max(0, DFS(root->right, maxSum));\\n        maxSum = max(maxSum, left + right + root->val);\\n        return max(left, right) + root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040330,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\n// just returns the nodes in post-order\\npublic Iterable<TreeNode> topSort(TreeNode root) {\\n    Deque<TreeNode> result = new LinkedList<>();\\n    if (root != null) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            result.push(curr);\\n            if (curr.right != null) stack.push(curr.right);\\n            if (curr.left != null) stack.push(curr.left);\\n        }\\n    }\\n    return result;\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n    int result = Integer.MIN_VALUE;\\n    Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n    maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n    for (TreeNode node : topSort(root)) {\\n        // as we process nodes in post-order their children are already cached\\n        int left = Math.max(maxRootPath.get(node.left), 0);\\n        int right = Math.max(maxRootPath.get(node.right), 0); \\n        maxRootPath.put(node, Math.max(left, right) + node.val);\\n        result = Math.max(left + right + node.val, result);\\n    }\\n    return result;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nint maxSum(TreeNode* root, int& ans) {\\n    /* This function return the Branch Sum......\\n    So if the node is NULL then it won\\'t have a branch....so the branch sum will be 0.\\n    */\\n    //Base Case\\n    if(root == NULL){\\n        return 0;\\n    }\\n    \\n    //Recursive Case \\n    //BS = Branch Sum\\n    int leftBS = root->val + maxSum( root->left , ans );\\n    int rightBS = root->val + maxSum( root->right , ans );\\n    \\n    ans = max({\\n                ans,            //we may have found the maximum ans already\\n                root->val,      //may be the current root val is the maximum sum possible\\n                leftBS,         //may be the answer contain root->val + left branch value\\n                rightBS,        //may be the answer contain root->val + right branch value\\n                leftBS + rightBS - root->val   // may be ans conatin left branch + right branch + root->val\\n                                               // Since the root val is added twice from leftBS and rightBS so we are sunstracting it.\\n            });\\n    \\n    //Return the max branch Sum\\n    return max({ leftBS , rightBS , root->val });\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    int ans = INT_MIN;\\n    maxSum(root, ans);\\n    return ans;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar maxPathSum = function(root) {\\n  var max = -Number.MAX_VALUE;\\n  getMaxSum(root);\\n  return max;\\n  function getMaxSum(node) {\\n    if (!node) return 0;\\n    var leftSum = getMaxSum(node.left);\\n    var rightSum = getMaxSum(node.right);\\n    max = Math.max(max, node.val + leftSum + rightSum);\\n    return Math.max(0, node.val + leftSum, node.val + rightSum);\\n  }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?) = postorder(root).maxSum\\n\\n    private fun postorder(node: TreeNode?): Res {\\n        if (node == null)\\n            return Res(Int.MIN_VALUE, 0)\\n\\n        val (leftMaxSum, leftPathSum) = postorder(node.left)\\n        val (rightMaxSum, rightPathSum) = postorder(node.right)\\n\\n        val value = node.`val`\\n        val sum = leftPathSum + rightPathSum + value\\n\\n        return Res(maxOf(leftMaxSum, rightMaxSum, sum), maxOf(0, value + maxOf(leftPathSum, rightPathSum)))\\n    }\\n\\n    private data class Res(val maxSum: Int, val pathSum: Int)\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\n// just returns the nodes in post-order\\npublic Iterable<TreeNode> topSort(TreeNode root) {\\n    Deque<TreeNode> result = new LinkedList<>();\\n    if (root != null) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            result.push(curr);\\n            if (curr.right != null) stack.push(curr.right);\\n            if (curr.left != null) stack.push(curr.left);\\n        }\\n    }\\n    return result;\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n    int result = Integer.MIN_VALUE;\\n    Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n    maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n    for (TreeNode node : topSort(root)) {\\n        // as we process nodes in post-order their children are already cached\\n        int left = Math.max(maxRootPath.get(node.left), 0);\\n        int right = Math.max(maxRootPath.get(node.right), 0); \\n        maxRootPath.put(node, Math.max(left, right) + node.val);\\n        result = Math.max(left + right + node.val, result);\\n    }\\n    return result;\\n}\\n```\n```\\n```\n```\\n```\n```\\nint maxSum(TreeNode* root, int& ans) {\\n    /* This function return the Branch Sum......\\n    So if the node is NULL then it won\\'t have a branch....so the branch sum will be 0.\\n    */\\n    //Base Case\\n    if(root == NULL){\\n        return 0;\\n    }\\n    \\n    //Recursive Case \\n    //BS = Branch Sum\\n    int leftBS = root->val + maxSum( root->left , ans );\\n    int rightBS = root->val + maxSum( root->right , ans );\\n    \\n    ans = max({\\n                ans,            //we may have found the maximum ans already\\n                root->val,      //may be the current root val is the maximum sum possible\\n                leftBS,         //may be the answer contain root->val + left branch value\\n                rightBS,        //may be the answer contain root->val + right branch value\\n                leftBS + rightBS - root->val   // may be ans conatin left branch + right branch + root->val\\n                                               // Since the root val is added twice from leftBS and rightBS so we are sunstracting it.\\n            });\\n    \\n    //Return the max branch Sum\\n    return max({ leftBS , rightBS , root->val });\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    int ans = INT_MIN;\\n    maxSum(root, ans);\\n    return ans;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```\n```\\n```\n```\\n```\n```\\nvar maxPathSum = function(root) {\\n  var max = -Number.MAX_VALUE;\\n  getMaxSum(root);\\n  return max;\\n  function getMaxSum(node) {\\n    if (!node) return 0;\\n    var leftSum = getMaxSum(node.left);\\n    var rightSum = getMaxSum(node.right);\\n    max = Math.max(max, node.val + leftSum + rightSum);\\n    return Math.max(0, node.val + leftSum, node.val + rightSum);\\n  }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?) = postorder(root).maxSum\\n\\n    private fun postorder(node: TreeNode?): Res {\\n        if (node == null)\\n            return Res(Int.MIN_VALUE, 0)\\n\\n        val (leftMaxSum, leftPathSum) = postorder(node.left)\\n        val (rightMaxSum, rightPathSum) = postorder(node.right)\\n\\n        val value = node.`val`\\n        val sum = leftPathSum + rightPathSum + value\\n\\n        return Res(maxOf(leftMaxSum, rightMaxSum, sum), maxOf(0, value + maxOf(leftPathSum, rightPathSum)))\\n    }\\n\\n    private data class Res(val maxSum: Int, val pathSum: Int)\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329033,
                "title": "python-bottom-up-dfs-solution",
                "content": "Please see and vote for my solutions for these similar problems.\\n[250. Count Univalue Subtrees](https://leetcode.com/problems/count-univalue-subtrees/discuss/329039/Python-bottom-up-DFS-solution)\\n[508. Most Frequent Subtree Sum](https://leetcode.com/problems/most-frequent-subtree-sum/discuss/329045/Python-bottom-up-DFS)\\n[543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/discuss/329022/Python-DFS-solution%3A-return-values-and-update-global-result-from-bottom-to-top)\\n[1245. Tree Diameter](https://leetcode.com/problems/tree-diameter/discuss/418906/Python-bottom-up-DFS-solution-(similar-problems-listed))\\n[687. Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/discuss/329031/Python-bottom-up-DFS-solution)\\n[124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/329033/Python-bottom-up-DFS-solution)\\n[Max Path Sum in a Grid](https://leetcode.com/discuss/interview-question/391278/google-phone-screen-maximal-path-sum/351744)\\n[298. Binary Tree Longest Consecutive Sequence](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/discuss/389208/Python-bottom-up-DFS-solution)\\n[549. Binary Tree Longest Consecutive Sequence II](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/discuss/389210/Python-bottom-up-DFS-solution-(56-ms-beat-93.37))\\n\\nA path may or may not pass through the root.\\nAll paths = {all paths passing through a node and its desendants | for each node in tree}.\\nBottom-up DFS: from bottom to top,\\nfind the maximum-sum path passing through a node and its desendants,\\nupdate the global maximum sum.\\n```\\n    def maxPathSum(self, root):\\n        def maxSum(root):\\n            if not root:\\n                return 0\\n            l_sum = maxSum(root.left)\\n            r_sum = maxSum(root.right)\\n            l = max(0, l_sum)\\n            r = max(0, r_sum)\\n            res[0] = max(res[0], root.val + l + r)\\n            return root.val + max(l, r)\\n        \\n        res = [-float(\\'inf\\')]\\n        maxSum(root)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxPathSum(self, root):\\n        def maxSum(root):\\n            if not root:\\n                return 0\\n            l_sum = maxSum(root.left)\\n            r_sum = maxSum(root.right)\\n            l = max(0, l_sum)\\n            r = max(0, r_sum)\\n            res[0] = max(res[0], root.val + l + r)\\n            return root.val + max(l, r)\\n        \\n        res = [-float(\\'inf\\')]\\n        maxSum(root)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 278525,
                "title": "python-iterative-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    \\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        res = float(\\'-inf\\')\\n        stack, last, d = [], None, defaultdict(int)\\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            node = stack[-1]        \\n            if node.right and last != node.right:\\n                root = node.right\\n            else:\\n                # Consume the node\\n                node = stack.pop()\\n                last = node\\n                d[node] = max(max(d[node.left], d[node.right]) + node.val, 0)\\n                res = max(res, d[node.left] + d[node.right] + node.val)\\n                \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    \\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        res = float(\\'-inf\\')\\n        stack, last, d = [], None, defaultdict(int)\\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            node = stack[-1]        \\n            if node.right and last != node.right:\\n                root = node.right\\n            else:\\n                # Consume the node\\n                node = stack.pop()\\n                last = node\\n                d[node] = max(max(d[node.left], d[node.right]) + node.val, 0)\\n                res = max(res, d[node.left] + d[node.right] + node.val)\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 602827,
                "title": "python-recursive-clean-beat-99",
                "content": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max = float(\\'-inf\\')\\n        def get_sum(root):\\n            if root is None:\\n                return 0\\n            else:\\n                ls = max(get_sum(root.left), 0)\\n                rs = max(get_sum(root.right), 0)\\n                self.max = max(self.max, ls + rs + root.val)\\n                return max(ls, rs, 0) + root.val\\n        \\n        get_sum(root)\\n        return self.max",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max = float(\\'-inf\\')\\n        def get_sum(root):\\n            if root is None:\\n                return 0\\n            else:\\n                ls = max(get_sum(root.left), 0)\\n                rs = max(get_sum(root.right), 0)\\n                self.max = max(self.max, ls + rs + root.val)\\n                return max(ls, rs, 0) + root.val\\n        \\n        get_sum(root)\\n        return self.max",
                "codeTag": "Java"
            },
            {
                "id": 39933,
                "title": "accepted-o-n-solution",
                "content": "The idea is based on the solution of max sum of a sequence array, Here is the explaination of the code:\\n\\n - Have a recursive method which traverse the binary tree, it also\\n   return the max possible sum of left branch and right branch\\n   saperately. for example, For node A, when it's left and right node\\n   recusive call returned, we will know the max possible sum of left\\n   branch, right branch.\\n   \\n - Have a CheckMax function which will compare the sequence sum and\\n   record the max history. For node A, check whether left branch + this \\n   node + right branch is the maximum, check whether left branch + this \\n   node is max\\uff0c check whether right branch + this node is max.\\n - When recursive method return, we should only return the max sum of one path - either the left branch + this node, or the right branch +\\n   this node. So that this is still a single path and can be used to\\n   link by node A's parent node.\\n\\nIt's accepted by OL. Let me know if you have any question\\n\\n    class Solution {\\n        public:\\n            int maxPathSum(TreeNode *root) {\\n                if(!root) return 0;\\n                maxSum = root->val;\\n                recNodes(root); \\n                return maxSum;\\n            }\\n        \\n        protected:\\n            int recNodes(TreeNode* node)\\n            {\\n                int numl=0,numr=0;\\n                if (node->left)\\n                    numl = recNodes(node->left);\\n                if (node->right)\\n                    numr = recNodes(node->right);\\n        \\n                //choose the max path, either left or right \\n                int value = node->val;\\n                int sumWhole = checkMax(value,numl+numr);\\n                int sumLeft = numl>0?checkMax(value,numl):value;\\n                int sumRight = numr>0?checkMax(value,numr):value;\\n        \\n                return max(sumLeft,sumRight);\\n            }\\n        \\n            int checkMax(int value, int sum)\\n            {\\n                if(sum>0)\\n                    sum+=value;\\n                else\\n                    sum=value;\\n                if(sum>maxSum)\\n                    maxSum = sum;\\n                return sum;\\n            }\\n        \\n            int maxSum;\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int maxPathSum(TreeNode *root) {\\n                if(!root) return 0;\\n                maxSum = root->val;\\n                recNodes(root); \\n                return maxSum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39871,
                "title": "sharing-a-simple-java-solution",
                "content": "\\n    int max = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    \\n    public int helper(TreeNode root) {\\n        if(root == null)\\n            return Integer.MIN_VALUE;\\n        int left = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        max = Math.max(max, root.val + left + right);\\n        return root.val + Math.max(left, right);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    int max = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    \\n    public int helper(TreeNode root) {\\n        if(root == null)\\n            return Integer.MIN_VALUE;\\n        int left = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        max = Math.max(max, root.val + left + right);\\n        return root.val + Math.max(left, right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39926,
                "title": "12-line-o-n-javascript-solution-with-176-ms-execution-time",
                "content": "    var maxPathSum = function(root) {\\n      var max = -Number.MAX_VALUE;\\n      getMaxSum(root);\\n      return max;\\n      function getMaxSum(node) {\\n        if (!node) return 0;\\n        var leftSum = getMaxSum(node.left);\\n        var rightSum = getMaxSum(node.right);\\n        max = Math.max(max, node.val + leftSum + rightSum);\\n        return Math.max(0, node.val + leftSum, node.val + rightSum);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var maxPathSum = function(root) {\\n      var max = -Number.MAX_VALUE;\\n      getMaxSum(root);\\n      return max;\\n      function getMaxSum(node) {\\n        if (!node) return 0;\\n        var leftSum = getMaxSum(node.left);\\n        var rightSum = getMaxSum(node.right);\\n        max = Math.max(max, node.val + leftSum + rightSum);\\n        return Math.max(0, node.val + leftSum, node.val + rightSum);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1242055,
                "title": "swift-binary-tree-maximum-path-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var maxSum = Int.min\\n        dfs(root, &maxSum)\\n        return maxSum\\n    }\\n    private func dfs(_ root: TreeNode?, _ maxSum: inout Int) -> Int {\\n        guard let root = root else { return 0 }\\n        let left = max(dfs(root.left, &maxSum), 0)\\n        let right = max(dfs(root.right, &maxSum), 0)\\n        maxSum = max(maxSum, (root.val + left + right))\\n        return root.val + max(left, right)\\n    }\\n}\\n```\\n<hr>\\n\\n##### Test Cases\\n\\n```swift\\nimport XCTest\\n\\n//      Executed 2 tests, with 0 failures (0 unexpected) in 0.387 (0.389) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let tree = TreeNode([1,2,3])\\n        XCTAssertEqual(s.maxPathSum(tree), 6)\\n    }\\n    func test2() {\\n        let tree = TreeNode([-10,9,20,nil,nil,15,7])\\n        XCTAssertEqual(s.maxPathSum(tree), 42)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n<hr>\\n\\n##### TreeNode class\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    \\n    // Additional initializer\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var maxSum = Int.min\\n        dfs(root, &maxSum)\\n        return maxSum\\n    }\\n    private func dfs(_ root: TreeNode?, _ maxSum: inout Int) -> Int {\\n        guard let root = root else { return 0 }\\n        let left = max(dfs(root.left, &maxSum), 0)\\n        let right = max(dfs(root.right, &maxSum), 0)\\n        maxSum = max(maxSum, (root.val + left + right))\\n        return root.val + max(left, right)\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n//      Executed 2 tests, with 0 failures (0 unexpected) in 0.387 (0.389) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let tree = TreeNode([1,2,3])\\n        XCTAssertEqual(s.maxPathSum(tree), 6)\\n    }\\n    func test2() {\\n        let tree = TreeNode([-10,9,20,nil,nil,15,7])\\n        XCTAssertEqual(s.maxPathSum(tree), 42)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    \\n    // Additional initializer\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271697,
                "title": "java-1ms-solution-with-highly-detailed-explanation",
                "content": "Intuitively, we can use recursive method to solve the problem. In order to get the max path sum, we must consider every node in the tree. \\nThe final path must consist of three parts: one node as root (necessary), an **Up To Down Path** originated from its left child (optional)  and an **Up To Down Path** originated from its right child (optional). Here, the **Up to Down Path denotes a sub path originated from a node to its leaf.**\\nWe use ```leftMax``` to denote the max up to down path sum originated from the left child of a node and ```rightMax``` to denote the max up to down path sum originated from the right child of a node. Then the **max path sum** of a node ```n``` is ```n.val + Math.max(leftMax, 0) + Math.max(rightMax, 0)```. Apparently, if ```leftMax``` or ```rightMax``` is no greater than zero, then we don\\'t need them and that\\'s why they are optional. \\nAfter processing a node, we return its **max up to down path sum (not max path sum)**, i.e., ```n.val + Math.max(Math.max(leftMax, 0), Math.max(rightMax, 0))```. \\nAs we can see, the key point of this problem is processing current node to get **max path sum** while returning **max up to down path sum** after processing the node. It is an important idea for solving complex tree problems: processing a problem and return the result of another problem.\\n```\\nint result = Integer.MIN_VALUE;\\n    \\npublic int maxSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\tint leftMax = Math.max(0, maxSum(root.left));\\n\\tint rightMax = Math.max(0, maxSum(root.right));\\n\\tresult = Math.max(result, root.val + leftMax + rightMax);\\n\\treturn root.val + Math.max(leftMax, rightMax);\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tmaxSum(root);\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```leftMax```\n```rightMax```\n```n```\n```n.val + Math.max(leftMax, 0) + Math.max(rightMax, 0)```\n```leftMax```\n```rightMax```\n```n.val + Math.max(Math.max(leftMax, 0), Math.max(rightMax, 0))```\n```\\nint result = Integer.MIN_VALUE;\\n    \\npublic int maxSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\tint leftMax = Math.max(0, maxSum(root.left));\\n\\tint rightMax = Math.max(0, maxSum(root.right));\\n\\tresult = Math.max(result, root.val + leftMax + rightMax);\\n\\treturn root.val + Math.max(leftMax, rightMax);\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tmaxSum(root);\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39913,
                "title": "clean-c-solution",
                "content": "    class Solution {\\n        int res;\\n    public:\\n        int depth(TreeNode *root){\\n            if(root==NULL) return 0;\\n            int a=depth(root->left), b=depth(root->right);\\n            res=max(res,a+b+root->val);//if *root is the top node in the path\\n            return max(0,max(a, b)+root->val);//if *root is in the path, if this branch a burden or a plus\\n        }\\n        int maxPathSum(TreeNode *root) {\\n            if(root==NULL) return 0;\\n            res=root->val;\\n            depth(root);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        int res;\\n    public:\\n        int depth(TreeNode *root){\\n            if(root==NULL) return 0;\\n            int a=depth(root->left), b=depth(root->right);\\n            res=max(res,a+b+root->val);//if *root is the top node in the path\\n            return max(0,max(a, b)+root->val);//if *root is in the path, if this branch a burden or a plus\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1481368,
                "title": "java-dfs-explained-faster-than-100-ttt",
                "content": "**This problem needs a bit of thinking**\\nThe key to solving this problem is to break the problem into 2 smaller and simpler sub-parts\\n\\nWe are asked to find out the path with the largest sum. **So, two cases can arise**\\n1. **Case 1** : the present node is included in the largest sum path. If so, it is obvious that the largest sum path will either pass through the left subtree or the right subtree or it might terminate here. *If the larget sum path has to terminate at the current node then it must not include any subtree contribution. Here, it is imp to understand that if the subtrees have a negative contribution then we MUST not add it to our path because if we add anyhting negative, the final value will be even lesser. *\\nExample: If the root val is -2 and the left subtree can generate a max sum of -1 and the right tree can generate -7. If we add either of these values the ultimate result will be lesser that -2. Hence, we WILL ADD ONLY POSITIVE VALUES \\n\\n2. **Case 2 :** the present node need not be included in the path to get the greatest path sum. So, we need to update the max result at every dfs call and we wil see how in the code\\n\\nNow, that we have segmented the question, let\\'s see the code\\n```\\nclass Solution {\\n    int res = Integer.MIN_VALUE; \\n    //this variable will be used to store the result after each possible path and hence will finally store the max  path sum\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null)return res;\\n        dfs(root);      //this will update the value or res as required\\n        return res;\\n    }\\n    public int dfs(TreeNode root){\\n        if(root == null)return 0;   //base case and very imp\\n        \\n        //at any node we want to find the left and right side max Sum\\n        int left = Math.max(dfs(root.left), 0);\\n        int right = Math.max(dfs(root.right), 0);\\n        // we are finding the max with 0 as we do not want to include any subtree with negative contributiuon. See explaination above\\n        \\n\\t\\t\\n\\t\\t//left here is storing the max possible contribution of the left subtree \\n\\t\\t//right here is storing the max possible contribution of right subtree\\n\\t\\t//if either of left and rigth have a possitive contribution(value), the larger will finally be taken \\n\\t\\t\\n\\t\\t//but first we will have to assume that the subtree with root node as root(the variable in this function) will have the largest sum path, so we will inlude this in our res if it has a value larger than previous res\\n        res = Math.max(res, root.val+left + right);\\n\\t\\t\\n\\t\\t\\n\\t\\t//the function however is expected to return the contribution of the current subtree if the subtree was include as in case 1 explained above. It it was terminating here, left and right would have value 0\\n\\t\\t//so we simply return the sum of the root val and the larger between left and rigth subtree sum\\n        return root.val + Math.max(left, right);\\n    \\n    }\\n} //do upvote if this helps\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE; \\n    //this variable will be used to store the result after each possible path and hence will finally store the max  path sum\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null)return res;\\n        dfs(root);      //this will update the value or res as required\\n        return res;\\n    }\\n    public int dfs(TreeNode root){\\n        if(root == null)return 0;   //base case and very imp\\n        \\n        //at any node we want to find the left and right side max Sum\\n        int left = Math.max(dfs(root.left), 0);\\n        int right = Math.max(dfs(root.right), 0);\\n        // we are finding the max with 0 as we do not want to include any subtree with negative contributiuon. See explaination above\\n        \\n\\t\\t\\n\\t\\t//left here is storing the max possible contribution of the left subtree \\n\\t\\t//right here is storing the max possible contribution of right subtree\\n\\t\\t//if either of left and rigth have a possitive contribution(value), the larger will finally be taken \\n\\t\\t\\n\\t\\t//but first we will have to assume that the subtree with root node as root(the variable in this function) will have the largest sum path, so we will inlude this in our res if it has a value larger than previous res\\n        res = Math.max(res, root.val+left + right);\\n\\t\\t\\n\\t\\t\\n\\t\\t//the function however is expected to return the contribution of the current subtree if the subtree was include as in case 1 explained above. It it was terminating here, left and right would have value 0\\n\\t\\t//so we simply return the sum of the root val and the larger between left and rigth subtree sum\\n        return root.val + Math.max(left, right);\\n    \\n    }\\n} //do upvote if this helps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39885,
                "title": "c-very-concise-recursive-solution",
                "content": "    int maxSum;\\n    int maxPathSum(TreeNode* root) {\\n        maxSum = INT_MIN;\\n        dfs(root);\\n        return maxSum;\\n    }\\n    // post order\\n    int dfs(TreeNode *root) {\\n        if (!root) return 0;\\n         int l = dfs(root->left);\\n         int r = dfs(root->right);\\n         maxSum = max(maxSum, root->val + (l > 0 ? l : 0) + (r > 0 ? r : 0));\\n         return (max(l, r) > 0 ? max(l, r) : 0) + root->val;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    int maxSum;\\n    int maxPathSum(TreeNode* root) {\\n        maxSum = INT_MIN;\\n        dfs(root);\\n        return maxSum;\\n    }\\n    // post order\\n    int dfs(TreeNode *root) {\\n        if (!root) return 0;\\n         int l = dfs(root->left);\\n         int r = dfs(root->right);\\n         maxSum = max(maxSum, root->val + (l > 0 ? l : 0) + (r > 0 ? r : 0));\\n         return (max(l, r) > 0 ? max(l, r) : 0) + root->val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39888,
                "title": "a-recursive-solution-with-comment",
                "content": "        \\n        // global max\\n        int max = Integer.MIN_VALUE;\\n\\n        public int maxPathSum(TreeNode root) {\\n            dfs(root);\\n            return max;\\n        }\\n        \\n        private int dfs(TreeNode root) {\\n            if (root == null) return 0;\\n            // 2 possible choices\\n            // 1.Already calculated in left or right child\\n            // 2.left max path + right max path + root\\n            int lMax = dfs(root.left);\\n            int rMax = dfs(root.right);\\n            if (lMax + rMax + root.val > max) max = lMax + rMax + root.val;\\n            // if the below path is negative, just make it 0 so that we could 'ignore' it\\n            return Math.max(0, root.val + Math.max(lMax, rMax));\\n        }",
                "solutionTags": [],
                "code": "        \\n        // global max\\n        int max = Integer.MIN_VALUE;\\n\\n        public int maxPathSum(TreeNode root) {\\n            dfs(root);\\n            return max;\\n        }\\n        \\n        private int dfs(TreeNode root) {\\n            if (root == null) return 0;\\n            // 2 possible choices\\n            // 1.Already calculated in left or right child\\n            // 2.left max path + right max path + root\\n            int lMax = dfs(root.left);\\n            int rMax = dfs(root.right);\\n            if (lMax + rMax + root.val > max) max = lMax + rMax + root.val;\\n            // if the below path is negative, just make it 0 so that we could 'ignore' it\\n            return Math.max(0, root.val + Math.max(lMax, rMax));\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1935332,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167952,
                "title": "clean-python-solution-o-n",
                "content": "Bottom up divider and conquer\\nAt each rode, it can form 3 tyes of path. \\n1st is node \\n2nd is left - node - right\\n3rd is left/right - node\\nOnce we get the max after comparsion, we return 1st or 3rd path sum to the upper level.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    res = -float(\\'inf\\')\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, root):\\n        if root == None:\\n            return 0\\n        leftMax = self.helper(root.left)\\n        rightMax = self.helper(root.right)\\n        tempPath = root.val + leftMax + rightMax\\n        sum = root.val + max(leftMax, rightMax, 0)\\n        self.res = max(sum, tempPath, self.res)\\n        return sum\\n",
                "solutionTags": [],
                "code": "Bottom up divider and conquer\\nAt each rode, it can form 3 tyes of path. \\n1st is node \\n2nd is left - node - right\\n3rd is left/right - node\\nOnce we get the max after comparsion, we return 1st or 3rd path sum to the upper level.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    res = -float(\\'inf\\')\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, root):\\n        if root == None:\\n            return 0\\n        leftMax = self.helper(root.left)\\n        rightMax = self.helper(root.right)\\n        tempPath = root.val + leftMax + rightMax\\n        sum = root.val + max(leftMax, rightMax, 0)\\n        self.res = max(sum, tempPath, self.res)\\n        return sum\\n",
                "codeTag": "Java"
            },
            {
                "id": 39810,
                "title": "12-lines-of-python-code-fast-and-easy-to-understand",
                "content": "    class Solution(object):\\n        def maxPathSum(self, root):\\n            def dfs(node):  # returns: max one side path sum, max path sum\\n                l = r = 0\\n                ls = rs = None\\n                if node.left:\\n                    l, ls = dfs(node.left)\\n                    l = max(l, 0)\\n                if node.right:\\n                    r, rs = dfs(node.right)\\n                    r = max(r, 0)\\n                return node.val + max(l, r), max(node.val + l + r, ls, rs)\\n            if root:\\n                return dfs(root)[1]\\n            return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def maxPathSum(self, root):\\n            def dfs(node):  # returns: max one side path sum, max path sum\\n                l = r = 0\\n                ls = rs = None\\n                if node.left:\\n                    l, ls = dfs(node.left)\\n                    l = max(l, 0)\\n                if node.right:\\n                    r, rs = dfs(node.right)\\n                    r = max(r, 0)\\n                return node.val + max(l, r), max(node.val + l + r, ls, rs)\\n            if root:\\n                return dfs(root)[1]\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 2899997,
                "title": "c-dfs-subtree-sum-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subTreesum(TreeNode* root,int& mx)\\n    {\\n        if(root==NULL) return 0;\\n\\n        // we are using max function over here because as we know node can be negative , and we also know that when we take negatuve nodes\\n        // then they will reduce our path cost but we need to maximize it as much as possible\\n        // so whenever we got negative node then just take 0 instead of negative value\\n        int l = max(0,subTreesum(root->left,mx));\\n        int r = max(0,subTreesum(root->right,mx));\\n\\n        int curr = root->val+l+r;                             // curr node + left node + right node (path sum for curr node)\\n        cout<<curr<<\" \";\\n\\n        mx = max(mx,curr);                                    // took max out of all\\n\\n        return root->val+max(l,r);                            // max(l,r) means we will chose one path that will gave max path sum to us\\n    }\\n    int maxPathSum(TreeNode* root) \\n    {\\n        int mx = INT_MIN;\\n        subTreesum(root,mx);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subTreesum(TreeNode* root,int& mx)\\n    {\\n        if(root==NULL) return 0;\\n\\n        // we are using max function over here because as we know node can be negative , and we also know that when we take negatuve nodes\\n        // then they will reduce our path cost but we need to maximize it as much as possible\\n        // so whenever we got negative node then just take 0 instead of negative value\\n        int l = max(0,subTreesum(root->left,mx));\\n        int r = max(0,subTreesum(root->right,mx));\\n\\n        int curr = root->val+l+r;                             // curr node + left node + right node (path sum for curr node)\\n        cout<<curr<<\" \";\\n\\n        mx = max(mx,curr);                                    // took max out of all\\n\\n        return root->val+max(l,r);                            // max(l,r) means we will chose one path that will gave max path sum to us\\n    }\\n    int maxPathSum(TreeNode* root) \\n    {\\n        int mx = INT_MIN;\\n        subTreesum(root,mx);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2632175,
                "title": "100-fastest-solution-with-explain-best-approach-easy-to-understand",
                "content": "**Read the below approach with dry run to understand the logic.**\\n\\n***Please upvote if you like it!!!!***\\n\\n**Approach:** \\n* A brute force approach would be to generate all paths and compare them. Generating all paths will be a time-costly activity therefore we need to look for something else.\\n\\n* We first need to define what is the maximum path sum through a given node (when that node is acting as the root node/curving point). At a given node with a value, if we find the max leftSumPath in the left-subtree and the max rightSumPath in the right subtree, then the maxPathSum through that node is value+(leftSumPath+rightSumPath).\\n\\n![image](https://assets.leetcode.com/users/images/8908909f-7acc-47b8-a570-2d6228fbd324_1664308086.3526118.png)\\n\\n* Now we can apply this formula at every node by doing a simple tree traversal and storing the maximum value (our answer) in a reference variable.\\n\\n* For our recursion to work, it is very important to understand what value we return from our function. In our recursive function, we find and compare the maxPathSum from a given node when it is the root/turning point of the path. But what we return is the maxPathSum of that same node when it is NOT the root/turning point of the path. To find the latter maxPath, we no longer have the liberty to consider both leftMaxPath and rightMaxPath, we will simply take the maximum of the two and it to the value of the node.\\n\\n![image](https://assets.leetcode.com/users/images/b1e861d5-d848-4f93-81d6-98aa8d162c6a_1664308132.2479436.png)\\n\\n**To summarize:**\\n\\n* Initialize a maxi variable to store our final answer.\\n* Do a simple tree traversal. At each node, find  recursively its leftMaxPath and its rightMaxPath.\\n* Calculate the maxPath through the node as val + (leftMaxPath + rightMaxPath) and update maxi accordingly.\\n* Return the maxPath when node is not the curving point as val + max(leftMaxPath, rightMaxPath).\\n\\n**Paper dry run:**\\n\\n![image](https://assets.leetcode.com/users/images/353e17b5-20b5-47f9-a434-ad2e83a01d7e_1664308186.004981.jpeg)\\n\\n**~Time Complexity: O(N).**\\n* **Reason:** We are doing a tree traversal.\\n\\n**~Space Complexity: O(N)**\\n* **Reason:** Space is needed for the recursion stack. In the worst case (skewed tree), space complexity can be O(N).\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int& mx){\\n        if(!root) return 0;\\n        \\n        int left=max(0,solve(root->left,mx));\\n        int right=max(0,solve(root->right,mx));\\n        int currVal=root->val;\\n        \\n        mx=max(mx,left+right+currVal);\\n        return max(left,right)+currVal;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int mx=INT_MIN;\\n        solve(root,mx);\\n        return mx;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int& mx){\\n        if(!root) return 0;\\n        \\n        int left=max(0,solve(root->left,mx));\\n        int right=max(0,solve(root->right,mx));\\n        int currVal=root->val;\\n        \\n        mx=max(mx,left+right+currVal);\\n        return max(left,right)+currVal;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int mx=INT_MIN;\\n        solve(root,mx);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295418,
                "title": "java-solution-with-explanation",
                "content": "**Idea**\\nThe main part of the logic is same as https://leetcode.com/problems/maximum-subarray/description/\\nThree key points here. \\n1. Since the path doesn\\'t need to go through the root node, we need to try all nodes.\\n2. At the current node, let us say you have maxPathSum **from** the left node and maxPathSum **from** the right node, we can easily check what is the `max` so far. It should be either of those or the path connecting both.\\n3. We should return \"max path sum ending here\" to the caller, this will be either extending the path on left or right or just returning `curr` node.\\n\\nFurther explanation https://leetcode.com/problems/longest-univalue-path/discuss/130315/Java-Solution-With-Explanation\\n\\n---\\n\\n```\\nclass Solution {\\n    int max = -Integer.MAX_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    private Integer helper(TreeNode curr){\\n        if(curr == null) return null;\\n        Integer l = helper(curr.left), r = helper(curr.right);\\n        int maxEndingHere = curr.val;\\n        if(l != null && r != null){\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n            max = Math.max(max, l+r+curr.val);\\n        }else if(l != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n        else if(r != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n        max = Math.max(max, maxEndingHere);\\n        return maxEndingHere;\\n    }\\n}\\n```\\n\\nShorter version of the same idea\\n```\\nclass Solution {\\n    int maxSumSoFar = -1001;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxSumSoFar;\\n    }\\n    \\n    private int helper(TreeNode curr){\\n        if(curr == null) return -1001;\\n        int l = helper(curr.left);\\n        int maxEndHere = Math.max(l+curr.val, curr.val);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        int r = helper(curr.right);\\n        maxEndHere = Math.max(r+curr.val, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, l+r+curr.val);\\n        \\n        return maxEndHere;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = -Integer.MAX_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    private Integer helper(TreeNode curr){\\n        if(curr == null) return null;\\n        Integer l = helper(curr.left), r = helper(curr.right);\\n        int maxEndingHere = curr.val;\\n        if(l != null && r != null){\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n            max = Math.max(max, l+r+curr.val);\\n        }else if(l != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n        else if(r != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n        max = Math.max(max, maxEndingHere);\\n        return maxEndingHere;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int maxSumSoFar = -1001;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxSumSoFar;\\n    }\\n    \\n    private int helper(TreeNode curr){\\n        if(curr == null) return -1001;\\n        int l = helper(curr.left);\\n        int maxEndHere = Math.max(l+curr.val, curr.val);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        int r = helper(curr.right);\\n        maxEndHere = Math.max(r+curr.val, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, l+r+curr.val);\\n        \\n        return maxEndHere;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39943,
                "title": "java-accepted-solution-with-post-order-traversal",
                "content": "Short Java solution involving a postorder visit of the tree. Complexity is O(n).\\n\\n\\n    public class Solution {\\n        \\n        int max;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            \\n            if(root==null) return 0;\\n            \\n            //still check the result of the \"root subtree\"\\n            max = root.val;\\n            int tmp = visit(root);\\n            if(tmp > max) max = tmp;\\n            \\n            return max;\\n            \\n        }\\n        \\n        //recursive visit\\n        private int visit(TreeNode current){\\n        \\n            if(current==null) return 0;\\n        \\n            int l = visit(current.left);\\n            int r = visit(current.right);\\n            \\n            if(l<0) l=0;\\n            if(r<0) r=0;\\n            \\n            //check if current subtree is better than max\\n            int tmp = l+r+current.val;\\n            if(tmp>max) max = tmp;\\n            \\n            //return the best of the two ways to go down\\n            //if coming from top, cannot go both left and right\\n            //same if we come from down and want to go up, cannot go down again through other child\\n            if(l>r) {return l+current.val;}\\n            else {return r+current.val;}\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        \\n        int max;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            \\n            if(root==null) return 0;\\n            \\n            //still check the result of the \"root subtree\"\\n            max = root.val;\\n            int tmp = visit(root);\\n            if(tmp > max) max = tmp;\\n            \\n            return max;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2899158,
                "title": "python-c-compute-left-right-partial-sums-with-dfs-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Depth First Search* approach to traverse the tree in order to compute left and right partial path sums for each node. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Python.**\\n```\\nclass Solution:\\n    def maxPathSum(self, root, s = -inf) -> int:\\n        \\n        def dfs(n):                    # this recursive function \\n            nonlocal s                 # computes best partial path\\n            if not n : return 0        # sum starting from node \\'n\\':\\n            l = max(0, dfs(n.left))    # [1] compute left and right\\n            r = max(0, dfs(n.right))   #     partial path sums\\n            s = max(s, l + r + n.val)  # [2] compute full path sum\\n            return n.val + max(l, r)   # [3] choose best partial sum\\n\\n        dfs(root)\\n        return s\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    int maxPathSum(TreeNode* root, int s = INT_MIN) \\n    {\\n        function<int(TreeNode*)> dfs;\\n        dfs = [&](TreeNode* n) -> int\\n        {\\n            if (!n) return 0;\\n            int l = max(0, dfs(n->left));\\n            int r = max(0, dfs(n->right));\\n            s = max(s, l + r + n->val);\\n            return n->val + max(l, r);\\n        };\\n        \\n        dfs(root);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root, s = -inf) -> int:\\n        \\n        def dfs(n):                    # this recursive function \\n            nonlocal s                 # computes best partial path\\n            if not n : return 0        # sum starting from node \\'n\\':\\n            l = max(0, dfs(n.left))    # [1] compute left and right\\n            r = max(0, dfs(n.right))   #     partial path sums\\n            s = max(s, l + r + n.val)  # [2] compute full path sum\\n            return n.val + max(l, r)   # [3] choose best partial sum\\n\\n        dfs(root)\\n        return s\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int maxPathSum(TreeNode* root, int s = INT_MIN) \\n    {\\n        function<int(TreeNode*)> dfs;\\n        dfs = [&](TreeNode* n) -> int\\n        {\\n            if (!n) return 0;\\n            int l = max(0, dfs(n->left));\\n            int r = max(0, dfs(n->right));\\n            s = max(s, l + r + n->val);\\n            return n->val + max(l, r);\\n        };\\n        \\n        dfs(root);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776579,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    int maxi = INT_MIN;\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        depth(root);\\n        return maxi;\\n    }\\n    \\n    int depth(TreeNode* root){\\n        if(root == NULL) return 0;\\n        \\n        int lh = max(0,depth(root->left));\\n        int rh = max(0,depth(root->right));\\n        \\n        maxi = max(maxi , root->val + lh + rh);\\n        \\n        return root->val + max(lh,rh);\\n    }\\n};\\n```\\n\\nThought Process : \\n\\nFor any node in the Tree , we will consider the current node as the pivot point and add it\\'s left sub-tree and right sub-tree and the node itself. We will check this value with the maximum yet found and update if its larger.\\n\\nWhile backtracking we will set the node\\'s value = root->val + max(left-subtree sum , right-subtree sum) so that in case if parent nodes chose to take it we have the maximum possible sum present to the leaf node.\\n\\nIn case , we have negative values in the sub-trees or the path sum turns out to be negative ,  we will not include it in our path as we want maximum possible sum and mark the sum as 0 instead of -ve.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxi = INT_MIN;\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        depth(root);\\n        return maxi;\\n    }\\n    \\n    int depth(TreeNode* root){\\n        if(root == NULL) return 0;\\n        \\n        int lh = max(0,depth(root->left));\\n        int rh = max(0,depth(root->right));\\n        \\n        maxi = max(maxi , root->val + lh + rh);\\n        \\n        return root->val + max(lh,rh);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332780,
                "title": "recursive-javascript-solution-with-comments",
                "content": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function(root) {\\n  var max = -Infinity // Initialize to a very small number to handle a path of negative values\\n  getMaxSum(root) // Call our recursive fn to start the program\\n  \\n  return max // Once we have popped out of our recursive calls, `max` contains our maximum path sum\\n  \\n  function getMaxSum(tree) {\\n    if (tree == null) { return 0 } // Termination condition\\n    \\n    const leftBranch = Math.max(0, getMaxSum(tree.left)) // calculate the root to leaf sum where root is the left node\\n    const rightBranch = Math.max(0, getMaxSum(tree.right)) // calculate the root to leaf sum where root is the right node\\n    const currentPath = leftBranch + tree.val + rightBranch  // Sum the path: left -> root -> right (leaf to leaf)\\n    \\n    max = Math.max(max, currentPath) // if the current path is greater than the previous value of `max`, update `max` to the current path sum\\n    return tree.val + Math.max(leftBranch, rightBranch)\\n  }\\n};\\n```\\n\\n---\\n\\nI hope others find my code and comments helpful.  Please add feedback if there is an error in my thinking.",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function(root) {\\n  var max = -Infinity // Initialize to a very small number to handle a path of negative values\\n  getMaxSum(root) // Call our recursive fn to start the program\\n  \\n  return max // Once we have popped out of our recursive calls, `max` contains our maximum path sum\\n  \\n  function getMaxSum(tree) {\\n    if (tree == null) { return 0 } // Termination condition\\n    \\n    const leftBranch = Math.max(0, getMaxSum(tree.left)) // calculate the root to leaf sum where root is the left node\\n    const rightBranch = Math.max(0, getMaxSum(tree.right)) // calculate the root to leaf sum where root is the right node\\n    const currentPath = leftBranch + tree.val + rightBranch  // Sum the path: left -> root -> right (leaf to leaf)\\n    \\n    max = Math.max(max, currentPath) // if the current path is greater than the previous value of `max`, update `max` to the current path sum\\n    return tree.val + Math.max(leftBranch, rightBranch)\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209995,
                "title": "python-solution",
                "content": "Idea: Use DFS to compute for each node `v` the largest path sum ending with `v`. This can be done recursively using the formua `max_end_here = max(l_max, r_max)`, where `l_max = dfs(v.left)+v.val` if `dfs(v.left)` > 0, and `l_max = v.val` if `dfs(v.left) <= 0` (i.e., the left path ending with `v` that has the maximum sum consists of `v` only because the maximum path ending with `v.left` sums to a negative value). Similarly, `r_max = dfs(v.right)+v.val` if `dfs(v.right)` > 0, and `l_max = v.val` if `dfs(v.right) <= 0`. From `l_max` and `r_max`, we can compute the maximum path sum of a path that pass through `v` (not necessarily ending with `v`) by the formula `maximum = l_max+r_max-root.val`. We can then update the global variable `self.maximum = max(self.maximum, maximum)`, and return `max_end_here`. After running DFS from the root of the tree, `self.maximum` gives the desired maximum path sum.\\n\\nTime complexity: `O(n)`, space complexity: `O(h)`.\\n\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            l_max = dfs(root.left)\\n            r_max = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            self.maximum = max(self.maximum, l_max+r_max-root.val)\\n            return max(l_max, r_max)\\n           \\n        self.maximum = -float(\\'inf\\')\\n        dfs(root)\\n        return self.maximum \\n```\\nWith a slight modification, we can eliminate the need for the variable `self.maximum`.\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0, -float(\\'inf\\')\\n            l_max, res_l = dfs(root.left)\\n            r_max, res_r = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            maximum = l_max+r_max-root.val\\n            return max(l_max, r_max), max(maximum, res_l, res_r)\\n        \\n        res = dfs(root)[1]\\n        return res if res != -float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            l_max = dfs(root.left)\\n            r_max = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            self.maximum = max(self.maximum, l_max+r_max-root.val)\\n            return max(l_max, r_max)\\n           \\n        self.maximum = -float(\\'inf\\')\\n        dfs(root)\\n        return self.maximum \\n```\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0, -float(\\'inf\\')\\n            l_max, res_l = dfs(root.left)\\n            r_max, res_r = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            maximum = l_max+r_max-root.val\\n            return max(l_max, r_max), max(maximum, res_l, res_r)\\n        \\n        res = dfs(root)[1]\\n        return res if res != -float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39879,
                "title": "my-ac-java-recursive-solution",
                "content": "max1 is the max value of the current node to pass to the upper level node. \\n\\nmax is the global max value that could be max1 or the sum of root and left max and right max \\n\\n    public class Solution {\\n    \\n    int max=Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumR(root);\\n        return max;\\n    }\\n    \\n    public int maxPathSumR(TreeNode root) {\\n        \\n        if(root==null) return 0;\\n        int left=maxPathSumR(root.left);\\n        int right=maxPathSumR(root.right);\\n        \\n        int max1 = Math.max(root.val,Math.max(root.val+left,root.val+right));\\n        max = Math.max(max,Math.max(max1,left+right+root.val));\\n        return max1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int max=Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumR(root);\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3655975,
                "title": "easiest-c-code-2-easy-concepts-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int m=INT_MIN;\\n\\n    int find_max_sum(TreeNode* root){   //maxsum \\n        if(!root)\\n        return 0;\\n\\n        return root->val+max(0,max(find_max_sum(root->left),find_max_sum(root->right)));\\n    }\\n\\n    void solve(TreeNode* root){   //postorder\\n        if(root){\\n            solve(root->left);\\n            solve(root->right);\\n            int ls=find_max_sum(root->left);\\n            int rs=find_max_sum(root->right);\\n\\n            if(ls<0)\\n            ls=0;\\n            if(rs<0)\\n            rs=0;\\n\\n            m=max(ls+rs+root->val,m);\\n        }\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int m=INT_MIN;\\n\\n    int find_max_sum(TreeNode* root){   //maxsum \\n        if(!root)\\n        return 0;\\n\\n        return root->val+max(0,max(find_max_sum(root->left),find_max_sum(root->right)));\\n    }\\n\\n    void solve(TreeNode* root){   //postorder\\n        if(root){\\n            solve(root->left);\\n            solve(root->right);\\n            int ls=find_max_sum(root->left);\\n            int rs=find_max_sum(root->right);\\n\\n            if(ls<0)\\n            ls=0;\\n            if(rs<0)\\n            rs=0;\\n\\n            m=max(ls+rs+root->val,m);\\n        }\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763640,
                "title": "c-solution-easy-simple-code-comment-explaination",
                "content": "\\n\\n# Code\\n```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root,int &ans){\\n        // base case\\n        if(root == NULL){\\n            return 0;\\n        }\\n\\n        int left = max(0,solve(root->left,ans));\\n        int right = max(0,solve(root->right,ans));\\n\\n        int curr = root->val + left + right;\\n        ans = max(curr,ans);\\n\\n        return root->val + max(left,right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n\\n        return ans;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root,int &ans){\\n        // base case\\n        if(root == NULL){\\n            return 0;\\n        }\\n\\n        int left = max(0,solve(root->left,ans));\\n        int right = max(0,solve(root->right,ans));\\n\\n        int curr = root->val + left + right;\\n        ans = max(curr,ans);\\n\\n        return root->val + max(left,right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n\\n        return ans;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827780,
                "title": "java-0-ms-faster-than-100-00-short-and-simple",
                "content": "```\\nclass Solution {\\n    int maxPath = 0;\\n    public int maxPathSum(TreeNode root) {\\n        maxPath = root.val;\\n        getMax(root);\\n        return maxPath;\\n    }\\n    \\n    private int getMax(TreeNode root) {\\n        if (root==null) {\\n            return 0;\\n        }\\n        int leftMax = getMax(root.left);\\n        int rightMax = getMax(root.right);\\n        leftMax = Math.max(leftMax, 0);\\n        rightMax = Math.max(rightMax, 0);\\n        maxPath = Math.max(maxPath, root.val + leftMax + rightMax);\\n        return root.val + Math.max(leftMax, rightMax);\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution..!!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxPath = 0;\\n    public int maxPathSum(TreeNode root) {\\n        maxPath = root.val;\\n        getMax(root);\\n        return maxPath;\\n    }\\n    \\n    private int getMax(TreeNode root) {\\n        if (root==null) {\\n            return 0;\\n        }\\n        int leftMax = getMax(root.left);\\n        int rightMax = getMax(root.right);\\n        leftMax = Math.max(leftMax, 0);\\n        rightMax = Math.max(rightMax, 0);\\n        maxPath = Math.max(maxPath, root.val + leftMax + rightMax);\\n        return root.val + Math.max(leftMax, rightMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187845,
                "title": "java-100-short-simple",
                "content": "```\\n\\nclass Solution {\\n    int ans = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        recurse(root);\\n        return ans;\\n    }\\n    \\n    public int recurse(TreeNode root) {\\n\\t\\t//base case\\n        if(root == null) return 0;\\n\\t\\t//postorder\\n        int left = recurse(root.left); \\n        int right = recurse(root.right);\\n        \\n\\t\\t//anything that is negative will never help maximize the path , so lets ignore it\\n        if(left < 0) left = 0;\\n        if(right < 0) right = 0;\\n\\t\\t\\n\\t\\t//worst case - root is only considered , if left and right are negatives\\n        int sum = root.val + left + right;\\n\\t\\t//update global answer\\n        ans = Math.max(sum, ans);\\n\\t\\t//from here send to parent what is max (it will be either curr+leftMax or curr+rightMax , as path in one directional)\\n        return Math.max(left + root.val, right + root.val);\\n    }\\n}\\n```\\n\\nIf the approach helps, please up-vote for reach.",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int ans = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        recurse(root);\\n        return ans;\\n    }\\n    \\n    public int recurse(TreeNode root) {\\n\\t\\t//base case\\n        if(root == null) return 0;\\n\\t\\t//postorder\\n        int left = recurse(root.left); \\n        int right = recurse(root.right);\\n        \\n\\t\\t//anything that is negative will never help maximize the path , so lets ignore it\\n        if(left < 0) left = 0;\\n        if(right < 0) right = 0;\\n\\t\\t\\n\\t\\t//worst case - root is only considered , if left and right are negatives\\n        int sum = root.val + left + right;\\n\\t\\t//update global answer\\n        ans = Math.max(sum, ans);\\n\\t\\t//from here send to parent what is max (it will be either curr+leftMax or curr+rightMax , as path in one directional)\\n        return Math.max(left + root.val, right + root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602931,
                "title": "c-o-n-recursive-short-and-easy-to-understand-with-comment",
                "content": "```\\nclass Solution {\\n    int helper( TreeNode* node, int &maxSum ) {\\n        if( !node ) return 0;\\n        int left = 0, right = 0;\\n        if( node->left )  left = helper( node->left, maxSum );\\n        if( node->right ) right = helper( node->right, maxSum );\\n        \\n        // node+left or node+right or node\\n        int leftOrRightOrNode = max( node->val, node->val + max( left, right ) );\\n        // set maxSum to max of maxSum, node+left+right, node+left, node+right, node\\n        maxSum = max( maxSum, max( node->val + left + right, leftOrRightOrNode ) );        \\n        return leftOrRightOrNode;\\n    }\\n    \\npublic:\\n    int maxPathSum( TreeNode* root ) {\\n        int maxSum = INT_MIN;\\n        helper( root, maxSum );\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int helper( TreeNode* node, int &maxSum ) {\\n        if( !node ) return 0;\\n        int left = 0, right = 0;\\n        if( node->left )  left = helper( node->left, maxSum );\\n        if( node->right ) right = helper( node->right, maxSum );\\n        \\n        // node+left or node+right or node\\n        int leftOrRightOrNode = max( node->val, node->val + max( left, right ) );\\n        // set maxSum to max of maxSum, node+left+right, node+left, node+right, node\\n        maxSum = max( maxSum, max( node->val + left + right, leftOrRightOrNode ) );        \\n        return leftOrRightOrNode;\\n    }\\n    \\npublic:\\n    int maxPathSum( TreeNode* root ) {\\n        int maxSum = INT_MIN;\\n        helper( root, maxSum );\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577860,
                "title": "python-beats-89-49-basic-recursion-structure-w-algorithm-explanation",
                "content": "Idea:\\n\\nEvery single node in the original tree could be the \"root\" of the max path.\\nFor every one of these \"roots,\" you could add the stuff on the left, the stuff on the right, neither, or both to get the max path.\\n* What is this \"stuff\"? It\\'s the max path of the subtree created by following node.left or node.right.\\n\\nAt the end, we return the max of EITHER just the root, the root and the max path left subtree, or the root and the max path right subtree.\\n* Why not root and both left and right subtree? If the root ISN\\'T the actual root, it\\'ll be in either the left or right subtree of the actual root. Since we want a single path, the path can\\'t \"split\", so it needs to take exactly one \"road\", namely left or right.\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254281,
                "title": "javascript",
                "content": "```\\nvar maxPathSum = function(root) {\\n    let maxPathSumNum = -Infinity;\\n    \\n    const maxPathSumRec = function(node){\\n        if(!node){\\n            return 0;\\n        }\\n        \\n        let leftMax = Math.max(maxPathSumRec(node.left), 0);\\n        let rightMax = Math.max(maxPathSumRec(node.right), 0);\\n        maxPathSumNum = Math.max(maxPathSumNum, leftMax + rightMax + node.val);\\n        return Math.max(leftMax, rightMax) + node.val;\\n    };\\n    \\n    maxPathSumRec(root);\\n    return maxPathSumNum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxPathSum = function(root) {\\n    let maxPathSumNum = -Infinity;\\n    \\n    const maxPathSumRec = function(node){\\n        if(!node){\\n            return 0;\\n        }\\n        \\n        let leftMax = Math.max(maxPathSumRec(node.left), 0);\\n        let rightMax = Math.max(maxPathSumRec(node.right), 0);\\n        maxPathSumNum = Math.max(maxPathSumNum, leftMax + rightMax + node.val);\\n        return Math.max(leftMax, rightMax) + node.val;\\n    };\\n    \\n    maxPathSumRec(root);\\n    return maxPathSumNum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 232373,
                "title": "postorder-iterative-solution-python",
                "content": "The general idea is that we can go through the nodes in post order traversal and cache the maximum path from a node\\'s subtree to itself (the reason is that we can obtain the left_max_path and right_max_path in O(1) time).\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: \\'TreeNode\\') -> \\'int\\':\\n        def post_order(node):\\n            cur = node\\n            stack = []\\n            res = []\\n            while cur or stack:\\n                if cur:\\n                    stack.append(cur)\\n                    res.append(cur)\\n                    cur = cur.right\\n                else:\\n                    cur = stack.pop()\\n                    cur = cur.left\\n            return res[::-1]\\n        \\n        res = -float(\\'inf\\')\\n        nodes = post_order(root)\\n        path_until_node = {None: 0}\\n        for node in nodes:\\n            left_max_path = max(0, path_until_node[node.left])\\n            right_max_path = max(0, path_until_node[node.right])\\n            res = max(res, left_max_path + right_max_path + node.val)\\n            path_until_node[node] = max(left_max_path, right_max_path) + node.val\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: \\'TreeNode\\') -> \\'int\\':\\n        def post_order(node):\\n            cur = node\\n            stack = []\\n            res = []\\n            while cur or stack:\\n                if cur:\\n                    stack.append(cur)\\n                    res.append(cur)\\n                    cur = cur.right\\n                else:\\n                    cur = stack.pop()\\n                    cur = cur.left\\n            return res[::-1]\\n        \\n        res = -float(\\'inf\\')\\n        nodes = post_order(root)\\n        path_until_node = {None: 0}\\n        for node in nodes:\\n            left_max_path = max(0, path_until_node[node.left])\\n            right_max_path = max(0, path_until_node[node.right])\\n            res = max(res, left_max_path + right_max_path + node.val)\\n            path_until_node[node] = max(left_max_path, right_max_path) + node.val\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171807,
                "title": "python-dfs",
                "content": "# 124. Binary Tree Maximum Path Sum\\n[\\u6B64\\u9898\\u6536\\u5F55\\u5728Github](https://github.com/yuzhoujr/leetcode/issues/33)\\n\\n1. \\u5206\\u5236\\u5230\\u5E95\\u90E8\\uFF0C\\u5728\\u8FD4\\u56DE\\u7684\\u65F6\\u5019\\u4F20\\u5165\\u5DE6\\u53F3\\u4EFB\\u610F\\u4E00\\u904D\\u6700\\u5927\\u503C\\u52A0\\u4E0A\\u76EE\\u524D`root.val`:\\n`cur = max(left, right) + root.val`\\n\\u8FD9\\u79CD\\u60C5\\u51B5\\u5904\\u7406\\u4E86\\u4ECERoot\\u5230\\u5DE6\\u53F3\\u4EFB\\u610F\\u4E00\\u8FB9\\u7684\\u6700\\u5927\\u503C\\uFF0C\\u4E5F\\u5C31\\u662F `root.val + left` \\u548C `root.val + right`\\n2. \\u8FD8\\u6709\\u4E00\\u79CD\\u60C5\\u51B5\\u5C31\\u662F\\u5F53\\u6700\\u5927\\u503C = `root.val + left + right`\\uFF0C \\u6211\\u4EEC\\u5728\\u653E\\u5165global\\u53D8\\u91CF\\u7684\\u65F6\\u5019\\u4F55\\u5176\\u6BD4\\u8F83\\u3002\\n3. \\u5BF9\\u4E8E\\u6700\\u5E95\\u90E8\\u53F6\\u5B50\\u8282\\u70B9\\u4F20\\u4E0A\\u6765\\u7684\\u503C\\uFF0C\\u6211\\u4EEC\\u5C06\\u5176\\u8BBE\\u7F6E\\u62100: `return cur if cur > 0 else 0`\\n\\n```python\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.res = - float(\\'inf\\')\\n        self.dfs(root)\\n        return self.res\\n\\n    \\n    def dfs(self, root):\\n        if not root: return 0\\n        left = self.dfs(root.left)\\n        right = self.dfs(root.right)\\n        self.res = max(self.res, left + right + root.val)\\n        cur = max(left, right) + root.val\\n        return cur if cur > 0 else 0\\n```\\n<br>",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.res = - float(\\'inf\\')\\n        self.dfs(root)\\n        return self.res\\n\\n    \\n    def dfs(self, root):\\n        if not root: return 0\\n        left = self.dfs(root.left)\\n        right = self.dfs(root.right)\\n        self.res = max(self.res, left + right + root.val)\\n        cur = max(left, right) + root.val\\n        return cur if cur > 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39813,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Binary Tree Maximum Path Sum** https://leetcode.com/problems/binary-tree-maximum-path-sum/\\n\\n**Brute Force Solution: O(N^2)**\\n* Assume we have nodes numbered 1 to N\\n* sum(i) = Maximum sum of a path containing node(i). Clearly the solution of the problem is max(sum(1), sum(2), ...., sum(N))\\n* Now what is the maximum sum of a path containing a particular node(i)?\\n* lresult[0]: maximum path sum starting at node(i).left\\n* rresult[0]: maximum path sum starting at node(i).right\\n* sum(i) = max(lresult[0], 0) + max(rresult[0], 0) + node(i).val\\n* Why do we do max(lresult[0], 0)? sum(i) must contain node(i).val. We will add lresult[0] or rresult[0] only when they help increase sum(i). We will ignore lresult[0] or rresult[0] if they are negative.\\n* We use pre-order traversal to iterate over the nodes and compute sum(i) for each node(i).\\n* Time complexity for sum(i) is O(N). Total time complexity is O(N^2)\\n* Space complexity is O(N)\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.answer = float('-inf')\\n        self.helper(root)\\n        return self.answer\\n    \\n    def max_path_sum(self, root, so_far, result):\\n        if root is None:\\n            return\\n        result[0] = max(result[0], so_far + root.val)\\n        self.max_path_sum(root.left, so_far + root.val, result)\\n        self.max_path_sum(root.right, so_far + root.val, result)\\n        return\\n    \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return\\n        lresult, rresult = [float('-inf')], [float('-inf')]\\n        self.max_path_sum(root.left, 0, lresult) # Find maximum path sum starting from root.left\\n        self.max_path_sum(root.right, 0, rresult) # Find maximum path sum starting from root.right\\n        self.answer = max(max(lresult[0], 0) + max(rresult[0], 0) + root.val, self.answer)\\n        self.helper(root.left)\\n        self.helper(root.right)        \\n        return\\n```\\n**Bottom Up Optimized Solution: O(N)**\\n* Bottom up template uses post-order traversal and usually returns two items. To visualize this algorithm, always start with bottom up picture returning 1 or 2 values\\n* In this algorithm, we can use post-order traversal and return the maximum sum in the subtree starting from the root. \\n* We call it lresult and rresult for left and right subtree\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max_so_far = float('-inf')\\n        self.helper(root) # Maximum sum starting from root\\n        return self.max_so_far\\n        \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        lresult = self.helper(root.left) # Maximum sum starting from root.left\\n        rresult = self.helper(root.right) # Maximum sum starting from root.left\\n        self.max_so_far = max(max(lresult, 0) + max(rresult, 0) + root.val, self.max_so_far)\\n        return max(lresult, rresult, 0) + root.val # Return maximum sum starting from root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.answer = float('-inf')\\n        self.helper(root)\\n        return self.answer\\n    \\n    def max_path_sum(self, root, so_far, result):\\n        if root is None:\\n            return\\n        result[0] = max(result[0], so_far + root.val)\\n        self.max_path_sum(root.left, so_far + root.val, result)\\n        self.max_path_sum(root.right, so_far + root.val, result)\\n        return\\n    \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return\\n        lresult, rresult = [float('-inf')], [float('-inf')]\\n        self.max_path_sum(root.left, 0, lresult) # Find maximum path sum starting from root.left\\n        self.max_path_sum(root.right, 0, rresult) # Find maximum path sum starting from root.right\\n        self.answer = max(max(lresult[0], 0) + max(rresult[0], 0) + root.val, self.answer)\\n        self.helper(root.left)\\n        self.helper(root.right)        \\n        return\\n```\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max_so_far = float('-inf')\\n        self.helper(root) # Maximum sum starting from root\\n        return self.max_so_far\\n        \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        lresult = self.helper(root.left) # Maximum sum starting from root.left\\n        rresult = self.helper(root.right) # Maximum sum starting from root.left\\n        self.max_so_far = max(max(lresult, 0) + max(rresult, 0) + root.val, self.max_so_far)\\n        return max(lresult, rresult, 0) + root.val # Return maximum sum starting from root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899144,
                "title": "kotlin-clean-and-efficient-less-than-15-lines",
                "content": "```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?): Int {\\n        var bestSum = Integer.MIN_VALUE\\n        \\n        fun recurse(node: TreeNode?): Int {\\n            if (node == null) return 0\\n            val left = Math.max(recurse(node.left), 0)\\n            val right =  Math.max(recurse(node.right), 0)\\n            bestSum = Math.max(bestSum, left + right + node.`val`)\\n            return node.`val` + Math.max(left, right)\\n        }\\n        recurse(root)\\n\\n        return bestSum\\n    }\\n}\\n```\\n\\nworst case time: O(n) the solution traverses all nodes\\nworst case space: O(n) the call stack could include the number of nodes",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?): Int {\\n        var bestSum = Integer.MIN_VALUE\\n        \\n        fun recurse(node: TreeNode?): Int {\\n            if (node == null) return 0\\n            val left = Math.max(recurse(node.left), 0)\\n            val right =  Math.max(recurse(node.right), 0)\\n            bestSum = Math.max(bestSum, left + right + node.`val`)\\n            return node.`val` + Math.max(left, right)\\n        }\\n        recurse(root)\\n\\n        return bestSum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305158,
                "title": "implementing-using-pair-class-c-o-n-easy-to-understand-15-line-code",
                "content": "The idea is to implement a pair class to store the answer of each node as well as the maximum sum including that node in the path(**NOTE: this is different from the actual answer because it is not necessary that the node is part of our answer**) this helps us to find maximum sum including that node in O(1) time.\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int> p={0,INT_MIN};\\n            return p;\\n        }\\n        pair<int,int> left=helper(root->left);\\n        pair<int,int> right=helper(root->right);\\n        int include=max(max(root->val,root->val+left.first+right.first),max(root->val+left.first,root->val+right.first)); \\n        int notinclude=max(left.second,right.second);\\n        pair<int,int>ans;\\n        ans.second=max(include,notinclude);\\n        ans.first=max(max(left.first,right.first)+root->val,root->val);\\n        return ans;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        return helper(root).second;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int> p={0,INT_MIN}",
                "codeTag": "Java"
            },
            {
                "id": 2304217,
                "title": "c-easy-short-and-fastest",
                "content": "```\\nclass Solution {\\nprivate:\\n    int helper(TreeNode* root, int&ans){\\n\\t\\t// Escape condition\\n        if(!root) return 0;\\n        \\n\\t\\t// DFS\\n\\t\\tint left = max(0, helper(root->left,ans));\\n        int right = max(0, helper(root->right,ans));\\n        \\n\\t\\t// There is also possibility left+parent+right > ans\\n\\t\\tans = max(ans, root->val + left + right);\\n\\t\\t\\n\\t\\t// Inorder to make the path continous we can send either right or the left side,\\n\\t\\t// So we will send the maximum side\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n\\t\\t// The answer\\n        int ans = INT_MIN;\\n        if(!root) return 0;\\n        \\n\\t\\t// Recurssive function\\n\\t\\thelper(root, ans);\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(TreeNode* root, int&ans){\\n\\t\\t// Escape condition\\n        if(!root) return 0;\\n        \\n\\t\\t// DFS\\n\\t\\tint left = max(0, helper(root->left,ans));\\n        int right = max(0, helper(root->right,ans));\\n        \\n\\t\\t// There is also possibility left+parent+right > ans\\n\\t\\tans = max(ans, root->val + left + right);\\n\\t\\t\\n\\t\\t// Inorder to make the path continous we can send either right or the left side,\\n\\t\\t// So we will send the maximum side\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n\\t\\t// The answer\\n        int ans = INT_MIN;\\n        if(!root) return 0;\\n        \\n\\t\\t// Recurssive function\\n\\t\\thelper(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335817,
                "title": "recursive-solution-c-and-java-0-ms",
                "content": "We need to find the maximum path sum, We can do it by simply comparing the sum of the root* along with its leftSubtree sum or rightSubtree sum and returning the max. But, there is a condition left that we still need to fulfill. \\n   Suppose, what is the maximum sum in a path -> sum of all the nodes present in the path but what if one or two nodes are negative what would we do in this case, as we need to find the maximum sum we will not count them and will take zero to obtain the maximum result.\\n  \\n ```\\n  class Solution {\\n  public:  \\n  \\n    int sum = INT_MIN;\\n   \\n    int helper(TreeNode* root)\\n    {\\n        if(!root)  return 0;\\n        \\n        int leftSum = max(0,helper(root->left));\\n        int rightSum = max(0,helper(root->right));\\n        \\n        sum = max(sum,leftSum + rightSum + root->val);\\n        \\n        return max(leftSum,rightSum) + root->val;   \\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        helper(root);\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\nwe didn\\'t  include current root->val + root-> left + root->right in the last line while returning value because, for current root\\'s parent root, if we were to include root->val + root->left + root->right in the maxPathSum, it would violate the principle that we can only traverse each node once.\\nWe are returning the path sum not the subtree sum.\\n\\nsame code in Java\\n\\n```\\nclass Solution {\\n    int sum = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        sum = Integer.MIN_VALUE;\\n        \\n        helper(root);\\n        \\n        return sum;\\n    }\\n    \\n    public int helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        int leftSum = Math.max(0,helper(root.left));\\n        int rightSum = Math.max(0,helper(root.right));\\n        \\n        sum = Math.max(sum,leftSum + rightSum + root.val);\\n        \\n        return Math.max(leftSum,rightSum) + root.val;  \\n    }\\n}\\n```\\n\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "solutionTags": [],
                "code": "```\\n  class Solution {\\n  public:  \\n  \\n    int sum = INT_MIN;\\n   \\n    int helper(TreeNode* root)\\n    {\\n        if(!root)  return 0;\\n        \\n        int leftSum = max(0,helper(root->left));\\n        int rightSum = max(0,helper(root->right));\\n        \\n        sum = max(sum,leftSum + rightSum + root->val);\\n        \\n        return max(leftSum,rightSum) + root->val;   \\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        helper(root);\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int sum = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        sum = Integer.MIN_VALUE;\\n        \\n        helper(root);\\n        \\n        return sum;\\n    }\\n    \\n    public int helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        int leftSum = Math.max(0,helper(root.left));\\n        int rightSum = Math.max(0,helper(root.right));\\n        \\n        sum = Math.max(sum,leftSum + rightSum + root.val);\\n        \\n        return Math.max(leftSum,rightSum) + root.val;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258344,
                "title": "c-concise-o-n-solution-easy",
                "content": "```\\n int sum(TreeNode* root, int& res)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int l = sum(root -> left, res);\\n        int r = sum(root -> right, res);\\n        \\n        int temp = max(max(l, r) + root -> val, root -> val);\\n        int ans = max(temp, l + r + root -> val);\\n        res =  max(res, ans);\\n        \\n        return temp;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n int sum(TreeNode* root, int& res)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int l = sum(root -> left, res);\\n        int r = sum(root -> right, res);\\n        \\n        int temp = max(max(l, r) + root -> val, root -> val);\\n        int ans = max(temp, l + r + root -> val);\\n        res =  max(res, ans);\\n        \\n        return temp;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113179,
                "title": "python-recursion-solution",
                "content": "See docstring for algorithm\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        # set initial max to negative to system max size\\n        self.max_sum = -sys.maxsize\\n        \\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def get_max(node):\\n            \"\"\"Search for max path for given node and update global max \\n            \\n            - Find max of these 4 cases:\\n            -- node \\n            -- node + left \\n            -- node + right \\n            -- node + left + right \\n            \\n            for left and right calculation use recursion \\n            \\n            - Update global max with this value \\n            \\n            Return max of only first 3 cases - becasue 4th case marks top of the tree \\n            If both children of node are added - then it can\\'t be connected to caller\\n            \\n            :param node: current node to calculate\\n            :type node: TreeNode\\n            :returns: max path that can be continued\\n            :rype: int\\n            \"\"\"\\n            if not node:\\n                return 0 \\n\\n            \\n            left = get_max(node.left)\\n            right = get_max(node.right)\\n            \\n            cases = [\\n                    node.val,                      # when node is the best case\\n                    node.val + left,               # when left path is chosen \\n                    node.val + right,              # when right parth is chosen\\n                    node.val + left + right,       # top of the tree case - this cannot be part of any other path\\n                ]\\n            \\n            self.max_sum = max(self.max_sum, max(cases))\\n                       \\n            return max(cases[0:3])\\n\\n        get_max(root)\\n        return self.max_sum\\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "See docstring for algorithm\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        # set initial max to negative to system max size\\n        self.max_sum = -sys.maxsize\\n        \\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def get_max(node):\\n            \"\"\"Search for max path for given node and update global max \\n            \\n            - Find max of these 4 cases:\\n            -- node \\n            -- node + left \\n            -- node + right \\n            -- node + left + right \\n            \\n            for left and right calculation use recursion \\n            \\n            - Update global max with this value \\n            \\n            Return max of only first 3 cases - becasue 4th case marks top of the tree \\n            If both children of node are added - then it can\\'t be connected to caller\\n            \\n            :param node: current node to calculate\\n            :type node: TreeNode\\n            :returns: max path that can be continued\\n            :rype: int\\n            \"\"\"\\n            if not node:\\n                return 0 \\n\\n            \\n            left = get_max(node.left)\\n            right = get_max(node.right)\\n            \\n            cases = [\\n                    node.val,                      # when node is the best case\\n                    node.val + left,               # when left path is chosen \\n                    node.val + right,              # when right parth is chosen\\n                    node.val + left + right,       # top of the tree case - this cannot be part of any other path\\n                ]\\n            \\n            self.max_sum = max(self.max_sum, max(cases))\\n                       \\n            return max(cases[0:3])\\n\\n        get_max(root)\\n        return self.max_sum\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 592138,
                "title": "clean-and-simple-c-solution-96-57-faster-100-memory",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int max_sum = root->val;\\n        getMaxSumPath(root, &max_sum);\\n        return max_sum;\\n    }\\nprivate:\\n    int getMaxSumPath(TreeNode* node, int* max_sum) {\\n        if (node == nullptr) return 0;\\n        auto l = max(getMaxSumPath(node->left, max_sum), 0);\\n        auto r = max(getMaxSumPath(node->right, max_sum), 0);\\n        *max_sum = max(*max_sum, node->val + l + r);\\n        return node->val + max(l, r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int max_sum = root->val;\\n        getMaxSumPath(root, &max_sum);\\n        return max_sum;\\n    }\\nprivate:\\n    int getMaxSumPath(TreeNode* node, int* max_sum) {\\n        if (node == nullptr) return 0;\\n        auto l = max(getMaxSumPath(node->left, max_sum), 0);\\n        auto r = max(getMaxSumPath(node->right, max_sum), 0);\\n        *max_sum = max(*max_sum, node->val + l + r);\\n        return node->val + max(l, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422797,
                "title": "javascript-solution-w-explanation",
                "content": "### The Idea\\n1. Use DFS\\n2. If a branch\\'s maximum sum is negative, we will never consider that route so we set it to 0\\n3. Right before we backtrack, calculate the global maximum sum\\n4. For the backtrack value, we return the current route\\'s max sum \\n``` \\nvar maxPathSum = function(root) {\\n    let max = -Infinity;\\n    var recur = function(node) {\\n        if (node == null) return 0;\\n        let left = Math.max(0, recur(node.left)); // negative sums will just be ignored\\n        let right = Math.max(0, recur(node.right));\\n        max = Math.max(left + right + node.val, max); // calculate the global max\\n        return Math.max(left, right)+node.val;  // return current route\\'s best sum\\n    }\\n    recur(root)\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar maxPathSum = function(root) {\\n    let max = -Infinity;\\n    var recur = function(node) {\\n        if (node == null) return 0;\\n        let left = Math.max(0, recur(node.left)); // negative sums will just be ignored\\n        let right = Math.max(0, recur(node.right));\\n        max = Math.max(left + right + node.val, max); // calculate the global max\\n        return Math.max(left, right)+node.val;  // return current route\\'s best sum\\n    }\\n    recur(root)\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213322,
                "title": "javascript-dfs-o-n-100",
                "content": "```\\nvar maxPathSum = function(root) {\\n    \\n    let max = -Infinity;\\n    \\n    function dfs(node) {\\n        if(!node) return 0;\\n        \\n        let left = dfs(node.left);\\n        let right = dfs(node.right);\\n        \\n        max = Math.max(\\n            left + right + node.val,\\n            left + node.val,\\n            right + node.val,\\n            node.val,\\n            max\\n        );\\n        \\n        return Math.max(left + node.val, right + node.val, node.val);\\n        \\n    }\\n    \\n    dfs(root);\\n    \\n    return max;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxPathSum = function(root) {\\n    \\n    let max = -Infinity;\\n    \\n    function dfs(node) {\\n        if(!node) return 0;\\n        \\n        let left = dfs(node.left);\\n        let right = dfs(node.right);\\n        \\n        max = Math.max(\\n            left + right + node.val,\\n            left + node.val,\\n            right + node.val,\\n            node.val,\\n            max\\n        );\\n        \\n        return Math.max(left + node.val, right + node.val, node.val);\\n        \\n    }\\n    \\n    dfs(root);\\n    \\n    return max;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189725,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    int Max = Int32.MinValue;\\n    \\n    public int MaxPathSum(TreeNode root) {\\n            Helper(root);\\n            return Max;\\n    }\\n    \\n    private int Helper(TreeNode root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        int leftMax = Helper(root.left),\\n            rightMax = Helper(root.right),\\n            currentMax = 0;\\n\\n        currentMax = Math.Max(currentMax, Math.Max(leftMax + root.val, rightMax + root.val));\\n        Max = Math.Max(Max, leftMax + root.val + rightMax);\\n\\n        return currentMax;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int Max = Int32.MinValue;\\n    \\n    public int MaxPathSum(TreeNode root) {\\n            Helper(root);\\n            return Max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 39872,
                "title": "ac-java-solution-very-simple-dfs",
                "content": "    private int maxPath = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        traverse(root);\\n        return maxPath;\\n    }\\n    \\n    public int traverse(TreeNode root){\\n        if(root == null)    return 0;\\n        \\n        int left = traverse(root.left) + root.val;\\n        int right = traverse(root.right) + root.val;\\n\\n        int tmpMax = Math.max(left, Math.max(right, root.val));\\n        maxPath = Math.max(maxPath, Math.max(tmpMax, left + right - root.val));\\n        return tmpMax;\\n    }",
                "solutionTags": [],
                "code": "    private int maxPath = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        traverse(root);\\n        return maxPath;\\n    }\\n    \\n    public int traverse(TreeNode root){\\n        if(root == null)    return 0;\\n        \\n        int left = traverse(root.left) + root.val;\\n        int right = traverse(root.right) + root.val;\\n\\n        int tmpMax = Math.max(left, Math.max(right, root.val));\\n        maxPath = Math.max(maxPath, Math.max(tmpMax, left + right - root.val));\\n        return tmpMax;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39940,
                "title": "accepted-java-code-19-lines-simple-and-effective",
                "content": "The thought is bottom-up, first we need to get left and right tree max value and make sure that they need to be larger than 0. Next add them to current node value, compare to the total max value and update the total max value. Finally return current value with one of left or right max value (>=0).\\n    \\n    public class Solution {\\n            int max = 0;\\n            public int maxPathSum(TreeNode root) {\\n                if(root == null) return 0;\\n                max = root.val;\\n                helper(root);\\n                return max;\\n            }\\n            public int helper(TreeNode node)\\n            {\\n                if(node == null) return 0;\\n                int left = helper(node.left);\\n                int right = helper(node.right);\\n                left = left > 0 ? left : 0;\\n                right = right > 0 ? right : 0;\\n                int curMax = node.val + left + right;\\n                max = Math.max(max, curMax);\\n                return node.val + Math.max(left, right);\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n            int max = 0;\\n            public int maxPathSum(TreeNode root) {\\n                if(root == null) return 0;\\n                max = root.val;\\n                helper(root);\\n                return max;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3587990,
                "title": "c-recursion-most-optimized-very-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,r+root->val,l+root->val,l+r+root->val});\\n        return max({max({l,r})+root->val,root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,r+root->val,l+root->val,l+r+root->val});\\n        return max({max({l,r})+root->val,root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425731,
                "title": "simple-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root,int &maxi){\\n        if(root == NULL)\\n            return 0;\\n\\n        int ls = max(0,helper(root->left,maxi));\\n        int rs = max(0,helper(root->right,maxi));\\n\\n        maxi = max(maxi,(ls + root->val + rs));\\n        return (root->val + max(ls,rs));\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        int maxi = INT_MIN;\\n        helper(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root,int &maxi){\\n        if(root == NULL)\\n            return 0;\\n\\n        int ls = max(0,helper(root->left,maxi));\\n        int rs = max(0,helper(root->right,maxi));\\n\\n        maxi = max(maxi,(ls + root->val + rs));\\n        return (root->val + max(ls,rs));\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        int maxi = INT_MIN;\\n        helper(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221814,
                "title": "best-o-n-solution",
                "content": "# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        findMaxPathSum(root, ans);\\n        return ans;\\n    }\\nprivate:\\n    int findMaxPathSum(TreeNode* root, int& ans) {\\n        if (root == NULL)\\n            return 0;\\n        int leftSum = max (0, findMaxPathSum(root->left, ans));    \\n        int rightSum = max (0, findMaxPathSum(root->right, ans)); \\n        ans = max (ans, root->val + leftSum + rightSum);\\n        return root->val + max (leftSum, rightSum);   \\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        findMaxPathSum(root, ans);\\n        return ans;\\n    }\\nprivate:\\n    int findMaxPathSum(TreeNode* root, int& ans) {\\n        if (root == NULL)\\n            return 0;\\n        int leftSum = max (0, findMaxPathSum(root->left, ans));    \\n        int rightSum = max (0, findMaxPathSum(root->right, ans)); \\n        ans = max (ans, root->val + leftSum + rightSum);\\n        return root->val + max (leftSum, rightSum);   \\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195903,
                "title": "beats-92-69-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also uses a recursive approach, but instead of keeping track of the maximum path sum so far in a global variable, it passes it down as a parameter to the recursive function. This allows for a cleaner implementation of the DFS function, as it only needs to return the maximum path sum of the current node and its subtrees.\\n\\nThe function dfs takes a node as input and returns the maximum path sum of the current node and its subtrees. It first checks if the node is None (i.e., a leaf node), and returns 0 in that case. Then, it recursively calls itself on the left and right subtrees, and stores the maximum sums in the variables left_sum and right_sum.\\n\\nThe maximum path sum of the current node is then calculated by adding the value of the node to the maximum sums of the left and right subtrees (if they are positive), and updating the global variable self.max_path_sum if necessary.\\n\\nFinally, the function returns the maximum sum of the current node and the maximum sums of its left and right subtrees.\\n\\nThe main function maxPathSum first initializes the maximum path sum to negative infinity, and then calls the dfs function on the root node. It then returns the maximum path sum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nBeats\\n92.69%\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(node):\\n            # Base case: node is None\\n            if not node:\\n                return 0\\n            \\n            # Get the maximum sum of the left subtree\\n            left_sum = max(dfs(node.left), 0)\\n            # Get the maximum sum of the right subtree\\n            right_sum = max(dfs(node.right), 0)\\n            \\n            # Update the maximum path sum so far with the sum of the current node\\n            # and the maximum sums of the left and right subtrees\\n            self.max_path_sum = max(self.max_path_sum, node.val + left_sum + right_sum)\\n            \\n            # Return the maximum sum of the current node and the maximum sum of its\\n            # left and right subtrees\\n            return node.val + max(left_sum, right_sum)\\n        \\n        # Initialize the maximum path sum to negative infinity\\n        self.max_path_sum = float(\\'-inf\\')\\n        \\n        # Start the depth-first search\\n        dfs(root)\\n        \\n        # Return the maximum path sum\\n        return self.max_path_sum\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(node):\\n            # Base case: node is None\\n            if not node:\\n                return 0\\n            \\n            # Get the maximum sum of the left subtree\\n            left_sum = max(dfs(node.left), 0)\\n            # Get the maximum sum of the right subtree\\n            right_sum = max(dfs(node.right), 0)\\n            \\n            # Update the maximum path sum so far with the sum of the current node\\n            # and the maximum sums of the left and right subtrees\\n            self.max_path_sum = max(self.max_path_sum, node.val + left_sum + right_sum)\\n            \\n            # Return the maximum sum of the current node and the maximum sum of its\\n            # left and right subtrees\\n            return node.val + max(left_sum, right_sum)\\n        \\n        # Initialize the maximum path sum to negative infinity\\n        self.max_path_sum = float(\\'-inf\\')\\n        \\n        # Start the depth-first search\\n        dfs(root)\\n        \\n        # Return the maximum path sum\\n        return self.max_path_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093544,
                "title": "java-c-100-solution-using-depth-first-search-binary-tree-maximum-path-sum",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\npublic class Solution {\\n    int maxValue;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxValue = Integer.MIN_VALUE;\\n        maxPathDown(root);\\n        return maxValue;\\n    }\\n    \\n    private int maxPathDown(TreeNode node) {\\n        if (node == null) return 0;\\n        int left = Math.max(0, maxPathDown(node.left));\\n        int right = Math.max(0, maxPathDown(node.right));\\n\\n        maxValue = Math.max(maxValue, left + right + node.val);\\n        return Math.max(left, right) + node.val;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    int solve(TreeNode* root){\\n        if(root)\\n        {   \\n            int left = max(0,solve(root->left));\\n            int right = max(0,solve(root->right));\\n\\n            res = max(res,root->val+left+right);\\n            return max(left,right)+root->val;\\n        }\\n        return 0;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```Java []\\npublic class Solution {\\n    int maxValue;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxValue = Integer.MIN_VALUE;\\n        maxPathDown(root);\\n        return maxValue;\\n    }\\n    \\n    private int maxPathDown(TreeNode node) {\\n        if (node == null) return 0;\\n        int left = Math.max(0, maxPathDown(node.left));\\n        int right = Math.max(0, maxPathDown(node.right));\\n\\n        maxValue = Math.max(maxValue, left + right + node.val);\\n        return Math.max(left, right) + node.val;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    int solve(TreeNode* root){\\n        if(root)\\n        {   \\n            int left = max(0,solve(root->left));\\n            int right = max(0,solve(root->right));\\n\\n            res = max(res,root->val+left+right);\\n            return max(left,right)+root->val;\\n        }\\n        return 0;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045768,
                "title": "very-short-c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust simply check for left subtree and right subtree and keep updating the maximum sum .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first we intiliaze our maxi by INT_MIN then check with left and right subtree\\'s data and current root\\'s data if its max update it .\\n\\n---\\n\\n\\n` int l=max(height(root->left,dis),0);`\\n - `is because we don\\'t want negative sum if there is negative node value then don\\'t take it or we should not explore that branch which gives overall negative sum and that means 0. So just take the sum if its +ve gain or take it 0 if its -ve`\\n\\n\\n---\\n\\n- `similarly for right subtree.` // ` int r=max(height(root->right,dis),0);`\\n- Then just update the the max_sum stored\\n     -  `dis=max(dis,l+r+root->val);`\\n- Then at last return  `max(l+root->val,r+root->val);` which starts recursive stack\\n# Complexity\\n- Time complexity:O(n) `Gotta Traverse n nodes`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) `Recusrive stack`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int height(TreeNode * root,int& dis){\\n       if(!root)return 0;\\n        int l=max(height(root->left,dis),0);\\n        int r=max(height(root->right,dis),0);\\n        dis=max(dis,l+r+root->val);\\n        return max(l+root->val,r+root->val);\\n   }\\n    int maxPathSum(TreeNode* root) {\\n        int dis=INT_MIN;\\n        height(root,dis);\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int height(TreeNode * root,int& dis){\\n       if(!root)return 0;\\n        int l=max(height(root->left,dis),0);\\n        int r=max(height(root->right,dis),0);\\n        dis=max(dis,l+r+root->val);\\n        return max(l+root->val,r+root->val);\\n   }\\n    int maxPathSum(TreeNode* root) {\\n        int dis=INT_MIN;\\n        height(root,dis);\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900900,
                "title": "simple-5-lines-dfs-solution-o-n-time-space",
                "content": "//upvote if helpful.\\n//thank you.\\n\\n# Approach\\nwe can see here we just need 5 values which are maximum value which we will get from my left child , maximum value which we will get from right child, we should add them to my value to return to my parent or just return my own value. I have commented the solution to get the understanding better.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int& ans){\\n        if(!root)return 0; //this is base case which is we have reached end of some path.\\n\\n        int lmax= dfs(root->left,  ans);// it will give me max value which i can get from my left child\\n        int rmax= dfs(root->right, ans);// it will give me max value which i can get from my right child\\n        ans= max({lmax+root->val, rmax+root->val, rmax+lmax+root->val, ans, root->val});// this is tricky because has 5 cases in total\\n        //1) should i take value coming from left child and add my value\\n        //2) should i take value coming from right child and add my value\\n        //3) or assume myself as root of that path then i have to take values coming from left+right and have to add mine too.\\n        //4) this is obvious\\n        //5)the path could contain myself only instead of taking left, right or my parent.\\n\\n        // now when i am returning my own max to my parent then \\n        //it will be my value+ either lmax or rmax because \\n        //if i am returning some value to my parent then it implies\\n        //that i am not root so we have to take either left or right.\\n        // and there is one more chance that both lmax, rmax are negative so i will return my value only.\\n        return max(root->val+max(lmax, rmax), root->val);\\n\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=root->val;\\n        //if(root->left==NULL && root->right==NULL)return root->val;\\n        int k= dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int& ans){\\n        if(!root)return 0; //this is base case which is we have reached end of some path.\\n\\n        int lmax= dfs(root->left,  ans);// it will give me max value which i can get from my left child\\n        int rmax= dfs(root->right, ans);// it will give me max value which i can get from my right child\\n        ans= max({lmax+root->val, rmax+root->val, rmax+lmax+root->val, ans, root->val});// this is tricky because has 5 cases in total\\n        //1) should i take value coming from left child and add my value\\n        //2) should i take value coming from right child and add my value\\n        //3) or assume myself as root of that path then i have to take values coming from left+right and have to add mine too.\\n        //4) this is obvious\\n        //5)the path could contain myself only instead of taking left, right or my parent.\\n\\n        // now when i am returning my own max to my parent then \\n        //it will be my value+ either lmax or rmax because \\n        //if i am returning some value to my parent then it implies\\n        //that i am not root so we have to take either left or right.\\n        // and there is one more chance that both lmax, rmax are negative so i will return my value only.\\n        return max(root->val+max(lmax, rmax), root->val);\\n\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=root->val;\\n        //if(root->left==NULL && root->right==NULL)return root->val;\\n        int k= dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481730,
                "title": "o-n-recursive-solution-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int max_so_far = INT_MIN;\\npublic:\\n    int dfs(TreeNode* root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        // l & r -> give the maximum sum path in both subtrees\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n\\n        // max_till_now -> assure path won\\'t be discontinuous\\n        int max_till_now = max({ root->val, r + root->val, l + root->val });\\n\\n        // max_path_in_subtrees -> forms the max path b/w 2 leaf nodes, through current node\\n        int max_path_in_subtrees = root->val + l + r;\\n        \\n        // max_so_far -> maintains the max path\\n        max_so_far = max({ max_so_far, max_till_now, max_path_in_subtrees });\\n\\n        // return\\n        return max_till_now;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int p = dfs(root);\\n        return max_so_far;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int max_so_far = INT_MIN;\\npublic:\\n    int dfs(TreeNode* root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        // l & r -> give the maximum sum path in both subtrees\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n\\n        // max_till_now -> assure path won\\'t be discontinuous\\n        int max_till_now = max({ root->val, r + root->val, l + root->val });\\n\\n        // max_path_in_subtrees -> forms the max path b/w 2 leaf nodes, through current node\\n        int max_path_in_subtrees = root->val + l + r;\\n        \\n        // max_so_far -> maintains the max path\\n        max_so_far = max({ max_so_far, max_till_now, max_path_in_subtrees });\\n\\n        // return\\n        return max_till_now;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int p = dfs(root);\\n        return max_so_far;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149399,
                "title": "deceptively-simple-problem-intuitive-java-solution-with-comments-beats-100",
                "content": "I felt the problem is deceptively simple, and very easy to get it wrong. Hence an intuitive answer is most helpful because you can possibly come up with this solution during interview without memorizing the approach!\\n\\nTwo main things to remember:\\n* This is a max path sum problem, not max subtree sum problem\\n* The value that is interesting for the current node may not be interesting for its parent, given the constraints of the problem\\n\\nI found the best way to solve this is to have a tracker that maintains maximum sum for every node visited. The tree is traversed post-order with each node returning path sum. The tracker is used to memorize the max path sum. The return value really is the path sum that the subtree rooted at the current node can contribute as path sum if the parent node decides to include it. This aspect is intuitive when you think about it, but it may not come to mind first time!\\n\\nThe time complexity of the code below is O(n) - every node is visited. Space complexity should be O(h) considering the recursion stack size.\\n\\n```\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root); // return value is not important in this function\\n        return maxSum;\\n    }\\n    \\n    private int helper(TreeNode node) {\\n        if (node == null) {\\n            return 0; // null node contributes nothing to the sum\\n        }\\n        \\n        // Postorder traversal\\n        int leftSum = helper(node.left);\\n        int rightSum = helper(node.right);\\n        \\n        int maxChildSum = Math.max(leftSum, rightSum);\\n        \\n        // We now need to compute three aspects:\\n        // Case 1: Max path is only the current node\\n        maxSum = Math.max(node.val, maxSum);\\n        // Case 2: the path includes node and both of its children\\n        maxSum = Math.max(node.val + leftSum + rightSum, maxSum);\\n        // Case 3: Path including Node and only one of the child\\n        maxSum = Math.max(node.val + maxChildSum, maxSum);\\n        \\n        // The question here is to find max path sum, and not max subtree sum\\n        // hence we return only a viable path sum to the parent node\\n        // Depending on the value of the nodes, this can either be the node itself, \\n        // or sum of the node and max of its children\\n        return Math.max(node.val, node.val + maxChildSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root); // return value is not important in this function\\n        return maxSum;\\n    }\\n    \\n    private int helper(TreeNode node) {\\n        if (node == null) {\\n            return 0; // null node contributes nothing to the sum\\n        }\\n        \\n        // Postorder traversal\\n        int leftSum = helper(node.left);\\n        int rightSum = helper(node.right);\\n        \\n        int maxChildSum = Math.max(leftSum, rightSum);\\n        \\n        // We now need to compute three aspects:\\n        // Case 1: Max path is only the current node\\n        maxSum = Math.max(node.val, maxSum);\\n        // Case 2: the path includes node and both of its children\\n        maxSum = Math.max(node.val + leftSum + rightSum, maxSum);\\n        // Case 3: Path including Node and only one of the child\\n        maxSum = Math.max(node.val + maxChildSum, maxSum);\\n        \\n        // The question here is to find max path sum, and not max subtree sum\\n        // hence we return only a viable path sum to the parent node\\n        // Depending on the value of the nodes, this can either be the node itself, \\n        // or sum of the node and max of its children\\n        return Math.max(node.val, node.val + maxChildSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101447,
                "title": "java-beats-100-easy-to-understand-solution-with-explanation-and-comments",
                "content": "/**\\n *Definition for a binary tree node.\\npublic class TreeNode {\\n \\xA0 int val;\\n TreeNode left;\\n TreeNode right;\\n  \\xA0 \\xA0 TreeNode() {}\\n TreeNode(int val) { this.val = val; }\\n TreeNode(int val, TreeNode left, TreeNode right) {\\n this.val = val;\\n this.left = left;\\n this.right = right;\\n }\\n}\\n */ \\n \\n \\n // Solution explanation\\n// In this solution we are doing postorder tranversal and finding maximum path sum for each node during traversal\\n\\n\\n// We need to take care of 3 test cases\\n// Case 1: The current node lies in the path of maximum sum \\n// Case 2: The current node is the root of maximum path sum\\n// Case 3: The current node doesn\\'t lie in the path of maximum sum \\n```\\n\\n```class Solution {\\n    // this variable is going to store maximum sum we have found \\n    int result= Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n       maxUtil( root);\\n          return result;\\n    }\\n    public int maxUtil(TreeNode root){\\n       \\n        if(root==null)\\n            return 0;\\n        // left & right variable is storing maximum path sum of left & right subtree\\n       int left=maxUtil(root.left);\\n       int right=maxUtil(root.right);\\n// checking for Case 1 here either we are coming from left subtree or right subtree in this case that\\'s why taking maximum of left & right \\n        int max1=Math.max(Math.max(left,right)+root.val,root.val);\\n        // checking for case 2 here and comparing it with previous case 1 value . In this case max sum is root\\'s value + left child value+ right child value \\n        int max2=Math.max(max1,left+right+root.val);\\n        // finally comparing the maximum sum we have got so far and updating its value checking case 3 as well \\n    \\n        result= Math.max(max2, result);\\n        return max1;\\n        \\n}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044638,
                "title": "java-intuitive-0ms-100",
                "content": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        postTraverse(root);\\n        return res;\\n    }\\n    \\n    public int postTraverse(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int leftMax = postTraverse(root.left);\\n        int rightMax = postTraverse(root.right);\\n        \\n        // Max of (root+left), (root+right), (root); \\n        //only max1 gets returned to it\\'s parent to make a single path along the parent node.\\n        int max1 = Math.max(Math.max(leftMax, rightMax)+root.val, root.val); \\n        \\n        // Max of (root+left), (root+right), (root), (root+left+right); \\n        // check if a subtree makes the max sum path.\\n        int max2 = Math.max(max1, leftMax + rightMax + root.val);\\n        \\n        res = Math.max(res, max2); \\n        \\n        return max1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        postTraverse(root);\\n        return res;\\n    }\\n    \\n    public int postTraverse(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int leftMax = postTraverse(root.left);\\n        int rightMax = postTraverse(root.right);\\n        \\n        // Max of (root+left), (root+right), (root); \\n        //only max1 gets returned to it\\'s parent to make a single path along the parent node.\\n        int max1 = Math.max(Math.max(leftMax, rightMax)+root.val, root.val); \\n        \\n        // Max of (root+left), (root+right), (root), (root+left+right); \\n        // check if a subtree makes the max sum path.\\n        int max2 = Math.max(max1, leftMax + rightMax + root.val);\\n        \\n        res = Math.max(res, max2); \\n        \\n        return max1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013639,
                "title": "c-clean-short-simplest-solution-ever-faster-than-99-5",
                "content": "This question should be medium, not hard!\\n```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = max(rec(root->left), 0);\\n        int right = max(rec(root->right), 0);\\n        maxi = max(maxi, left+right+root->val);\\n        return max(left, right) + root->val;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        rec(root);\\n        return maxi;\\n    }\\nprivate:\\n    int maxi = INT_MIN;\\n};\\n```\\n**Like it? Please upvote!!\\nHave any comments? I\\'d love to hear...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = max(rec(root->left), 0);\\n        int right = max(rec(root->right), 0);\\n        maxi = max(maxi, left+right+root->val);\\n        return max(left, right) + root->val;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        rec(root);\\n        return maxi;\\n    }\\nprivate:\\n    int maxi = INT_MIN;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769037,
                "title": "a-precise-recursive-dfs-solution-in-java-with-explanation",
                "content": "Algorithm for Problem: Since we have to find the maximum sum from some node in the binary tree to any node,we can use  a recursive bottom up approach to solve this problem. \\nWe have to consider the left child of every node and right child of every node then we need to find the current sum  that can be  calculated using basic logic.\\n**currentsum=Math.max((root.val+left),Math.max((root.val+right),Math.max(root.val,root.val+left+right)));\\nWe need to consider three cases:\\n1)The subtree sum of left child+right child +root value(subtree might be the maximu path).\\n2)The sum of left child and root value.\\n3)The sum of right child and root value.\\n4)We need to find the maximum of step 1,2,3.**\\n\\nAfter finding the current sum we need to compare it with maxsum,if it is less than maxsum then we do nothing,if it is greater than maxsum then we update maxsum to currentsum.\\n\\nMost Important process to whole algorithm is to get the return value form the function,this is a little bit tricky.\\nWe cannot return maxsum because it might contain the whole subtree(which might not be maxmium path) and we seek to find maximum path .\\nHere we define integer ret:\\n**ret=Math.max(root.val+left,Math.max(root.val+right,root.val));\\nValue to be returned we be either of the three:\\n1)Sum of Left child and Root value.\\n2)Sum of Right child and Root value.\\n3)Only root value.**\\n\\nSolution contains a print statement to demonstrate the flow of program, but is commented.\\n\\n\\n```\\nclass Solution {\\n    int maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        maxpath(root);\\n        return maxsum;\\n    }\\n    public int maxpath(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int left=maxpath(root.left);\\n        int right=maxpath(root.right);\\n        int currentsum=Math.max((root.val+left),Math.max((root.val+right),Math.max(root.val,root.val+left+right)));\\n        //System.out.println(\"left \"+left+\" right \"+right+\" currentsum \"+currentsum);\\n        maxsum=Math.max(maxsum,currentsum);\\n        int ret=Math.max(root.val+left,Math.max(root.val+right,root.val));\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        maxpath(root);\\n        return maxsum;\\n    }\\n    public int maxpath(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int left=maxpath(root.left);\\n        int right=maxpath(root.right);\\n        int currentsum=Math.max((root.val+left),Math.max((root.val+right),Math.max(root.val,root.val+left+right)));\\n        //System.out.println(\"left \"+left+\" right \"+right+\" currentsum \"+currentsum);\\n        maxsum=Math.max(maxsum,currentsum);\\n        int ret=Math.max(root.val+left,Math.max(root.val+right,root.val));\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684624,
                "title": "java-with-picture",
                "content": "\\nThanks [@wei-bung](https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39775/Accepted-short-solution-in-Java)\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_124_common.png)  \\n\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_124_careful_with_return.png)  \\n\\n\\n``` java\\nclass Solution {\\n    \\n    int ans = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }\\n    \\n    private int helper(TreeNode root){\\n        \\n        // Base case.\\n        if (root == null) return 0;\\n        \\n        int left  = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        int cur   = root.val + left + right;\\n        ans       = Math.max(ans, cur);\\n        // return cur;\\n        return Math.max(left, right) + root.val;\\n    }\\n}\\n```\\n\\n`Enjoy it ! `",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    \\n    int ans = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }\\n    \\n    private int helper(TreeNode root){\\n        \\n        // Base case.\\n        if (root == null) return 0;\\n        \\n        int left  = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        int cur   = root.val + left + right;\\n        ans       = Math.max(ans, cur);\\n        // return cur;\\n        return Math.max(left, right) + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467723,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 16 ms, faster than 90.40% of Go online submissions for Binary Tree Maximum Path Sum.\\nMemory Usage: 6.7 MB, less than 100.00% of Go online submissions for Binary Tree Maximum Path Sum.\\n\\n```go\\nfunc maxPathSum(root *TreeNode) int {\\n    res := math.MinInt32\\n    helper(root, &res)\\n    return res\\n}\\n\\nfunc helper(node *TreeNode, res *int) int {\\n    if node == nil { return 0 }\\n    left := helper(node.Left, res)\\n    right := helper(node.Right, res)\\n    currentNodeNotAsRoot := max(max(left, right) + node.Val, node.Val)\\n    currentNodeAsRoot := max(currentNodeNotAsRoot, left + right + node.Val)\\n    *res = max(*res, currentNodeAsRoot)\\n    return currentNodeNotAsRoot\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxPathSum(root *TreeNode) int {\\n    res := math.MinInt32\\n    helper(root, &res)\\n    return res\\n}\\n\\nfunc helper(node *TreeNode, res *int) int {\\n    if node == nil { return 0 }\\n    left := helper(node.Left, res)\\n    right := helper(node.Right, res)\\n    currentNodeNotAsRoot := max(max(left, right) + node.Val, node.Val)\\n    currentNodeAsRoot := max(currentNodeNotAsRoot, left + right + node.Val)\\n    *res = max(*res, currentNodeAsRoot)\\n    return currentNodeNotAsRoot\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340521,
                "title": "my-java-solution",
                "content": "We need to figure out 3 things to solve this problem. \\nSuppose we are on one tree node,\\n**1. what do we want from left subtree and right subtree.**\\nWe need to know max sum from two children. And if sum < 0, we must left it be 0 to eliminate its negative effect because we want the max sum path. This is very important.\\n```\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n```\\n**2. What do we want to do in the current layer**\\nWe want to add leftSum, rightSum and the node value up. This is a sum path from one leaf node to another leaf node. So we need to get the global_max like\\n```\\n\\tglobal_max = Math.max(global_max, left + right + root.val);\\n```\\n**3. What value we want to return to our parent node.**\\nWhat we want to return is not the full sum path. It\\'s the max path from root to one leaf node. So, we need to return\\n```\\n\\treturn Math.max(left, right) + root.val;\\n```\\nMy code is shown below:\\n```\\nclass Solution {\\n    int global_max;\\n    public int maxPathSum(TreeNode root) {\\n        global_max = Integer.MIN_VALUE;\\n        dfs(root);\\n\\t    return global_max;\\n}\\nprivate int dfs(TreeNode root){\\n\\tif (root == null){\\n\\t\\treturn 0;\\n\\t}\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n\\tif (root.left != null && root.right != null){\\n\\t\\tglobal_max = Math.max(global_max, left + right + root.val);\\n\\t\\treturn Math.max(left, right) + root.val;\\n\\t}\\n\\tif (root.left == null){\\n\\t\\tglobal_max = Math.max(global_max, right + root.val);\\n\\t\\treturn right + root.val;\\n\\t}\\t\\n\\telse {\\n\\t\\tglobal_max = Math.max(global_max, left + root.val);\\n\\t\\treturn  left + root.val;\\n\\t}\\n}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n```\n```\\n\\tglobal_max = Math.max(global_max, left + right + root.val);\\n```\n```\\n\\treturn Math.max(left, right) + root.val;\\n```\n```\\nclass Solution {\\n    int global_max;\\n    public int maxPathSum(TreeNode root) {\\n        global_max = Integer.MIN_VALUE;\\n        dfs(root);\\n\\t    return global_max;\\n}\\nprivate int dfs(TreeNode root){\\n\\tif (root == null){\\n\\t\\treturn 0;\\n\\t}\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n\\tif (root.left != null && root.right != null){\\n\\t\\tglobal_max = Math.max(global_max, left + right + root.val);\\n\\t\\treturn Math.max(left, right) + root.val;\\n\\t}\\n\\tif (root.left == null){\\n\\t\\tglobal_max = Math.max(global_max, right + root.val);\\n\\t\\treturn right + root.val;\\n\\t}\\t\\n\\telse {\\n\\t\\tglobal_max = Math.max(global_max, left + root.val);\\n\\t\\treturn  left + root.val;\\n\\t}\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321667,
                "title": "swift-o-n-linear-recursive-solution",
                "content": "```\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var result: Int = 0;\\n        if root != nil {\\n            result = root!.val\\n            maxPathSumHelper(root, &result)\\n        }\\n        return result\\n    }\\n    \\n    func maxPathSumHelper(_ root: TreeNode?, _ result: inout Int) -> Int {\\n        \\n        guard let root = root else { return 0 }\\n        \\n        var leftCost = maxPathSumHelper(root.left, &result)\\n        if leftCost < 0 { leftCost = 0 }\\n        \\n        var rightCost = maxPathSumHelper(root.right, &result)\\n        if rightCost < 0 { rightCost = 0 }\\n        \\n        var val = root.val + leftCost + rightCost\\n        if val > result { result = val }\\n        \\n        return root.val + max(leftCost, rightCost)\\n    }\\n    \\n}\\n```\\n\\nThe main difficulty with this question is understanding what \"path\" means at each recursion level. For calculating the max possible path, we can take into consideration the current node AND (none, one, or both children). For calculating the return value, we are focusing on a sub-path, which means there would be a fork in our path - basically, we can only pick one child as our max path to return to a parent, which will count both directional children of its max computation... \\n\\nThink of the max/result computation as independent from the return value, because it is...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var result: Int = 0;\\n        if root != nil {\\n            result = root!.val\\n            maxPathSumHelper(root, &result)\\n        }\\n        return result\\n    }\\n    \\n    func maxPathSumHelper(_ root: TreeNode?, _ result: inout Int) -> Int {\\n        \\n        guard let root = root else { return 0 }\\n        \\n        var leftCost = maxPathSumHelper(root.left, &result)\\n        if leftCost < 0 { leftCost = 0 }\\n        \\n        var rightCost = maxPathSumHelper(root.right, &result)\\n        if rightCost < 0 { rightCost = 0 }\\n        \\n        var val = root.val + leftCost + rightCost\\n        if val > result { result = val }\\n        \\n        return root.val + max(leftCost, rightCost)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306274,
                "title": "actually-reabable-python-with-explanation-14-lines",
                "content": "**Idea**:\\n1) The first and most imporant insight here is a path, as defined formally in the question, can only **cross the two subtrees at most once in the entire path**.  \\n```\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\n```\\n**E.g. Once we have path [15,20,7], we can never have a path that includes 20 and any of its ancestor together. Because in those paths, we will be touching 20 more than once and that would not be a legal path. For instance, had -10 and 20 been included together on the same path, there\\'s no way to touch every node of the subtree rooted at 20 without touching 20 twice.**\\n\\n**When we include a root node of a tree, I call it *crossing the subtrees* (imagine crossing left subtree into right subtree).**\\n\\n2) The second insight is just that there are two kinds of sums - a) the sum you get by crossing some pair of subtrees b) the sum you get by not crossing any pair of subtrees.\\n\\nIn the code, for each node, I call the sum you get crossing the subtrees max_ex (for max_extensible because you could choose to extend this sum by crossing subtrees when we get to its ancestors) and the max_nonex (for max_nonextensible). \\n\\nThen everything follows from these definitions/worldviews.\\na) (max_ex, again, the sum by going on a straight path, no crossing subtrees) max_ex is defined to be the max of i) root.val (straight path of 1 node) and ii) results of subproblems\\nb) max_nonex is defined to be i) max_ex (for the optimal result could be a straight path from current node to one of its descendent and we just don\\'t extend it for reasons like maybe ancestors are negative as in our example), ii) root.val + max_left_ex + max_right_ex (for extending and crossing the subtrees) and finally iii) results of the subproblems.\\n\\nSee everything in action, a modified diagram of max_ex and max_nonex next to each node.val:\\n```\\nformat: node.val (max_ex, max_nonex)\\n   -10 (25,42)\\n   /           \\\\\\n  9 (9,9) 20 (35,42)\\n    /              \\\\\\n   15 (15,15)  7 (7,7)\\n```\\n\\nNote:\\nThis writing is one of my first few writings on Leetcode, I\\'d love to get some feedback from you and keep improving and shareing my thoughts. My focus is try to explain what may be confusing in other explanations as simply as possible while keeping the insights I had while coding. Because at the end of the day, it\\'s these insights that help us solve these problems. \\n\\nPlease don\\'t feel frustrated or give up if you don\\'t understand as my writing could\\'ve been confusing. Do try focus on the above example I provided here. Please provide feedback, leave a comment, and I will try my best to get back to you. \\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        return max(self.exten_and_nonexten_sum(root))\\n    def exten_and_nonexten_sum(self, root: TreeNode) -> int:\\n        if not root:\\n            return (float(\\'-inf\\'), float(\\'-inf\\'))\\n        max_left_ex, max_left_nonex = self.exten_and_nonexten_sum(root.left)\\n        max_right_ex, max_right_nonex = self.exten_and_nonexten_sum(root.right)\\n        max_ex = max(root.val, root.val + max_left_ex, root.val + max_right_ex)\\n        max_nonex = max(\\n            max_ex,\\n            root.val + max_left_ex + max_right_ex,\\n            max_left_nonex,\\n            max_right_nonex)\\n        return (max_ex, max_nonex)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\n```\n```\\nformat: node.val (max_ex, max_nonex)\\n   -10 (25,42)\\n   /           \\\\\\n  9 (9,9) 20 (35,42)\\n    /              \\\\\\n   15 (15,15)  7 (7,7)\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        return max(self.exten_and_nonexten_sum(root))\\n    def exten_and_nonexten_sum(self, root: TreeNode) -> int:\\n        if not root:\\n            return (float(\\'-inf\\'), float(\\'-inf\\'))\\n        max_left_ex, max_left_nonex = self.exten_and_nonexten_sum(root.left)\\n        max_right_ex, max_right_nonex = self.exten_and_nonexten_sum(root.right)\\n        max_ex = max(root.val, root.val + max_left_ex, root.val + max_right_ex)\\n        max_nonex = max(\\n            max_ex,\\n            root.val + max_left_ex + max_right_ex,\\n            max_left_nonex,\\n            max_right_nonex)\\n        return (max_ex, max_nonex)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179498,
                "title": "recursion-thinking-process",
                "content": ">Each node can be the root of the final Maximum Path Sum - root here means the topmost node in a path.\\n\\n>We calculate Maximum Path Sum rooted at each node and update `maxSum`  on the fly.\\n\\n>Maximum Path Sum rooted at a node = \\n```\\nmax(maxPathSumFrom(node.left), 0) + max(maxPathSumFrom(node.right), 0) + node.val)\\n// Pay attention to how 0-trick saves tedious comparison.\\n```\\n\\n> getDownwardPathSum(node) =\\n```\\nmax(maxPathSumFrom(node.left), maxPathSumFrom(node.right)) + node.val\\n```\\n\\n****\\n```\\n    private int maxSum;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxPathSumFrom(root);\\n        return maxSum;\\n    }\\n    \\n    private int maxPathSumFrom(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        int left = Math.max(0, maxPathSumFrom(root.left));\\n        int right = Math.max(0, maxPathSumFrom(root.right));\\n        \\n        maxSum = Math.max(maxSum, left + right + root.val);\\n        \\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nmax(maxPathSumFrom(node.left), 0) + max(maxPathSumFrom(node.right), 0) + node.val)\\n// Pay attention to how 0-trick saves tedious comparison.\\n```\n```\\nmax(maxPathSumFrom(node.left), maxPathSumFrom(node.right)) + node.val\\n```\n```\\n    private int maxSum;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxPathSumFrom(root);\\n        return maxSum;\\n    }\\n    \\n    private int maxPathSumFrom(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        int left = Math.max(0, maxPathSumFrom(root.left));\\n        int right = Math.max(0, maxPathSumFrom(root.right));\\n        \\n        maxSum = Math.max(maxSum, left + right + root.val);\\n        \\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39851,
                "title": "simple-recursive-yet-still-accepted-as-best-in-cpp",
                "content": "    class Solution {\\n    private:\\n        int traverse(TreeNode* root, int& maxSum)\\n        {\\n            if(!root) return 0;\\n            int lMax = max(0, traverse(root->left, maxSum));\\n            int rMax = max(0, traverse(root->right, maxSum));\\n            maxSum = max(maxSum, lMax+rMax+root->val);\\n            return max(lMax, rMax)+root->val;\\n        }\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            int maxSum = INT_MIN;\\n            traverse(root, maxSum);\\n            return maxSum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private:\\n        int traverse(TreeNode* root, int& maxSum)\\n        {\\n            if(!root) return 0;\\n            int lMax = max(0, traverse(root->left, maxSum));\\n            int rMax = max(0, traverse(root->right, maxSum));\\n            maxSum = max(maxSum, lMax+rMax+root->val);\\n            return max(lMax, rMax)+root->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3998373,
                "title": "a-dynamic-programming-dp-approach-images-c-simple-intuitive-100-runtime-90-memory",
                "content": "# Intuition\\nWhen faced with a problem like finding the maximum sum binary tree path, it\\'s tempting to draw parallels with familiar algorithms like the maximum sum subarray problem. However, in this case, we don\\'t have a simple array to work with. Instead, we\\'re dealing with a binary tree. The question arises: can we transform the tree into an array and then apply a 1D dynamic programming approach? The answer is not straightforward. Consider the following counterexample:\\n`[1,-2,-3,1,3,-2,null,-1]`\\n\\n![Screenshot 2023-09-03 at 13.33.41.png](https://assets.leetcode.com/users/images/95804efb-eb89-4544-b6a7-2401a8d0174d_1693762433.8614566.png)\\n\\nIn the inorder traversal of this tree `[-1,1,-2,3,1,-3,-2]`, the numbers 1 and 3 are adjacent. However, they do not form a valid path in the tree.\\n\\nNevertheless, the essence of the idea is promising. For calculating the maximum subarray sum, we can use the dynamic programming formula:\\n`dp[i] = max(dp[i - 1] + arr[i], arr[i])`\\n\\nIn our case, we have more options than just considering the previous element, and we must account for the \"path\" nature of the problem.\\n\\n# Approach\\nLet\\'s define our dynamic programming (DP) for the current node. We want to calculate the maximum path sum that includes the current node as the root. Logically, it can be expressed as:\\n```\\ndp[curr_node] = max(\\n    dp[left_child] + curr_val, \\n    dp[right_child] + curr_val, \\n    curr_val\\n)\\n```\\n\\nWe have three choices: either take the left subtree sum and add the current node\\'s value, or take the right subtree sum and add the current node\\'s value, or ignore both subtrees and just take the current node\\'s value.\\n\\nHowever, there are two significant problems with this solution so far:\\n\\n- We don\\'t know how to calculate dp[node] because there is no unique way to define a node (values are not guaranteed to be unique).\\n- The solution only supports paths that start in a specific node as their left or right subtree, while the path may lead from any node to any other node.\\n\\n![1.png](https://assets.leetcode.com/users/images/008a6416-ca3b-45b4-b365-414a5560b250_1693763460.2434177.png)\\n\\nLet\\'s address the second problem first. Every time we calculate `dp[curr_node]`, we can also compute the `ans`, which represents the best answer seen so far (the maximum path sum up to that point). To accommodate paths that don\\'t necessarily start from a specific node, we modify our answer calculation as follows:\\n```\\nans = max(ans, dp[curr_node], dp[left_child] + curr_val + dp[right_child])\\n```\\n\\nNow what about `dp[curr_node]`? Well, we have `node.val` for every node, and we do not have a requirement on keeping this value after the function execution. So we can use this `node.val` as our `dp[curr_node]`:\\n```\\ncurr.val = max(curr.val, max(left + curr.val, right + curr.val));\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - we simply do tree traversal (dfs)\\n\\n- Space complexity:\\n$$O(n)$$ - because of the recursive approach, we could also do that in $$O(1)$$ rewriting in iterative way.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    int ans = -1e9;\\n\\n    // dp for current node is max(left + curr, right + curr, left + right + curr, curr);\\n\\n    int dfs(TreeNode *curr) {\\n        if (curr == NULL) return -INF;\\n\\n        int left = dfs(curr->left);\\n        int right = dfs(curr->right);\\n\\n        int cval = curr->val;\\n        curr->val = std::max(\\n            cval,\\n            std::max(left + cval, right + cval)\\n        );\\n\\n        ans = std::max(std::max(ans, curr->val), left + cval + right);\\n\\n        return curr->val;\\n    }\\n\\n    int maxPathSum(TreeNode* curr) {\\n        int res = dfs(curr);\\n        return std::max(res, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\ndp[curr_node] = max(\\n    dp[left_child] + curr_val, \\n    dp[right_child] + curr_val, \\n    curr_val\\n)\\n```\n```\\nans = max(ans, dp[curr_node], dp[left_child] + curr_val + dp[right_child])\\n```\n```\\ncurr.val = max(curr.val, max(left + curr.val, right + curr.val));\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    int ans = -1e9;\\n\\n    // dp for current node is max(left + curr, right + curr, left + right + curr, curr);\\n\\n    int dfs(TreeNode *curr) {\\n        if (curr == NULL) return -INF;\\n\\n        int left = dfs(curr->left);\\n        int right = dfs(curr->right);\\n\\n        int cval = curr->val;\\n        curr->val = std::max(\\n            cval,\\n            std::max(left + cval, right + cval)\\n        );\\n\\n        ans = std::max(std::max(ans, curr->val), left + cval + right);\\n\\n        return curr->val;\\n    }\\n\\n    int maxPathSum(TreeNode* curr) {\\n        int res = dfs(curr);\\n        return std::max(res, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813082,
                "title": "java-easy-solution-full-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a `maxValue` array to store our final answer.\\n- Do a simple tree traversal. At each node, find  recursively its `leftMaxPath` and its `rightMaxPath`.\\n- Calculate the maxPath through the node as `val + (leftMaxPath + rightMaxPath)` and update maxi accordingly.\\n- Return the maxPath when node is not the curving point as `val + max(leftMaxPath, rightMaxPath)`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int maxPathSum(TreeNode root) {\\n      int maxValue[] = new int[1];\\n      maxValue[0] = Integer.MIN_VALUE;\\n      helper(root, maxValue);\\n      return maxValue[0];\\n    }\\n  int helper(TreeNode root, int[] maxValue) {\\n    if(root == null) return 0;\\n    int left = Math.max(helper(root.left, maxValue), 0);\\n    int right = Math.max(helper(root.right, maxValue), 0);  \\n    \\n    maxValue[0] = Math.max(maxValue[0], root.val + left + right);\\n    return root.val + Math.max(left, right);\\n  }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int maxPathSum(TreeNode root) {\\n      int maxValue[] = new int[1];\\n      maxValue[0] = Integer.MIN_VALUE;\\n      helper(root, maxValue);\\n      return maxValue[0];\\n    }\\n  int helper(TreeNode root, int[] maxValue) {\\n    if(root == null) return 0;\\n    int left = Math.max(helper(root.left, maxValue), 0);\\n    int right = Math.max(helper(root.right, maxValue), 0);  \\n    \\n    maxValue[0] = Math.max(maxValue[0], root.val + left + right);\\n    return root.val + Math.max(left, right);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718407,
                "title": "binary-tree-maximum-path-sum-leetcode",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, int &maxi){\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int left = max(solve(root -> left, maxi), 0);\\n        int right = max(solve(root -> right, maxi), 0);\\n\\n        maxi = max(maxi, left + right + root -> val);\\n        return max(left,right) + root -> val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int maxi = INT_MIN;\\n        int ans = solve(root,maxi);\\n        return max(maxi,ans);\\n    }\\n// By ~ Shubham Verma\\n};\\n```\\n![7cfadaec-4ab3-45e4-9ad8-313c2db992f9_1678433858.6366765.png](https://assets.leetcode.com/users/images/a89c7575-9822-4560-9cbc-50f4ffa8b753_1688490238.7928553.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, int &maxi){\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int left = max(solve(root -> left, maxi), 0);\\n        int right = max(solve(root -> right, maxi), 0);\\n\\n        maxi = max(maxi, left + right + root -> val);\\n        return max(left,right) + root -> val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int maxi = INT_MIN;\\n        int ans = solve(root,maxi);\\n        return max(maxi,ans);\\n    }\\n// By ~ Shubham Verma\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702811,
                "title": "a-simple-accepted-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int maxPathSumHelper(TreeNode* root, int& res) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        \\n        int leftSum = maxPathSumHelper(root->left, res);\\n        int rightSum = maxPathSumHelper(root->right, res);\\n        \\n        int maxChildSum = max(leftSum, rightSum);\\n        \\n        int maxRootSum = max(maxChildSum + root->val, root->val);\\n        int maxTreeSum = max(maxRootSum, leftSum + rightSum + root->val);\\n        \\n        res = max(res, maxTreeSum);\\n        \\n        return maxRootSum;\\n    }\\n    \\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        maxPathSumHelper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int maxPathSumHelper(TreeNode* root, int& res) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        \\n        int leftSum = maxPathSumHelper(root->left, res);\\n        int rightSum = maxPathSumHelper(root->right, res);\\n        \\n        int maxChildSum = max(leftSum, rightSum);\\n        \\n        int maxRootSum = max(maxChildSum + root->val, root->val);\\n        int maxTreeSum = max(maxRootSum, leftSum + rightSum + root->val);\\n        \\n        res = max(res, maxTreeSum);\\n        \\n        return maxRootSum;\\n    }\\n    \\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        maxPathSumHelper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693478,
                "title": "100-beats-cpp-c-code-tc-o-n-easy-code-dfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root, int &maxi){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lefti=max(0,solve(root->left,maxi));\\n        int righti=max(0,solve(root->right,maxi));\\n        // int op1=max(lefti,righti);\\n        // int op2=max(lefti+root->val,righti+root->val);\\n        // int op3=root->val+lefti+righti;\\n        // maxi=max(op1,max(op2,op3));\\n        // return maxi;\\n        maxi=max(maxi,lefti+righti+root->val);\\n        return max(lefti,righti)+root->val;\\n\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int maxi=INT_MIN;\\n        int result=solve(root,maxi);\\n        return max(maxi,result);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root, int &maxi){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lefti=max(0,solve(root->left,maxi));\\n        int righti=max(0,solve(root->right,maxi));\\n        // int op1=max(lefti,righti);\\n        // int op2=max(lefti+root->val,righti+root->val);\\n        // int op3=root->val+lefti+righti;\\n        // maxi=max(op1,max(op2,op3));\\n        // return maxi;\\n        maxi=max(maxi,lefti+righti+root->val);\\n        return max(lefti,righti)+root->val;\\n\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int maxi=INT_MIN;\\n        int result=solve(root,maxi);\\n        return max(maxi,result);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645311,
                "title": "c-easy-and-crisp-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxsum(TreeNode* root, int & maxi){\\n        if(!root) return 0;\\n        int l=max(maxsum(root->left,maxi),0);\\n        int r=max(maxsum(root->right,maxi),0);\\n        maxi=max(maxi,root->val+l+r);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root){\\n        int maxi=INT_MIN;\\n        maxsum(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxsum(TreeNode* root, int & maxi){\\n        if(!root) return 0;\\n        int l=max(maxsum(root->left,maxi),0);\\n        int r=max(maxsum(root->right,maxi),0);\\n        maxi=max(maxi,root->val+l+r);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root){\\n        int maxi=INT_MIN;\\n        maxsum(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169589,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        find_max(root, res);\\n        return res;\\n    }\\n\\n    int find_max(TreeNode* root, int& res) {\\n        if (root == nullptr) return 0;\\n\\n        int left_max = find_max(root->left, res);\\n        int right_max = find_max(root->right, res);\\n\\n        int sum = root->val;\\n        if (left_max > 0) sum += left_max;\\n        if (right_max > 0) sum += right_max;\\n        if (sum > res) res = sum;\\n\\n        int root_max = root->val;\\n        root_max += max(0, max(left_max, right_max));\\n        return root_max;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        self.sum = root.val\\n        def maxHelper( root: Optional[TreeNode]) -> int:\\n            l, r = 0, 0\\n            if root.left != None:\\n                l += maxHelper(root.left)\\n            if root.right != None:\\n                r += maxHelper(root.right)\\n\\n            sum1, sum2 = root.val, root.val\\n            if l > 0:\\n                sum1 += l\\n            if r > 0:\\n                sum1 += r\\n            \\n            if l > 0 or r > 0:\\n                sum2 += l if l > r else r\\n\\n            self.sum = sum2 if self.sum < sum2 else self.sum\\n            self.sum = sum1 if self.sum < sum1 else self.sum\\n            return sum2\\n        if root:\\n            maxHelper(root)\\n        return self.sum\\n```\\n\\n```Java []\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumHelper(root);\\n        return ans;\\n    }\\n\\n    public int maxPathSumHelper(TreeNode root) {\\n\\n         if(root == null) return 0;\\n         int left = maxPathSumHelper(root.left);\\n         int right = maxPathSumHelper(root.right);\\n         int max = Math.max(root.val, Math.max(Math.max(root.val+left, root.val+right), root.val+left+right)); \\n         ans = Math.max(ans, max);\\n        return Math.max(root.val, Math.max(root.val+left, root.val+right));\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        find_max(root, res);\\n        return res;\\n    }\\n\\n    int find_max(TreeNode* root, int& res) {\\n        if (root == nullptr) return 0;\\n\\n        int left_max = find_max(root->left, res);\\n        int right_max = find_max(root->right, res);\\n\\n        int sum = root->val;\\n        if (left_max > 0) sum += left_max;\\n        if (right_max > 0) sum += right_max;\\n        if (sum > res) res = sum;\\n\\n        int root_max = root->val;\\n        root_max += max(0, max(left_max, right_max));\\n        return root_max;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        self.sum = root.val\\n        def maxHelper( root: Optional[TreeNode]) -> int:\\n            l, r = 0, 0\\n            if root.left != None:\\n                l += maxHelper(root.left)\\n            if root.right != None:\\n                r += maxHelper(root.right)\\n\\n            sum1, sum2 = root.val, root.val\\n            if l > 0:\\n                sum1 += l\\n            if r > 0:\\n                sum1 += r\\n            \\n            if l > 0 or r > 0:\\n                sum2 += l if l > r else r\\n\\n            self.sum = sum2 if self.sum < sum2 else self.sum\\n            self.sum = sum1 if self.sum < sum1 else self.sum\\n            return sum2\\n        if root:\\n            maxHelper(root)\\n        return self.sum\\n```\n```Java []\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumHelper(root);\\n        return ans;\\n    }\\n\\n    public int maxPathSumHelper(TreeNode root) {\\n\\n         if(root == null) return 0;\\n         int left = maxPathSumHelper(root.left);\\n         int right = maxPathSumHelper(root.right);\\n         int max = Math.max(root.val, Math.max(Math.max(root.val+left, root.val+right), root.val+left+right)); \\n         ans = Math.max(ans, max);\\n        return Math.max(root.val, Math.max(root.val+left, root.val+right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042357,
                "title": "postorder-traversal-solution-with-pair-int-int-approach",
                "content": "# Intuition\\nIn this question we have to return maximum the sum of path between any 2 node. So, if we are present at root we have to compare between 3 entity :\\n1. Max path sum in left subtree(if exist).\\n2. Max path sum in right subtree(if exist).\\n3. sum of left, right subtree from node to root with root.\\n\\n# Approach\\nTake helper function pathSum with return type pair<int, int> where first int store the maximum path sum between any two node in a tree and second int store the maximum path sum of any node from the root node either from the left sub tree or right subtree. \\n\\n# Complexity\\n- Time complexity:\\nO(n) : As it traverse all nodes\\n\\n- Space complexity:\\nO(n) : if tree is skew tree.\\nO(logn) : if tree is a binary tree.\\n\\n# Abbreviation\\n\\n1. lpsum : maximum path sum exist between any 2 nodes in left subtree\\n2. rpsum : maximum path sum exist between any 2 nodes in right subtree\\n3. lsum : maximum sum from node to root in left subtree.\\n4. rsum : maximum sum from node to root in right subtree.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> pathSum(TreeNode* root){\\n        if(root == NULL){\\n            return {INT_MIN, INT_MIN};\\n        }\\n        pair<int, int> leftchild = pathSum(root->left);\\n        pair<int, int> rightchild = pathSum(root->right);\\n        int lpsum = leftchild.first;\\n        int lsum = leftchild.second;\\n        int rpsum = rightchild.first;\\n        int rsum = rightchild.second;\\n        // if leftsum or rightsum is less than 0 then initialise as zero as we don\\'t include that path in it\\n        if(lsum < 0){\\n            lsum = 0;\\n        }\\n        if(rsum < 0){\\n            rsum = 0;\\n        }\\n        int valu = lsum+rsum+root->val;\\n        int maxpsum = max(lpsum, max(rpsum, valu));\\n        return {maxpsum, max(lsum,rsum)+root->val};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        pair<int, int> ans = pathSum(root);\\n        return ans.first;\\n    }\\n};\\n```\\n\\nPlease do UPVOTE if you like it !!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> pathSum(TreeNode* root){\\n        if(root == NULL){\\n            return {INT_MIN, INT_MIN};\\n        }\\n        pair<int, int> leftchild = pathSum(root->left);\\n        pair<int, int> rightchild = pathSum(root->right);\\n        int lpsum = leftchild.first;\\n        int lsum = leftchild.second;\\n        int rpsum = rightchild.first;\\n        int rsum = rightchild.second;\\n        // if leftsum or rightsum is less than 0 then initialise as zero as we don\\'t include that path in it\\n        if(lsum < 0){\\n            lsum = 0;\\n        }\\n        if(rsum < 0){\\n            rsum = 0;\\n        }\\n        int valu = lsum+rsum+root->val;\\n        int maxpsum = max(lpsum, max(rpsum, valu));\\n        return {maxpsum, max(lsum,rsum)+root->val};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        pair<int, int> ans = pathSum(root);\\n        return ans.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900629,
                "title": "c-stacks-and-queue-modifying-tree-value",
                "content": "# Intuition\\nStart from bottom.\\nAt a node, there are 3 options:\\n* Choose the left path (left sum - lc)\\n* Choose the right path (right sum - rc)\\n* Choosing none (0)\\n\\nThe path is selected by checking the maximum value of these 3 options.\\nAdding the sum to node\\'s value acts like selecting a maximum sum path.\\n\\nBends can be handled easily just by adding left value , right value and node value for the node.\\n\\nThe maximum of all values for all nodes is our answer.\\n\\n# Approach\\nStore the nodes in a stack in level wise order (Bottom first and right to left)\\nPop and store elements from this stack. Make a variable that stores the sum of paths that have bends in them.\\nUpdate the node\\'s value by adding the larger of left path sum and right path sum(making sure new value is a greater value). \\nThe new result will be maximum of bended value, the node value and old result.\\n\\nWhen the stack is finished, res will return the maximum path sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        queue<TreeNode*> level;\\n        level.push(root);\\n        while(!level.empty()){\\n            TreeNode* temp = level.front();\\n            level.pop();\\n            st.push(temp);\\n            if(temp->left){\\n                level.push(temp->left);\\n            }\\n            if(temp->right){\\n                level.push(temp->right);\\n            }\\n        }\\n        int res=INT_MIN;\\n        while(!st.empty()){\\n            TreeNode* temp = st.top();\\n            st.pop();\\n            int lc = temp->left? temp->left->val : 0;\\n            int rc = temp->right? temp->right->val : 0;\\n            int bend = lc + rc + temp->val;\\n            temp->val += max(0,max(lc,rc));\\n            res = max(bend,max(res,temp->val));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        queue<TreeNode*> level;\\n        level.push(root);\\n        while(!level.empty()){\\n            TreeNode* temp = level.front();\\n            level.pop();\\n            st.push(temp);\\n            if(temp->left){\\n                level.push(temp->left);\\n            }\\n            if(temp->right){\\n                level.push(temp->right);\\n            }\\n        }\\n        int res=INT_MIN;\\n        while(!st.empty()){\\n            TreeNode* temp = st.top();\\n            st.pop();\\n            int lc = temp->left? temp->left->val : 0;\\n            int rc = temp->right? temp->right->val : 0;\\n            int bend = lc + rc + temp->val;\\n            temp->val += max(0,max(lc,rc));\\n            res = max(bend,max(res,temp->val));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900612,
                "title": "c-begineer-friendly-easy-understanding-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/IIn-jtjniXw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int sum =INT_MIN;\\n\\n    int maxPathSum(TreeNode* root) {\\n\\n        calcualteMaxPathSum(root);\\n        return sum;\\n\\n    }\\n    // max sum path including root of the tree.\\n    int calcualteMaxPathSum(TreeNode* root){\\n        if(root == NULL) return 0;\\n\\n        //if lhsum is comming -ve so we will return 0;\\n\\n      int  lhsum = max(0,calcualteMaxPathSum(root->left));\\n      int  rhsum = max(0,calcualteMaxPathSum(root->right));\\n\\n\\n        //updating the value in the sum.. // maximum sum upto now.(can be subtree sum)\\n        sum = max(sum,root->val+lhsum+rhsum);\\n\\n\\n        //returning the maxximum sum possible.. using which path.\\n        return max(lhsum,rhsum) + root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int sum =INT_MIN;\\n\\n    int maxPathSum(TreeNode* root) {\\n\\n        calcualteMaxPathSum(root);\\n        return sum;\\n\\n    }\\n    // max sum path including root of the tree.\\n    int calcualteMaxPathSum(TreeNode* root){\\n        if(root == NULL) return 0;\\n\\n        //if lhsum is comming -ve so we will return 0;\\n\\n      int  lhsum = max(0,calcualteMaxPathSum(root->left));\\n      int  rhsum = max(0,calcualteMaxPathSum(root->right));\\n\\n\\n        //updating the value in the sum.. // maximum sum upto now.(can be subtree sum)\\n        sum = max(sum,root->val+lhsum+rhsum);\\n\\n\\n        //returning the maxximum sum possible.. using which path.\\n        return max(lhsum,rhsum) + root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899155,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function (root) {\\n  const ans = { val: -Infinity };\\n  dfs(root, ans);\\n\\n  return ans.val;\\n};\\n\\nfunction dfs(root, ans) {\\n  if (!root) return 0;\\n\\n  const left = dfs(root.left, ans);\\n  const right = dfs(root.right, ans);\\n\\n  const maxVal = Math.max(root.val, root.val + left, root.val + right);\\n  ans.val = Math.max(ans.val, maxVal, root.val + left + right);\\n\\n  return maxVal;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function (root) {\\n  const ans = { val: -Infinity };\\n  dfs(root, ans);\\n\\n  return ans.val;\\n};\\n\\nfunction dfs(root, ans) {\\n  if (!root) return 0;\\n\\n  const left = dfs(root.left, ans);\\n  const right = dfs(root.right, ans);\\n\\n  const maxVal = Math.max(root.val, root.val + left, root.val + right);\\n  ans.val = Math.max(ans.val, maxVal, root.val + left + right);\\n\\n  return maxVal;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899116,
                "title": "java-code-solution-it-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) as we have to traverse all of the nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) as we are using a recursion stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int maxsum;\\n    public int maxPathSum(TreeNode root) {\\n        maxsum = Integer.MIN_VALUE;\\n        maxPathSumUtil(root);\\n        return maxsum;\\n    }\\n    \\n    public int maxPathSumUtil(TreeNode root){\\n        if(root==null) return 0;\\n        int leftMaxSum = Math.max(0,maxPathSumUtil(root.left));\\n        int rightMaxSum = Math.max(0,maxPathSumUtil(root.right));\\n        \\n        maxsum = Math.max(maxsum, root.val+leftMaxSum+rightMaxSum);\\n        return root.val+Math.max(leftMaxSum, rightMaxSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    int maxsum;\\n    public int maxPathSum(TreeNode root) {\\n        maxsum = Integer.MIN_VALUE;\\n        maxPathSumUtil(root);\\n        return maxsum;\\n    }\\n    \\n    public int maxPathSumUtil(TreeNode root){\\n        if(root==null) return 0;\\n        int leftMaxSum = Math.max(0,maxPathSumUtil(root.left));\\n        int rightMaxSum = Math.max(0,maxPathSumUtil(root.right));\\n        \\n        maxsum = Math.max(maxsum, root.val+leftMaxSum+rightMaxSum);\\n        return root.val+Math.max(leftMaxSum, rightMaxSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616820,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode *root, int &ans){\\n        if(root==nullptr) return 0;        \\n        int l = solve(root->left, ans);\\n        int r = solve(root->right, ans);\\n        int v = root->val;\\n        ans = max({ans, v, r+l+v, r+v, l+v});\\n        return max(max(r,l)+v, v);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int ans=-1001;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode *root, int &ans){\\n        if(root==nullptr) return 0;        \\n        int l = solve(root->left, ans);\\n        int r = solve(root->right, ans);\\n        int v = root->val;\\n        ans = max({ans, v, r+l+v, r+v, l+v});\\n        return max(max(r,l)+v, v);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int ans=-1001;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485475,
                "title": "python-what-is-a-path-intuition-for-the-problem",
                "content": "This problem is a mash up of\\n* https://leetcode.com/problems/maximum-depth-of-binary-tree/ BT height/width\\n* https://leetcode.com/problems/diameter-of-binary-tree/ BT height/width\\n* https://leetcode.com/problems/maximum-subarray/ Kadane\\'s algo applied to a tree\\n* https://leetcode.com/problems/longest-univalue-path/ BT path\\n\\nIf you understand all of the above, there\\'s nothing to solve here.\\n\\nThe crux of the problem is the \"path\" definition. A few examples what\\'s path and what\\'s not.\\nAs it\\'s said \"a picture is worth a thousand words\":\\n\\n**What is a path here?**\\n\\nYou can imagine a path as a road (set of nodes). You can turn left or right. But you **cannot turn left and right** at the same time. Path can be a single node, or it can be a linked-list like skewed tree. It can start anywhere and also end in the middle of the tree.\\n\\n![image](https://assets.leetcode.com/users/images/d5202c73-011e-4ecd-bd23-02979540997e_1661544784.4822035.png)\\n\\n**How to solve the problem with a few examples?**\\n\\nWe are going to build and check paths from the tree leaves and up to the root, from bottom to top.\\n\\nWe\\'ll need to use a **post order traversal** for this. (offtop: btw, the same idea with Binary Tree Cameras problem)\\nWhy?\\n\\nPost-order processing: *process left subtree paths*, *process right subtree paths*, and only then **process root**.\\n\\nBecause in order to make a decision - \"pick the left subtree path or pick the right subtree path\", we need to know information from the node children beforehand.\\n\\n```\\nleft_path_sum = postorder(node.left)\\nright_path_sum = postorder(node.right)\\n\\n# info processing code\\n```\\n\\nWe have info from the left subtree, the right subtree and the node - so we can make some decision about path building. \\n\\n**How Kadane\\'s algo ideas and max sum are related to the problem?**\\n\\nLet\\'s look at examples where we need to make decisions:\\n\\n**Case #1**\\nYellow node needs to decide if it\\'s going to join the path from left subtree or from the right subtree.\\n\\n![image](https://assets.leetcode.com/users/images/49e5b58c-a7f4-4bc2-8763-05ee288adcef_1661548368.0108829.png)\\n\\nHere it\\'s easy: pick the one with the max sum. In our case:\\n\\n80 + 0 vs 5+100 + 0\\n\\nObviously we choose 105 and form a path 5->100->0.\\n\\nLogic to handle the case:\\n```\\npath_sum = max(left_path_sum + node.val, right_path_sum + node.val)\\n```\\n\\n**Case #2**\\nYellow node needs to decide if it\\'s going to join the path from left subtree or from the right subtree.\\nNow what heppens in this case???\\n\\n![image](https://assets.leetcode.com/users/images/ddd7e50f-a496-4ad3-93e0-32a5d58ab770_1661549406.0686157.png)\\n\\nPick the one with the max sum... but wait! left path sum = -50, right path sum = -85\\n\\n-50 vs -85\\n\\nWhich one is the best???\\n\\n**NEITHER!!!**\\n\\nLet\\'s see what\\'s going on: building a path with the left path is -50+100 = 50. With the right path is -85+100 = 15.\\n\\nHere\\'s where the idea from Kadane\\'s algo come into play...\\nWe choose neither and start building the path from scratch from the node that we have.\\n\\n-50 vs -85 **vs 100**\\n\\nLogic to handle the cases 1-2:\\n```\\npath_sum = max(node.val, left_path_sum + node.val, right_path_sum + node.val)\\n```\\n\\nRemember about \"**cannot turn left and right** at the same time\"? That is where we decide how we build the path - join left part or right. So we have the option #3: start building a path from scratch from the node.\\n\\n**Case with only negative numbers**\\nWhat if we have negative values. Only negative values.\\n\\n![image](https://assets.leetcode.com/users/images/23e815ce-ef90-4792-a2f2-1385d097e4a5_1661550144.2250712.png)\\n\\nIn this case logic from case #2 will handle the case. How?\\n\\nEvery time the node see\\'s that there\\'s an option to build a new better path with max sum from scratch, it will do it. Pick max from (node_left_path + node.val, node_right_path + node.val, node.val)\\n\\nThis way we will have the following paths: -100, -15, -50, -200. Pick the max values from the paths.\\n\\n---\\n\\n**There is one more important case #3**\\nGoing back to our case #1 example:\\n\\nBut is this the max possible path where the node \"0\" is a part of?\\nSo far we checked the following path: 5, 5+100, 5+100+0, 80, 80+0.\\n\\n![image](https://assets.leetcode.com/users/images/49e5b58c-a7f4-4bc2-8763-05ee288adcef_1661548368.0108829.png)\\n\\n*Here it\\'s easy: pick the one with the max sum. In our case:*\\n*80 + 0 vs 5+100 + 0*\\n*Obviously we choose 105 and form a path 5->100->0.*\\n\\nBut is this the max path sum???\\n\\n---\\n!!!\\nThe most important part of the problem is to understand that the path can be not only **root -> left path** or **root -> right path**, **BUT** path can also **go through the node itself** starting from the **left path -> subtree root -> the right path**.\\n!!!\\n\\n---\\n\\nYes. this is a valid path too. It does not \"turn left and right at the same time\" and gives us the max path sum for the node \"0\".\\n\\n![image](https://assets.leetcode.com/users/images/5368634d-0889-4576-8621-e1a0f6dde6a0_1661551187.5639656.png)\\n\\nHere it\\'s **not that** easy: pick the one with left + root + right paths. In our case:\\n80 + 0 vs 5+100 + 0 **vs 80 + 0 + 5 + 100**\\nObviously we choose max 185 and form a path 80->0->100->5*.\\n\\nHow do we handle the logic? The way we described it with words:\\n\\n```\\n# pick max from current_node or left_path + current_node or right_path + current_node\\npath_sum = max(current_node.val, left_path_sum + current_node.val, right_path_sum + current_node.val) # cases 1-2\\n\\n# pick global max path sum: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\nself.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val) # case 3\\n```\\n\\nThat\\'s it!\\n\\nThe full source code for the problem:\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node: # no node - no value, aka the empty sum = 0\\n                return 0\\n            \\n            left = postorder(node.left) # get left max path sum\\n            right = postorder(node.right) # get right max path sum\\n            \\n\\t\\t\\t# pick max from (current_node_only, left_path + current_node, right_path + current_node)\\n\\t\\t\\t# \\'local node\\' max path sum\\n            path_sum = max(node.val, max(left, right) + node.val)\\n\\t\\t\\t\\n\\t\\t\\t# pick global max path: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\n\\t\\t\\t# \\'global\\' max path sum\\n            self.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val)\\n            \\n\\t\\t\\t# return current path max sum - local max_sum\\n            return path_sum\\n\\n\\t\\t# we might have negative path sum only trees, so use \"-infinity\"\\n        self.max_path_sum = float(-inf)\\n        postorder(root) # find the \\'global\\' max path sum\\n        return self.max_path_sum\\n```\\n\\nThat\\'s it!\\n\\nOK. More like dp on trees approach without the \"global/local\" variable.\\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node:\\n                return (float(-inf),0) # global_max_path_sum, path_sum\\n            \\n            left = postorder(node.left)\\n            right = postorder(node.right)\\n            \\n            path_sum = max(node.val, max(left[1],right[1]) + node.val)\\n            max_path_sum = max(left[0], right[0], path_sum, left[1] + right[1] + node.val)\\n            \\n            return (max_path_sum, path_sum)\\n        \\n        return postorder(root)[0]\\n```\\n\\n( \\u25D1\\u203F\\u25D1)\\u0254\\u250F\\uD83C\\uDF5F--\\uD83C\\uDF54\\u2511\\u0669(^\\u25E1^ )\\n\\nIf you liked the read, **upvote so the other people can see it too.**\\n\\nP.S. I think after solving \"Binary Tree Cameras\" I mastered the post order traversl that I can now do anything with it.\\n\\nP.P.S. https://leetcode.com/problems/diameter-of-binary-tree/ and this one has quite copy+paste like code. The intuition is different: find \"node\\'s left height + right height + 1\" vs \"max path sum between any 2 nodes\"",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nleft_path_sum = postorder(node.left)\\nright_path_sum = postorder(node.right)\\n\\n# info processing code\\n```\n```\\npath_sum = max(left_path_sum + node.val, right_path_sum + node.val)\\n```\n```\\npath_sum = max(node.val, left_path_sum + node.val, right_path_sum + node.val)\\n```\n```\\n# pick max from current_node or left_path + current_node or right_path + current_node\\npath_sum = max(current_node.val, left_path_sum + current_node.val, right_path_sum + current_node.val) # cases 1-2\\n\\n# pick global max path sum: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\nself.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val) # case 3\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node: # no node - no value, aka the empty sum = 0\\n                return 0\\n            \\n            left = postorder(node.left) # get left max path sum\\n            right = postorder(node.right) # get right max path sum\\n            \\n\\t\\t\\t# pick max from (current_node_only, left_path + current_node, right_path + current_node)\\n\\t\\t\\t# \\'local node\\' max path sum\\n            path_sum = max(node.val, max(left, right) + node.val)\\n\\t\\t\\t\\n\\t\\t\\t# pick global max path: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\n\\t\\t\\t# \\'global\\' max path sum\\n            self.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val)\\n            \\n\\t\\t\\t# return current path max sum - local max_sum\\n            return path_sum\\n\\n\\t\\t# we might have negative path sum only trees, so use \"-infinity\"\\n        self.max_path_sum = float(-inf)\\n        postorder(root) # find the \\'global\\' max path sum\\n        return self.max_path_sum\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node:\\n                return (float(-inf),0) # global_max_path_sum, path_sum\\n            \\n            left = postorder(node.left)\\n            right = postorder(node.right)\\n            \\n            path_sum = max(node.val, max(left[1],right[1]) + node.val)\\n            max_path_sum = max(left[0], right[0], path_sum, left[1] + right[1] + node.val)\\n            \\n            return (max_path_sum, path_sum)\\n        \\n        return postorder(root)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309746,
                "title": "go-26-lines-o-n",
                "content": "```\\nfunc maxPathSum(root *TreeNode) int {\\n    globalMax := -1<<63\\n    dfs(root, &globalMax)\\n    return globalMax\\n}\\n\\nfunc dfs(root *TreeNode, globalMax *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n\\n    pathSumFromLeft := max(dfs(root.Left, globalMax), 0)\\n    pathSumFromRight := max(dfs(root.Right, globalMax), 0)\\n    \\n    *globalMax = max(*globalMax, root.Val + pathSumFromLeft + pathSumFromRight)\\n    \\n    return root.Val + max(pathSumFromLeft, pathSumFromRight) \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc maxPathSum(root *TreeNode) int {\\n    globalMax := -1<<63\\n    dfs(root, &globalMax)\\n    return globalMax\\n}\\n\\nfunc dfs(root *TreeNode, globalMax *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n\\n    pathSumFromLeft := max(dfs(root.Left, globalMax), 0)\\n    pathSumFromRight := max(dfs(root.Right, globalMax), 0)\\n    \\n    *globalMax = max(*globalMax, root.Val + pathSumFromLeft + pathSumFromRight)\\n    \\n    return root.Val + max(pathSumFromLeft, pathSumFromRight) \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2130341,
                "title": "simple-clean-faster-than-95-c",
                "content": "The code is self explanatory ! Have a look : ) \\n```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;    // store the maximum \\n    int sum(TreeNode *root){\\n        if(!root)return 0;\\n        \\n        int a = sum(root->right);  // maximum path *starting* from root->right \\n        int b = sum(root->left);   // maximum path *starting* from root->right\\n        \\n        maxi = max({maxi,root->val,root->val+a,root->val+b,root->val+a+b});\\n        return max({root->val,root->val+a,root->val+b});  // return maximum path starting from root itself \\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n      int _ = sum(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;    // store the maximum \\n    int sum(TreeNode *root){\\n        if(!root)return 0;\\n        \\n        int a = sum(root->right);  // maximum path *starting* from root->right \\n        int b = sum(root->left);   // maximum path *starting* from root->right\\n        \\n        maxi = max({maxi,root->val,root->val+a,root->val+b,root->val+a+b});\\n        return max({root->val,root->val+a,root->val+b});  // return maximum path starting from root itself \\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n      int _ = sum(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954827,
                "title": "recursion-easy-to-unuderstand-c",
                "content": "```class Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int maxPathSum(TreeNode* root) {\\n        solve(root,ans);\\n        return ans;\\n    }\\n    \\n    int solve(TreeNode* root,int &ans)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=solve(root->left,ans);\\n        int right=solve(root->right,ans);\\n        ans=max({ans,left+right+root->val,left+root->val,right+root->val,root->val});\\n        return max({root->val,root->val+left,root->val+right});\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int maxPathSum(TreeNode* root) {\\n        solve(root,ans);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1775976,
                "title": "divide-and-conquer-method-in-python-time-o-n-explained-very-clearly",
                "content": "**Divide and Conquer**!\\n\\nFirst we need to understand when reaching a node, what should we compare and return.\\n\\n**For example:**\\na tree like this\\n```\\n     [5]\\n   [3, 6]\\n[2, 7, -8, -9]\\n```\\n\\nSuppose now we are at level 1, we need to compare **three** possible cases:\\n* maximum path sum of the **left subtree of 5** (3 as a root)\\n\\twhich is [2, 3, 7] in our example\\n* maximum path sum of the **right subtree of 5** (6 as a root)\\n\\twhich is [6] in our example\\n* maximum path sum of the tree 5 that **includes root 5 in the path**\\n\\nNow the question comes to, how could we get the maximum path sum of the tree 5 that includes root 5 in the path?\\nThe answer should be: We need to know the **left maximum chain**  and **the right maximum chain**!\\n**In the example**, it should be:\\n* left maximum chain: [3, 7]\\n* right maximum chain: [6]\\n\\n**The requirement of maximum chain** is that: it must include the root, and can only goes one direction down, in our example:\\n* left maximum chain: from [3, 7], [3, 2], and [3], we choose [3, 7]\\n* right maximum chain: from [6, -8], [6, -9], and [6], we choose [6]\\n\\nSo, maximum path sum of the tree 5 that includes root 5 should be [3, 7, 5, 6]:\\nleft maximum chain [3, 7] + root 5 + right maximum chain [6]\\n\\nSo now, we understand that, at each subtree of the divide and conquer helper function, we need to **return two things**:\\n* **maximum path sum** of this subtree\\n* **maximum path chain** that includes root of this subtree\\n\\n**Time:** O(n)\\n**Space:** O(H), to keep the recursion stack, H is the height of the binary tree, worst case O(n)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        \\n        max_sum, _ = self.divideConquer(root)\\n        return max_sum\\n    \\n    def divideConquer(self, node):\\n\\n        if not node:\\n            return float(\\'-inf\\'), 0\\n        \\n        # Divide and conquer, return the maximum path of both left and right subtree of root node, and also return the maximum path chain of both left and right subtree of root node\\n        left_sum, left_chain = self.divideConquer(node.left)\\n        right_sum, right_chain = self.divideConquer(node.right)\\n        \\n        # If any maximum path chain is negative, we will update it to 0, meaning that we will not go down that chain\\n        left_chain = max(left_chain, 0)\\n        right_chain = max(right_chain, 0)\\n\\n        # Construct the maximum path that includes root node\\n        root_sum = node.val + left_chain + right_chain\\n\\n        # Now compare three possible cases, that is\\n        # maximum path sum of the left subtree, maximum path sum of the right subtree, and maximum path sum of the current tree that includes root  \\n        max_sum = max(left_sum, right_sum, root_sum)\\n\\n        # We also need to return the maximum path chain of the current tree\\n        max_chain = max(left_chain, right_chain) + node.val\\n        \\n        return max_sum, max_chain\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\n     [5]\\n   [3, 6]\\n[2, 7, -8, -9]\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        \\n        max_sum, _ = self.divideConquer(root)\\n        return max_sum\\n    \\n    def divideConquer(self, node):\\n\\n        if not node:\\n            return float(\\'-inf\\'), 0\\n        \\n        # Divide and conquer, return the maximum path of both left and right subtree of root node, and also return the maximum path chain of both left and right subtree of root node\\n        left_sum, left_chain = self.divideConquer(node.left)\\n        right_sum, right_chain = self.divideConquer(node.right)\\n        \\n        # If any maximum path chain is negative, we will update it to 0, meaning that we will not go down that chain\\n        left_chain = max(left_chain, 0)\\n        right_chain = max(right_chain, 0)\\n\\n        # Construct the maximum path that includes root node\\n        root_sum = node.val + left_chain + right_chain\\n\\n        # Now compare three possible cases, that is\\n        # maximum path sum of the left subtree, maximum path sum of the right subtree, and maximum path sum of the current tree that includes root  \\n        max_sum = max(left_sum, right_sum, root_sum)\\n\\n        # We also need to return the maximum path chain of the current tree\\n        max_chain = max(left_chain, right_chain) + node.val\\n        \\n        return max_sum, max_chain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454245,
                "title": "postorder-traversal-kadane-algortihm-commented",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    \\n    int traverse(TreeNode *root){\\n        if(!root) return 0;\\n        \\n        int left = traverse(root->left);\\n        int right = traverse(root->right);\\n        \\n        // same as kadane\\'s algo. if negative, make 0\\n        left = (left < 0) ? 0 : left;\\n        right = (right < 0) ? 0 : right;\\n        \\n        // max sum will be root data + left sum + right sum\\n        res = max(res, root->val + left + right);\\n        \\n        // we need path\\'s sum not whole subtree sum; so, return only max sum from left or right\\n        return root->val + max(left, right);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        traverse(root);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    \\n    int traverse(TreeNode *root){\\n        if(!root) return 0;\\n        \\n        int left = traverse(root->left);\\n        int right = traverse(root->right);\\n        \\n        // same as kadane\\'s algo. if negative, make 0\\n        left = (left < 0) ? 0 : left;\\n        right = (right < 0) ? 0 : right;\\n        \\n        // max sum will be root data + left sum + right sum\\n        res = max(res, root->val + left + right);\\n        \\n        // we need path\\'s sum not whole subtree sum; so, return only max sum from left or right\\n        return root->val + max(left, right);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        traverse(root);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361330,
                "title": "java-faster-than-100",
                "content": "```\\npublic class BinaryTreeMaximumPathSumProblem {\\n\\n    int maxSum = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum(root);\\n\\n        return maxSum;\\n    }\\n\\n    /*\\n    Steps:\\n    1. check for edge case [null node]\\n    2. calculate left and right sum by recursively calling the child nodes\\n    3. store currSum as the sum of node value, left and right sum\\n    4. update the max sum if current sum is greater\\n    5. return the sum of node value and max of left/right node\\n\\n    Time complexity: O(N), where N is number of nodes, since we visit each node not more than 2 times.\\n\\n    Space complexity: O(H), where H is a tree height, to keep the recursion stack. \\n    In the average case of balanced tree, the tree height H = logN, in the worst case of skewed tree, H=N.\\n    */\\n    public int maxSum(TreeNode node) {\\n\\n        if (node == null) return 0;\\n\\n        int leftSum = Math.max(maxSum(node.left), 0);\\n        int rightSum = Math.max(maxSum(node.right), 0);\\n\\n        int currSum = node.val + leftSum + rightSum;\\n\\n        if (currSum > maxSum) maxSum = currSum;\\n\\n        return node.val + Math.max(leftSum, rightSum);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/b414232c-f008-4cc8-8200-6689b908d8f6_1627197889.2321608.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class BinaryTreeMaximumPathSumProblem {\\n\\n    int maxSum = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum(root);\\n\\n        return maxSum;\\n    }\\n\\n    /*\\n    Steps:\\n    1. check for edge case [null node]\\n    2. calculate left and right sum by recursively calling the child nodes\\n    3. store currSum as the sum of node value, left and right sum\\n    4. update the max sum if current sum is greater\\n    5. return the sum of node value and max of left/right node\\n\\n    Time complexity: O(N), where N is number of nodes, since we visit each node not more than 2 times.\\n\\n    Space complexity: O(H), where H is a tree height, to keep the recursion stack. \\n    In the average case of balanced tree, the tree height H = logN, in the worst case of skewed tree, H=N.\\n    */\\n    public int maxSum(TreeNode node) {\\n\\n        if (node == null) return 0;\\n\\n        int leftSum = Math.max(maxSum(node.left), 0);\\n        int rightSum = Math.max(maxSum(node.right), 0);\\n\\n        int currSum = node.val + leftSum + rightSum;\\n\\n        if (currSum > maxSum) maxSum = currSum;\\n\\n        return node.val + Math.max(leftSum, rightSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122979,
                "title": "java-0ms-all-test-cases-covered",
                "content": "```\\nclass Solution {\\n    int pathsum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path_sum(root);\\n        return pathsum;\\n    }\\n    int path_sum(TreeNode node){\\n        if(node==null){\\n            return 0;\\n        }\\n        \\n        int left= path_sum(node.left);\\n        int right= path_sum(node.right);\\n        \\n        pathsum= Math.max(node.val, Math.max(node.val + left, Math.max(node.val + right, Math.max(node.val+left+right, pathsum))));\\n        \\n        return Math.max(node.val, Math.max(node.val + left, node.val+right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int pathsum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path_sum(root);\\n        return pathsum;\\n    }\\n    int path_sum(TreeNode node){\\n        if(node==null){\\n            return 0;\\n        }\\n        \\n        int left= path_sum(node.left);\\n        int right= path_sum(node.right);\\n        \\n        pathsum= Math.max(node.val, Math.max(node.val + left, Math.max(node.val + right, Math.max(node.val+left+right, pathsum))));\\n        \\n        return Math.max(node.val, Math.max(node.val + left, node.val+right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924563,
                "title": "concise-java-solution-using-dfs-beats-100",
                "content": "```\\nclass Solution {\\n    \\n    private int result;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        \\n        result = Integer.MIN_VALUE;\\n        \\n        getMaxSum(root);\\n        \\n        return result;\\n    }\\n    \\n    private int getMaxSum(TreeNode node)\\n    {\\n        if (node == null)\\n            return 0;\\n        \\n        int leftSum = getMaxSum(node.left);\\n        int rightSum = getMaxSum(node.right);\\n        \\n        result = Math.max(result, node.val + leftSum + rightSum);\\n        \\n        // We will not count the path if the max path sum is less than zero\\n        return Math.max(0, node.val + Math.max(leftSum, rightSum));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int result;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        \\n        result = Integer.MIN_VALUE;\\n        \\n        getMaxSum(root);\\n        \\n        return result;\\n    }\\n    \\n    private int getMaxSum(TreeNode node)\\n    {\\n        if (node == null)\\n            return 0;\\n        \\n        int leftSum = getMaxSum(node.left);\\n        int rightSum = getMaxSum(node.right);\\n        \\n        result = Math.max(result, node.val + leftSum + rightSum);\\n        \\n        // We will not count the path if the max path sum is less than zero\\n        return Math.max(0, node.val + Math.max(leftSum, rightSum));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767082,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int sum=INT_MIN;\\n        helper(root,sum);\\n        return sum;\\n    }\\n    int helper(TreeNode* root, int &sum)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=max(0,helper(root->left,sum));\\n        int r=max(0,helper(root->right,sum));\\n        \\n        sum=max(sum, root->val+l+r);\\n        return (root->val +max(l,r));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int sum=INT_MIN;\\n        helper(root,sum);\\n        return sum;\\n    }\\n    int helper(TreeNode* root, int &sum)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=max(0,helper(root->left,sum));\\n        int r=max(0,helper(root->right,sum));\\n        \\n        sum=max(sum, root->val+l+r);\\n        return (root->val +max(l,r));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727545,
                "title": "super-easy-python-o-n-time-single-traversal",
                "content": "\\n**Super Easy - Python - O(n) Time (Single Traversal)**\\n\\nSimple Code Performing a One-Time Traversal through the Binary Tree with O(n) Time Complexity . The bulk of the work is made by the internal MaxPath function.\\n\\nMaxPath function highlights:\\n\\n1. Each call to the function MaxPath(node) returns the branch with the highest sum starting from \"node\".\\n2. The best path possible is calculated as an in-between move, by attempting to join the left and right branches into one arc.\\n3. Any negative values for the \"left\" and \"right\" branches are ignored, as if they hadn\\'t existed.\\n\\nI think this problem should be \"Medium\" difficulty with all due respect. Cheers,\\n\\n```\\nfmax = lambda x,y: x if x>y else y # Custom Max Function (33% Faster than Python\\'s Built-in Max function)\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.result = root.val\\n        def maxpath(node):\\n            if not node:\\n                return 0\\n            x = node.val\\n            l = fmax(0,maxpath(node.left )) # ignore \"left\" branch if negative\\n            r = fmax(0,maxpath(node.right)) # ignore \"right\" branch if negative\\n            self.result = fmax(self.result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\\n            return fmax(x+l,x+r) # Try to build maximum branch value\\n        maxpath(root)\\n        return self.result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfmax = lambda x,y: x if x>y else y # Custom Max Function (33% Faster than Python\\'s Built-in Max function)\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.result = root.val\\n        def maxpath(node):\\n            if not node:\\n                return 0\\n            x = node.val\\n            l = fmax(0,maxpath(node.left )) # ignore \"left\" branch if negative\\n            r = fmax(0,maxpath(node.right)) # ignore \"right\" branch if negative\\n            self.result = fmax(self.result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\\n            return fmax(x+l,x+r) # Try to build maximum branch value\\n        maxpath(root)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673314,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\n   int res;\\n    public:\\n    int maxPathSum(TreeNode* root) {\\n        res = INT_MIN;\\n        call(root);\\n        return res;\\n    }\\n    int call(TreeNode* root)\\n    {\\n        if(root==NULL)return 0;\\n        int l = call(root->left);\\n        int r = call(root->right);\\n        int data_without = max(root->val,max(l,r)+root->val);\\n        int data_with = max(data_without, l+r+root->val);\\n        res = max(res,data_with);\\n        return data_without;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n   int res;\\n    public:\\n    int maxPathSum(TreeNode* root) {\\n        res = INT_MIN;\\n        call(root);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 611877,
                "title": "in-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n\\nint maxPathSumInt(struct TreeNode* root, int *max)\\n{\\n    if (root == NULL) {\\n        return 0;\\n    }\\n    \\n    int left = maxPathSumInt(root->left, max);\\n    int right = maxPathSumInt(root->right, max);\\n    \\n    left = MAX(left, 0);\\n    right = MAX(right, 0);\\n\\n    // XXX: what about int overflows?\\n    int curr = left + root->val + right;\\n    *max = MAX(*max, curr);\\n\\n    return root->val + MAX(left, right);\\n}\\n    \\n\\nint maxPathSum(struct TreeNode* root)\\n{\\n    int max = INT_MIN;\\n    maxPathSumInt(root, &max);\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n\\nint maxPathSumInt(struct TreeNode* root, int *max)\\n{\\n    if (root == NULL) {\\n        return 0;\\n    }\\n    \\n    int left = maxPathSumInt(root->left, max);\\n    int right = maxPathSumInt(root->right, max);\\n    \\n    left = MAX(left, 0);\\n    right = MAX(right, 0);\\n\\n    // XXX: what about int overflows?\\n    int curr = left + root->val + right;\\n    *max = MAX(*max, curr);\\n\\n    return root->val + MAX(left, right);\\n}\\n    \\n\\nint maxPathSum(struct TreeNode* root)\\n{\\n    int max = INT_MIN;\\n    maxPathSumInt(root, &max);\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 603612,
                "title": "java-easy-o-n-solution",
                "content": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n       if (root!=null) maxPath(root);\\n        return max;\\n    }\\n    public void maxPath(TreeNode root) {\\n        int current = root.val;\\n          max = Math.max(max, current);\\n        if (root.right!=null){\\n            maxPath(root.right);\\n            root.val = Math.max(root.val, current+root.right.val);\\n            max = Math.max(max, current+root.right.val);\\n        } \\n        if (root.left!=null) {\\n            maxPath(root.left);\\n            root.val = Math.max(root.val, current+root.left.val);\\n            max = Math.max(max, current+root.left.val);\\n        }\\n        if (root.right!=null && root.left!=null){\\n          max = Math.max(max, current+root.left.val+root.right.val);\\n\\t\\t}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n       if (root!=null) maxPath(root);\\n        return max;\\n    }\\n    public void maxPath(TreeNode root) {\\n        int current = root.val;\\n          max = Math.max(max, current);\\n        if (root.right!=null){\\n            maxPath(root.right);\\n            root.val = Math.max(root.val, current+root.right.val);\\n            max = Math.max(max, current+root.right.val);\\n        } \\n        if (root.left!=null) {\\n            maxPath(root.left);\\n            root.val = Math.max(root.val, current+root.left.val);\\n            max = Math.max(max, current+root.left.val);\\n        }\\n        if (root.right!=null && root.left!=null){\\n          max = Math.max(max, current+root.left.val+root.right.val);\\n\\t\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416095,
                "title": "c-7-lines-with-explanation",
                "content": "```\\nclass Solution {\\nprivate:  \\n    // Partial sum is like a logger, it logs the max we\\'ve seen so far.\\n    int maxHelper(TreeNode* root, int& partialSum) {\\n        if (!root) return 0;\\n        int leftMine = maxHelper(root->left, partialSum), rightMine = maxHelper(root->right, partialSum); \\n        partialSum = max(partialSum, leftMine + rightMine + root->val); // Log the max we\\'ve seen\\n        return max(0, root->val + max(leftMine, rightMine)); // Here we are returning paths\\n    } // Since we are looking for the longest single path, we make a decision between\\n\\t// returning our current value plus either the left or the right path.\\n\\t// If a path sums to negative, we don\\'t want to return it, it won\\'t add to our longest path\\n      // If a path is positive, it will have a positive impact on our max path, so we want to \\n\\t  // return it as opposed to returning 0.\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res{numeric_limits<int>::min()};\\n        maxHelper(root, res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\nprivate:  \\n    // Partial sum is like a logger, it logs the max we\\'ve seen so far.\\n    int maxHelper(TreeNode* root, int& partialSum) {\\n        if (!root) return 0;\\n        int leftMine = maxHelper(root->left, partialSum), rightMine = maxHelper(root->right, partialSum); \\n        partialSum = max(partialSum, leftMine + rightMine + root->val); // Log the max we\\'ve seen\\n        return max(0, root->val + max(leftMine, rightMine)); // Here we are returning paths\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 301587,
                "title": "8-line-python-beats-90-very-clear",
                "content": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max = root.val\\n        def dfs(root):\\n            if not root: return 0\\n            left, right = dfs(root.left), dfs(root.right)\\n            self.max = max(self.max, root.val + left + right, left+root.val, right+root.val)\\n            return max(left+root.val, right+root.val, root.val)\\n        dfs(root)\\n        return self.max\\n```\\n\\nSo this one is a bit different from the other Path sum questions in that the path need not pass through the root. We do some kind of postorder traversal.\\n\\nNote that the return value in each call of the recursive function must be either: the root value + left value or root value + right value, or just the root value. We **cannot** return root value + left value + right value because otherwise that would end up being an invalid path in case some other tree node wants to include this value in its path. For example: (apology for formatting, tree is taken from the example)\\n\\n   **-10**\\n        / \\\\\\\\\\n  9    **20**\\n        / \\\\\\\\\\n     **15**   **7**\\nis an invalid path. However, the maximum path sum **can** be root value + left value + right value.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max = root.val\\n        def dfs(root):\\n            if not root: return 0\\n            left, right = dfs(root.left), dfs(root.right)\\n            self.max = max(self.max, root.val + left + right, left+root.val, right+root.val)\\n            return max(left+root.val, right+root.val, root.val)\\n        dfs(root)\\n        return self.max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233315,
                "title": "c-well-commented-solution-with-explanation",
                "content": "```\\n/* Idea ----- \\n   First, we calculate the maximum path value for each node such that the path starts from below (or at) the node\\n   However, in addition to this, we also keep track of the global maximum which also consists of paths going down a node\\n   The trick here is that if you go down a node, the journey is completed and you cannot go up again .\\n   Now, any maxPath sum will eventually come in the section of maxGoingDownRoot and hence will be updated \\n**/   \\n\\n/* Idea borrowed from below source */\\n\\n/* https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39775/Accepted-short-solution-in-Java */\\n\\n/* Tricky corner case ---- What if everything is negative */\\n\\nclass Solution\\n{    \\npublic:\\n    int maxSoFar = INT_MIN;\\n    int maxPathSum(TreeNode* root);\\n    int maxEndingAt(TreeNode* root);\\n};\\n\\n/* Returns the maximum path value ending at root */\\nint Solution :: maxEndingAt(TreeNode* root)\\n{\\n    // If root is not present, return 0\\n    if(!root) return 0;\\n    \\n    // Get the maximum path value ending at the left and right subtree \\n    int leftMax  = maxEndingAt(root->left);\\n    int rightMax = maxEndingAt(root->right);\\n    \\n    // The maximum value ending at root can include exactly one of them or none of them \\n    int maxEndingAtRoot = max({leftMax + root->val, rightMax + root->val, root->val});\\n    \\n    // Keep updating the global maximum\\n    maxSoFar = max(maxSoFar, maxEndingAtRoot);\\n    \\n    // Once you go down the root, the journey is finished\\n    int maxGoingDownRoot = leftMax + rightMax + root->val;\\n    \\n    // Check if going down can be beneficial. We are just going down virtually\\n    maxSoFar = max(maxSoFar, maxGoingDownRoot);\\n    \\n    // Return the max value ending at root, as per the definitions\\n    return maxEndingAtRoot;\\n}\\n\\n/* Returns the maximum value of the path anywhere in the tree */\\nint Solution :: maxPathSum(TreeNode* root)\\n{\\n    // Run the algorithm and keep track of the maximum path seen\\n    int maxFromRoot = maxEndingAt(root);\\n    \\n    // Return the updated global maximum\\n    return maxSoFar;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* Idea ----- \\n   First, we calculate the maximum path value for each node such that the path starts from below (or at) the node\\n   However, in addition to this, we also keep track of the global maximum which also consists of paths going down a node\\n   The trick here is that if you go down a node, the journey is completed and you cannot go up again .\\n   Now, any maxPath sum will eventually come in the section of maxGoingDownRoot and hence will be updated \\n**/   \\n\\n/* Idea borrowed from below source */\\n\\n/* https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39775/Accepted-short-solution-in-Java */\\n\\n/* Tricky corner case ---- What if everything is negative */\\n\\nclass Solution\\n{    \\npublic:\\n    int maxSoFar = INT_MIN;\\n    int maxPathSum(TreeNode* root);\\n    int maxEndingAt(TreeNode* root);\\n};\\n\\n/* Returns the maximum path value ending at root */\\nint Solution :: maxEndingAt(TreeNode* root)\\n{\\n    // If root is not present, return 0\\n    if(!root) return 0;\\n    \\n    // Get the maximum path value ending at the left and right subtree \\n    int leftMax  = maxEndingAt(root->left);\\n    int rightMax = maxEndingAt(root->right);\\n    \\n    // The maximum value ending at root can include exactly one of them or none of them \\n    int maxEndingAtRoot = max({leftMax + root->val, rightMax + root->val, root->val});\\n    \\n    // Keep updating the global maximum\\n    maxSoFar = max(maxSoFar, maxEndingAtRoot);\\n    \\n    // Once you go down the root, the journey is finished\\n    int maxGoingDownRoot = leftMax + rightMax + root->val;\\n    \\n    // Check if going down can be beneficial. We are just going down virtually\\n    maxSoFar = max(maxSoFar, maxGoingDownRoot);\\n    \\n    // Return the max value ending at root, as per the definitions\\n    return maxEndingAtRoot;\\n}\\n\\n/* Returns the maximum value of the path anywhere in the tree */\\nint Solution :: maxPathSum(TreeNode* root)\\n{\\n    // Run the algorithm and keep track of the maximum path seen\\n    int maxFromRoot = maxEndingAt(root);\\n    \\n    // Return the updated global maximum\\n    return maxSoFar;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39837,
                "title": "c-recursive-solution-beats-99-with-explanation",
                "content": "Basic idea:\\n- ```maxPathDownwards:``` denotes max sum from the current node downwards **including the current node**\\n- Traverse bottom-up and update ```ans = max(ans, (max(0, left) + max(0, right) + root->val));```, 0 here means we don't use the left/right son's downward path.\\n```\\nclass Solution {\\nprivate:\\n    int ans = -2147483648;\\npublic:\\n    int maxPathDownwards(TreeNode* root) {\\n        if (!root) return 0;\\n        int left = maxPathDownwards(root->left);\\n        int right = maxPathDownwards(root->right);\\n        ans = max(ans, (max(0, left) + max(0, right) + root->val));\\n        return root->val + max(0, max(left, right));\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        maxPathDownwards(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Interactive"
                ],
                "code": "```maxPathDownwards:```\n```ans = max(ans, (max(0, left) + max(0, right) + root->val));```\n```\\nclass Solution {\\nprivate:\\n    int ans = -2147483648;\\npublic:\\n    int maxPathDownwards(TreeNode* root) {\\n        if (!root) return 0;\\n        int left = maxPathDownwards(root->left);\\n        int right = maxPathDownwards(root->right);\\n        ans = max(ans, (max(0, left) + max(0, right) + root->val));\\n        return root->val + max(0, max(left, right));\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        maxPathDownwards(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39930,
                "title": "simple-and-easy-understood-recursive-c-code-with-o-n-time",
                "content": "    class Solution {\\n    public:\\n        int maxPathSum(TreeNode *root) {\\n            buildVector(root);\\n            return maxVal;\\n        }\\n        int buildVector(TreeNode *root){\\n            if(!root)\\n                return 0;\\n            int left = buildVector(root->left);\\n            int right = buildVector(root->right);\\n            //assume this node as root and calcu maxVal based on it\\n            int sum = root->val;\\n            if(left > 0)\\n                sum += left;\\n            if(right > 0)\\n                sum += right;\\n            if(sum > maxVal)\\n                maxVal = sum;\\n            //return val is either left or right node with this node\\n            left = left > right ? left : right;\\n            sum = root->val;\\n            if(left > 0)\\n                sum += left;\\n            return sum;\\n        }\\n    private:\\n        int maxVal = INT_MIN;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPathSum(TreeNode *root) {\\n            buildVector(root);\\n            return maxVal;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39953,
                "title": "a-java-solution-without-using-a-global-variable",
                "content": "I am using an array with only one element as a function parameter.\\n\\n\\n    public class Solution {\\n        public int maxPathSum(TreeNode root) {\\n            \\n            if (root==null) return 0;\\n            int[] max={Integer.MIN_VALUE};\\n            maxTree(root,max);\\n            return max[0];\\n            \\n        }\\n        //@Param:return the sum of the root value and largest branch\\n        private int maxTree(TreeNode root,int[] max){\\n            if (root==null) return 0;\\n            \\n            int left=root.left!=null?maxTree(root.left,max):Integer.MIN_VALUE;\\n            int right=root.right!=null?maxTree(root.right,max):Integer.MIN_VALUE;\\n            \\n            max[0]=Math.max(max[0],(left>0?left:0)+(right>0?right:0)+root.val);\\n    \\n            return root.val+((left>0||right>0)?Math.max(left,right):0);\\n    \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxPathSum(TreeNode root) {\\n            \\n            if (root==null) return 0;\\n            int[] max={Integer.MIN_VALUE}",
                "codeTag": "Java"
            },
            {
                "id": 3801935,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private int maxPath = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root.left == null && root.right == null) return root.val;\\n        helper(root);\\n        return maxPath;\\n    }\\n\\n    private int helper(TreeNode node) {\\n        if(node == null) return 0;\\n\\n        int left = Math.max(0, helper(node.left));\\n        int right = Math.max(0, helper(node.right));\\n        \\n        maxPath = Math.max(node.val + left + right, maxPath);\\n        return node.val + Math.max(left, right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int maxPath = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root.left == null && root.right == null) return root.val;\\n        helper(root);\\n        return maxPath;\\n    }\\n\\n    private int helper(TreeNode node) {\\n        if(node == null) return 0;\\n\\n        int left = Math.max(0, helper(node.left));\\n        int right = Math.max(0, helper(node.right));\\n        \\n        maxPath = Math.max(node.val + left + right, maxPath);\\n        return node.val + Math.max(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652916,
                "title": "commented-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(h)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxAll=INT_MIN;\\n    int maxSum(TreeNode*root){\\n        //Base case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        // go for left and right\\n        // we don\\'t want negative value to go forward\\n        int left=max(maxSum(root->left),0);\\n        int right=max(maxSum(root->right),0);\\n        \\n        maxAll=max(maxAll,root->val+left+right);\\n\\n        return root->val+max(left,right);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int sum = maxSum(root);\\n        return maxAll;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxAll=INT_MIN;\\n    int maxSum(TreeNode*root){\\n        //Base case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        // go for left and right\\n        // we don\\'t want negative value to go forward\\n        int left=max(maxSum(root->left),0);\\n        int right=max(maxSum(root->right),0);\\n        \\n        maxAll=max(maxAll,root->val+left+right);\\n\\n        return root->val+max(left,right);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int sum = maxSum(root);\\n        return maxAll;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647138,
                "title": "easy-to-understand-8-liner-dfs-recursion-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWell if you read the question carefully and observe ...you will get the vibe of easy dfs only where we need to store all possibilities at each node and store the maximum of them. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we have 4 possibilities\\n1. ans will lie in below three only (2nd example)\\n2. ans will lie somewhere upper root side which take advantage of left part of current node\\n3. ans will lie somewhere upper root side which take advantage of right part of current node\\n4. ans will be just root without any previous involvement.(ex-[2,-1]...here ans will be 2 only)\\nAt every point we return left_part_max and righ_part_max\\nlets take a variable to store res which takes the maximum of all 4 possibilities.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//--------------------------------normal dfs----------------\\n    pair<int,int> dfs(TreeNode *root,int &res){\\n        if(root==NULL) return {0,0};\\n        pair<int,int> left_part = dfs(root->left,res);\\n        pair<int,int> right_part = dfs(root->right,res);\\n        // if your desired tree exist below this root only hemce no upper connection\\n        int no_upper_conn  = max(left_part.first,left_part.second)+max(right_part.first,right_part.second)+root->val;\\n        //if your desired tree constitute of left part only\\n        int max_left_part  = max(left_part.first,left_part.second)  +root->val ;\\n        //if your desired tree constitute of right part only\\n        int max_right_part = max(right_part.first,right_part.second)+root->val ;\\n        //RES will be max of all 4 possibilities\\n        res = max({res,no_upper_conn,max_left_part,max_right_part,root->val});\\n        //and also IT MAY CONSIST OF ONLY ROOT NODE e.g;[1,-2,3] , [2,1] \\n        //that\\'s why we check max with root->val also\\n        return {max(max_left_part,root->val),max(max_right_part,root->val)};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int res=INT_MIN;\\n        dfs(root,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//--------------------------------normal dfs----------------\\n    pair<int,int> dfs(TreeNode *root,int &res){\\n        if(root==NULL) return {0,0};\\n        pair<int,int> left_part = dfs(root->left,res);\\n        pair<int,int> right_part = dfs(root->right,res);\\n        // if your desired tree exist below this root only hemce no upper connection\\n        int no_upper_conn  = max(left_part.first,left_part.second)+max(right_part.first,right_part.second)+root->val;\\n        //if your desired tree constitute of left part only\\n        int max_left_part  = max(left_part.first,left_part.second)  +root->val ;\\n        //if your desired tree constitute of right part only\\n        int max_right_part = max(right_part.first,right_part.second)+root->val ;\\n        //RES will be max of all 4 possibilities\\n        res = max({res,no_upper_conn,max_left_part,max_right_part,root->val});\\n        //and also IT MAY CONSIST OF ONLY ROOT NODE e.g;[1,-2,3] , [2,1] \\n        //that\\'s why we check max with root->val also\\n        return {max(max_left_part,root->val),max(max_right_part,root->val)};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int res=INT_MIN;\\n        dfs(root,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583833,
                "title": "c-solution-with-diagrammatic-explanation",
                "content": "Before heading to the solution let us see all possible form of testcases for the given question.\\n\\n1. Maximum path exist in the left-subtree or right-subtree. shown in example (i) & (ii).\\n1. Maximum path is the sum of the part of left-subtree , right-subtree and root. shown in example (iii).\\n1. Maximum path is the sum of the (Maximum consecutive path of left-subtree and right-subtree) and root. shown in example (iv) & (v).\\n\\n![image](https://assets.leetcode.com/users/images/452ee832-327d-4443-aae0-699148a7a4ef_1685568434.8347857.png)\\n\\n![image](https://assets.leetcode.com/users/images/37dc84c8-061a-4386-ac35-10f798af31ac_1685568522.5391746.png)\\n\\n![image](https://assets.leetcode.com/users/images/51ed88b8-4ef4-4869-ad91-956253c70853_1685570162.9089835.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3e4e518c-92c2-4c52-933d-67065293986a_1685568716.1070657.png)\\n\\n\\n\\n**Recursive Code Explanation:**\\n* max_ps is storing the maximum path sum and if at some ith recursive call we get a path having sum greater than max_ps then we will change the max_ps.\\n* solve function is giving us the maximum consecutive path posibble including the root node.\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\tint solve(TreeNode* root,int &max_ps) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int l = max(0,solve(root->left,max_ps));\\n        // l gives the maximum consecutive path from left-subtree that can contribute to the  maximum path sum\\n        \\n        int r = max(0,solve(root->right,max_ps));\\n        // r gives the maximum consecutive path from right-subtree that can contribute to the  maximum path sum\\n        \\n        int curr_max = max(max(l,r) + root->val,root->val);\\n        // curr_max gives the maximum consecutive path including root-node as explained in example-(iv) and (v).\\n        \\n        int new_max_ps = max(l + r + root->val,curr_max);\\n        // explanation of l + r + root->val is given in example-(iii)\\n        \\n        max_ps = max(new_max_ps,max_ps);\\n        // updating the max_ps\\n        \\n        return curr_max;\\n    }\\n\\tint maxPathSum(TreeNode* root) {\\n        int max_ps = INT_MIN;\\n        int temp = solve(root,max_ps);\\n        return max_ps;\\n    }\\n};\\n```\\n\\n\\n\\n\\t",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint solve(TreeNode* root,int &max_ps) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int l = max(0,solve(root->left,max_ps));\\n        // l gives the maximum consecutive path from left-subtree that can contribute to the  maximum path sum\\n        \\n        int r = max(0,solve(root->right,max_ps));\\n        // r gives the maximum consecutive path from right-subtree that can contribute to the  maximum path sum\\n        \\n        int curr_max = max(max(l,r) + root->val,root->val);\\n        // curr_max gives the maximum consecutive path including root-node as explained in example-(iv) and (v).\\n        \\n        int new_max_ps = max(l + r + root->val,curr_max);\\n        // explanation of l + r + root->val is given in example-(iii)\\n        \\n        max_ps = max(new_max_ps,max_ps);\\n        // updating the max_ps\\n        \\n        return curr_max;\\n    }\\n\\tint maxPathSum(TreeNode* root) {\\n        int max_ps = INT_MIN;\\n        int temp = solve(root,max_ps);\\n        return max_ps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394265,
                "title": "detailed-image-solution-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int []ans=new int[1];\\n        ans[0]=Integer.MIN_VALUE;\\n        solve(root,ans);\\n        return ans[0];        \\n    }\\n\\n    public int solve(TreeNode root,int[]ans){\\n        if(root==null) return 0;\\n\\n        //if solve(root.left,ans) return the value < 0 then leftSum = 0;\\n        int leftSum=Math.max(0,solve(root.left,ans));\\n\\n        //if solve(root.right,ans) return the value < 0 then rightSum = 0;\\n        int rightSum=Math.max(0,solve(root.right,ans));\\n\\n        ans[0]=Math.max(ans[0],leftSum+rightSum+root.val);\\n\\n        return root.val+Math.max(leftSum,rightSum);\\n    }\\n}\\n```\\n![WhatsApp Image 2023-04-08 at 8.44.18 PM.jpeg](https://assets.leetcode.com/users/images/616bf59f-03d2-43cb-8c45-cd8e5143d825_1680966911.0263126.jpeg)\\n\\n```\\nGive An Upvote if you Understand the solution.\\n```\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int []ans=new int[1];\\n        ans[0]=Integer.MIN_VALUE;\\n        solve(root,ans);\\n        return ans[0];        \\n    }\\n\\n    public int solve(TreeNode root,int[]ans){\\n        if(root==null) return 0;\\n\\n        //if solve(root.left,ans) return the value < 0 then leftSum = 0;\\n        int leftSum=Math.max(0,solve(root.left,ans));\\n\\n        //if solve(root.right,ans) return the value < 0 then rightSum = 0;\\n        int rightSum=Math.max(0,solve(root.right,ans));\\n\\n        ans[0]=Math.max(ans[0],leftSum+rightSum+root.val);\\n\\n        return root.val+Math.max(leftSum,rightSum);\\n    }\\n}\\n```\n```\\nGive An Upvote if you Understand the solution.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363263,
                "title": "this-is-easier-than-easy-category-question-beats-93",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/2d6e0912-50e8-4546-a8c2-855be4a3d60b_1680286287.571895.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt just like finding the height of binary tree...Traverse the tree and at every node calculate the sum of node.left+node.right+node.val.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        \\n        int maxValue[] = new int[1]; // Create an array to hold the max value\\n        maxValue[0] = Integer.MIN_VALUE; // Initialize the max value to the lowest possible integer value\\n        maxPathDown(root,maxValue); // Call the recursive helper function to compute the max path sum\\n\\n        return maxValue[0]; // Return the max path sum\\n    }\\n\\n    public int maxPathDown(TreeNode root, int maxValue[]){\\n\\n        if(root == null){ // Base case: If the node is null, return 0\\n            return 0;\\n        }\\n\\n        // Compute the maximum path sum in the left and right subtrees\\n        // int left = maxPathDown(root.left,maxValue);\\n        // int right = maxPathDown(root.right,maxValue);\\n\\n        // Modify the above lines to take care of negative values\\n        int left = Math.max(0,maxPathDown(root.left,maxValue));\\n        int right = Math.max(0,maxPathDown(root.right,maxValue));\\n\\n        // Update the max path sum if the path passing through the current node has a greater sum\\n        maxValue[0] = Math.max(maxValue[0], left + right + root.val);\\n\\n        // Return the maximum path sum down to the current node\\n        return Math.max(left,right) + root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        \\n        int maxValue[] = new int[1]; // Create an array to hold the max value\\n        maxValue[0] = Integer.MIN_VALUE; // Initialize the max value to the lowest possible integer value\\n        maxPathDown(root,maxValue); // Call the recursive helper function to compute the max path sum\\n\\n        return maxValue[0]; // Return the max path sum\\n    }\\n\\n    public int maxPathDown(TreeNode root, int maxValue[]){\\n\\n        if(root == null){ // Base case: If the node is null, return 0\\n            return 0;\\n        }\\n\\n        // Compute the maximum path sum in the left and right subtrees\\n        // int left = maxPathDown(root.left,maxValue);\\n        // int right = maxPathDown(root.right,maxValue);\\n\\n        // Modify the above lines to take care of negative values\\n        int left = Math.max(0,maxPathDown(root.left,maxValue));\\n        int right = Math.max(0,maxPathDown(root.right,maxValue));\\n\\n        // Update the max path sum if the path passing through the current node has a greater sum\\n        maxValue[0] = Math.max(maxValue[0], left + right + root.val);\\n\\n        // Return the maximum path sum down to the current node\\n        return Math.max(left,right) + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327481,
                "title": "java-dfs-solution-beats-100-online-submissions",
                "content": "# Complexity\\n- Time complexity: **O(N)**\\n\\n- Space complexity: **O(N)**\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        update(root);\\n\\n        return ans;\\n    }\\n\\n    private int update(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int leftsum = Math.max(update(root.left),0);\\n        int rightsum = Math.max(update(root.right),0);\\n\\n        ans = Math.max(ans,leftsum+rightsum+root.val);\\n\\n        return Math.max(leftsum+root.val, rightsum+root.val);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        update(root);\\n\\n        return ans;\\n    }\\n\\n    private int update(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int leftsum = Math.max(update(root.left),0);\\n        int rightsum = Math.max(update(root.right),0);\\n\\n        ans = Math.max(ans,leftsum+rightsum+root.val);\\n\\n        return Math.max(leftsum+root.val, rightsum+root.val);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296155,
                "title": "time-space-o-n-short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,root->val+max({l,r,l+r})});\\n        return max({root->val,root->val+max({l,r})});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        return max(ans,solve(root,ans));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,root->val+max({l,r,l+r})});\\n        return max({root->val,root->val+max({l,r})});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        return max(ans,solve(root,ans));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280297,
                "title": "note-made-it-clear-onlycode-in-java",
                "content": "# Note\\nIn the maxPathSum function, we want to find the maximum path sum in a binary tree. To accomplish this, we traverse the binary tree and compute the sum of all paths from the root node to a leaf node.\\n\\nDuring the traversal, we keep track of the maximum path sum found so far in the max[0] variable. This variable is initialized to Integer.MIN_VALUE at the beginning of the function.\\n\\nNow, let\\'s consider what would happen if we don\\'t initialize max[0] to Integer.MIN_VALUE. If we simply declare the max array without initializing it, then the default value for an integer, which is 0, would be used as the initial value for max[0].\\n\\nIf all the path sum values in the binary tree are negative, the max[0] variable would never get updated, because every path sum value encountered during the traversal would be less than max[0] (which is 0). Therefore, the function would return 0, which is not correct, since there could be negative path sum values that are less than 0.\\n\\nOn the other hand, by initializing max[0] to Integer.MIN_VALUE, we ensure that max[0] will always be updated with the correct maximum path sum value during the traversal, even if all the path sum values are negative. This is because any path sum value encountered during the traversal will be greater than or equal to Integer.MIN_VALUE, so max[0] will always get updated with the maximum path sum value found so far.\\n\\nTherefore, it is important to initialize max[0] to a value that is lower than any possible path sum value in the binary tree. By convention, Integer.MIN_VALUE is used as the initial value for maximum path sum problems to ensure that max[0] gets updated correctly during the traversal.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int max[]= new int[1];\\n        max[0] = Integer.MIN_VALUE;\\n        ht(root,max);\\n        return max[0];\\n    }\\n    public int ht(TreeNode root,int maxValue[]){\\n        if(root==null) return 0;\\n        int lh = Math.max(0,ht(root.left,maxValue));\\n        int rh = Math.max(0,ht(root.right,maxValue));\\n        maxValue[0] = Math.max(maxValue[0], lh + rh + root.val);\\n        return root.val + Math.max(lh,rh);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int max[]= new int[1];\\n        max[0] = Integer.MIN_VALUE;\\n        ht(root,max);\\n        return max[0];\\n    }\\n    public int ht(TreeNode root,int maxValue[]){\\n        if(root==null) return 0;\\n        int lh = Math.max(0,ht(root.left,maxValue));\\n        int rh = Math.max(0,ht(root.right,maxValue));\\n        maxValue[0] = Math.max(maxValue[0], lh + rh + root.val);\\n        return root.val + Math.max(lh,rh);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270970,
                "title": "1ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int maximum[]=new int[1];\\n        maximum[0]=Integer.MIN_VALUE;\\n        maxPathDown(root,maximum);\\n        return maximum[0];\\n    }\\n    public int maxPathDown(TreeNode node,int maximum[]){\\n        if(node==null){\\n            return 0;\\n        }\\n        int left=Math.max(0,maxPathDown(node.left,maximum));\\n        int right=Math.max(0,maxPathDown(node.right,maximum));\\n        maximum[0]=Math.max(maximum[0],left+right+node.val);\\n        return Math.max(left,right)+node.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int maximum[]=new int[1];\\n        maximum[0]=Integer.MIN_VALUE;\\n        maxPathDown(root,maximum);\\n        return maximum[0];\\n    }\\n    public int maxPathDown(TreeNode node,int maximum[]){\\n        if(node==null){\\n            return 0;\\n        }\\n        int left=Math.max(0,maxPathDown(node.left,maximum));\\n        int right=Math.max(0,maxPathDown(node.right,maximum));\\n        maximum[0]=Math.max(maximum[0],left+right+node.val);\\n        return Math.max(left,right)+node.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936559,
                "title": "striver-recursive-simple-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int[] maxp=new int[1]; //to pass the maxp integer by reference\\n        maxp[0]=Integer.MIN_VALUE; //because we have to compare to find max\\n        solver(root,maxp);\\n        return maxp[0];\\n    }\\n\\n    public int solver(TreeNode root, int[] maxp){\\n        if(root==null) return 0;\\n        int lh=solver(root.left,maxp); //max path sum from left \\n        int rh=solver(root.right,maxp); //max path sum from right\\n        maxp[0]=Math.max(maxp[0],lh+rh+root.val); \\n        int ret= Math.max(root.val,Math.max(lh,rh)+root.val); //max of root and \\n        maxp[0]=Math.max(maxp[0],ret);// max stores the max of (root value, root+maxLeft/right ,path sum including the node from right to left,previous max)\\n        //max can be a discontinuos set sum but returned value is a continous part of branch of tree\\n        return ret; //max path sum from this node \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int[] maxp=new int[1]; //to pass the maxp integer by reference\\n        maxp[0]=Integer.MIN_VALUE; //because we have to compare to find max\\n        solver(root,maxp);\\n        return maxp[0];\\n    }\\n\\n    public int solver(TreeNode root, int[] maxp){\\n        if(root==null) return 0;\\n        int lh=solver(root.left,maxp); //max path sum from left \\n        int rh=solver(root.right,maxp); //max path sum from right\\n        maxp[0]=Math.max(maxp[0],lh+rh+root.val); \\n        int ret= Math.max(root.val,Math.max(lh,rh)+root.val); //max of root and \\n        maxp[0]=Math.max(maxp[0],ret);// max stores the max of (root value, root+maxLeft/right ,path sum including the node from right to left,previous max)\\n        //max can be a discontinuos set sum but returned value is a continous part of branch of tree\\n        return ret; //max path sum from this node \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902290,
                "title": "binary-tree-maximum-path-sum-c-o-n-solution",
                "content": "# Intuition\\nDFS and max between left and right subtree.\\n\\n# Approach\\nUse dfs and check max left and right subtree value then return max(current,left,right), and check max answer at each and every node.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans = INT_MIN;\\n    int solve(TreeNode * root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left = solve(root->left);\\n        int right = solve(root->right);\\n        // calculate the max path \\n        // considering current node as a part of the path\\n        int path = root->val;\\n        path = max(path,path+left);\\n        path = max(path,path+right);\\n\\n        //store the ans\\n        ans = max(ans,path);\\n\\n        // return max(current node, left subtree, right subtree);\\n        return max(root->val,root->val+max(left,right));        \\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        ans = root->val;\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans = INT_MIN;\\n    int solve(TreeNode * root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left = solve(root->left);\\n        int right = solve(root->right);\\n        // calculate the max path \\n        // considering current node as a part of the path\\n        int path = root->val;\\n        path = max(path,path+left);\\n        path = max(path,path+right);\\n\\n        //store the ans\\n        ans = max(ans,path);\\n\\n        // return max(current node, left subtree, right subtree);\\n        return max(root->val,root->val+max(left,right));        \\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        ans = root->val;\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902181,
                "title": "c-dfs-single-traversal-easy-to-understand",
                "content": "# Intuition\\nwe have to calculate sum of each possible path in a binary tree and then maximize it and store the maximum sum into any variable. So, we can use subtree sum where we can pick the max sum obtained from left subtree and right subtree and on the same time maximize the maxSum (holds the maximum sum of any particular path in a tree)variable as well. \\n\\n# Approach\\nevery time we are going to a particular node we recursively calculating the left sum (left subtree sum) and right sum (right subtree sum) and store them in specified variables. Then we have to maximize the maxSum variable by adding current node value into our leftsubtree sum and rightsubtree sum. At last, we are returning the maximum of leftsubtree sum and rightsubtree sum by adding the root value into it.\\n\\n# Complexity\\n- Time complexity:\\no(h) where h is the height of the tree. In worst case it can got upto o(n) where n is the number of nodes in the tree.\\n\\n- Space complexity:\\n0(n) functional call is stack is used \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root, int& maxSum) {\\n        if(root == NULL) return 0;\\n        \\n        int lSum = max(0, solve(root->left,maxSum));\\n        int rSum = max(0, solve(root->right,maxSum));\\n        \\n        maxSum = max(maxSum, lSum + rSum + root->val);\\n        \\n        return root->val + max(lSum,rSum);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root, int& maxSum) {\\n        if(root == NULL) return 0;\\n        \\n        int lSum = max(0, solve(root->left,maxSum));\\n        int rSum = max(0, solve(root->right,maxSum));\\n        \\n        maxSum = max(maxSum, lSum + rSum + root->val);\\n        \\n        return root->val + max(lSum,rSum);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901692,
                "title": "easy-c-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint maxi = INT_MIN;\\n    int dfs(TreeNode* root){\\n        if(!root) return 0;\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n        maxi = max(maxi , root->val+l+r);\\n        int sum = root->val + max(l , r);\\n        if(sum<0){\\n            sum=0;\\n        }\\n        return sum;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        dfs(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint maxi = INT_MIN;\\n    int dfs(TreeNode* root){\\n        if(!root) return 0;\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n        maxi = max(maxi , root->val+l+r);\\n        int sum = root->val + max(l , r);\\n        if(sum<0){\\n            sum=0;\\n        }\\n        return sum;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        dfs(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901370,
                "title": "java-easiest-solution-possible",
                "content": "# Code\\n```\\nclass Solution {\\n    private static int ans = Integer.MIN_VALUE;\\n    private static int PathMax(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = PathMax(root.left);\\n        int right = PathMax(root.right);\\n        int ms = Math.max(Math.max(left,right)+root.val, root.val);\\n        int ms_1 = Math.max((left+right+root.val), ms);\\n        ans = Math.max(ans, ms_1);\\n\\n        return ms;\\n    }\\n    public int maxPathSum(TreeNode root) {\\n        ans = Integer.MIN_VALUE;\\n        PathMax(root);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static int ans = Integer.MIN_VALUE;\\n    private static int PathMax(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = PathMax(root.left);\\n        int right = PathMax(root.right);\\n        int ms = Math.max(Math.max(left,right)+root.val, root.val);\\n        int ms_1 = Math.max((left+right+root.val), ms);\\n        ans = Math.max(ans, ms_1);\\n\\n        return ms;\\n    }\\n    public int maxPathSum(TreeNode root) {\\n        ans = Integer.MIN_VALUE;\\n        PathMax(root);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900237,
                "title": "simple-dfs-log-n",
                "content": "1. Find non negative leftPathSum\\n2. Find non negative rightPathSum\\n3. Calculate maxPathSum for current Node (left+right+root.val)\\n4. Compair final ans and update it.\\n\\n# Code\\n### Python\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n\\n        self.ans = float(\\'-inf\\')\\n        def leftRightSum(root):\\n            if not root:\\n                return 0\\n            l = max(leftRightSum(root.left), 0)\\n            r = max(leftRightSum(root.right), 0)\\n            self.ans = max(l+r+root.val, self.ans)\\n            # print(l, r, root.val, self.ans)\\n            return max(l, r) + root.val\\n        \\n        leftRightSum(root)\\n        return self.ans\\n\\n```\\n### Go\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc maxPathSum(root *TreeNode) int {\\n    ans := -1 << 63\\n    maxPath(root, &ans)\\n    return ans\\n}\\n\\nfunc maxPath(root *TreeNode, ans *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    leftPathSum := maxPath(root.Left, ans)\\n    rightPathSum := maxPath(root.Right, ans)\\n    *ans = max(*ans, leftPathSum + rightPathSum + root.Val)\\n    return max(max(leftPathSum+root.Val, rightPathSum+root.Val), 0)\\n}\\n\\nfunc max(a int, b int) int {\\n    if (a >= b) {\\n        return a\\n    }\\n    return b\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n\\n        self.ans = float(\\'-inf\\')\\n        def leftRightSum(root):\\n            if not root:\\n                return 0\\n            l = max(leftRightSum(root.left), 0)\\n            r = max(leftRightSum(root.right), 0)\\n            self.ans = max(l+r+root.val, self.ans)\\n            # print(l, r, root.val, self.ans)\\n            return max(l, r) + root.val\\n        \\n        leftRightSum(root)\\n        return self.ans\\n\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc maxPathSum(root *TreeNode) int {\\n    ans := -1 << 63\\n    maxPath(root, &ans)\\n    return ans\\n}\\n\\nfunc maxPath(root *TreeNode, ans *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    leftPathSum := maxPath(root.Left, ans)\\n    rightPathSum := maxPath(root.Right, ans)\\n    *ans = max(*ans, leftPathSum + rightPathSum + root.Val)\\n    return max(max(leftPathSum+root.Val, rightPathSum+root.Val), 0)\\n}\\n\\nfunc max(a int, b int) int {\\n    if (a >= b) {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899200,
                "title": "easiest-java-solution-faster-than-99-63",
                "content": "**Intuition:**\\nAt every node, check what is the maxium left and right path sum that you can get. Take the max sum of current path (left + root + right). Now return max(left, right) + root.\\n\\n```java\\n class Solution {\\n    public int maxPathSum(TreeNode root) {\\n        solve(root);\\n        return maxSum;\\n    }\\n    \\n    int maxSum = Integer.MIN_VALUE;\\n    int solve(TreeNode root) {\\n        if (root == null) return 0;\\n        int maxLeft = Math.max(0, solve(root.left));\\n        int maxRight = Math.max(0, solve(root.right));\\n        maxSum = Math.max(maxSum, root.val + maxLeft + maxRight);\\n        return root.val + Math.max(maxLeft, maxRight);\\n    }\\n}\\n```\\n**Time complexity :** `O(N)` for traversing all nodes\\n**Space complexity :** `O(N)` for recursion stack space",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n class Solution {\\n    public int maxPathSum(TreeNode root) {\\n        solve(root);\\n        return maxSum;\\n    }\\n    \\n    int maxSum = Integer.MIN_VALUE;\\n    int solve(TreeNode root) {\\n        if (root == null) return 0;\\n        int maxLeft = Math.max(0, solve(root.left));\\n        int maxRight = Math.max(0, solve(root.right));\\n        maxSum = Math.max(maxSum, root.val + maxLeft + maxRight);\\n        return root.val + Math.max(maxLeft, maxRight);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899166,
                "title": "c-easy-explaination",
                "content": "# Intuition\\nAt every node , we have two possible actions \\n1. At this node, we decide to join the paths from left and right , which means we are trying to form our answer from this node.\\n2. Find the maximum path from left and right , so that it can be used by the ancestor nodes to perform action 1.\\n\\n# Approach\\n1. We will just do a postorder traversal\\n2. At each node, we maximise the answer by adding maximum in left and right\\n3. At the same time we find the maximum path, from left and right\\n4. If the pathsum becomes less than 0, we should drop that path\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(h) h=height of tree \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int helper(TreeNode * root){\\n        if(!root) return 0;\\n        int left = helper(root->left);\\n        int right = helper(root->right);\\n        ans = max(ans , left+right+root->val);\\n        return max({left+root->val,right+root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int helper(TreeNode * root){\\n        if(!root) return 0;\\n        int left = helper(root->left);\\n        int right = helper(root->right);\\n        ans = max(ans , left+right+root->val);\\n        return max({left+root->val,right+root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899138,
                "title": "simple-and-easy-to-understand-c-recursive-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is quiet simple just travel each node and get max positive path cost of left and right sub tree. Check if cost of left and right sub tree plus cost of node is greater than max path cost till now then update it. Return max positive path cost from left and right sub with increment of node\\'s cost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ if Consider Recursive Call Stack then Space Complexity will be $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getMaxPath(TreeNode* root, int &maxPath){\\n        if(!root)\\n            return 0;\\n        int leftVal = max(getMaxPath(root->left, maxPath),0);\\n        int rightVal = max(getMaxPath(root->right, maxPath),0);\\n        maxPath = max(maxPath, root->val+leftVal+rightVal);\\n        return max(leftVal, rightVal)+root->val;\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxPath = -1001;\\n        getMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getMaxPath(TreeNode* root, int &maxPath){\\n        if(!root)\\n            return 0;\\n        int leftVal = max(getMaxPath(root->left, maxPath),0);\\n        int rightVal = max(getMaxPath(root->right, maxPath),0);\\n        maxPath = max(maxPath, root->val+leftVal+rightVal);\\n        return max(leftVal, rightVal)+root->val;\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxPath = -1001;\\n        getMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899130,
                "title": "java-beat-99-6-post-order-traversal-easy-solution",
                "content": "```\\n    //post order traverse\\n    int res = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        getSiglePathMax(root);\\n        return res;\\n    }\\n    \\n    private int getSiglePathMax(TreeNode root) {\\n        if(root == null) return 0;\\n        //no need to add if it\\'s negetive\\n        int left = Math.max(0, getSiglePathMax(root.left));\\n        int right = Math.max(0, getSiglePathMax(root.right));\\n        int curPath = left + right + root.val;\\n        res = Math.max(res, curPath);\\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    //post order traverse\\n    int res = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        getSiglePathMax(root);\\n        return res;\\n    }\\n    \\n    private int getSiglePathMax(TreeNode root) {\\n        if(root == null) return 0;\\n        //no need to add if it\\'s negetive\\n        int left = Math.max(0, getSiglePathMax(root.left));\\n        int right = Math.max(0, getSiglePathMax(root.right));\\n        int curPath = left + right + root.val;\\n        res = Math.max(res, curPath);\\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831066,
                "title": "c-o-n-solution-with-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int as(TreeNode* root,int& ans){\\n        if(root==NULL) return 0;\\n        int l=as(root->left,ans);\\n        if(l<0) l=0;\\n        int r=as(root->right,ans);\\n        if(r<0) r=0;\\n        ans=max(ans,root->val+l+r);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        as(root,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int as(TreeNode* root,int& ans){\\n        if(root==NULL) return 0;\\n        int l=as(root->left,ans);\\n        if(l<0) l=0;\\n        int r=as(root->right,ans);\\n        if(r<0) r=0;\\n        ans=max(ans,root->val+l+r);\\n        return root->val+max(l,r);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2749045,
                "title": "easy-c-solution-o-n-with-comments",
                "content": "Here is my C++ Solution :\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int demo (TreeNode* root){\\n        if (root==NULL)return 0;\\n        int ls= max(0,demo(root->left));   // taking max with 0 to avoid negative nodes\\n        int rs= max(0,demo(root->right));\\n        maxi = max(maxi, root->val+ls+rs); // for umbrellas;\\n        return root->val + max(ls,rs); // for along heights;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        demo(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int demo (TreeNode* root){\\n        if (root==NULL)return 0;\\n        int ls= max(0,demo(root->left));   // taking max with 0 to avoid negative nodes\\n        int rs= max(0,demo(root->right));\\n        maxi = max(maxi, root->val+ls+rs); // for umbrellas;\\n        return root->val + max(ls,rs); // for along heights;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        demo(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571541,
                "title": "very-easy-solution-binary-tree-maximum-path-sum",
                "content": "class Solution {\\npublic:\\n    int solve(TreeNode*root, int &res){\\n        if(!root) return 0;\\n        \\n        int l=solve(root->left, res);\\n        int r=solve(root->right, res);\\n        \\n        int temp=max(max(l,r)+root->val, root->val);\\n      //  cout<<temp<<\" \"<<endl;\\n        int ans=max(temp, l+r+root->val);\\n        cout<<ans<<\" \";\\n        res=max(res,ans);\\n        \\n        return temp;\\n        \\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int res=INT_MIN;\\n        solve(root, res);\\n        \\n        return res;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solve(TreeNode*root, int &res){\\n        if(!root) return 0;\\n        \\n        int l=solve(root->left, res);\\n        int r=solve(root->right, res);\\n        \\n        int temp=max(max(l,r)+root->val, root->val);\\n      //  cout<<temp<<\" \"<<endl;\\n        int ans=max(temp, l+r+root->val);\\n        cout<<ans<<\" \";\\n        res=max(res,ans);\\n        \\n        return temp;\\n        \\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2392892,
                "title": "5-line-c-dfs-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* node , int &ans) {\\n        if(node == NULL) return 0;\\n        int l = max(0, dfs(node->left, ans));\\n        int r = max(0, dfs(node->right, ans));\\n        ans = max(ans, l + r + node->val);\\n        return max(l, r) + node->val;\\n    }\\n};\\n```\\n**Please Upvote\\nthank you!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* node , int &ans) {\\n        if(node == NULL) return 0;\\n        int l = max(0, dfs(node->left, ans));\\n        int r = max(0, dfs(node->right, ans));\\n        ans = max(ans, l + r + node->val);\\n        return max(l, r) + node->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262932,
                "title": "simple-c-solution-recursion",
                "content": "Solution -->\\n```\\nclass Solution {\\npublic:\\n    int sum(TreeNode* root, int& ans)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int left=sum(root->left,ans);\\n        int right=sum(root->right,ans);\\n        \\n        int temp=max(max(left,right)+root->val,root->val);\\n        temp=max(temp,left+right+root->val);\\n        ans=max(ans,temp);\\n        return max(max(left,right)+root->val,root->val);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(TreeNode* root, int& ans)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int left=sum(root->left,ans);\\n        int right=sum(root->right,ans);\\n        \\n        int temp=max(max(left,right)+root->val,root->val);\\n        temp=max(temp,left+right+root->val);\\n        ans=max(ans,temp);\\n        return max(max(left,right)+root->val,root->val);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254617,
                "title": "aditya-varma-dp-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int solve(TreeNode *root, int &res)\\n    {\\n        if (root == NULL)\\n            return 0;\\n\\n        int l = solve(root->left, res);\\n        int r = solve(root->right, res);\\n\\n        int temp = max(max(l, r) + root->val, root->val);\\n        int ans = max(temp, l + r + root->val);\\n        res = max(res, ans);\\n        return temp;\\n    }\\n\\n    int maxPathSum(TreeNode *root)\\n    {\\n        int res = INT_MIN;\\n        solve(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int solve(TreeNode *root, int &res)\\n    {\\n        if (root == NULL)\\n            return 0;\\n\\n        int l = solve(root->left, res);\\n        int r = solve(root->right, res);\\n\\n        int temp = max(max(l, r) + root->val, root->val);\\n        int ans = max(temp, l + r + root->val);\\n        res = max(res, ans);\\n        return temp;\\n    }\\n\\n    int maxPathSum(TreeNode *root)\\n    {\\n        int res = INT_MIN;\\n        solve(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177649,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mx=-1001;\\n    int getans(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=max(0,getans(root->left));\\n        int right=max(0,getans(root->right));\\n        \\n        mx=max(mx,root->val+left+right);\\n        return max(left,right)+root->val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int k= getans(root);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx=-1001;\\n    int getans(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=max(0,getans(root->left));\\n        int right=max(0,getans(root->right));\\n        \\n        mx=max(mx,root->val+left+right);\\n        return max(left,right)+root->val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int k= getans(root);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105359,
                "title": "java-commented-beats-100",
                "content": "**Idea**: At any point in time we need to maintain the best at that node but the value that we bubble up must be part of a path (cannot have both children), so we must choose the best of current value with left subtree, right subtree or the current node\\'s value itself. But our actual maximum may go through the root, so we can keep track of it separately.\\nRest is explained with comments.\\n\\n```\\nclass Solution {\\n\\t// to maintain the actual maximum sum of path\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path(root);\\n        return max;\\n    }\\n    \\n    private int path(TreeNode node) {\\n\\t\\t// base case\\n        if(node == null) {\\n            return 0;\\n        }\\n        \\n\\t\\t// traverse left and right subtrees\\n        int left = path(node.left);\\n        int right = path(node.right);\\n        \\n\\t\\t// get the best of left subtree + current node\\'s val vs. right subtree + current node\\'s val vs. current node\\'s val \\n\\t\\t// as this value will ensure either of the path (left, right or just from the current node itself but not both the children)\\n\\t\\t// we return this to the parent\\n        int leftOrRightOrCurrent = \\n            Math.max(Math.max(left + node.val, right + node.val), node.val);\\n\\t\\t\\n\\t\\t// maximum of current node\\'s val vs. all the above possibilities to see if this is actually the max path?\\n\\t\\t// best max path upto this node is this (localMaxima)\\n        int localMaxima = Math.max(left + right + node.val, leftOrRightOrCurrent);\\n            \\n        // overall maximum\\n\\t\\t// compare the localMaxima with overall tree\\'s max value, this will be our answer\\n        max = Math.max(localMaxima, max);\\n        \\n\\t\\t// return to parent as discussed earlier\\n        return leftOrRightOrCurrent;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(N)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t// to maintain the actual maximum sum of path\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path(root);\\n        return max;\\n    }\\n    \\n    private int path(TreeNode node) {\\n\\t\\t// base case\\n        if(node == null) {\\n            return 0;\\n        }\\n        \\n\\t\\t// traverse left and right subtrees\\n        int left = path(node.left);\\n        int right = path(node.right);\\n        \\n\\t\\t// get the best of left subtree + current node\\'s val vs. right subtree + current node\\'s val vs. current node\\'s val \\n\\t\\t// as this value will ensure either of the path (left, right or just from the current node itself but not both the children)\\n\\t\\t// we return this to the parent\\n        int leftOrRightOrCurrent = \\n            Math.max(Math.max(left + node.val, right + node.val), node.val);\\n\\t\\t\\n\\t\\t// maximum of current node\\'s val vs. all the above possibilities to see if this is actually the max path?\\n\\t\\t// best max path upto this node is this (localMaxima)\\n        int localMaxima = Math.max(left + right + node.val, leftOrRightOrCurrent);\\n            \\n        // overall maximum\\n\\t\\t// compare the localMaxima with overall tree\\'s max value, this will be our answer\\n        max = Math.max(localMaxima, max);\\n        \\n\\t\\t// return to parent as discussed earlier\\n        return leftOrRightOrCurrent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017695,
                "title": "java-best-solution-easy",
                "content": "IF YOU FIND THE SOLUTION HELPFULL , KINDLY UPVOTE.\\nThank You\\n\\n```\\npublic class Solution {\\n  int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n      helper(root);\\n      return max;\\n    }\\n  int helper(TreeNode root) {\\n    if(root == null) return 0;\\n    int left = Math.max(helper(root.left), 0);\\n    int right = Math.max(helper(root.right), 0);  \\n    \\n    max = Math.max(max, root.val + left + right);\\n    return root.val + Math.max(left, right);\\n  }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n  int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n      helper(root);\\n      return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1944012,
                "title": "beats-96-91-5-lines-logic-c",
                "content": "1. First thing is we have to traverse every node. So it needs a DFS solution.\\n2. On every node, we need to find out maximum left and right downward path. Node should only focus on its children and grandchildren.\\n3. At every node, if its left or right path is > 0, then only it is going to increase the sum. So we use **max(leftSum, 0)** and **max(rightSum, 0)**\\n4. At every node, we calculate node->val + left + right and compare it with answer till now and update the answer if the current node has a better value.\\n5. Tricky and important part what should DFS return at every node. Whatever current DFS node will return will be used by its parent. \\ne.g. \\n____________________________________1\\n___________________________2_____________3\\n________________________4___5_________6___7\\n\\nSo it should return current **node->val + max(left,right)**. Because parent cannot use its children\\'s both left and right sum. In above example, DFS(2) should return 2 + max(4,5), because 1 can include only 4 or 5 in its path\\n\\n```\\nclass Solution {\\nprivate:\\n    int DFS(TreeNode* root, int& ans) {\\n        if(root == NULL) return 0;\\n        int left = max(DFS(root->left, ans), 0);\\n        int right = max(DFS(root->right, ans), 0);\\n\\n        int sum = root->val + left + right;\\n        ans = max(ans, sum);\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        DFS(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int DFS(TreeNode* root, int& ans) {\\n        if(root == NULL) return 0;\\n        int left = max(DFS(root->left, ans), 0);\\n        int right = max(DFS(root->right, ans), 0);\\n\\n        int sum = root->val + left + right;\\n        ans = max(ans, sum);\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        DFS(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870416,
                "title": "we-just-have-to-find-the-diameter-java-beats-100-with-explanation",
                "content": "**Approach and Intuition:-**  In this question, the catch is to find the diameter of the binary tree, with little changes. Instead of just finding the left and right height of a particular node in the tree, we find the maximum left and right heights of that node, including it. The remaining steps are similar to the \\'diameter\\' problem, but we need to ensure that while returning the ```max(lh,rh)```, we need to add ```root.val``` to it, because the path passes through that node too. \\n\\n**Code:-**\\n\\n```\\n    int ans=Integer.MIN_VALUE;;\\n    public int maxPathSum(TreeNode root)\\n    {\\n        height(root);\\n        return ans;\\n    }\\n    public int height(TreeNode root)\\n    {\\n        if (root==null) return 0;\\n        int lh=Math.max(0,height(root.left));\\n        int rh=Math.max(0,height(root.right));\\n        ans=Math.max(ans,lh+rh+root.val);\\n        return Math.max(lh,rh)+root.val;\\n    }\\n```\\t\\n\\n**Time Complexity:-**  O(n), where n is the number of nodes\\n**Space Complexity:-**  O(h), where h is the height of the binary tree",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```max(lh,rh)```\n```root.val```\n```\\n    int ans=Integer.MIN_VALUE;;\\n    public int maxPathSum(TreeNode root)\\n    {\\n        height(root);\\n        return ans;\\n    }\\n    public int height(TreeNode root)\\n    {\\n        if (root==null) return 0;\\n        int lh=Math.max(0,height(root.left));\\n        int rh=Math.max(0,height(root.right));\\n        ans=Math.max(ans,lh+rh+root.val);\\n        return Math.max(lh,rh)+root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1712502,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567490,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1712498,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1575621,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568229,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568300,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567489,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1573705,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568163,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568185,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1712502,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567490,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1712498,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1575621,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568229,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568300,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567489,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1573705,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568163,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568185,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1719855,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1575882,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1568161,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1568372,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1831659,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1574509,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1570162,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1573688,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1569581,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1569384,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1571258,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1568939,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1968277,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1913206,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1713496,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1713041,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1712996,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1576840,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1574948,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1574635,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1574522,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1574241,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573743,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573728,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573179,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573082,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573043,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573000,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1572765,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1572530,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1571918,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571256,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571257,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571259,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571260,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1569854,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1569832,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1574464,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 2053458,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 2049353,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 2044402,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2043278,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2043258,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2029786,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2015070,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2011346,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2001542,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1995849,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1985488,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1976870,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1968407,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1960420,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1954087,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1949563,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1948314,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1944726,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1936781,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1929615,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1904357,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1891895,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1891194,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1881384,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1867463,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1809989,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1784664,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1741884,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1728215,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1723785,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1720514,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1719123,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1714502,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713611,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713526,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713491,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713442,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713415,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713277,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713269,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713171,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713050,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            }
        ]
    }
]